<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
  <meta charset="UTF-8">
  <meta 
    name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta 
    http-equiv="X-UA-Compatible" 
    content="ie=edge">
  <meta 
    name="theme-color" 
    content="#fff" 
    id="theme-color">
  <meta 
    name="description" 
    content="前滴滴出行技术专家。极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者。个人博客：戴铭的博客。微信公共号：starming-weixin。微博：@戴铭">
  <link 
    rel="icon" 
    href="/img/logo-starming.png">
  <title>使用 LLVM</title>
  
    
      <meta 
        property="og:title" 
        content="使用 LLVM">
    
    
      <meta 
        property="og:url" 
        content="http://ming1016.github.io/2022/06/10/use-llvm/index.html">
    
    
      <meta 
        property="og:img" 
        content="/uploads/use-llvm/03.png">
    
    
      <meta 
        property="og:img" 
        content="前滴滴出行技术专家。极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者。个人博客：戴铭的博客。微信公共号：starming-weixin。微博：@戴铭">
    
    
      <meta 
        property="og:type" 
        content="article">
      <meta 
        property="og:article:published_time" 
        content="2022-06-10">
      <meta 
        property="og:article:modified_time" 
        content="2022-07-13">
      <meta 
        property="og:article:author" 
        content="戴铭">
      
        
          <meta 
            property="og:article:tag" 
            content="LLVM">
        
      
    
  
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  <link rel="preload" href="/css/main.css" as="style" >
  
  <link rel="modulepreload" href="//instant.page/5.1.0">
  
  <link rel="stylesheet" href="/css/main.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">
  
  <link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">
  
  
  
    <link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">
  
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
    function loadCSS(href, data, attr) {
      var sheet = document.createElement('link');
      sheet.ref = 'stylesheet';
      sheet.href = href;
      sheet.dataset[data] = attr;
      document.head.appendChild(sheet);
    }
    function changeCSS(cssFile, data, attr) {
      var oldlink = document.querySelector(data);
      var newlink = document.createElement("link");
      newlink.setAttribute("rel", "stylesheet");
      newlink.setAttribute("href", cssFile);
      newlink.dataset.prism = attr;
      document.head.replaceChild(newlink, oldlink);
    }
  </script>
  
    
      
      
      
      
        
        
        
        <script>
          function prismThemeChange() {
            if(document.getElementById('theme-color').dataset.mode === 'dark') {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism-tomorrow.min.css', '[data-prism]', 'prism-tomorrow');
              } else {
                loadCSS('/js/lib/prism/prism-tomorrow.min.css', 'prism', 'prism-tomorrow');
              }
            } else {
              if(document.querySelector('[data-prism]')) {
                changeCSS('/js/lib/prism/prism.min.css', '[data-prism]', 'prism');
              } else {
                loadCSS('/js/lib/prism/prism.min.css', 'prism', 'prism');
              }
            }
          }
          prismThemeChange()
        </script>
      
      
        
        <link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">
      
    
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
  </script>
  
    <script>
      var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
        document.getElementById('theme-color').dataset.mode = setting;
        prismThemeChange();
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
        document.getElementById('theme-color').dataset.mode = getCssMediaQuery();
        prismThemeChange();
      }
    };
    setDarkmode();
    </script>
  
  
  
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
    <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
    <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>

  <body>
    <div class="wrapper">
       
      <nav class="navbar">
  <div class="navbar-logo">
    <a class="navbar-logo-main" href="/">
      
        <img 
          class="navbar-logo-img"
          width="32"
          height="32"
          src="/img/logo-starming.png" 
          alt="blog logo">
      
      <span class="navbar-logo-dsc">戴铭的博客</span>
      </a>
  </div>
  <div class="navbar-menu">
    
      <a 
        href="/" 
        class="navbar-menu-item">
        
          首頁
        
      </a>
    
      <a 
        href="/archives" 
        class="navbar-menu-item">
        
          存檔
        
      </a>
    
      <a 
        href="/tags" 
        class="navbar-menu-item">
        
          標籤
        
      </a>
    
      <a 
        href="/categories" 
        class="navbar-menu-item">
        
          分類
        
      </a>
    
      <a 
        href="/about" 
        class="navbar-menu-item">
        
          關於
        
      </a>
    
      <a 
        href="/null" 
        class="navbar-menu-item">
        
          友鏈
        
      </a>
    
    <button 
      class="navbar-menu-item darknavbar navbar-menu-btn" 
      aria-label="Toggle dark mode"
      id="dark">
      <i class="iconfont icon-weather"></i>
    </button>
    <button 
      class="navbar-menu-item searchnavbar navbar-menu-btn" 
      aria-label="Toggle search"
      id="search">
      <!-- <i 
        class="iconfont icon-search" 
        style="font-size: 1.2rem; font-weight: 400;">
      </i> -->
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img"
        class="iconify iconify--ion" width="28" height="28" preserveAspectRatio="xMidYMid meet" viewBox="0 0 512 512">
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M256 80a176 176 0 1 0 176 176A176 176 0 0 0 256 80Z"></path>
        <path fill="none" stroke="currentColor" stroke-miterlimit="10" stroke-width="28"
          d="M232 160a72 72 0 1 0 72 72a72 72 0 0 0-72-72Z"></path>
        <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="28"
          d="M283.64 283.64L336 336"></path>
      </svg>
    </button>
  </div>
</nav> 
      
      <div 
        id="local-search" 
        style="display: none">
        <input
          class="navbar-menu-item"
          id="search-input"
          placeholder="请输入搜索内容..." />
        <div id="search-content"></div>
      </div>
      
      <div class="section-wrap">
        <div class="container">
          <div class="columns">
            <aside class="left-column">
              
              <div class="card card-author">
                
  <img 
    src="/img/ming.jpeg" 
    class="author-img"
    width="88"
    height="88"
    alt="author avatar">

<p class="author-name">戴铭</p>
<p class="author-description">极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者</p>
<div class="author-message">
  <a 
    class="author-posts-count" 
    href="/archives">
    <span>57</span>
    <span>文章</span>
  </a>
  <a 
    class="author-categories-count" 
    href="/categories">
    <span>5</span>
    <span>分類</span>
  </a>
  <a 
    class="author-tags-count" 
    href="/tags">
    <span>38</span>
    <span>標籤</span>
  </a>
</div>

  <div class="author-card-society">
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://weibo.com/allstarming">
          <i class="iconfont icon-sina society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a target="_blank" rel="noopener" href="https://github.com/ming1016">
          <i class="iconfont icon-github society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a href="mailto:ming1016@foxmail.com">
          <i class="iconfont icon-mail society-icon"></i>
        </a>
      </div>
    
      <div class="author-card-society-icon">
        <a href="/atom.xml">
          <i class="iconfont icon-chrome society-icon"></i>
        </a>
      </div>
    
  </div>

              </div>
               <div class="sticky-tablet">
  
  
    <article class="display-when-two-columns spacer">
      <div class="card card-content toc-card">
        <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目錄
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2"><span class="toc-number">2.</span> <span class="toc-text">代码新陈代谢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">方案总体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%8E%B0%E6%9C%89%E6%96%B9%E6%A1%88%E5%92%8C%E5%85%B6%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">一些现有方案和其不可用的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gcov"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">gcov</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%AF%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4%E7%9A%84-Pass"><span class="toc-number">2.1.2.</span> <span class="toc-text">自制可插入指令的 Pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.2.</span> <span class="toc-text">生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.3.</span> <span class="toc-text">Xcode 配置生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">Fuzzing 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.5.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-LLVM"><span class="toc-number">2.6.</span> <span class="toc-text">安装 LLVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">手动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%88%B6-Pass"><span class="toc-number">2.7.</span> <span class="toc-text">自制 Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">Pass 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xcode-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">Xcode 开发模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4-pass"><span class="toc-number">2.7.3.</span> <span class="toc-text">自制插入指令 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E8%87%AA%E5%88%B6-pass"><span class="toc-number">2.7.4.</span> <span class="toc-text">更多自制 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IR"><span class="toc-number">2.7.5.</span> <span class="toc-text">IR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IR-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">IR 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.3.</span> <span class="toc-text">本地变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.7.5.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.7.5.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.7.5.6.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.5.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">2.7.5.8.</span> <span class="toc-text">函数和声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unions"><span class="toc-number">2.7.5.9.</span> <span class="toc-text">Unions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if-then-else-%E5%88%86%E6%94%AF"><span class="toc-number">2.7.5.10.</span> <span class="toc-text">if-then-else 分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E4%B8%80%E8%B5%8B%E5%80%BC%E8%A1%A8%EF%BC%88SSA-Form%EF%BC%89%E5%92%8C-PHI"><span class="toc-number">2.7.5.11.</span> <span class="toc-text">静态单一赋值表（SSA Form）和 PHI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.5.12.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generators"><span class="toc-number">2.7.5.13.</span> <span class="toc-text">生成器 Generators</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.5.14.</span> <span class="toc-text">面向对象结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.7.5.15.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.5.16.</span> <span class="toc-text">虚拟方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.17.</span> <span class="toc-text">单一继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.18.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.19.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-number">2.7.5.20.</span> <span class="toc-text">接口 Interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boxing-%E5%92%8C-Unboxing"><span class="toc-number">2.7.5.21.</span> <span class="toc-text">Boxing 和 Unboxing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#New-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.7.5.22.</span> <span class="toc-text">New 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.8.</span> <span class="toc-text">C 调用 LLVM 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.9.</span> <span class="toc-text">Swift 调用 LLVM 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">动态执行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DYLD-INSERT-LIBRARIES"><span class="toc-number">3.1.</span> <span class="toc-text">DYLD_INSERT_LIBRARIES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-bitcode%EF%BC%88IR%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">解释执行 bitcode（IR）</span></a></li></ol></li></ol>
      </div>
    </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header">
    <i 
      class="iconfont icon-fenlei" 
      style="padding-right: 2px;">
    </i>分類
  </div>
  <div class="categories-list">
    
      <a href="/categories/Programming/">
        <div class="categories-list-item">
          Programming
          <span class="categories-list-item-badge">43</span>
        </div>
      </a>
    
      <a href="/categories/My-novel/">
        <div class="categories-list-item">
          My-novel
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/My-painting/">
        <div class="categories-list-item">
          My-painting
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/travel/">
        <div class="categories-list-item">
          travel
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/APP/">
        <div class="categories-list-item">
          APP
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header">
    <i 
      class="iconfont icon-biaoqian" 
      style="padding-right: 2px;">
    </i>熱門標籤
  </div>
  <div class="tags-list">
    
      <a 
        href="/tags/iOS/" 
        title="iOS">
        <div class="tags-list-item">iOS</div>
      </a>
    
      <a 
        href="/tags/Swift/" 
        title="Swift">
        <div class="tags-list-item">Swift</div>
      </a>
    
      <a 
        href="/tags/Apple/" 
        title="Apple">
        <div class="tags-list-item">Apple</div>
      </a>
    
      <a 
        href="/tags/Painting/" 
        title="Painting">
        <div class="tags-list-item">Painting</div>
      </a>
    
      <a 
        href="/tags/Slides/" 
        title="Slides">
        <div class="tags-list-item">Slides</div>
      </a>
    
      <a 
        href="/tags/iPad/" 
        title="iPad">
        <div class="tags-list-item">iPad</div>
      </a>
    
      <a 
        href="/tags/Procreate/" 
        title="Procreate">
        <div class="tags-list-item">Procreate</div>
      </a>
    
      <a 
        href="/tags/LLVM/" 
        title="LLVM">
        <div class="tags-list-item">LLVM</div>
      </a>
    
      <a 
        href="/tags/Web/" 
        title="Web">
        <div class="tags-list-item">Web</div>
      </a>
    
      <a 
        href="/tags/Novel/" 
        title="Novel">
        <div class="tags-list-item">Novel</div>
      </a>
    
      <a 
        href="/tags/SwiftUI/" 
        title="SwiftUI">
        <div class="tags-list-item">SwiftUI</div>
      </a>
    
      <a 
        href="/tags/macOS/" 
        title="macOS">
        <div class="tags-list-item">macOS</div>
      </a>
    
      <a 
        href="/tags/%E7%BC%96%E8%AF%91/" 
        title="编译">
        <div class="tags-list-item">编译</div>
      </a>
    
      <a 
        href="/tags/WWDC/" 
        title="WWDC">
        <div class="tags-list-item">WWDC</div>
      </a>
    
      <a 
        href="/tags/ReactiveCocoa/" 
        title="ReactiveCocoa">
        <div class="tags-list-item">ReactiveCocoa</div>
      </a>
    
      <a 
        href="/tags/GOT/" 
        title="GOT">
        <div class="tags-list-item">GOT</div>
      </a>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
            <main class="main-column">
              
  <div class="image-wrapper">
    <img 
      src="/uploads/use-llvm/03.png" 
      data-src="/uploads/use-llvm/03.png"
      srcset="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20300%20300&#39;%3E%3C/svg%3E"
      class="image lozad"
      alt="使用 LLVM thumbnail">
  </div>

<article class="card card-content">
  <header>
    <h1 class="post-title">
      使用 LLVM
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2022-06-10T09:04:31.000Z">
      <i 
        class="iconfont icon-calendar" 
        style="margin-right: 2px;">
      </i>
      <span>2022-06-10</span>
    </time>
    
      <span class="dot"></span>
      
        <a 
          href="/categories/Programming/" 
          class="post-meta-link">
          Programming
        </a>
      
    
    
      <span class="dot"></span>
      <span>18.7k 個字</span>
    
  </div>
  
    <div 
      class="post-meta post-show-meta" 
      style="margin-top: -10px;">
      <div style="display: flex; align-items: center;">
        <i 
          class="iconfont icon-biaoqian" 
          style="margin-right: 2px; font-size: 1.15rem;">
        </i>
        
          
          <a 
            href="/tags/LLVM/" 
            class="post-meta-link">
            LLVM
          </a>
        
      </div>
    </div>
  
  </header>
  <div 
    id="section" 
    class="post-content">
    <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇还会持续更新，增加更多用 llvm 干的事情，直到本句话被删掉为止。欢迎关注本篇。</p>
<p>目前在做一些编译相关调研。先前写过篇《<a href="https://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM</a>》和《<a href="https://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/">深入剖析 iOS 编译 Clang &#x2F; LLVM 直播的 Slides</a>》，内容偏理论。本篇着重对 LLVM 的使用，理论内容会很少，主要是说下如何使用 llvm 来做些事情，会有详细的操作步骤和工程示例。本文对应的幻灯片见 《<a href="https://ming1016.github.io/2022/07/08/slides-of-use-llvm/">使用 LLVM 分享的幻灯片</a>》。</p>
<h2 id="代码新陈代谢"><a href="#代码新陈代谢" class="headerlink" title="代码新陈代谢"></a>代码新陈代谢</h2><p>昨天看了昨天和今天 WWDC22 的 session，看到了苹果为包体积也做了很多工作，甚至不惜改 C ABI的 call convention 来达到此目的。</p>
<p>我很早前就做过一个方案，可以说是一个更好处理代码新陈代谢的方案，那就先说下这个。</p>
<h3 id="方案总体介绍"><a href="#方案总体介绍" class="headerlink" title="方案总体介绍"></a>方案总体介绍</h3><p>静态检查无法分析真实使用场景里代码是不是真的用了，或用的是否多。</p>
<p>动态检查来说，以前检查的方式有通过埋点查看相应代码是否有用到，还可以通过类的 isInitialized 方法来统计类是否被用到。第一个方案成本高，第二个方案范围太大，如果类都很大，那么检查结果的意义就没了。因此，需要一个能够动态检查函数和代码块级别是否使用的方法。</p>
<h4 id="一些现有方案和其不可用的地方"><a href="#一些现有方案和其不可用的地方" class="headerlink" title="一些现有方案和其不可用的地方"></a>一些现有方案和其不可用的地方</h4><p>下面列两个已有可检查比类更小粒度的方案。</p>
<h5 id="gcov"><a href="#gcov" class="headerlink" title="gcov"></a>gcov</h5><p>clang 使用 -fprofile-instr-generate -fcoverage-mapping ，swiftc 使用 -profile-generate -profile-coverage-mapping 生成 .profraw 文件。llvm-profdata merge 转成 .profdata。编译时每个文件会用 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp">GCOVProfiling</a> 生成 .gcno 包含计数和源码的映射关系，运行时用的是 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/profile/GCDAProfiling.c">GCDAProfiling</a> 处理回调记录运行时执行了哪些代码。最后 llvm-cov 转成报告，生成工具是 <a target="_blank" rel="noopener" href="http://www.opensource.apple.com/source/gcc/gcc-5484/gcc/gcov.c">gcov</a>，生成的报告可以看到哪些代码有用到，哪些没有用。</p>
<p>gcov 对于线下测试够用，但无法放到线上使用。</p>
<h5 id="SanitizerCoverage-插桩回调函数"><a href="#SanitizerCoverage-插桩回调函数" class="headerlink" title="SanitizerCoverage 插桩回调函数"></a>SanitizerCoverage 插桩回调函数</h5><p>SanitizerCoverage 是 libfuzzer 使用的代码覆盖技术，使用 <code>-fsanitize-coverage=trace-pc-guard</code> 这个编译 flag 插入不同级别的桩，会在程序控制流图的每条边插入<code>__sanitizer_cov_trace_pc_guard</code>。</p>
<p>如果只对函数插桩，使用 <code>-fsanitize-coverage=func</code>,<code>trace-pc-guard</code>，只对基本块用 <code>-fsanite-coverage=bb</code>,<code>no-prune</code>,<code>trace-pc-guard</code>。swift 使用 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 编译 flags。</p>
<p>在回调函数 <code>__sanitizer_cov_trace_pc_guard_init</code> 和 <code>__sanitizer_cov_trace_pc_guard</code> 里实现自己要干的事情，比如对当前插桩地址符号化，运行后就可以得到运行时调用了哪些方法。</p>
<p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/use-llvm/01.png" class="lozad post-image"src="/uploads/use-llvm/01.png"></p>
<p>使用 SanitizerCoverage 插桩，一个是编译会很慢，另一个是插入范围难控制，上线后各方面影响不可控。SanitizerCoverage 本是用于 fuzzing 测试的一个 llvm pass，因此可以了解 SanitizerCoverage 使用的技术，自建一个专门用于代码新陈代谢的 pass 用来解决 SanitizerCoverage 和 gcov 不好用的问题。</p>
<h4 id="自制可插入指令的-Pass"><a href="#自制可插入指令的-Pass" class="headerlink" title="自制可插入指令的 Pass"></a>自制可插入指令的 Pass</h4><p>之所以在编译中间层插入指令而不在编译 frontend 插入代码的原因是，这样做的话能用类似 llvm-mctoll 二进制转中间层 IR 代码的方式，可对第三方这样没有 frontend 源码而只有生成的二进制产物的库进行分析。</p>
<p>在函数中插入执行指令执行自定功能的方法是，用 IRBuilder 使用 SetInsertPoint 设置位置，CreateCall 插入指令，插入在块的初始位置，用的是 <code>dyn_cast&lt;BinaryOperator&gt;(&amp;I)</code> 。CreateCall 调用 LLVMContextFunctionCallee 来自 <code>F.getParent()-&gt;getOrInsertFunction</code>，其第一个参数就是要执行我们自定义函数的函数名，第二个参数 FunctionType 是通过 <code>paramTypes</code> 和 <code>Type::getVoidTy</code> 根据 LLVMContext 而来。 使用编译属性可以指定要控制的函数，pass 可用 getGlobalVariable 取到 <code>llvm.global.annotations</code> ，也就是所有编译属性。 </p>
<p><code>F.getName().front()</code> 为 <code>\x01</code> 表示的是 OC 方法，去掉这个前缀可得到方法名，<code>.contains(&quot;_block&quot;)</code> 是闭包函数。<code>F.getName().startswith(&quot;_Z&quot;)</code> 是 C++ 函数（<code>_Z</code>、<code>__Z</code>、<code>___Z</code> 都是）。使用 <code>F.getName()</code> 判读读取一个映射表进行对比，也可以达到通过编译属性设置控制指定函数的效果。映射表里设置需要线上验证的函数集合。然后，处理函数和块计数与源码的映射关系，编译加入处理自制 pass 记录运行时代码执行情况的回调。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>pass 代码编译生成 dylib 后，在 Xcode 中使用需要替换 clang 为编译 pass 的 clang，编译 pass 的版本也要对应上。在 xconfig 中设置构建命令选项 OTHER_CFLAGS OTHER_CPLUSPLUSFLAGS 是 -Xclang -load -Xclang $pass，CC CXX 设置为替换的 clang。调试是用的 opt，可换成 opt scheme，在 Edit Scheme 里设置 opt 的启动参数。</p>
<p>llvm 14 后只能使用 new pm，legcy pm(pass manager) 通过 Xlang 给 clang 传参，而 new pm 不行，new pm 的 pass 让 clang 加载，一种方法是使用 -fpass-plugin，另一种是把 pass 加到 clang 的 pipeline 里，重新构建对应版本的 clang。具体来说就是 PassBuilder 的回调 registerPipelineStartEPCallback 允许 ModulePassManager 使用 addPass 添加我们的 pass。</p>
<p>方案是这样，接下来的内容是偏实际的一些操作，你也可以跟着实践下，毕竟本篇是说怎么使用 LLVM 嘛。</p>
<p>先看看 gcov 的用法。</p>
<h3 id="生成代码覆盖率报告"><a href="#生成代码覆盖率报告" class="headerlink" title="生成代码覆盖率报告"></a>生成代码覆盖率报告</h3><p>命令行中开启代码覆盖率的编译选项，参看官方指南：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">Source-based Code Coverage</a> 。</p>
<p>通过一个例子实践下。</p>
<p>建个 C 代码文件 main.m ：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hi there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>加上代码覆盖率的编译参数进行编译。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun clang -fprofile-instr-generate -fcoverage-mapping main.m -o mainCoverage<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行生成的 mainCoverage 会生成 default.profraw 文件，自定义文件名使用 LLVM_PROFILE_FILE&#x3D;”my.profraw” .&#x2F;mainCoverage 命令。</p>
<p>对于 Swift 文件也没有问题，建一个 swift 文件 hi.swift </p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function-definition function">hi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"hi"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function-definition function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">func</span> <span class="token function-definition function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过 swiftc 来编译</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swiftc -profile-generate -profile-coverage-mapping hi.swift<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从上面 clang 和 swiftc 的命令可以看出，clang 使用的是 -fprofile-instr-generate 和 -fcoverage-mapping 编译 flags，swiftc 使用的是 -profile-generate 和 -profile-coverage-mapping 编译 flags。</p>
<p>编译出的可执行文件 mainCoverage 和 hi 都会多出</p>
<p>生成代码覆盖率前建立索引，也就是生成 .profdata 文件。通过 xcrun 调用 llvm-prodata 命令。命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun llvm-profdata merge -sparse my.profraw -o my.profdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>合并多个 .profdata 文件使用下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">llvm-profdata merge one.profdata two.profdata -output all.profdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 <a target="_blank" rel="noopener" href="https://llvm.org/docs/CommandGuide/llvm-cov.html">llvm-cov</a> 命令生成行的报告</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun llvm-cov show ./mainCoverage -instr-profile<span class="token operator">=</span>my.profdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token number">1</span><span class="token operator">|</span>       <span class="token operator">|</span><span class="token comment">#include &lt;stdio.h></span>
 <span class="token number">2</span><span class="token operator">|</span>       <span class="token operator">|</span>
 <span class="token number">3</span><span class="token operator">|</span>       <span class="token operator">|</span>int main<span class="token punctuation">(</span>int argc, char *argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token number">4</span><span class="token operator">|</span>      <span class="token number">1</span><span class="token operator">|</span><span class="token punctuation">&#123;</span>
 <span class="token number">5</span><span class="token operator">|</span>      <span class="token number">1</span><span class="token operator">|</span>    printf<span class="token punctuation">(</span><span class="token string">"hi there!<span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token number">6</span><span class="token operator">|</span>      <span class="token number">1</span><span class="token operator">|</span>    <span class="token builtin class-name">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token number">7</span><span class="token operator">|</span>      <span class="token number">1</span><span class="token operator">|</span><span class="token punctuation">&#125;</span>
 <span class="token number">8</span><span class="token operator">|</span>       <span class="token operator">|</span>
 <span class="token number">9</span><span class="token operator">|</span>      <span class="token number">0</span><span class="token operator">|</span>void <span class="token function-name function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token number">10</span><span class="token operator">|</span>      <span class="token number">0</span><span class="token operator">|</span>  <span class="token builtin class-name">return</span><span class="token punctuation">;</span>
<span class="token number">11</span><span class="token operator">|</span>      <span class="token number">0</span><span class="token operator">|</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面的输出可以看到，9到11行是没有执行的。</p>
<p>从文件层面看覆盖率，可以通过下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun llvm-cov report ./mainCoverage -instr-profile<span class="token operator">=</span>my.profdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>输出的报告如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Filename                                  Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover    Branches   Missed Branches     Cover
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
/Users/mingdai/Downloads/PTest/main.m           <span class="token number">2</span>                 <span class="token number">1</span>    <span class="token number">50.00</span>%           <span class="token number">2</span>                 <span class="token number">1</span>    <span class="token number">50.00</span>%           <span class="token number">7</span>                 <span class="token number">3</span>    <span class="token number">57.14</span>%           <span class="token number">0</span>                 <span class="token number">0</span>         -
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
TOTAL                                           <span class="token number">2</span>                 <span class="token number">1</span>    <span class="token number">50.00</span>%           <span class="token number">2</span>                 <span class="token number">1</span>    <span class="token number">50.00</span>%           <span class="token number">7</span>                 <span class="token number">3</span>    <span class="token number">57.14</span>%           <span class="token number">0</span>                 <span class="token number">0</span>         -<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>生成 JSON 的命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun llvm-cov <span class="token builtin class-name">export</span> -format<span class="token operator">=</span>text ./mainCoverage -instr-profile<span class="token operator">=</span>my.profdata <span class="token operator">></span> my.json<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>从生成的 json 文件可以看到这个生成的报告有5个统计项，分别是函数、实例化、行、区域和分支。</p>
<p>更多报告生成选型参看 <a target="_blank" rel="noopener" href="https://llvm.org/docs/CommandGuide/llvm-cov.html">llvm-cov 官方说明</a> 。</p>
<h3 id="Xcode-配置生成代码覆盖率报告"><a href="#Xcode-配置生成代码覆盖率报告" class="headerlink" title="Xcode 配置生成代码覆盖率报告"></a>Xcode 配置生成代码覆盖率报告</h3><p>在 Xcode 里开启代码覆盖率，先选择”Edit Scheme…”，再在 Test 中的 Options 里勾上 Gather coverage for all targets 或 some targets。如下图<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/use-llvm/02.png" class="lozad post-image"src="/uploads/use-llvm/02.png"></p>
<p>在 Build Setting 中进行设置，添加 -profile-generate 和 -profile-coverage-mapping 编译 flags。<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/use-llvm/03.png" class="lozad post-image"src="/uploads/use-llvm/03.png"></p>
<p>调用 llvm profile 的 c 函数生成 .profraw 文件。代码见：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token comment">// MARK: - 代码覆盖率</span>
<span class="token keyword">func</span> <span class="token function-definition function">codeCoverageProfrawDump</span><span class="token punctuation">(</span>fileName<span class="token punctuation">:</span> <span class="token class-name">String</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"cc"</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">fileName</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">.profraw"</span></span>
    <span class="token keyword">let</span> fileManager <span class="token operator">=</span> <span class="token class-name">FileManager</span><span class="token punctuation">.</span><span class="token keyword">default</span>
    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">let</span> documentDirectory <span class="token operator">=</span> <span class="token keyword">try</span> fileManager<span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>documentDirectory<span class="token punctuation">,</span> <span class="token keyword">in</span><span class="token punctuation">:</span> <span class="token punctuation">.</span>userDomainMask<span class="token punctuation">,</span> appropriateFor<span class="token punctuation">:</span><span class="token nil constant">nil</span><span class="token punctuation">,</span> create<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token keyword">let</span> filePath<span class="token punctuation">:</span> <span class="token class-name">NSString</span> <span class="token operator">=</span> documentDirectory<span class="token punctuation">.</span><span class="token function">appendingPathComponent</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>path <span class="token keyword">as</span> <span class="token class-name">NSString</span>
        <span class="token function">__llvm_profile_set_filename</span><span class="token punctuation">(</span>filePath<span class="token punctuation">.</span>utf8String<span class="token punctuation">)</span>
        <span class="token function">print</span><span class="token punctuation">(</span>"<span class="token class-name">File</span> at<span class="token punctuation">:</span> <span class="token punctuation">\</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">(</span>cString<span class="token punctuation">:</span> <span class="token function">__llvm_profile_get_filename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>"<span class="token punctuation">)</span>
        <span class="token function">__llvm_profile_write_file</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>codeCoverageProfrawDump 函数放到 applicationWillTerminate 里执行，就可以生成在本次操作完后的代码覆盖率。</p>
<p>通过 llvm-cov report 命令将 .profraw 和生成的 Mach-O 文件关联输出代码覆盖率的报告，完整实现和调试看，参看 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/SwiftPamphletApp">DaiMingCreationToolbox</a> 里的 FundationFunction.swift 和 SwiftPamphletAppApp.swift 文件。</p>
<h3 id="Fuzzing-介绍"><a href="#Fuzzing-介绍" class="headerlink" title="Fuzzing 介绍"></a>Fuzzing 介绍</h3><p>另外，llvm 还提供另一种覆盖率输出，编译参数是 -fprofile-arcs -ftest-coverage 和链接参数 -lgcov，运行程序后会生成 .gcda 和 .gcno 文件，使用 lcov 或 gcovr 就可以生成一个 html 来查看覆盖率。</p>
<p>之所以能够输出代码覆盖率，主要是 llvm 在编译期间给函数、基本块（IDA 中以指令跳转当分界线的每块代码）和边界（较基本块多了执行边界信息）插了桩。插桩的函数也有回调，如果想使用插桩函数的回调，有源码可以使用 SanitizerCoverage， 官方说明见：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>。</p>
<p>SanitizerCoverage 用的是 ModulePass，是 llvm 提供的 ModulePass、CallGraphSCCPass、FunctionPass、LoopPass、RegionPass 这几个插桩 pass 中的一种。SanitizerCoverage 还应用在 llvm 的 Fuzz 生成器 <a target="_blank" rel="noopener" href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> 上，libfuzzer 可以从硬件和 IR 层面进行插桩获取程序的覆盖率。</p>
<p>Fuzzing 生成器的概念最早是威斯康星大学 Barton Miller 教授在<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">他的课</a>上提出的，后应用于安全测试领域，比如 <a target="_blank" rel="noopener" href="https://rd.springer.com/content/pdf/10.1007%2F978-0-387-35413-2_16.pdf">PROTOS 测试集项目</a>、网络协议安全测试 SPIKE、最普遍应用的文件 Fuzzing 技术 Peach、语法模板 <a target="_blank" rel="noopener" href="https://github.com/MozillaSecurity/funfuzz">funfuzz</a> 和 Dom fuzz 的 <a target="_blank" rel="noopener" href="https://github.com/googleprojectzero/domato">Domato</a>、分析 llvm IR 符号执行平台 <a target="_blank" rel="noopener" href="http://klee.github.io/">Klee</a>、源码插桩和 QEMU 模式实现代码覆盖 fuzzing 的 AFL 和刚才我提到的 llvm 自带基于 SanitizerCoverage 的 libfuzzer、挖掘系统内核漏洞的系统函数调用模板 Fuzzing 库 syzkaller 和基于 libfuzzer 和 protobuf 做的 <a target="_blank" rel="noopener" href="https://github.com/google/libprotobuf-mutator">libprotobuf-mutator</a>、组合了 libFuzzer，<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a> 和 <a target="_blank" rel="noopener" href="https://github.com/google/honggfuzz">Honggfuzz</a> 还有 ClusterFuzz 的平台 <a target="_blank" rel="noopener" href="https://github.com/google/oss-fuzz">OSS-Fuzz</a>。</p>
<p>其中 Spike 是网络协议开源 Fuzzing 工具，由 Dave Aitel 编写的，Dave Aitel 是《the Hacker’s Handbook》（《黑客防范手册》）和《the Shellcoder’s Handbook》（《黑客攻防技术宝典：系统实战篇》）的作者。网络协议分析工具主要是 WireShark 和应用层的 SockMon（特定进程、协议、IP、函数抓包），和 IDA、OD 等工具结合找到软件执行的网络命令分析数据包的处理过程。Spike 可以对数据发包收包，还可以构造数据包自动化做覆盖更大的测试。</p>
<p>QEMU 是 2003 年 Fabrice Bellard 做的虚拟机，包含很多架构和硬件设备的模拟执行，原理是 qemu TCG 模块把机器代码转成 llvm IR，这个过程叫做反编译，关于反编译可以参考这篇论文《<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_andriesse.pdf">An In-Depth Analysis of Disassembly on Full-Scale x86&#x2F;x64 Binaries</a>》。之所以可以做到反编译是因为机器指令和汇编指令是一一对应的，可以先将机器指令翻译成机器对应的汇编，IR 实际上就是一个不遵循硬件设计的指令集，和硬件相关的汇编会按照 IR 的设计翻译成机器无关的 IR 指令。这样做的好处就是无论是哪个机器上的可执行二进制文件都能够统一成一份标准的指令表示。IR 也可以设计成 DSL，比如 <a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a> 的 Sleigh 语言。</p>
<p>反编译后，再将得到的 IR 转成目标硬件设备可执行机器语言，IDA Pro 也是用的这个原理，IDA 的 IR 叫 microcode，IDA 的插件 <a target="_blank" rel="noopener" href="https://github.com/patois/genmc">genmc</a> 专门用来显示 microcode，<a target="_blank" rel="noopener" href="https://github.com/RolfRolles/HexRaysDeob">HexRaysDeob</a> 是利用 microcode 来做混淆的库。</p>
<p>qemu 做的是没有源码的二进制程序的分析，是一个完整的虚拟机工具，其中只有 tcg 模块的一部分功能就可以实现模拟 CPU 执行，执行过程中插入分析的代码就能够方便的访问寄存器，对地址或指令 hook，实现这些功能的库是 <a target="_blank" rel="noopener" href="https://github.com/unicorn-engine/unicorn">Unicorn</a>，还有功能更多些的 <a target="_blank" rel="noopener" href="https://github.com/qilingframework/qiling">Qiling</a>。Qiling 和 Unicorn 不同的是 Unicorn 只完成了 CPU 指令的仿真，而 Qiling 可以处理更高层次的动态库、系统调用、I&#x2F;O 处理或 Mach-O 加载等，Qiling 还可以通过 Python 开发自己动态分析工具，运行时进行 hotpatch，支持 macOS。基于 qemu 还有可以访问执行的所有代码和数据做回放程序执行过程的 <a target="_blank" rel="noopener" href="https://github.com/panda-re/panda">PANDA</a>、虚拟地址消毒剂 <a target="_blank" rel="noopener" href="https://github.com/andreafioraldi/qasan">QASan</a>、组合 Klee 和 qemu 的 <a target="_blank" rel="noopener" href="https://s2e.systems/">S2E</a>。</p>
<p>能够使用 js 来开发免编译功能的 <a target="_blank" rel="noopener" href="https://frida.re/">Frida</a> 也可以用于 Fuzzing，在 iOS 平台上的 Fuzzing 参看<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-1.html">1</a>、<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-2.html">2</a>、<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-3.html">3</a>，使用工具见 <a target="_blank" rel="noopener" href="https://github.com/googleprojectzero/iOS-messaging-tools/tree/master/iMessage">iOS-messaging-tools</a>。</p>
<p>更多 Fuzzing 资料可以参看 GitHub 上一份整理好的 <a target="_blank" rel="noopener" href="https://github.com/secfigo/Awesome-Fuzzing">Awesome-Fuzzing</a>。</p>
<p>可见 Fuzzing 生成器应用范围非常广，除了获取代码覆盖率，还能够进行网络安全分析和安全漏洞分析。本文主要是基于源码插桩，源码插桩库主要是 libfuzzer、AFL++、honggfuzz、riufuzz（honggfuzz 二次开发）。</p>
<p>AFL++ 在有源码情况下原理和 libfuzzer 差不多，只是底层不是用的 SanitizerCoverage，而是自实现的一个 pass，没有源码时 AFL++ 用的就是 qemu 中 TCG 模块的代码，在反编译为 IR 时进行插桩。更多 AFL++ 应用参见《<a target="_blank" rel="noopener" href="https://github.com/google/fuzzing/blob/master/docs/afl-based-fuzzers-overview.md">What is AFL and What is it Good for?</a>》</p>
<p>Fuzzing 除了代码覆盖率，还需要又能够创建更多输出条件，记录执行路径，目标和方向是找出程序运行时在什么输入条件和路径下会有问题。但仅是检测哪些代码有用到，实际上只要用上 Fuzzing 的代码覆盖率就可以了。</p>
<h3 id="SanitizerCoverage-插桩回调函数-1"><a href="#SanitizerCoverage-插桩回调函数-1" class="headerlink" title="SanitizerCoverage 插桩回调函数"></a>SanitizerCoverage 插桩回调函数</h3><p>那接下来实践下 libfuzzer 中实现代码覆盖率的 SanitizerCoverage 技术。</p>
<p>命令行执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">xcrun clang -fembed-bitcode main.m -save-temps -v -fsanitize-coverage<span class="token operator">=</span>trace-pc-guard<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>使用 -fsanitize-coverage&#x3D;trace-pc-guard 这个编译 flag 插入不同级别的桩，会在程序控制流图的每条边插入：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">__sanitizer_cov_trace_pc_guard<span class="token punctuation">(</span><span class="token operator">&amp;</span>guard_variable<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果只对函数插桩，使用 <code>-fsanitize-coverage=func</code>,<code>trace-pc-guard</code>，只对基本块用 <code>-fsanite-coverage=bb</code>,<code>no-prune</code>,<code>trace-pc-guard</code>。swift 使用 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 编译 flags。</p>
<p>使用插桩函数回调，先在 Xcode 的 Other C Flags 里添加 <code>-fsanitize-coverage=trace-pc-guard</code>。swift 就是在 Other Swift Flags 里添加 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 。</p>
<p>在回调函数里实现自己要干的事情，比如对当前插桩地址符号化，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">import</span> <span class="token expression"><span class="token operator">&lt;</span>dlfcn<span class="token punctuation">.</span>h<span class="token operator">></span></span></span>

<span class="token keyword">void</span> <span class="token function">__sanitizer_cov_trace_pc_guard_init</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span>start<span class="token punctuation">,</span>
           <span class="token class-name">uint32_t</span> <span class="token operator">*</span>stop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token class-name">uint64_t</span> N<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> stop <span class="token operator">||</span> <span class="token operator">*</span>start<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"INIT: %p %p\n"</span><span class="token punctuation">,</span> start<span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span>x <span class="token operator">=</span> start<span class="token punctuation">;</span> x <span class="token operator">&lt;</span> stop<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>
  <span class="token punctuation">,</span><span class="token operator">*</span>x <span class="token operator">=</span> <span class="token operator">++</span>N<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">__sanitizer_cov_trace_pc_guard</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span> <span class="token operator">*</span>guard<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span>guard<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>PC <span class="token operator">=</span> <span class="token function">__builtin_return_address</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Dl_info info<span class="token punctuation">;</span>
    <span class="token function">dladdr</span><span class="token punctuation">(</span>PC<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"调用了方法: %s \n"</span><span class="token punctuation">,</span> info<span class="token punctuation">.</span>dli_sname<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行后就可以得到运行时调用了哪些方法。</p>
<p>有了这些数据就可以统计哪些方法调用了，调用了多少次。通过和全源码对比，取差集能够找到运行中没有执行的方法和代码块。其实利用 Fuzzing 的概念还可以做很多分析的工作，全面数据化观测代码执行情况。可以到我的 <a target="_blank" rel="noopener" href="https://github.com/ming1016/GCDFetchFeed">GCDFetchFeed</a> 工程中，打开 AppDelegate.m 里的两个插桩回调方法的注释来试用。</p>
<p>停止试用插桩，可以用 <code>__attribute__((no_sanitize(&quot;coverage&quot;)))</code> 编译属性。或者通过黑名单或白名单，分别是 <code>-fsanitize-coverage-ignorelist=blocklist.txt</code> 和 <code>-fsanitize-coverage-allowlist=allowlist.txt</code>，范围可以试文件夹、单个文件或者单个方法。</p>
<p>allowlist.txt 示例：</p>
<pre class="line-numbers language-none"><code class="language-none"># 允许文件夹里所有文件
src:bar&#x2F;*
# 特定源文件
src:foo&#x2F;a.cpp
# 允许文件中所有函数
fun:*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>blocklist.txt 示例：</p>
<pre class="line-numbers language-none"><code class="language-none"># 禁用特定源文件
src:bar&#x2F;b.cpp
# 禁用特定函数
fun:*myFunc*<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>上线前检查出的没有用到的代码，并不表示上线后用户不会用到，比如 AB 实验、用户特殊设置、不常见 Case 等。这就可以利用 allowlist.txt 将部分不确定的代码放到线上去检测，或者通过自动插入埋点灰度检测，这些不确定的代码不是主链路的，因此检测影响范围会很低。</p>
<p>SanitizerCoverage 本身是一个 llvm pass，代码在 llvm 工程的 llvm-project&#x2F;llvm&#x2F;lib&#x2F;Transforms&#x2F;Instrumentation&#x2F;SanitizerCoverage.cpp 路径下，那么怎么实现一个自定义的 pass 呢？</p>
<p>先把 llvm 装到本地。</p>
<h3 id="安装-LLVM"><a href="#安装-LLVM" class="headerlink" title="安装 LLVM"></a>安装 LLVM</h3><h4 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h4><p>使用 homebrew，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">brew <span class="token function">install</span> llvm@13<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><code>@13</code> 表示 llvm 的版本。安装后使用路径在是 <code>/usr/local/opt/llvm/</code>，比如 cmake 构建编译环境可以使用下面的命令：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$LLVM_DIR</span><span class="token operator">=</span>/usr/local/opt/llvm/lib/cmake/llvm cmake <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可以用 Visual Studio Code 开发 pass，安装微软的 C&#x2F;C++ 的 extension，在 C&#x2F;C++ Configurations 里把 <code>/usr/local/opt/llvm/include/</code> 加入到包含路径中。</p>
<p>llvm 的更新使用 <code>brew upgrade llvm</code></p>
<p>llvm 也可以通过源码来安装，执行如下命令即可：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/llvm/llvm-project.git
<span class="token builtin class-name">cd</span> llvm-project
<span class="token function">git</span> checkout release/14.x
<span class="token function">mkdir</span> build
<span class="token builtin class-name">cd</span> build
cmake -DCMAKE_BUILD_TYPE<span class="token operator">=</span>Release -DLLVM_TARGETS_TO_BUILD<span class="token operator">=</span>host -DLLVM_ENABLE_PROJECTS<span class="token operator">=</span>clang <span class="token punctuation">..</span>/llvm
cmake --build <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的 cmake 参数 <code>-DLLVM_ENABLE_PROJECTS=clang</code> 表示也会构建 clang 工具。如果还要加上 lld 以在构建时能够用自己的 pass，可以直接加成 <code>-DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot;</code> 。</p>
<p>自定义安装目录的话，增加 <code>-DCMAKE_INSTALL_PREFIX=/home/user/custom-llvm</code> 。然后在设置路径 <code>export PATH=$PATH:/home/user/custom-llvm/bin</code> 。</p>
<p>-G 编译选项选择 Ninja 编译速度快。</p>
<p>各种设置整到一起：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cmake -G <span class="token string">"Ninja"</span> -DCMAKE_BUILD_TYPE<span class="token operator">=</span>Release -DLLVM_TARGETS_TO_BUILD<span class="token operator">=</span>host -DLLVM_ENABLE_PROJECTS<span class="token operator">=</span><span class="token string">"clang;lld"</span> -DCMAKE_INSTALL_PREFIX<span class="token operator">=</span>/Users/mingdai/Downloads/PTest/my-llvm-bin <span class="token punctuation">..</span>/llvm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="自制-Pass"><a href="#自制-Pass" class="headerlink" title="自制 Pass"></a>自制 Pass</h3><h4 id="Pass-介绍"><a href="#Pass-介绍" class="headerlink" title="Pass 介绍"></a>Pass 介绍</h4><p>llvm 属于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multi-pass_compiler">multi-pass</a> 编译器，LLVM Pass 管理器是处理 pass 执行的注册和时序安排。曾有两个 pass 管理器，一个是 New Pass 管理器也叫 Pass 管理器，另一个是 Legacy Pass 管理器。New Pass 目前是默认的管理器，Legacy Pass 在 LLVM 14 中被废弃。Legacy 和 New 两个 pass 管理器在使用上最大的区别就是，Legacy 会注册一个新的命令选项，而 New Pass 只用定义一个 pass。另外 Legacy 需要实现 print 成员方法来打印，需要在通过 opt 通过传递 -analyze 命令行选项来运行，而 New Pass 管理器是不用的，只需要实现 printing pass。</p>
<p>总的来说<br>Legacy</p>
<ul>
<li>基于继承性</li>
<li>分析和打印 pass 之间没有区别</li>
<li>注册时加载所有需要的 pass</li>
<li>不变的 pass 执行调度</li>
<li>Transformation passes 定义了它们在执行前保证保留的内容</li>
</ul>
<p>Legacy 的 pass 类</p>
<ul>
<li><code>llvm::Pass</code><ul>
<li><code>llvm::ModulePass</code></li>
<li><code>llvm::FunctionPass</code></li>
<li><code>llvm::PassRegistry</code></li>
</ul>
</li>
</ul>
<p>New</p>
<ul>
<li>基于 CRTP、mixin 和 concept-model 的 idiom-based</li>
<li>在执行过程中，根据需要有条件的加载依赖的 pass（更快、更有效）</li>
<li>Transformation passes 在执行后返回它们所保留的内容</li>
</ul>
<p>New 的 pass 类</p>
<ul>
<li><code>llvm::PassInfoMixin&lt;DerivedT&gt;</code></li>
<li><code>llvm::AnalysisInfoMixin&lt;DerivedT&gt;</code></li>
<li><code>llvm::FunctionAnalysisManager</code><ul>
<li>别名类型 <code>llvm::AnalysisManager&lt;llvm::Function&gt;</code></li>
</ul>
</li>
<li><code>llvm::ModuleAnalysisManager</code><ul>
<li>别名类型 <code>llvm::AnalysisManager&lt;llvm::Module&gt;</code></li>
</ul>
</li>
<li><code>llvm::PreservedAnalysis</code></li>
</ul>
<p>LLVM Pass 可以对 LLVM IR 进行优化。优化表现在 Pass 可以对 IR 进行分析和转换，因此 Pass 主要也是分为分析（analysis）和转换（transform）两类。</p>
<p>分析里有数据流分析技术，分为以下三种：</p>
<ul>
<li>Reaching-Definition Analysis 到达定值分析</li>
<li>Live-Variable Analysis 活跃变量分析</li>
<li>Available-Expression Analysis 可用表达式分析</li>
</ul>
<p>一些常用的优化方法，比如删除计算结果不会使用的语句、删除归纳变量、删除公共子表达式、进入循环前就对不管循环多少次都是同样结果的表达式进行求值、快的操作替换慢操作、用可推导出值是常量的表达式来替代表达式等。</p>
<p>编写优化的几个方法。完整代码参看<a target="_blank" rel="noopener" href="https://github.com/Kiprey/Skr_Learning/tree/master/week7-8/Assignment1-Introduction_to_LLVM">这里</a>。</p>
<p>插入新指令：</p>
<ul>
<li>直接通过类或命名的构造函数。</li>
<li>使用 llvm::IRBuilder&lt;&gt; 模板类。</li>
</ul>
<p>删除指令：</p>
<ul>
<li>llvm::Instruction::eraseFromParent() 成员函数</li>
</ul>
<p>替换存在指令：</p>
<ul>
<li>llvm::ReplaceInstWithInst() 函数<ul>
<li><code>#include &quot;llvm/Transforms/Utils/BasicBlockUtils.h&quot;</code></li>
</ul>
</li>
</ul>
<p>直接改指令</p>
<ul>
<li>llvm::User::setOperand() 成员函数</li>
</ul>
<p>Value ⇒ ConstantInt 类型转换：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Type _t;
ConstantInt* val &#x3D; dyn_cast&lt;ConstantInt&gt;(_t);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>获取 ConstantInt 类的值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ConstantInt* const_int;
uint64_t val &#x3D; const_int-&gt;getZExtValue();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>替换某个指令</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Instruction inst;
&#x2F;&#x2F; 替换，只是替换了引用，并没删
inst.replaceAllUsesWith(val);

&#x2F;&#x2F; 删除
if(inst-&gt;isSafeToRemove())
    inst-&gt;eraseFromParent();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 IR 代码</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; 执行前
%12 &#x3D; load i32, i32* %2, align 4
%13 &#x3D; add nsw i32 %12, 0
store i32 %13, i32* %3, align 4
; 只替换指令引用
%12 &#x3D; load i32, i32* %2, align 4
%13 &#x3D; add nsw i32 %12, 0          
store i32 %12, i32* %3, align 4
%12 &#x3D; load i32, i32* %2, align 4
store i32 %12, i32* %3, align 4
Instruction referencing instruction not embedded in a basic block!
  %12 &#x3D; load i32, i32* %2, align 4
  &lt;badref&gt; &#x3D; add nsw i32 %12, 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>建立新指令</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 取出第一个操作数
Value* val &#x3D; inst.getOperand(0);
&#x2F;&#x2F; 确定新指令的插入位置
IRBuilder&lt;&gt; builder(&amp;inst);
&#x2F;&#x2F; val &lt;&lt; 1
Value* newInst &#x3D; builder.CreateShl(val, 1);
&#x2F;&#x2F; 替换指令
inst.replaceAllUsesWith(newInst);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Analysis pass 的 print pass 是基于一个 Transformation pass，会请求原始 pass 分析的结果，并打印这些结果。会注册一个命令行选项 <code>print&lt;analysis-pass-name&gt;</code>。</p>
<p>实现 pass 要选择是 Analysis 还是 Transformation，也就是要对进行输入 IR 的分析还是进行转换来决定采用哪种。选择 Transformation 通常继承 PassInfoMixin。Analysis 继承 AnalysisInfoMixin。</p>
<p>pass 生成的插件分为动态和静态的。静态插件不需要在运行时用 -load-pass-plugin 选项进行加载，但需要在 llvm 工程中设置 CMake 重新构建 opt。</p>
<p>做自己 pass 前可以先了解下 llvm 内部的 <a target="_blank" rel="noopener" href="https://llvm.org/docs/Passes.html">pass</a> 示例，可以先从两个最基本的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/13.x/llvm/lib/Transforms/Hello">Hello</a> 和 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/release/13.x/llvm/examples/Bye">Bye</a> 来。比较实用的是一些做优化的 pass，这些 pass 也是学习写 pass ，了解编译器如何工作的重要资源。许多 pass 都实现了编译器开发理论中著名的概念。比如优化 memcpy 调用（比如用 memset 替换）的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp">memcpyopt</a> 、简化 CFG <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/release/13.x/llvm/examples/IRTransforms">IRTransforms</a>、总是内联用 alwaysinline 修饰的函数的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/IPO/AlwaysInliner.cpp">always-inline</a> 、死代码消除的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/DCE.cpp">dce</a> 和删除未使用的循环的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/LoopDeletion.cpp">loop-deletion</a>。</p>
<h4 id="Xcode-开发模式"><a href="#Xcode-开发模式" class="headerlink" title="Xcode 开发模式"></a>Xcode 开发模式</h4><p>在下好的 LLVM 源码中找到 <code>llvm/lib/Transforms</code> 目录，创建一个 MingPass 目录，在这个目录下创建 <code>MingPass.cpp</code> 和 <code>MingPass.exports</code> ，还有 cmake 文件 <code>CMakeLists.txt</code> ，<code>CMakeLists.txt</code> 内容写成：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">if<span class="token punctuation">(</span> NOT LLVM_REQUIRES_RTTI <span class="token punctuation">)</span>
if<span class="token punctuation">(</span> NOT LLVM_REQUIRES_EH <span class="token punctuation">)</span>
  set<span class="token punctuation">(</span>LLVM_EXPORTED_SYMBOL_FILE <span class="token variable">$</span><span class="token punctuation">&#123;</span>CMAKE_CURRENT_SOURCE_DIR<span class="token punctuation">&#125;</span>/MingPass.exports<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

if<span class="token punctuation">(</span>WIN32 OR CYGWIN<span class="token punctuation">)</span>
set<span class="token punctuation">(</span>LLVM_LINK_COMPONENTS Core Support<span class="token punctuation">)</span>
<span class="token keyword">endif</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

set<span class="token punctuation">(</span>LLVM_LINK_COMPONENTS Demangle<span class="token punctuation">)</span>

add_llvm_library<span class="token punctuation">(</span> LLVMMingPass MODULE BUILDTREE_ONLY
MingPass.cpp

DEPENDS
intrinsics_gen
PLUGIN_TOOL
opt
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 <code>llvm/lib/Transforms/CMakelists.txt</code> 里加上 <code>add_subdirectory(MingPass)</code> 。<code>MingPass.cpp</code> 里编写实际的 pass 代码。</p>
<p>使用 <code>cmake -G &quot;Xcode&quot;</code> 构建 LLVM 工程，打开 <code>LLVM.xcodeproj</code> ，选择 MingPass 这个 target，使用 <code>command+b</code> 进行编译，会生成 <code>MingPass.dylib</code> 产物。</p>
<p>下载和 Xcode 对应 clang 版本。在工程中创建 <code>Config.xcconfig</code> 文件，内容如下：</p>
<pre class="line-numbers language-makefile" data-language="makefile"><code class="language-makefile">LLVM_DIR <span class="token operator">=</span> <span class="token variable">$HOME/Downloads/PTest/LLVMSource</span>
PASS_DYLIB <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>LLVM_DIR<span class="token punctuation">)</span>/build_dir/build_xcode/Debug/lib/LLVMMingPass.dylib
OTHER_CFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>inherited<span class="token punctuation">)</span> -Xclang -load -Xclang <span class="token variable">$</span><span class="token punctuation">(</span>PASS_DYLIB<span class="token punctuation">)</span>
OTHER_CPLUSPLUSFLAGS <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>inherited<span class="token punctuation">)</span> -Xclang -load -Xclang <span class="token variable">$</span><span class="token punctuation">(</span>PASS_DYLIB<span class="token punctuation">)</span>
COMPILER_INDEX_STORE_ENABLE <span class="token operator">=</span> NO
CC <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>LLVM_DIR<span class="token punctuation">)</span>/clang-13.0.0/bin/clang
CXX <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>LLVM_DIR<span class="token punctuation">)</span>/clang-13.0.0/bin/clang++<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="自制插入指令-pass"><a href="#自制插入指令-pass" class="headerlink" title="自制插入指令 pass"></a>自制插入指令 pass</h4><p>接下来，怎么在运行时插入指令来获取我们需要代码使用情况。完整代码可以在这里 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/MingPass">MingPass</a> 拉下代码参考进行修改调试。</p>
<p>个 pass 功能是在运行时环境直接在特定位置执行指定的函数。先写个要执行的函数，新建个文件 loglib.m，代码如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>

<span class="token keyword">void</span> <span class="token function">runtimeLog</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"计算结果: %i\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>再到 MingPass.cpp 中包含模块头文件</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"llvm/IR/Module.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>会用到 Module::getOrInsertFunction 函数来给 loglib.m 的 runtimeLog 做声明。</p>
<p>更改 runOnFunction 函数，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">virtual bool runOnFunction(Function &amp;F) &#123;
    &#x2F;&#x2F; 从运行时库中获取函数
    LLVMContext &amp;Context &#x3D; F.getContext();
    std::vector&lt;Type*&gt; paramTypes &#x3D; &#123;Type::getInt32Ty(Context)&#125;;
    Type *retType &#x3D; Type::getVoidTy(Context);
    FunctionType *funcType &#x3D; FunctionType::get(retType, paramTypes, false);
    FunctionCallee logFunc &#x3D; F.getParent()-&gt;getOrInsertFunction(&quot;runtimeLog&quot;, funcType);
  
    for (auto &amp;BB : F) &#123;
  for (auto &amp;I : BB) &#123;
      if (auto *op &#x3D; dyn_cast&lt;BinaryOperator&gt;(&amp;I)) &#123;
    IRBuilder&lt;&gt; builder(op);
              
    &#x2F;&#x2F; 在 op 后面加入新指令
    builder.SetInsertPoint(&amp;BB, ++builder.GetInsertPoint());
    &#x2F;&#x2F; 在函数中插入新指令
    Value* args[] &#x3D; &#123;op&#125;;
    builder.CreateCall(logFunc, args);

    return true;
      &#125; &#x2F;&#x2F; end if
  &#125;
    &#125;
    return false;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 build 目录下 make 出 pass 的 so 后，链接 main.m 和 loglib.m 的产物成可执行文件，命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">clang -c loglib.m
/usr/local/opt/llvm/bin/clang -flegacy-pass-manager -Xclang -load -Xclang build/src/libMingPass.so -c main.m
clang main.o loglib.o
./a.out<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>输入数字4后，打印如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">4</span>
计算结果: <span class="token number">6</span>
<span class="token number">6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="更多自制-pass"><a href="#更多自制-pass" class="headerlink" title="更多自制 pass"></a>更多自制 pass</h4><p>可以在<a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/LeanLLVMPass">这里</a>查看，代码里有详细注释。这里先留个白，后面再添加内容。</p>
<h4 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h4><p>你会发现开发 pass 需要更多的了解 IR，才可以更好的控制 LLVM 前端处理的高级语言。接下来我会说下那些高级语言的特性是怎么在 IR 里表现的。先介绍下 IR。</p>
<h5 id="IR-介绍"><a href="#IR-介绍" class="headerlink" title="IR 介绍"></a>IR 介绍</h5><p>LLVM IR(Intermediate Representation) 可以称为中间代码，是 LLVM 整个编译过程的中间表示。</p>
<p>llvm ir 的基础块里的指令是不可跳转到基础块的中间或尾部，只能从基础块的第一个指令进入基础块。</p>
<p>下面是 ir 的几个特点：</p>
<ul>
<li>llvm ir  不是机器代码而是生成机器代码之前的一种有些看起来像高级语言的，比如函数和强类型，有些看起来像低级程序集，比如分支和基本块。</li>
<li>llvm ir 是强类型。</li>
<li>llvm 没有 sign 和 unsign 整数区别。</li>
<li>全局符号用 @ 符号开头。</li>
<li>本地符号用 % 符号开头。</li>
<li>必须定义和声明所有符号。</li>
</ul>
<p>IR 指令</p>
<p><em>常用指令</em></p>
<ul>
<li>alloca：分配栈空间</li>
<li>load：从栈和全局内存读值</li>
<li>store：将值写到栈或全局内存</li>
<li>br：分支（条件或非条件）</li>
<li>call：调用函数</li>
<li>ret：从一个函数返回，可能会带上一个返回值</li>
<li>icmp&#x2F;fcmp：比较整型或浮点值</li>
<li>add&#x2F;sub&#x2F;mul：整数二进制算术运算</li>
<li>fadd&#x2F;fsub&#x2F;fmul：浮点二进制算术运算</li>
<li>sdiv&#x2F;udiv&#x2F;fdiv：有符号位整数&#x2F;无符号位整数&#x2F;浮点除法</li>
<li>shl&#x2F;shr：位向左&#x2F;向右</li>
<li>lshr&#x2F;ashr：逻辑&#x2F;算术右移</li>
<li>and&#x2F;or&#x2F;xor：位逻辑运算（没有 <code>not</code>！）</li>
</ul>
<p><em>常用特殊 ir 指令</em></p>
<ul>
<li>select：根据一个没有 IR 级别分支的条件选择一个值。</li>
<li>phi：根据当前基本块前身选择一个值。</li>
<li>getelementpointer：获取数组或结构体里子元素的地址（不是值）。官方说明[[<a target="_blank" rel="noopener" href="https://llvm.org/docs/GetElementPtr.html][The">https://llvm.org/docs/GetElementPtr.html][The</a> Often Misunderstood GEP Instruction]]。</li>
<li>extractvalue：从一个数组或结构体中提取一个成员字段的值（不是地址）。</li>
<li>insertvalue：将一个值添加给数组或结构体的成员字段。</li>
</ul>
<p><em>ir 转换指令</em></p>
<ul>
<li>bitcast：将一个值转成给定类型而不改变它的位。</li>
<li>trunc&#x2F;fptrunc：将一个类型的整数&#x2F;浮点值截断为一个更小的整数&#x2F;浮点类型。</li>
<li>zext&#x2F;sext&#x2F;fpext：将一个值扩展到一个更大的整数&#x2F;浮点类型上。</li>
<li>fptoui&#x2F;fptosi：将一个浮点值转换为无符号&#x2F;有符号位的整数类型。</li>
<li>uitofp&#x2F;sitofp：将一个无符号&#x2F;有符号位整数值转换为浮点类型。</li>
<li>ptrtoint：将指针转成整数。</li>
<li>inttoptr：将整数值转成指针类型。</li>
</ul>
<p>ir 库的 header 地址在 <code>include/llvm/IR</code> ，源文件在 <code>lib/IR</code> ，文档 <a target="_blank" rel="noopener" href="https://llvm.org/doxygen/namespacellvm.html">llvm Namespace Reference</a>。所有类和函数都在 llvm 命名空间里。</p>
<p>主要基础类的说明如下：</p>
<ul>
<li>llvm::Module：ir 的容器类的最高级。</li>
<li>llvm::Value：所有可作为其他值或指令操作数的基类。<ul>
<li>llvm::Constant<ul>
<li>llvm::ConstantDataArray (Constants.h)</li>
<li>llvm::ConstantInt (Constants.h)</li>
<li>llvm::ConstantFP (Constants.h)</li>
<li>llvm::ConstantStruct (Constants.h)</li>
<li>llvm::ConstantPointerNull (Constants.h)</li>
<li>llvm::Function</li>
<li>llvm::GlobalVariable</li>
</ul>
</li>
<li>llvm::BasicBlock</li>
<li>llvm::Instruction<ul>
<li>Useful X-macro header: Instruction.def</li>
<li>llvm::BinaryOperator (InstrTypes.h)<ul>
<li>add, sub, mul, sdiv, udiv, srem, urem</li>
<li>fadd, fsub, fmul, fdiv, frem</li>
<li>shl, lshr, ashr, and, or, xor</li>
</ul>
</li>
<li>llvm::CmpInst (InstrTypes.h)<ul>
<li>llvm::ICmpInst (Instructions.h)</li>
<li>llvm::FCmpInst (Instructions.h)</li>
</ul>
</li>
<li>llvm::UnaryInstruction (InstrTypes.h)<ul>
<li>llvm::CastInst (Instrtypes.h)</li>
</ul>
</li>
</ul>
</li>
<li>llvm::BitCastInst (Instructions.h)</li>
</ul>
</li>
<li>llvm::Type：代表所有的 IR 数据类型，包括原始类型，结构类型和函数类型。</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>下面 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> variable <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    variable <span class="token operator">=</span> variable <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> variable<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@variable &#x3D; global i32 21

define i32 @main() &#123;
    %1 &#x3D; load i32, i32* @variable  ; load the global variable
    %2 &#x3D; mul i32 %1, 2
    store i32 %2, i32* @variable   ; store instruction to write to global variable
    ret i32 %2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上代码，你可以看到全局变量是 @ 字符前缀，main 函数也是 @ 符号作为前缀，因此 main 函数也是 llvm 中的全局变量。llvm 将全局变量看成指针，因此访问全局变量时，必须用 load 指令显示取消对全局变量的引用，同样的，你要用 store 指令显示存储全局变量的值。</p>
<h5 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h5><p>本地变量有两种，一种是临时变量，也可以说是寄存器，另一种是堆栈分配的局部变量。</p>
<p>临时变量或寄存器是通过为变量引入一个新的符号来创建的：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%reg &#x3D; add i32 4, 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>堆栈分配的局部变量是通过在堆上分配变量来创建的。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%stack &#x3D; alloca i32<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>几乎每条指令都会返回一个值，该值通常分配给一个临时变量。由于 llvm ir 的 SSA 形式，临时变量只能分配一次。因此下面的代码就会出错：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%tmp &#x3D; add i32 4, 2
%tmp &#x3D; add i32 4, 1  ; Error here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>为符合 SSA，一般会是下面的代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%tmp.0 &#x3D; add i32 4, 2
%tmp.1 &#x3D; add i32 4, 1  ; fine now<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>简化为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%0 &#x3D; add i32 4, 2
%1 &#x3D; add i32 4, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这种局部变量的数量基本是无限的。因为真实机器的寄存器数量有限，因此编译器后端可能需要将其中一些临时寄存器放在堆栈上。</p>
<p>alloca 产生一个指向已分配类型的指针。必须要显示的使用 load 或 store 指令来分别读取和写入值。</p>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>有两种常量，一种是不占用分配内存的常量，另一种是占用分配内存的常量。</p>
<p>不占用分配内存的常量没有等效 llvm ir，他们是在编译前端将常量值插入到使用他们的位置。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%1 &#x3D; add i32 %0, 17     ; 17 就是内联的常量<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>占用分配内存的常量使用 constant 关键字定义：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@hello &#x3D; internal constant [6 x i8] c&quot;hello\00&quot;
%struct &#x3D; type &#123; i32, i8 &#125;
@struct_constant &#x3D; internal constant %struct &#123; i32 16, i8 4 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>可以看出常量实际也是个全局变量，可见性可以用 private 和 internal 来限制，这样它在当前模式之外是不可见的。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>在 LLVM 中有两种实现字符串类型的方法：</p>
<ul>
<li>在 LLVM IR 中编写实现</li>
<li>用生成 IR 的高级语言编写实现</li>
</ul>
<p>LLVM IR 中有一个简单但有用的字符串类型。</p>
<p>我们将创建一个动态的、可变的字符串类型，它可以被添加，也可以插入，转换大小写等等，这取决于定义了哪些支持函数来操作字符串类型。</p>
<p>这一切都归结为为类制作合适的类型定义，然后定义一组丰富的函数来对类型定义进行操作</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">    store i8* %output, i8** %1

    ;this-&gt;maxlen &#x3D; %value (value that was passed into @malloc is the new maxlen)
    %4 &#x3D; getelementptr %String* this, i32 0, i32 2
    store i32 %value, i32* %4
    ret void
&#125;

define fastcc void @String_Add_Char(%String* %this, i8 %value) &#123;
    ; Check if we need to grow the string.
    %1 &#x3D; getelementptr %String* %this, i32 0, i32 1
    %length &#x3D; load i32* %1
    %2 &#x3D; getelementptr %String* %this, i32 0, i32 2
    %maxlen &#x3D; load i32* %2
    ; if length &#x3D;&#x3D; maxlen:
    %3 &#x3D; icmp eq i32 %length, %maxlen
    br i1 %3, label %grow_begin, label %grow_close

grow_begin:
    %4 &#x3D; getelementptr %String* %this, i32 0, i32 3
    %factor &#x3D; load i32* %4
    %5 &#x3D; add i32 %maxlen, %factor
    call void @String_Resize(%String* %this, i32 %5)
    br label %grow_close

grow_close:
    %6 &#x3D; getelementptr %String* %this, i32 0, i32 0
    %buffer &#x3D; load i8** %6
    %7 &#x3D; getelementptr i8* %buffer, i32 %length
    store i8 %value, i8* %7
    %8 &#x3D; add i32 %length, 1
    store i32 %8, i32* %1

    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>下面的 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Foo</span>
<span class="token punctuation">&#123;</span>
  <span class="token class-name">size_t</span> x<span class="token punctuation">;</span>
  <span class="token keyword">double</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Foo &#x3D; type &#123;
    i64,       ; index 0 &#x3D; x
    double     ; index 1 &#x3D; y
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 struct 的结构成员是从0开始的数字进行索引。</p>
<p>下面是嵌套结构的例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">FooBar</span>
<span class="token punctuation">&#123;</span>
    Foo x<span class="token punctuation">;</span>
    <span class="token keyword">char</span><span class="token operator">*</span> c<span class="token punctuation">;</span>
    Foo<span class="token operator">*</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 ir 代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%FooBar &#x3D; type &#123;
    %Foo,         ; index 0 &#x3D; x
    i8*,          ; index 1 &#x3D; c
    %Foo*         ; index 2 &#x3D; y
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>不完整结构类型，对于隐藏结构细节非常有用。比如下面的 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对应的 ir 代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Foo &#x3D; type opaque
declare void @Bar(%Foo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>ir 的结构成员是通过索引而不是名称来记录的，getelementptr(GEP) 是专门用来计算指向任何结构成员的指针。比如下面 c++ 代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Foo
&#123;
    int a;
    char *b;
    double c;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应 ir 是：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Foo &#x3D; type &#123;
    i32,        ; 0: a
    i8*,        ; 1: b
    double      ; 2: c
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>GEP 索引如 ir 代码中的注释所示。现在访问 b 成员，c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Foo foo<span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>bptr <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">.</span>b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>先在堆栈上使用 alloca 指令分配对象，访问 b 成员，使用 GEP 指令计算指向内存位置的指针。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%foo &#x3D; alloca %Foo
; char **bptr &#x3D; &amp;foo.b
%1 &#x3D; getelementptr %Foo, %Foo* %foo, i32 0, i32 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>如果创建一个 Foo 对象数组，如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Foo bar[100];
bar[17].c &#x3D; 0.0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>会转成以下 ir 代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; Foo bar[100]
%bar &#x3D; alloca %Foo, i32 100
; bar[17].c &#x3D; 0.0
%2 &#x3D; getelementptr %Foo, %Foo* %bar, i32 17, i32 2
store double 0.0, double* %2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上面代码所示，它首先会分配一个指向 100 个 Foo 对象的指针。然后用 GEP 指令检索数组中第17个条目的第二个元素。</p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>有九种不同类型的转换</p>
<ul>
<li>Bitwise casts (type casts)</li>
<li>Zero-extending casts (unsigned upcasts).</li>
<li>Sign-extending casts (signed upcasts).</li>
<li>Truncasting casts (signed and unsigned downcasts).</li>
<li>Floating-point extending casts (float upcasts).</li>
<li>Floating-point truncasting casts (float downcasts)</li>
<li>Pointer-to-integer casts.</li>
<li>Integer-to-pointer casts.</li>
<li>Address-space casts (pointer casts).</li>
</ul>
<p><em>Bitwise Casts</em><br>bitwise cast 是按位强制转换。比如可以将指向字节的指针位转换为指向某个结构的指针。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token punctuation">(</span>Foo <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    foo<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>转换成对应的 ir：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Foo &#x3D; type &#123; i32 &#125;

declare i8* @malloc(i32)
declare void @free(i8*)

define void @allocate() nounwind &#123;
    %1 &#x3D; call i8* @malloc(i32 4)
    %foo &#x3D; bitcast i8* %1 to %Foo*
    %2 &#x3D; getelementptr %Foo, %Foo* %foo, i32 0, i32 0
    store i32 12, i32* %2
    call void @free(i8* %1)
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Zero-Extending Casts(Unsigned Upcasts)</em><br>比如下面的 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">uint8 byte <span class="token operator">=</span> <span class="token number">117</span><span class="token punctuation">;</span>
uint32 word<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* The compiler automatically upcasts the byte to a word. */</span>
    word <span class="token operator">=</span> byte<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 zext 指令：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@byte &#x3D; global i8 117
@word &#x3D; global i32 0

define void @main() nounwind &#123;
    %1 &#x3D; load i8, i8* @byte
    %2 &#x3D; zext i8 %1 to i32
    store i32 %2, i32* @word
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Sign-Extending Casts (Signed Upcasts)</em><br>将 zext 替换成 sext 指令即可。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@char &#x3D; global i8 -17
@int  &#x3D; global i32 0

define void @main() nounwind &#123;
    %1 &#x3D; load i8, i8* @char
    %2 &#x3D; sext i8 %1 to i32
    store i32 %2, i32* @int
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Truncating Casts (Signed and Unsigned Downcasts)</em><br>signed 和 unsigned 整数都使用相同的指令 trunc 来减少相关数字的大小。这是因为 llvm ir 假设所有有符号整数值都是二进制补码格式，因此 turn 注意处理这两种情况：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@int &#x3D; global i32 -1
@char &#x3D; global i8 0

define void @main() nounwind &#123;
    %1 &#x3D; load i32, i32* @int
    %2 &#x3D; trunc i32 %1 to i8
    store i8 %2, i8* @char
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Floating-Point Extending Casts (Float Upcasts)</em><br>浮点数可以使用 fpext 指令进行扩展，比如下面的 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> small <span class="token operator">=</span> <span class="token number">1.25</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> large<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/* The compiler inserts an implicit float upcast. */</span>
    large <span class="token operator">=</span> small<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>会变成：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@small &#x3D; global float 1.25
@large &#x3D; global double 0.0

define void @main() nounwind &#123;
    %1 &#x3D; load float, float* @small
    %2 &#x3D; fpext float %1 to double
    store double %2, double* @large
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Floating-Point Truncating Casts (Float Downcasts)</em><br>浮点数可以截断为更小的大小：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@large &#x3D; global double 1.25
@small &#x3D; global float 0.0

define void @main() nounwind &#123;
    %1 &#x3D; load double, double* @large
    %2 &#x3D; fptrunc double %1 to float
    store float %2, float* @small
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>Pointer-to-Integer Casts</em><br>使用 ptrtoint 指令将指针类型转换为整数类型。</p>
<p><em>Integer-to-Pointer Casts</em><br>使用 inttoptr 指令将整数转换成指针。</p>
<h5 id="函数和声明"><a href="#函数和声明" class="headerlink" title="函数和声明"></a>函数和声明</h5><p>函数定义取决于 calling convention、excption-aware 和模块是否对外公开。</p>
<p>下面是一个简单的 c 函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">17</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>会转换成</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @Bar() nounwind &#123;
    ret i32 17
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>私有函数定义如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define private i32 @Foo() nounwind &#123;
    ret i32 17
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>ir 的私有函数只是 llvm 模块级的私有函数，并不是和高级语言 private 关键字定义的函数对应。</p>
<p>函数原型在 ir 里使用 declare 来声明：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对应使用 declare 声明为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">declare i32 @Bar(i32 %value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>可变参数的函数，要用省略号定义或声明它，然后需要使用特殊的函数调用语法。示例如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">declare i32 @printf(i8*, ...) nounwind

@.textstr &#x3D; internal constant [20 x i8] c&quot;Argument count: %d\0A\00&quot;

define i32 @main(i32 %argc, i8** %argv) nounwind &#123;
    ; printf(&quot;Argument count: %d\n&quot;, argc)
    %1 &#x3D; call i32 (i8*, ...) @printf(i8* getelementptr([20 x i8], [20 x i8]* @.textstr, i32 0, i32 0), i32 %argc)
    ret i32 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>函数重载不是在 ir 里处理的，是在源语言上处理的。重载的函数名称不同，示例如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">double</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">double</span> a<span class="token punctuation">,</span> <span class="token keyword">double</span> b<span class="token punctuation">,</span> <span class="token keyword">double</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token operator">*</span>b <span class="token operator">+</span> x<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面 c 代码对应 ir 是：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @_Z8functionii(i32 %a, i32 %b) #0 &#123;
; [...]
  ret i32 %5
&#125;

define double @_Z8functionddd(double %a, double %b, double %x) #0 &#123;
; [...]
  ret double %8
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可见在 ir 里，重载函数的名称和功能都是不同的。</p>
<p>类或结构体通常是按值传递，在传递对象时隐式克隆对象。比如下面的 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">double</span> x<span class="token punctuation">;</span>
    <span class="token keyword">double</span> y<span class="token punctuation">;</span>
    <span class="token keyword">double</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Point <span class="token function">add_points</span><span class="token punctuation">(</span>Point a<span class="token punctuation">,</span> Point b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  Point p<span class="token punctuation">;</span>
  p<span class="token punctuation">.</span>x <span class="token operator">=</span> a<span class="token punctuation">.</span>x <span class="token operator">+</span> b<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
  p<span class="token punctuation">.</span>y <span class="token operator">=</span> a<span class="token punctuation">.</span>y <span class="token operator">+</span> b<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
  p<span class="token punctuation">.</span>z <span class="token operator">=</span> a<span class="token punctuation">.</span>z <span class="token operator">+</span> b<span class="token punctuation">.</span>z<span class="token punctuation">;</span>
  <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应 ir 是：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%struct.Point &#x3D; type &#123; double, double, double &#125;

define void @add_points(%struct.Point* noalias sret %agg.result,
                        %struct.Point* byval align 8 %a,
                        %struct.Point* byval align 8 %b) #0 &#123;
; there is no alloca here for Point p;
; p.x &#x3D; a.x + b.x;
  %1 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 0
  %2 &#x3D; load double, double* %1, align 8
  %3 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 0
  %4 &#x3D; load double, double* %3, align 8
  %5 &#x3D; fadd double %2, %4
  %6 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 0
  store double %5, double* %6, align 8
; p.y &#x3D; a.y + b.y;
  %7 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 1
  %8 &#x3D; load double, double* %7, align 8
  %9 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 1
  %10 &#x3D; load double, double* %9, align 8
  %11 &#x3D; fadd double %8, %10
  %12 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 1
  store double %11, double* %12, align 8
; p.z &#x3D; a.z + b.z;
  %13 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 2
  %14 &#x3D; load double, double* %13, align 8
  %15 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 2
  %16 &#x3D; load double, double* %15, align 8
  %17 &#x3D; fadd double %14, %16
  %18 &#x3D; getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 2
  store double %17, double* %18, align 8
; there is no real returned value, because the previous stores directly wrote
; to the caller allocated value via %agg.result
  ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 add_points 函数返回的是 void，另外添加了一个参数，这个参数是指向返回结果的指针，有调用者来分配。这个指针是 noalias 属性，sret 属性表明这是返回值。参数是 byval 属性，表示他们是按值传递的结构。</p>
<p>下面代码是展示如何调用 add_points 函数。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  Point a <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token number">4.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  Point b <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token number">8.0</span><span class="token punctuation">,</span> <span class="token number">5.0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  Point c <span class="token operator">=</span> <span class="token function">add_points</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编成 ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @main() #1 &#123;
; these are the a, b, c in the scope of main
  %a &#x3D; alloca %struct.Point, align 8
  %b &#x3D; alloca %struct.Point, align 8
  %c &#x3D; alloca %struct.Point, align 8
; these are copies, which are passed as arguments
  %1 &#x3D; alloca %struct.Point, align 8
  %2 &#x3D; alloca %struct.Point, align 8
; copy the global initializer main::a to %a
  %3 &#x3D; bitcast %struct.Point* %a to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* bitcast (%struct.Point* @main.a to i8*), i64 24, i32 8, i1 false)
; copy the global initializer main::b to %b
  %4 &#x3D; bitcast %struct.Point* %b to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* bitcast (%struct.Point* @main.b to i8*), i64 24, i32 8, i1 false)
; clone a to %1
  %5 &#x3D; bitcast %struct.Point* %1 to i8*
  %6 &#x3D; bitcast %struct.Point* %a to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 24, i32 8, i1 false)
; clone b to %1
  %7 &#x3D; bitcast %struct.Point* %2 to i8*
  %8 &#x3D; bitcast %struct.Point* %b to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 24, i32 8, i1 false)
; call add_points with the cloned values
  call void @add_points(%struct.Point* sret %c, %struct.Point* byval align 8 %1, %struct.Point* byval align 8 %2)
  ; [...]
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到调用者为返回值 %c 分配空间，并且确保在实际通过引用传递参数前克隆参数 a 和 b。</p>
<p>异常处理函数，可以返回一个指向异常实例的指针，创建一个 setjmp&#x2F;longjmp 帧，或者简单指定 uwtable 属性。</p>
<p>函数指针的表达方式和 c 差不多，比如下面 c 代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>Function<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>对应 ir 为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@Function &#x3D; global i32(i8*)* null<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h5><p>llvm 不支持 unions，下面的 c++ 代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">union Foo
&#123;
    int a;
    char *b;
    double c;
&#125;;

Foo Union;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应 ir 为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%union.Foo &#x3D; type &#123; double &#125;
@Union &#x3D; %union.Foo &#123; 0.0 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>其它成员没有了，ir 要访问他们要用 bitcast 指令将指向 union 的指针转换为你想要的指针。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%1 &#x3D; bitcast %union.Foo* @Union to i32*
store i32 1, i32* %1
%2 &#x3D; bitcast %union.Foo* @Union to i8**
store i8* null, i8** %2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>实际上 unions 只不过是一块使用不同隐式指针强制转换访问的内存。处理 unions 没有类型安全。前端语言需要对 unions 做支持，可以简单的分配 unions 的总大小，也就是最大成员的大小，然后根据需要生成代码来重新解释分配的内存。</p>
<h5 id="if-then-else-分支"><a href="#if-then-else-分支" class="headerlink" title="if-then-else 分支"></a>if-then-else 分支</h5><p>llvm ir 是按顺序执行的指令序列组成。这些指令组合在一起形成基本块，每个基本块都以改变程序控制流的指令结束。</p>
<p>下面是个简单的 if-then-else 分支：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 ir 中，控制流是通过在基本块之间跳转实现的。这些基本块包含不改变控制流的指令序列。每个基本块都以改变程序控制流的指令结束。最常见的分支指令是 br。br 可以带上条件，然后它实现了一个简单的 if-then-else 。如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">br i1 %cond, label %iftrue, label %iffalse<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>br 也可以实现无条件跳转到某个目的地：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">br label %dest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>前面的 c 函数对应的 ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %retval &#x3D; alloca i32, align 4
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:                                      ; preds &#x3D; %2
  store i32 %a, i32* %retval, align 4
  br label %end

bfalse:                                     ; preds &#x3D; %2
  store i32 %b, i32* %retval, align 4
  br label %end

end:                                     ; preds &#x3D; %btrue, %bfalse
  %1 &#x3D; load i32, i32* %retval, align 4
  ret i32 %1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上代码所示，共有4个基本块，第一个是函数入口，使用 alloca 在堆栈上分配空间，用作较大的临时存储，然后使用 icmp 指令比较两个参数 %a 和 %b。结果是一个布尔标志 i1，将其用于 br 指令的条件。然后根据所采用的分支，将 %a 或 %b 存储到临时 %retval 变量中。每个分支都以无条件分支到最后一个基本块 %end 结束。来自 %retval 的值被加载并返回。</p>
<p>通过 opt -dot-cfg input.ll 可以获得 CFG 流程图。</p>
<p>select 指令可以进行更高级别优化，不生成分支，缩短代码，比如上面的 ir 代码优化后为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @max(i32 %a, i32 %b) &#123;
  %1 &#x3D; icmp sgt i32 %a, %b
  %2 &#x3D; select i1 %1, i32 %a, i32 %b
  ret i32 %2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="静态单一赋值表（SSA-Form）和-PHI"><a href="#静态单一赋值表（SSA-Form）和-PHI" class="headerlink" title="静态单一赋值表（SSA Form）和 PHI"></a>静态单一赋值表（SSA Form）和 PHI</h5><p>下面是一个 c 函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 llvm ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %retval &#x3D; alloca i32, align 4
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:                                      ; preds &#x3D; %2
  store i32 %a, i32* %retval, align 4
  br label %end

bfalse:                                     ; preds &#x3D; %2
  store i32 %b, i32* %retval, align 4
  br label %end

end:                                     ; preds &#x3D; %btrue, %bfalse
  %1 &#x3D; load i32, i32* %retval, align 4
  ret i32 %1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 max 函数使用 alloc 在堆栈上分配空间，其中存储了较大的值。在一个分支中，%a 被存储，而在另一个分支中，%b 被存储到堆栈分配的内存中。尽可能避免使用内存 load&#x2F;store 操作，而是更多的使用寄存器。所以按下面方式来写：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:
  %retval &#x3D; %a
  br label %end

bfalse:
  %retval &#x3D; %b
  br label %end

end:
  ret i32 %retval
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这不是有效的 LLVM IR，因为 LLVM IR 是静态单已分配形式，也就是 SSA。SSA 形式要求每个变量只分配一次。SSA 形式支持并简化了大量的编译器优化，并且是命令式编程语言解释器中中间表示的实际上的标准。</p>
<p>那怎么用 SSA 形式 LLVM IR 实现上述代码？答案是神奇的 phi 指令。phi 指令以 SSA 理论中使用的 φ 函数命名。这个函数会根据控制流神奇的选择正确的值。在 LLVM 中，你必须手动指定值的名称和前一个基本块。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">end:
  %retval &#x3D; phi i32 [%a, %btrue], [%b, %bfalse]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>这里我们指示 phi 指令在前一个基本块为 %btrue 时选择 %a。如果之前的基本块是 %bfalse，那么将使用 %b。然后将该值分配给一个新变量 %retval。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define i32 @max(i32 %a, i32 %b) &#123;
entry:
  %0 &#x3D; icmp sgt i32 %a, %b
  br i1 %0, label %btrue, label %bfalse

btrue:                                      ; preds &#x3D; %2
  br label %end

bfalse:                                     ; preds &#x3D; %2
  br label %end

end:                                     ; preds &#x3D; %btrue, %bfalse
  %retval &#x3D; phi i32 [%a, %btrue], [%b, %bfalse]
  ret i32 %retval
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><em>后端的 PHI</em></p>
<p>让我们看看 @max 函数现在如何映射到实际的机器代码。查看的是 x86 64 位生成的代码，用不同优化级别进行编译。非优化后端命令 llc -O0 -filetype&#x3D;asm。得到的结果是：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">max:                                    # @max
# %bb.0:                                # %entry
    cmpl    %esi, %edi                  # %edi &#x3D; %a, %esi &#x3D; %b
    jle     .LBB0_2
# %bb.1:                                # %btrue
    movl    %edi, -4(%rsp)              # mov src, dst
    jmp     .LBB0_3
.LBB0_2:                                # %bfalse
    movl    %esi, -4(%rsp)              # mov src, dst
    jmp     .LBB0_3
.LBB0_3:                                # %end
    movl    -4(%rsp), %eax              # return value in eax
    retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>参数 %a 和 %b 分别在 %edi 和 %esi 中传递。我们可以看到编译后端生成的代码使用堆栈来存储更大的值。因此，当我们编写 LLVM IR 时，编译器后端生成的代码并不是我们所想的。原因是编译器后端需要用真机指令来实现 phi 指令。通常这是通过分配给一个寄存器或存储到一个公共堆栈位置来完成的。通常编译器后端将使用堆栈来实现 phi 指令。但是，如果我们在后端使用更多优化，也就是 llc -O1，可以获得更优化的版本：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">max:                                    # @max
# %bb.0:                                # %entry
    cmpl    %esi, %edi
    jg      .LBB0_2
# %bb.1:                                # %bfalse
    movl    %esi, %edi
.LBB0_2:                                # %end
    movl    %edi, %eax
    retq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的 phi 函数是通过使用 %edi 寄存器实现的。在一个分支中，%edi 已经包含所需的值，所以什么都没发生。在另一个分支中，%esi 被复制到 %edi。在 %end 基本块中，%edi 包含来自两个分支的所需值。这更像是我们的想法。我们可以看到优化是需要在整个编译管道中的应用的东西。</p>
<h5 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h5><p>lambda 函数是一个匿名函数，它可以自由引用包含函数中的局部变量，也包括参数变量。Lambda 的实现和 Pascal 的嵌套函数一样，只是编译器负责为 lambda 函数生成内部名称。有几种不同的方法可以实现 lambda 函数。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int foo(int a)
&#123;
  auto function &#x3D; [a](int x) &#123; return x + a; &#125;;
  return function(10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里的问题是 lambda 函数引用了调用者的一个局部变量，即 a，即使 lambda 函数是它自己的函数。这可以通过将局部变量作为隐式参数传递给 lambda 函数来轻松解决：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">define internal i32 @lambda(i32 %a, i32 %x) &#123;
  %1 &#x3D; add i32 %a, %x
  ret i32 %1
&#125;

define i32 @foo(i32 %a) &#123;
  %1 &#x3D; call i32 @lambda(i32 %a, i32 10)
  ret i32 %1
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>或者，如果 lambda 函数使用多个变量，你可以将他们包装在一个结构中，然后将指针传递给 lambda 函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">extern int integer_parse();

int foo(int a, int b)
&#123;
  int c &#x3D; integer_parse();
  auto function &#x3D; [a, b, c](int x) &#123; return (a + b - c) * x; &#125;;
  return function(10);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应 IR 是：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; ModuleID &#x3D; &#39;lambda_func_1_cleaned.ll&#39;
source_filename &#x3D; &quot;lambda_func_1_cleaned.ll&quot;
target datalayout &#x3D; &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;
target triple &#x3D; &quot;x86_64-unknown-linux-gnu&quot;

%lambda_args &#x3D; type &#123; i32, i32, i32 &#125;

declare i32 @integer_parse()

define i32 @lambda(%lambda_args* %args, i32 %x) &#123;
  %1 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 0
  %a &#x3D; load i32, i32* %1
  %2 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 1
  %b &#x3D; load i32, i32* %2
  %3 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 2
  %c &#x3D; load i32, i32* %3
  %4 &#x3D; add i32 %a, %b
  %5 &#x3D; sub i32 %4, %c
  %6 &#x3D; mul i32 %5, %x
  ret i32 %6
&#125;

define i32 @foo(i32 %a, i32 %b) &#123;
  %args &#x3D; alloca %lambda_args
  %1 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 0
  store i32 %a, i32* %1
  %2 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 1
  store i32 %b, i32* %2
  %c &#x3D; call i32 @integer_parse()
  %3 &#x3D; getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 2
  store i32 %c, i32* %3
  %4 &#x3D; call i32 @lambda(%lambda_args* %args, i32 10)
  ret i32 %4
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>显然，这个主题有一些可能的变化：</p>
<ul>
<li>你可以将所有隐式作为参数参数当成参数来传递。</li>
<li>你可以将结构中所有隐式参数作为显示参数传递。</li>
<li>你可以传入一个指向调用者帧的指针，并让 lambda 函数从输入帧中提取参数和局部变量。</li>
</ul>
<h5 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器 Generators"></a>生成器 Generators</h5><p>生成器是一个函数，它以这样的一种方式重复生成一个值，使函数的状态在函数的重复调用中保持不变，包括函数在生产值时的局部偏移量。</p>
<p>实现生成器最直接的方法就是将其所有状态变量，包括参数、局部变量和返回值都包装到一个 ad-hoc 结构中，然后将该结构的地址传递给生成器。</p>
<p>某种程度上说，你需要在每次调用时跟踪你正在执行的生成器是哪个块。这可以通过多种方式完成。我们在这展示的方式是使用 LLVM 的 blockaddress 指令来保存下一个应该执行的本地代码块的地址。其它实现使用简单的状态变量，然后根据状态变量的值进行类似开关的调度。在这两种情况下，最终结果是相同的，也就是为生成器中的每个本地块执行不同的代码块。</p>
<p>重要的是将迭代器视为一种微线程，每当再次调用迭代器时，它就会恢复。换句话说，我们需要保存迭代器每次通过多远的地址，以便它可以恢复，就好像发生了微观线程切换一样。所以我们在返回指令之后保存指令的地址，这样我们就可以继续运行，就好像我们一开始就没有返回一样。</p>
<p>下面是一段简化的伪代码。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;

generator int foo()
&#123;
    yield 1;
    yield 2;
    yield 3;
&#125;

int main()
&#123;
    foreach (int i in foo())
  printf(&quot;Value: %d\n&quot;, i);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对应的 IR 如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%foo_context &#x3D; type &#123;
    i8*,      ; 0: block (state)
    i32       ; 1: value (result)
&#125;

define void @foo_setup(%foo_context* %context) nounwind &#123;
    ; set up &#39;block&#39;
    %1 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.yield1), i8** %1

    ret void
&#125;

; The boolean returned indicates if a result was available or not.
; Once no more results are available, the caller is expected to not call
; the iterator again.
define i1 @foo_yield(%foo_context* %context) nounwind &#123;
    ; dispatch to the active generator block
    %1 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    %2 &#x3D; load i8** %1
    indirectbr i8* %2, [ label %.yield1, label %.yield2, label %.yield3, label %.done ]

.yield1:
    ; store the result value (1)
    %3 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    store i32 1, i32* %3

    ; make &#39;block&#39; point to next block to execute
    %4 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.yield2), i8** %4

    ret i1 1

.yield2:
    ; store the result value (2)
    %5 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    store i32 2, i32* %5

    ; make &#39;block&#39; point to next block to execute
    %6 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.yield3), i8** %6

    ret i1 1

.yield3:
    ; store the result value (3)
    %7 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    store i32 3, i32* %7

    ; make &#39;block&#39; point to next block to execute
    %8 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.done), i8** %8

    ret i1 1

.done:
    ret i1 0
&#125;

declare i32 @printf(i8*, ...) nounwind

@.string &#x3D; internal constant [11 x i8] c&quot;Value: %d\0A\00&quot;

define void @main() nounwind &#123;
    ; allocate and initialize generator context structure
    %context &#x3D; alloca %foo_context
    call void @foo_setup(%foo_context* %context)
    br label %.head

.head:
    ; foreach (int i in foo())
    %1 &#x3D; call i1 @foo_yield(%foo_context* %context)
    br i1 %1, label %.body, label %.tail

.body:
    %2 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    %3 &#x3D; load i32* %2
    %4 &#x3D; call i32 (i8*, ...)* @printf(i8* getelementptr([11 x i8]* @.string, i32 0, i32 0), i32 %3)
    br label %.head

.tail:
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>下面是一个涉及局部变量的稍微复杂的示例：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;

generator int foo(int start, int after)
&#123;
    for (int index &#x3D; start; index &lt; after; index++)
    &#123;
        if (index % 2 &#x3D;&#x3D; 0)
            yield index + 1;
        else
            yield index - 1;
    &#125;
&#125;

int main(void)
&#123;
    foreach (int i in foo(0, 5))
        printf(&quot;Value: %d\n&quot;, i);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>生成 IR 代码为：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%foo_context &#x3D; type &#123;
    i8*,      ; 0: block (state)
    i32,      ; 1: start (argument)
    i32,      ; 2: after (argument)
    i32,      ; 3: index (local)
    i32       ; 4: value (result)
&#125;

define void @foo_setup(%foo_context* %context, i32 %start, i32 %after) nounwind &#123;
    ; set up &#39;block&#39;
    %1 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.init), i8** %1

    ; set up &#39;start&#39;
    %2 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    store i32 %start, i32* %2

    ; set up &#39;after&#39;
    %3 &#x3D; getelementptr %foo_context* %context, i32 0, i32 2
    store i32 %after, i32* %3

    ret void
&#125;

define i1 @foo_yield(%foo_context* %context) nounwind &#123;
    ; dispatch to the active generator block
    %1 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    %2 &#x3D; load i8** %1
   indirectbr i8* %2, [ label %.init, label %.loop_close, label %.end ]

.init:
    ; copy argument &#39;start&#39; to the local variable &#39;index&#39;
    %3 &#x3D; getelementptr %foo_context* %context, i32 0, i32 1
    %start &#x3D; load i32* %3
    %4 &#x3D; getelementptr %foo_context* %context, i32 0, i32 3
    store i32 %start, i32* %4
    br label %.head

.head:
    ; for (; index &lt; after; )
    %5 &#x3D; getelementptr %foo_context* %context, i32 0, i32 3
    %index &#x3D; load i32* %5
    %6 &#x3D; getelementptr %foo_context* %context, i32 0, i32 2
    %after &#x3D; load i32* %6
    %again &#x3D; icmp slt i32 %index, %after
    br i1 %again, label %.loop_begin, label %.exit

.loop_begin:
    %7 &#x3D; srem i32 %index, 2
    %8 &#x3D; icmp eq i32 %7, 0
    br i1 %8, label %.even, label %.odd

.even:
    ; store &#39;index + 1&#39; in &#39;value&#39;
    %9 &#x3D; add i32 %index, 1
    %10 &#x3D; getelementptr %foo_context* %context, i32 0, i32 4
    store i32 %9, i32* %10

    ; make &#39;block&#39; point to the end of the loop (after the yield)
    %11 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.loop_close), i8** %11

    ret i1 1

.odd:
    ; store &#39;index - 1&#39; in value
    %12 &#x3D; sub i32 %index, 1
    %13 &#x3D; getelementptr %foo_context* %context, i32 0, i32 4
    store i32 %12, i32* %13

    ; make &#39;block&#39; point to the end of the loop (after the yield)
    %14 &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.loop_close), i8** %14

    ret i1 1

.loop_close:
    ; increment &#39;index&#39;
    %15 &#x3D; getelementptr %foo_context* %context, i32 0, i32 3
    %16 &#x3D; load i32* %15
    %17 &#x3D; add i32 %16, 1
    store i32 %17, i32* %15
    br label %.head

.exit:
    ; make &#39;block&#39; point to the %.end label
    %x &#x3D; getelementptr %foo_context* %context, i32 0, i32 0
    store i8* blockaddress(@foo_yield, %.end), i8** %x
    br label %.end

.end:
    ret i1 0
&#125;

declare i32 @printf(i8*, ...) nounwind

@.string &#x3D; internal constant [11 x i8] c&quot;Value: %d\0A\00&quot;

define i32 @main() nounwind &#123;
    ; allocate and initialize generator context structure
    %context &#x3D; alloca %foo_context
    call void @foo_setup(%foo_context* %context, i32 0, i32 5)
    br label %.head

.head:
    ; foreach (int i in foo(0, 5))
    %1 &#x3D; call i1 @foo_yield(%foo_context* %context)
    br i1 %1, label %.body, label %.tail

.body:
    %2 &#x3D; getelementptr %foo_context* %context, i32 0, i32 4
    %3 &#x3D; load i32* %2
    %4 &#x3D; call i32 (i8*, ...)* @printf(i8* getelementptr([11 x i8]* @.string, i32 0, i32 0), i32 %3)
    br label %.head

.tail:
    ret i32 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行上述操作的另一种可能方法是为每个状态生成一个 LLVM IR 函数，然后存储一个函数指针。</p>
<p>在上下文结构中，每当需要调用新的状态或函数时都会更新。</p>
<h5 id="面向对象结构"><a href="#面向对象结构" class="headerlink" title="面向对象结构"></a>面向对象结构</h5><p>接下来研究各种面向对象的结构，看怎么映射到 LLVM IR。</p>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>一个类只不过是一个结构，它具有一组相关函数，这些函数接受一个隐式的第一个参数，即指向该结构的指针。因此将一个类映射到 LLVM IR 很简单：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stddef.h&gt;

class Foo
&#123;
public:
    Foo()
    &#123;
  _length &#x3D; 0;
    &#125;

    size_t GetLength() const
    &#123;
  return _length;
    &#125;

    void SetLength(size_t value)
    &#123;
  _length &#x3D; value;
    &#125;

private:
    size_t _length;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先将这段代码转换成两个独立的部分：</p>
<ul>
<li>结构定义</li>
<li>方法列表，包括构造函数</li>
</ul>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; The structure definition for class Foo.
%Foo &#x3D; type &#123; i32 &#125;

; The default constructor for class Foo.
define void @Foo_Create_Default(%Foo* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    store i32 0, i32* %1
    ret void
&#125;

; The Foo::GetLength() method.
define i32 @Foo_GetLength(%Foo* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    %2 &#x3D; load i32, i32* %1
    ret i32 %2
&#125;

; The Foo::SetLength() method.
define void @Foo_SetLength(%Foo* %this, i32 %value) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    store i32 %value, i32* %1
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后我们确保调用了构造函数 Foo_Create_Default。</p>
<p>每当创建结构的实例时：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Foo foo;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%foo &#x3D; alloca %Foo
call void @Foo_Create_Default(%Foo* %foo)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h5><p>虚方法只不过是编译器控制的函数指针。每个虚方法都记录在 vtable 中，它是给定类所需的所有函数指针的结构：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Foo &#123;
public:
  virtal int GetLengthTimesTwo() const &#123;
    return _length * 2;
  &#125;

  void SetLength(size_t value) &#123;
    _length &#x3D; value;
  &#125;
private:
  int _length;

&#125;;

int main() &#123;
  Foo foo;
  foo.setLength(4);
  return foo.GetLengthTimesTwo();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这变成：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Foo_vtable_type &#x3D; type &#123; i32(%Foo*)* &#125;

%Foo &#x3D; type &#123; %Foo_vtable_type*, i32 &#125;

define i32 @Foo_GetLengthTimesTwo(%Foo* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 1
    %2 &#x3D; load i32, i32* %1
    %3 &#x3D; mul i32 %2, 2
    ret i32 %3
&#125;

@Foo_vtable_data &#x3D; global %Foo_vtable_type &#123;
    i32(%Foo*)* @Foo_GetLengthTimesTwo
&#125;

define void @Foo_Create_Default(%Foo* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 0
    store %Foo_vtable_type* @Foo_vtable_data, %Foo_vtable_type** %1
    %2 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 1
    store i32 0, i32* %2
    ret void
&#125;

define void @Foo_SetLength(%Foo* %this, i32 %value) nounwind &#123;
    %1 &#x3D; getelementptr %Foo, %Foo* %this, i32 0, i32 1
    store i32 %value, i32* %1
    ret void
&#125;

define i32 @main(i32 %argc, i8** %argv) nounwind &#123;
    %foo &#x3D; alloca %Foo
    call void @Foo_Create_Default(%Foo* %foo)
    call void @Foo_SetLength(%Foo* %foo, i32 4)
    %1 &#x3D; getelementptr %Foo, %Foo* %foo, i32 0, i32 0
    %2 &#x3D; load %Foo_vtable_type*, %Foo_vtable_type** %1
    %3 &#x3D; getelementptr %Foo_vtable_type, %Foo_vtable_type* %2, i32 0, i32 0
    %4 &#x3D; load i32(%Foo*)*, i32(%Foo*)** %3
    %5 &#x3D; call i32 %4(%Foo* %foo)
    ret i32 %5
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>请注意，一些 C++ 编译器将 _vtable 存储在结构中的负偏移量处，这样 memeset(this, 0, sizeof(*this))之类的东西就可以工作，即使在 OOP 上下文中应始终避免使用此类命令。</p>
<p><em>Rust 特征和 VTable</em><br>与 C++ 相比，Rust 确实具有完全不同的对象模型。但是，当涉及到动态调度的低级细节时，他们非常相似。我们将探讨 rust 文档中的一个示例，以及 rustc 编译器发出什么样的 llvm IR。rust 和 C++ 都使用虚拟方法进行动态调度。但是，在 rust 中，高级语言中没有虚拟方法之类的东西。相反，我们可以为我们的数据类型实现 trait，然后实现一个接口，该接口接受所有实现 trait 的数据类型并动态分派到正确的 trait 实现，也就是下面示例中 dyn Trait 语法。</p>
<p>编译器必须在运行时动态决定使用哪个函数。编译器只知道存储在 components 向量中的对象确实满足特征 Draw。作为对不太熟悉 rust 的人的附注：将对象包装在 Box 中本质上是将对象放在堆上，有点类似于 C++ 中的 unique_ptr 并有效地允许我们放置 trait 对象，也就是本例中为 dyn Drawable 在向量中。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; test::Screen::run
; Function Attrs: nonlazybind uwtable
define void @&quot;Screen::run&quot;(%Screen* %self) &#123;
start:

;; (omitting the initial prologue and setup code)
;; this is the start of the for loop in Screen::run calling the next method
;; on the iterator for the first time and checking whether it is None (or
;; null in llvm here)
;; %5 contains the pointer to the first component in the vector here
  %6 &#x3D; icmp eq i64* %5, null
  br i1 %6, label %end, label %forloop

end:                                              ; preds &#x3D; %forloop, %start
  ret void

forloop:                                          ; preds &#x3D; %start, %forloop
  %7 &#x3D; phi i64* [ %next_component, %forloop ], [ %5, %start ]
;; here the boxed pointer is retrieved and dereferenced to retrieve the
;; vtable pointer
  %8 &#x3D; bitcast i64* %7 to &#123;&#125;**
  %self_ptr &#x3D; load &#123;&#125;*, &#123;&#125;** %8
  %9 &#x3D; getelementptr inbounds i64, i64* %7, i64 1
  %vtable_ptr &#x3D; bitcast i64* %9 to void (&#123;&#125;*)***
  %vtable &#x3D; load void (&#123;&#125;*)**, void (&#123;&#125;*)*** %vtable_ptr
;; 3 is the index into the vtable struct, which refers to the draw implementation for this particular struct
  %trait_method_ptr &#x3D; getelementptr inbounds void (&#123;&#125;*)*, void (&#123;&#125;*)** %vtable, i64 3
  %trait_method &#x3D; load void (&#123;&#125;*)*, void (&#123;&#125;*)** %vmethod
;; indirect call to trait method
  call void %trait_method(&#123;&#125;* %self_ptr)

;; retrieve the next object
  %next_component &#x3D; call i64* @&quot;&lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::next&quot;(&#123; i64*, i64* &#125;* %iter)
  %14 &#x3D; icmp eq i64* %next_component, null
  br i1 %14, label %end, label %forloop
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 llvm 模块的全局变量中，我们可以看到如下所示的 vtable。Button 和 SelectBox 都有关联的 vtable。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@vtable.screen &#x3D; private unnamed_addr constant
  ;; the Type of the constant vtable structure
  &#123; void (%SelectBox*)*, i64, i64, void (%SelectBox*)* &#125;
  &#123;
    ;; first entry is the function to drop the object
    void (%SelectBox*)* @&quot;core::ptr::drop_in_place&lt;test::SelectBox&gt;&quot;,  ;; destructor
    i64 32, ;; size
    i64 8,  ;; alignment
    ;; last in the vtable is the pointer to the SelectBox::draw implementation
    void (%SelectBox*)* @&quot;&lt;test::SelectBox as test::Draw&gt;::draw&quot;
  &#125;

;; the vtable for Button is structured basically the same
@vtable.button &#x3D; private unnamed_addr constant
    &#123; void (%Button*)*, i64, i64, void (%Button*)* &#125;
    &#123;
  void (%Button*)* @&quot;core::ptr::drop_in_place&lt;test::Button&gt;&quot;,
  i64 32, i64 8,
  void (%Button*)* @&quot;&lt;test::Button as test::Draw&gt;::draw&quot;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这篇博文 <a target="_blank" rel="noopener" href="https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/">Exploring Dynamic Dispatch in Rust</a> 更详细的解释 vtable 和动态调度以及他们在 rust 和 C++ 中的区别。</p>
<h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>单继承非常简单：每个结构体或类在内存中按声明顺序依次排列。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base &#123;
  public:
    void SetA(int value) &#123;
_a &#x3D; value;
    &#125;
  private:
    int _a;
&#125;;

class Derived: public Base &#123;
  public:
    void SetB(int value) &#123;
SetA(value);
_b &#x3D; value;
    &#125;
  protected:
    int _b;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里 a 和 b 将在内存中彼此跟随，因此从一个类继承只是一个简单的问题。</p>
<p>将基类声明为继承类中的第一个成员。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%Base &#x3D; type &#123;
    i32         ; &#39;_a&#39; in class Base
&#125;

define void @Base_SetA(%Base* %this, i32 %value) nounwind &#123;
    %1 &#x3D; getelementptr %Base, %Base* %this, i32 0, i32 0
    store i32 %value, i32* %1
    ret void
&#125;

%Derived &#x3D; type &#123;
    i32,        ; &#39;_a&#39; from class Base
    i32         ; &#39;_b&#39; from class Derived
&#125;

define void @Derived_SetB(%Derived* %this, i32 %value) nounwind &#123;
    %1 &#x3D; bitcast %Derived* %this to %Base*
    call void @Base_SetA(%Base* %1, i32 %value)
    %2 &#x3D; getelementptr %Derived, %Derived* %this, i32 0, i32 1
    store i32 %value, i32* %2
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此，基类简单的成为派生类的类型声明的普通成员。</p>
<p>然后编译器必须在派生类被引用为其基类时插入适当的类型转换，如上所示，使用 bitcast 运算符。</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承也不是很难，只是在每个派生类内部按顺序排列多个继承的结构，同时考虑到多次继承的数据成员的重复性。</p>
<p>下面的 c++ 代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BaseA
&#123;
public:
    void SetA(int value)
    &#123;
  _a &#x3D; value;
    &#125;

private:
    int _a;
&#125;;

class BaseB: public BaseA
&#123;
public:
    void SetB(int value)
    &#123;
  SetA(value);
  _b &#x3D; value;
    &#125;

private:
    int _b;
&#125;;

class Derived:
    public BaseA,
    public BaseB
&#123;
public:
    void SetC(int value)
    &#123;
  SetB(value);
  _c &#x3D; value;
    &#125;

private:
    &#x2F;&#x2F; Derived now has two &#39;_a&#39; members and one &#39;_b&#39; member.
    int _c;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>等效 LLVM IR：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">%BaseA &#x3D; type &#123;
    i32         ; &#39;_a&#39; from BaseA
&#125;

define void @BaseA_SetA(%BaseA* %this, i32 %value) nounwind &#123;
    %1 &#x3D; getelementptr %BaseA, %BaseA* %this, i32 0, i32 0
    store i32 %value, i32* %1
    ret void
&#125;

%BaseB &#x3D; type &#123;
    i32,        ; &#39;_a&#39; from BaseA
    i32         ; &#39;_b&#39; from BaseB
&#125;

define void @BaseB_SetB(%BaseB* %this, i32 %value) nounwind &#123;
    %1 &#x3D; bitcast %BaseB* %this to %BaseA*
    call void @BaseA_SetA(%BaseA* %1, i32 %value)
    %2 &#x3D; getelementptr %BaseB, %BaseB* %this, i32 0, i32 1
    store i32 %value, i32* %2
    ret void
&#125;

%Derived &#x3D; type &#123;
    i32,        ; &#39;_a&#39; from BaseA
    i32,        ; &#39;_a&#39; from BaseB
    i32,        ; &#39;_b&#39; from BaseB
    i32         ; &#39;_c&#39; from Derived
&#125;

define void @Derived_SetC(%Derived* %this, i32 %value) nounwind &#123;
    %1 &#x3D; bitcast %Derived* %this to %BaseB*
    call void @BaseB_SetB(%BaseB* %1, i32 %value)
    %2 &#x3D; getelementptr %Derived, %Derived* %this, i32 0, i32 2
    store i32 %value, i32* %2
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后，只要将 baseB 作为 BaseB 的实例引用，编译器就会提供所需的类型转换和指针算术。请注意，他所需要的只是从一个类到另一个类的位转换以及及时 getelementptr 的最后一个参数的调整。</p>
<h5 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h5><p>虚拟继承实际上非常简单，因为它要求将相同的基类合并到一个实例中。比如下面的 c++ 代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BaseA
&#123;
public:
    int a;
&#125;;

class BaseB: public BaseA
&#123;
public:
    int b;
&#125;;

class BaseC: public BaseA
&#123;
public:
    int c;
&#125;;

class Derived:
    public virtual BaseB,
    public virtual BaseC
&#123;
    int d;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Dervied 将只包含一个 BaseA 实例，即使它的继承图规定它应该有两个继承。</p>
<p>结果如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Derived
&#123;
public:
    int a;
    int b;
    int c;
    int d;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>所以 a 的第二个实例被默认的忽略，因为它会导致 BaseA 的多个实例存在于 Derived 中。</p>
<h5 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h5><p>接口只不过是没有数据成员的基类，其中所有方法都是纯虚拟的，也就是没有主体。因此转化 IR 的方式和将虚拟成员函数转换为 LLVM IR 的方式是一样的。</p>
<h5 id="Boxing-和-Unboxing"><a href="#Boxing-和-Unboxing" class="headerlink" title="Boxing 和 Unboxing"></a>Boxing 和 Unboxing</h5><p>Boxing 是将非对象原始值转换成对象的过程。创建一个包装类，你可以用非对象值实例化和初始化它。</p>
<p>Unboxing 是 boxing 的逆过程。你通过从 box 对象中检索 box 的值，将一个完整的对象降级为一个纯标量值。</p>
<p>下面是 Boxing 和 Unboxing 对应的 IR 代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@Boxee &#x3D; global i32 17

%Integer &#x3D; type &#123; i32 &#125;

define void @Integer_Create(%Integer* %this, i32 %value) nounwind &#123;
    ; you might set up a vtable and associated virtual methods here
    %1 &#x3D; getelementptr %Integer, %Integer* %this, i32 0, i32 0
    store i32 %value, i32* %1
    ret void
&#125;

define i32 @Integer_GetValue(%Integer* %this) nounwind &#123;
    %1 &#x3D; getelementptr %Integer, %Integer* %this, i32 0, i32 0
    %2 &#x3D; load i32, i32* %1
    ret i32 %2
&#125;

define i32 @main() nounwind &#123;
    ; box @Boxee in an instance of %Integer
    %1 &#x3D; load i32, i32* @Boxee
    %2 &#x3D; alloca %Integer
    call void @Integer_Create(%Integer* %2, i32 %1)

    ; unbox @Boxee from an instance of %Integer
    %3 &#x3D; call i32 @Integer_GetValue(%Integer* %2)

    ret i32 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="New-运算符"><a href="#New-运算符" class="headerlink" title="New 运算符"></a>New 运算符</h5><p>new 运算符通常只不过是 C malloc 函数的类型安全版本，在 C++ 的某些实现中，它们可以互换调用，而不会导致看不见或不需要的副作用。</p>
<p><em>实例的 new 操作符</em><br>new X 对应的 llvm ir 代码如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">declare i8* @malloc(i32) nounwind

%X &#x3D; type &#123; i8 &#125;

define void @X_Create_Default(%X* %this) nounwind &#123;
    %1 &#x3D; getelementptr %X, %X* %this, i32 0, i32 0
    store i8 0, i8* %1
    ret void
&#125;

define void @main() nounwind &#123;
    %1 &#x3D; call i8* @malloc(i32 1)
    %2 &#x3D; bitcast i8* %1 to %X*
    call void @X_Create_Default(%X* %2)
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>new X(Y,Z) 形式的调用是相同的，除了 X 和 Z 作为参数传递给构造函数。</p>
<p><em>数组的 new 运算符</em><br>代码 new X[100] 被映射到一个循环中，一次初始化每个数组元素：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">declare i8* @malloc(i32) nounwind

%X &#x3D; type &#123; i32 &#125;

define void @X_Create_Default(%X* %this) nounwind &#123;
    %1 &#x3D; getelementptr %X, %X* %this, i32 0, i32 0
    store i32 0, i32* %1
    ret void
&#125;

define void @main() nounwind &#123;
    %n &#x3D; alloca i32                  ; %n &#x3D; ptr to the number of elements in the array
    store i32 100, i32* %n

    %i &#x3D; alloca i32                  ; %i &#x3D; ptr to the loop index into the array
    store i32 0, i32* %i

    %1 &#x3D; load i32, i32* %n           ; %1 &#x3D; *%n
    %2 &#x3D; mul i32 %1, 4               ; %2 &#x3D; %1 * sizeof(X)
    %3 &#x3D; call i8* @malloc(i32 %2)    ; %3 &#x3D; malloc(100 * sizeof(X))
    %4 &#x3D; bitcast i8* %3 to %X*       ; %4 &#x3D; (X*) %3
    br label %.loop_head

.loop_head:                         ; for (; %i &lt; %n; %i++)
    %5 &#x3D; load i32, i32* %i
    %6 &#x3D; load i32, i32* %n
    %7 &#x3D; icmp slt i32 %5, %6
    br i1 %7, label %.loop_body, label %.loop_tail

.loop_body:
    %8 &#x3D; getelementptr %X, %X* %4, i32 %5
    call void @X_Create_Default(%X* %8)

    %9 &#x3D; add i32 %5, 1
    store i32 %9, i32* %i

    br label %.loop_head

.loop_tail:
    ret void
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="C-调用-LLVM-接口"><a href="#C-调用-LLVM-接口" class="headerlink" title="C 调用 LLVM 接口"></a>C 调用 LLVM 接口</h3><p>项目在：<a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/CLLVMCase">CLLVMCase</a></p>
<p>这是代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
int sum(int a, int b) &#123;
    return a + b;
&#125;
,*/</span>
<span class="token keyword">void</span> <span class="token function">csum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    LLVMModuleRef module <span class="token operator">=</span> <span class="token function">LLVMModuleCreateWithName</span><span class="token punctuation">(</span><span class="token string">"sum_module"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LLVMTypeRef param_types<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token function">LLVMInt32Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LLVMInt32Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 函数参数依次是函数的类型，参数类型向量，函数数，表示函数是否可变的布尔值。</span>
    LLVMTypeRef ftype <span class="token operator">=</span> <span class="token function">LLVMFunctionType</span><span class="token punctuation">(</span><span class="token function">LLVMInt32Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param_types<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    LLVMValueRef sum <span class="token operator">=</span> <span class="token function">LLVMAddFunction</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> <span class="token string">"sum"</span><span class="token punctuation">,</span> ftype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    LLVMBasicBlockRef entry <span class="token operator">=</span> <span class="token function">LLVMAppendBasicBlock</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token string">"entry"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    LLVMBuilderRef builder <span class="token operator">=</span> <span class="token function">LLVMCreateBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMPositionBuilderAtEnd</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// IR 的表现形式有三种，一种是内存中的对象集，一种是文本语言，比如汇编，一种是二进制编码字节 bitcode。</span>
  
    LLVMValueRef tmp <span class="token operator">=</span> <span class="token function">LLVMBuildAdd</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> <span class="token function">LLVMGetParam</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LLVMGetParam</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"tmp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMBuildRet</span><span class="token punctuation">(</span>builder<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token keyword">char</span> <span class="token operator">*</span>error <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">LLVMVerifyModule</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> LLVMAbortProcessAction<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMDisposeMessage</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 可执行引擎，如果支持 JIT 就用它，否则用 Interpreter。</span>
    LLVMExecutionEngineRef engine<span class="token punctuation">;</span>
    error <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">LLVMLinkInMCJIT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMInitializeNativeTarget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LLVMCreateExecutionEngineForModule</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>engine<span class="token punctuation">,</span> module<span class="token punctuation">,</span> <span class="token operator">&amp;</span>error<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Could not create execution engine: %s\n"</span><span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
  <span class="token function">LLVMDisposeMessage</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  
    <span class="token keyword">long</span> <span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> y <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
  
    <span class="token comment">// LLVM 提供了工厂函数来创建值，这些值可以被传递给函数。</span>
    LLVMGenericValueRef args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token function">LLVMCreateGenericValueOfInt</span><span class="token punctuation">(</span><span class="token function">LLVMInt32Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LLVMCreateGenericValueOfInt</span><span class="token punctuation">(</span><span class="token function">LLVMInt32Type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
  
    <span class="token function">LLVMInitializeNativeAsmPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMInitializeNativeAsmParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 函数调用</span>
    LLVMGenericValueRef result <span class="token operator">=</span> <span class="token function">LLVMRunFunction</span><span class="token punctuation">(</span>engine<span class="token punctuation">,</span> sum<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> <span class="token function">LLVMGenericValueToInt</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
    <span class="token comment">// 生成 bitcode 文件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LLVMWriteBitcodeToFile</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> <span class="token string">"sum.bc"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"Could not write bitcode to file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
  
    <span class="token function">LLVMDisposeBuilder</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">LLVMDisposeExecutionEngine</span><span class="token punctuation">(</span>engine<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="Swift-调用-LLVM-接口"><a href="#Swift-调用-LLVM-接口" class="headerlink" title="Swift 调用 LLVM 接口"></a>Swift 调用 LLVM 接口</h3><p>llvm 的接口还可以通过 swift 来调用。</p>
<p>先创建一个 module.modulemap 文件，创建 LLVMC.h 和 LLVMC.c 文件，自动生成 SwiftLLVMCase-Bridging-Header.h。设置 header search paths 为 llvm 所在路径 <code>/usr/local/opt/llvm/include</code> ，library search paths 设置为 <code>/usr/local/opt/llvm/lib</code> 。将 <code>/usr/local/opt/llvm/lib/libLLVM.dylib</code> 加到 Linked Frameworks and Libraries 里。</p>
<p>module.modulemap 内容</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">module llvm <span class="token punctuation">[</span>extern_c<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    header <span class="token string">"LLVMC.h"</span>
    export <span class="token operator">*</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>LLVMC.h 里设置要用到的 llvm 的头文件，比如：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">LLVMC_h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LLVMC_h</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Analysis.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/BitReader.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/BitWriter.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Core.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Disassembler.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/ExecutionEngine.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/IRReader.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Initialization.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Linker.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Object.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Support.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Target.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/TargetMachine.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Transforms/IPO.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Transforms/PassManagerBuilder.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Transforms/Scalar.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/Transforms/Vectorize.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;llvm-c/lto.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">/* LLVMC_h */</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 swift 中写如下代码试试</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token class-name">Foundation</span>
<span class="token keyword">import</span> llvm

<span class="token keyword">func</span> <span class="token function-definition function">hiIR</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> module <span class="token operator">=</span> <span class="token class-name">LLVMModuleCreateWithName</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"HiModule"</span></span><span class="token punctuation">)</span>
    <span class="token class-name">LLVMDumpModule</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span>
    <span class="token class-name">LLVMDisposeModule</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token function">hiIR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>执行结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">;</span> ModuleID <span class="token operator">=</span> <span class="token string">'HiModule'</span>
source_filename <span class="token operator">=</span> <span class="token string">"HiModule"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>下面一个简单的 c 函数</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>使用 llvm 的接口写对应的 IR 代码如下：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">cSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Module</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"CSum"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> bd <span class="token operator">=</span> <span class="token class-name">IRBuilder</span><span class="token punctuation">(</span>module<span class="token punctuation">:</span> m<span class="token punctuation">)</span>
    <span class="token keyword">let</span> f1 <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">addFunction</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"sum"</span></span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token class-name">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">IntType</span><span class="token punctuation">.</span>int32<span class="token punctuation">,</span> <span class="token class-name">IntType</span><span class="token punctuation">.</span>int32<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">IntType</span><span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token punctuation">)</span>
  
    <span class="token comment">// 添加基本块</span>
    <span class="token keyword">let</span> entryBB <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">appendBasicBlock</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"entry"</span></span><span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">positionAtEnd</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> entryBB<span class="token punctuation">)</span>
  
    <span class="token keyword">let</span> a <span class="token operator">=</span> f1<span class="token punctuation">.</span>parameters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> f1<span class="token punctuation">.</span>parameters<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  
    <span class="token keyword">let</span> tmp <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">buildAdd</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">buildRet</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span>
  
    m<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>dump 出对应 IR 如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; ModuleID &#x3D; &#39;CSum&#39;
source_filename &#x3D; &quot;CSum&quot;

define i32 @sum(i32 %0, i32 %1) &#123;
entry:
%2 &#x3D; add i32 %0, %1
ret i32 %2
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对于控制流函数，比如下面的 swift 函数：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">giveMeNumber</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> isBig <span class="token punctuation">:</span> <span class="token class-name">Bool</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Int</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> re <span class="token punctuation">:</span> <span class="token class-name">Int</span>
    <span class="token keyword">if</span> <span class="token operator">!</span>isBig <span class="token punctuation">&#123;</span>
  <span class="token comment">// the fibonacci series (sort of)</span>
  re <span class="token operator">=</span> <span class="token number">3</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// the fibonacci series (sort of) backwards</span>
  re <span class="token operator">=</span> <span class="token number">4</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> re
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用 llvm 接口编写 IR，代码如下：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">controlFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token class-name">Module</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"CF"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> bd <span class="token operator">=</span> <span class="token class-name">IRBuilder</span><span class="token punctuation">(</span>module<span class="token punctuation">:</span> m<span class="token punctuation">)</span>
    <span class="token keyword">let</span> f1 <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">addFunction</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"calculateFibs"</span></span><span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token class-name">FunctionType</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token class-name">IntType</span><span class="token punctuation">.</span>int1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> entryBB <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">appendBasicBlock</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"entry"</span></span><span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">positionAtEnd</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> entryBB<span class="token punctuation">)</span>
  
    <span class="token comment">// 给本地变量分配空间 let retVal : Double</span>
    <span class="token keyword">let</span> local <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">buildAlloca</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"local"</span></span><span class="token punctuation">)</span>
  
    <span class="token comment">// 条件比较 if !backward</span>
    <span class="token keyword">let</span> test <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">buildICmp</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span>parameters<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">IntType</span><span class="token punctuation">.</span>int1<span class="token punctuation">.</span><span class="token function">zero</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>equal<span class="token punctuation">)</span>
  
    <span class="token comment">// 创建 block</span>
    <span class="token keyword">let</span> thenBB <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">appendBasicBlock</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"then"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> elseBB <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">appendBasicBlock</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"else"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> mergeBB <span class="token operator">=</span> f1<span class="token punctuation">.</span><span class="token function">appendBasicBlock</span><span class="token punctuation">(</span>named<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"merge"</span></span><span class="token punctuation">)</span>
  
    bd<span class="token punctuation">.</span><span class="token function">buildCondBr</span><span class="token punctuation">(</span>condition<span class="token punctuation">:</span> test<span class="token punctuation">,</span> then<span class="token punctuation">:</span> thenBB<span class="token punctuation">,</span> <span class="token keyword">else</span><span class="token punctuation">:</span> elseBB<span class="token punctuation">)</span>
  
    <span class="token comment">// 指到 then block</span>
    bd<span class="token punctuation">.</span><span class="token function">positionAtEnd</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> thenBB<span class="token punctuation">)</span>
    <span class="token keyword">let</span> thenVal <span class="token operator">=</span> <span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">.</span><span class="token function">constant</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">89</span><span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">buildBr</span><span class="token punctuation">(</span>mergeBB<span class="token punctuation">)</span> <span class="token comment">// 到 merge block</span>
  
    <span class="token comment">// 指到 else block</span>
    bd<span class="token punctuation">.</span><span class="token function">positionAtEnd</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> elseBB<span class="token punctuation">)</span>
    <span class="token keyword">let</span> elseVal <span class="token operator">=</span> <span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">.</span><span class="token function">constant</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">109</span><span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">buildBr</span><span class="token punctuation">(</span>mergeBB<span class="token punctuation">)</span> <span class="token comment">// 到 merge block</span>
  
    <span class="token comment">// 指到 merge block</span>
    bd<span class="token punctuation">.</span><span class="token function">positionAtEnd</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> mergeBB<span class="token punctuation">)</span>
    <span class="token keyword">let</span> phi <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">buildPhi</span><span class="token punctuation">(</span><span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"phi_example"</span></span><span class="token punctuation">)</span>
    phi<span class="token punctuation">.</span><span class="token function">addIncoming</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token punctuation">(</span>thenVal<span class="token punctuation">,</span> thenBB<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">(</span>elseVal<span class="token punctuation">,</span> elseBB<span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token comment">// 赋值给本地变量</span>
    bd<span class="token punctuation">.</span><span class="token function">buildStore</span><span class="token punctuation">(</span>phi<span class="token punctuation">,</span> to<span class="token punctuation">:</span> local<span class="token punctuation">)</span>
    <span class="token keyword">let</span> ret <span class="token operator">=</span> bd<span class="token punctuation">.</span><span class="token function">buildLoad</span><span class="token punctuation">(</span>local<span class="token punctuation">,</span> type<span class="token punctuation">:</span> <span class="token class-name">FloatType</span><span class="token punctuation">.</span>double<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"ret"</span></span><span class="token punctuation">)</span>
    bd<span class="token punctuation">.</span><span class="token function">buildRet</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
  
    m<span class="token punctuation">.</span><span class="token function">dump</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出对应 IR 代码：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">; ModuleID &#x3D; &#39;CF&#39;
source_filename &#x3D; &quot;CF&quot;

define double @giveMeNumber(i1 %0) &#123;
entry:
  %local &#x3D; alloca i32, align 4
  %1 &#x3D; icmp eq i1 %0, false
  br i1 %1, label %then, label %else

then:                                             ; preds &#x3D; %entry
  br label %merge

else:                                             ; preds &#x3D; %entry
  br label %merge

merge:                                            ; preds &#x3D; %else, %then
  %phi_example &#x3D; phi i32 [ 3, %then ], [ 4, %else ]
  store i32 %phi_example, i32* %local, align 4
  %ret &#x3D; load i32, i32* %local, align 4
  ret i32 %ret
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这里有完整代码 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/SwiftLLVMCase">SwiftLLVMCase</a>。</p>
<h2 id="动态执行代码"><a href="#动态执行代码" class="headerlink" title="动态执行代码"></a>动态执行代码</h2><h3 id="DYLD-INSERT-LIBRARIES"><a href="#DYLD-INSERT-LIBRARIES" class="headerlink" title="DYLD_INSERT_LIBRARIES"></a>DYLD_INSERT_LIBRARIES</h3><p>DYLD_INSERT_LIBRARIES 是一个环境变量，可以插入你的代码到没有源码的程序进程中。比如下面的代码：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">DYLD_INSERT_LIBRARIES</span><span class="token operator">=</span>@path/Frameworks/Interposing.framework/Interpos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这样就可以在 <code>+load</code> 方法中添加自己的代码。SwiftUI Preview 也是使用的这种方法。如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">DYLD_INSERT_LIBRARIES</span><span class="token operator">=</span>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot//System/Library/PrivateFrameworks/PreviewsInjection.framework/PreviewsInjection<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>dyld 有机会修改一个二进制地址用来指向你定义的函数地址。在 Mach-O 里新增一个用来记录替换函数和函数地址的 <code>(__DATA,__interpose)</code>。对应宏定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DYLD_INTERPOSE</span><span class="token expression"><span class="token punctuation">(</span>_replacement<span class="token punctuation">,</span>_replacee<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>used<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">static</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> replacement<span class="token punctuation">;</span> <span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> replacee<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> _interpose_</span><span class="token punctuation">##</span><span class="token expression">_replacee </span><span class="token punctuation">\</span>
            <span class="token expression"><span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">section</span> <span class="token punctuation">(</span></span><span class="token string">"__DATA,__interpose"</span><span class="token expression"><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_replacement<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>_replacee <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>dyld 还包含了一个 dyld_dynamic_interpose 函数用以在运行时插入函数。</p>
<h3 id="解释执行-bitcode（IR）"><a href="#解释执行-bitcode（IR）" class="headerlink" title="解释执行 bitcode（IR）"></a>解释执行 bitcode（IR）</h3><p>IR 的表现形式有三种，一种是内存中的对象集，一种是文本语言，一种是二进制编码字节 bitcode。</p>
<p>对于 Intel 芯片可以通过 <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Pin</a>，arm 架构可以用 <a target="_blank" rel="noopener" href="https://github.com/DynamoRIO/dynamorio">DynamoRIO</a>，目前 DynamoRIO 只支持 Window、Linux 和 Android 系统，对 macOS 的支持还在进行中。另一种方式是通过基于 llvm 的 interpreter 开发来实现解释执行 bitcode，llvm 用很多 C++ 的接口在内存中操作，将可读的文本文件解析到内存中，编译过程文本的 IR 不会生成，只会生成一种紧凑的二进制表示，也就是 bitcode。下面具体说下怎么做。</p>
<p>先构建一个支持 libffi 的 llvm。编译 llvm 源码时加上 libffi 的选项来打开 DLLVM_ENABLE_FFI 的选项打开 libffi，编译命令如下：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">cmake -G Ninja -DLLVM_ENABLE_FFI:BOOL&#x3D;ON ..&#x2F;llvm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>创建一个项目。cmake 文件里注意设置自己的编译生成的 llvm 路径，还有 llvm 源码路径，设置这个路径主要是为了用安装 llvm 时没有包含的 ExecutionEngine&#x2F;Interpreter&#x2F;Interpreter.h 头文件。</p>
<p>实现方式是通过访问 llvm 的 ExcutionEngine 进行 IR 指令解释执行。声明一个可访问 ExcutionEngine 内部的类 PInterpreter，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 使用 public 访问内部
class PInterpreter : public llvm::ExecutionEngine,
         public llvm::InstVisitor&lt;llvm::Interpreter&gt; &#123;
    public:
    llvm::GenericValue ExitValue;
    llvm::DataLayout TD;
    llvm::IntrinsicLowering *IL;
    std::vector&lt;llvm::ExecutionContext&gt; ECStack;
    std::vector&lt;llvm::Function*&gt; AtExitHandlers;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后声明要用的方法。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MInterpreter : public llvm::ExecutionEngine &#123;
    public:
    llvm::Interpreter *interp;
    PInterpreter *pItp;
    llvm::Module *module;
  
    explicit MInterpreter(llvm::Module *M);
    virtual ~MInterpreter();
  
    virtual void run();
    virtual void execute(llvm::Instruction &amp;I);
  
    &#x2F;&#x2F; 入口
    virtual int runMain(std::vector&lt;std::string&gt; args,
      char * const *envp &#x3D; 0);
  
    &#x2F;&#x2F; 遵循 ExecutionEngine 接口
    llvm::GenericValue runFunction(
  llvm::Function *F,
  const std::vector&lt;llvm::GenericValue&gt; &amp;ArgValues
    );
    void *getPointerToNamedFunction(const std::string &amp;Name,
            bool AbortOnFailure &#x3D; true);
    void *recompileAndRelinkFunction(llvm::Function *F);
    void freeMachineCodeForFunction(llvm::Function *F);
    void *getPointerToFunction(llvm::Function *F);
    void *getPointerToBasicBlock(llvm::BasicBlock *BB);
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如上面代码所示，因为要执行 IR，所以用到获取 IR 的函数和基本块地址的方法，getPointerToFunction 和 getPointerToBasicBlock。最后再执行指令时，先打印出指令，然后进行执行，代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class MingInterpreter : public MInterpreter &#123;
    public:
    MingInterpreter(Module *M) : MInterpreter(M) &#123;&#125;;
    virtual void execute(Instruction &amp;I) &#123;
  I.print(errs());
  MInterpreter::execute(I);
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>完整代码参看 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/MingInterpreter">MingInterpreter</a>。</p>
<p>项目是基于 c 语言，可以使用 llvm include 里的 llvm-c&#x2F;ExecutionEngine.h 接口头文件，使用 c 来编写。OC 和 Swift 项目还需要根据各自语言特性进行开发完善解释功能。</p>

  </div>
  <div>
    
      <div 
        class="post-note note-warning copyright" 
        style="margin-top: 42px">
        <p>
          <span style="font-weight: bold;">作者：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="/about">
            戴铭
          </a>
        </p>
        <p>
          <span style="font-weight: bold;">文章链接：</span><a 
            target="_blank" 
            rel="nofollow noopener noreferrer" 
            href="http://ming1016.github.io/2022/06/10/use-llvm/">
            http://ming1016.github.io/2022/06/10/use-llvm/
          </a>
        </p>
        <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
      </div>
    
  </div>
</article>
<div class="nav">
  
    <div class="nav-item-prev">
      <a 
        href="/2022/07/08/slides-of-use-llvm/" 
        class="nav-link">
        <i class="iconfont icon-left nav-prev-icon"></i>
        <div>
          <div class="nav-label">上一篇</div>
          
            <div class="nav-title">使用 LLVM 分享的幻灯片 </div>
          
        </div>
      </a>
    </div>
  
  
    <div class="nav-item-next">
      <a 
        href="/2022/06/10/wwdc22-notes/" 
        class="nav-link">
        <div>
          <div class="nav-label">下一篇</div>
          
            <div class="nav-title">WWDC22 笔记 </div>
          
        </div>
        <i class="iconfont icon-right nav-next-icon"></i>
      </a>
    </div>
  
</div>

<div 
  class="card card-content toc-card" 
  id="mobiletoc">
  <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目錄
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2"><span class="toc-number">2.</span> <span class="toc-text">代码新陈代谢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">方案总体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%8E%B0%E6%9C%89%E6%96%B9%E6%A1%88%E5%92%8C%E5%85%B6%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">一些现有方案和其不可用的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gcov"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">gcov</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%AF%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4%E7%9A%84-Pass"><span class="toc-number">2.1.2.</span> <span class="toc-text">自制可插入指令的 Pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.2.</span> <span class="toc-text">生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.3.</span> <span class="toc-text">Xcode 配置生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">Fuzzing 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.5.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-LLVM"><span class="toc-number">2.6.</span> <span class="toc-text">安装 LLVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">手动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%88%B6-Pass"><span class="toc-number">2.7.</span> <span class="toc-text">自制 Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">Pass 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xcode-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">Xcode 开发模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4-pass"><span class="toc-number">2.7.3.</span> <span class="toc-text">自制插入指令 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E8%87%AA%E5%88%B6-pass"><span class="toc-number">2.7.4.</span> <span class="toc-text">更多自制 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IR"><span class="toc-number">2.7.5.</span> <span class="toc-text">IR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IR-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">IR 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.3.</span> <span class="toc-text">本地变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.7.5.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.7.5.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.7.5.6.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.5.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">2.7.5.8.</span> <span class="toc-text">函数和声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unions"><span class="toc-number">2.7.5.9.</span> <span class="toc-text">Unions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if-then-else-%E5%88%86%E6%94%AF"><span class="toc-number">2.7.5.10.</span> <span class="toc-text">if-then-else 分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E4%B8%80%E8%B5%8B%E5%80%BC%E8%A1%A8%EF%BC%88SSA-Form%EF%BC%89%E5%92%8C-PHI"><span class="toc-number">2.7.5.11.</span> <span class="toc-text">静态单一赋值表（SSA Form）和 PHI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.5.12.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generators"><span class="toc-number">2.7.5.13.</span> <span class="toc-text">生成器 Generators</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.5.14.</span> <span class="toc-text">面向对象结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.7.5.15.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.5.16.</span> <span class="toc-text">虚拟方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.17.</span> <span class="toc-text">单一继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.18.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.19.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-number">2.7.5.20.</span> <span class="toc-text">接口 Interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boxing-%E5%92%8C-Unboxing"><span class="toc-number">2.7.5.21.</span> <span class="toc-text">Boxing 和 Unboxing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#New-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.7.5.22.</span> <span class="toc-text">New 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.8.</span> <span class="toc-text">C 调用 LLVM 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.9.</span> <span class="toc-text">Swift 调用 LLVM 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">动态执行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DYLD-INSERT-LIBRARIES"><span class="toc-number">3.1.</span> <span class="toc-text">DYLD_INSERT_LIBRARIES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-bitcode%EF%BC%88IR%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">解释执行 bitcode（IR）</span></a></li></ol></li></ol>
</div>
            </main>
            <aside class="right-column">
              <div class="sticky-widescreen">
  
  
    <article class="card card-content toc-card">
      <div class="toc-header">
  <i 
    class="iconfont icon-menu" 
    style="padding-right: 2px;">
  </i>目錄
</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2"><span class="toc-number">2.</span> <span class="toc-text">代码新陈代谢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">方案总体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%8E%B0%E6%9C%89%E6%96%B9%E6%A1%88%E5%92%8C%E5%85%B6%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">一些现有方案和其不可用的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gcov"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">gcov</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%AF%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4%E7%9A%84-Pass"><span class="toc-number">2.1.2.</span> <span class="toc-text">自制可插入指令的 Pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.2.</span> <span class="toc-text">生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">2.3.</span> <span class="toc-text">Xcode 配置生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">Fuzzing 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">2.5.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-LLVM"><span class="toc-number">2.6.</span> <span class="toc-text">安装 LLVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8"><span class="toc-number">2.6.1.</span> <span class="toc-text">手动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%88%B6-Pass"><span class="toc-number">2.7.</span> <span class="toc-text">自制 Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.1.</span> <span class="toc-text">Pass 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xcode-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">Xcode 开发模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4-pass"><span class="toc-number">2.7.3.</span> <span class="toc-text">自制插入指令 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E8%87%AA%E5%88%B6-pass"><span class="toc-number">2.7.4.</span> <span class="toc-text">更多自制 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IR"><span class="toc-number">2.7.5.</span> <span class="toc-text">IR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IR-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.7.5.1.</span> <span class="toc-text">IR 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">2.7.5.3.</span> <span class="toc-text">本地变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">2.7.5.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.7.5.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.7.5.6.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.5.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">2.7.5.8.</span> <span class="toc-text">函数和声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unions"><span class="toc-number">2.7.5.9.</span> <span class="toc-text">Unions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if-then-else-%E5%88%86%E6%94%AF"><span class="toc-number">2.7.5.10.</span> <span class="toc-text">if-then-else 分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E4%B8%80%E8%B5%8B%E5%80%BC%E8%A1%A8%EF%BC%88SSA-Form%EF%BC%89%E5%92%8C-PHI"><span class="toc-number">2.7.5.11.</span> <span class="toc-text">静态单一赋值表（SSA Form）和 PHI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.5.12.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generators"><span class="toc-number">2.7.5.13.</span> <span class="toc-text">生成器 Generators</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.7.5.14.</span> <span class="toc-text">面向对象结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">2.7.5.15.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95"><span class="toc-number">2.7.5.16.</span> <span class="toc-text">虚拟方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.17.</span> <span class="toc-text">单一继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.18.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.5.19.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-number">2.7.5.20.</span> <span class="toc-text">接口 Interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boxing-%E5%92%8C-Unboxing"><span class="toc-number">2.7.5.21.</span> <span class="toc-text">Boxing 和 Unboxing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#New-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.7.5.22.</span> <span class="toc-text">New 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.8.</span> <span class="toc-text">C 调用 LLVM 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.9.</span> <span class="toc-text">Swift 调用 LLVM 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">动态执行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DYLD-INSERT-LIBRARIES"><span class="toc-number">3.1.</span> <span class="toc-text">DYLD_INSERT_LIBRARIES</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-bitcode%EF%BC%88IR%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">解释执行 bitcode（IR）</span></a></li></ol></li></ol>
    </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header">
    <i 
      class="iconfont icon-wenzhang_huaban" 
      style="padding-right: 2px;">
    </i>最新文章
  </div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-07-08</div>
        <a href="/2022/07/08/slides-of-use-llvm/"><div class="recent-posts-item-content">使用 LLVM 分享的幻灯片</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-06-10</div>
        <a href="/2022/06/10/use-llvm/"><div class="recent-posts-item-content">使用 LLVM</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-06-10</div>
        <a href="/2022/06/10/wwdc22-notes/"><div class="recent-posts-item-content">WWDC22 笔记</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2022-03-25</div>
        <a href="/2022/03/25/develop-with-swiftui/"><div class="recent-posts-item-content">在苹果加速器活动做的 SwiftUI 开发分享</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
            </aside>
          </div>
        </div>
      </div>
    </div>
     
    <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>
          Copyright ©
          
            2014
          
          
                - 
                2022
          
        </span>
        &nbsp;
        <a 
          href="/" 
          class="footer-link">
          戴铭的博客
        </a>
      </div>
    </div>

    
    
    
      <div class="BbeiAn-info">
        <a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">鄂ICP备17011999号 </a>
      </div>
      
        <div class="BbeiAn-info">
          <span style="padding-left: 25px;background: url(/img/beian.png) no-repeat left center"></span>
          <a target="_blank" rel="noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=7011999 ">京公网安备 7011999号
          </a>
          <br />
        </div>
      
    
    
      <div class="footer-dsc">
        
          本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
          <span>&nbsp;|&nbsp;</span>
        
        
          本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
 
    
  <a 
    role="button" 
    id="scrollbutton" 
    class="basebutton" 
    aria-label="回到顶部">
    <i class="iconfont icon-arrowleft button-icon"></i>
  </a>

<a 
  role="button" 
  id="menubutton"
  aria-label="menu button"
  class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a 
  role="button" 
  id="popbutton" 
  class="basebutton" 
  aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a 
  role="button" 
  id="darkbutton" 
  class="basebutton darkwidget" 
  aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a 
  role="button" 
  id="searchbutton" 
  class="basebutton searchwidget" 
  aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a> 
     
     
     
      <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img')
    var i
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a')
      wrapper.setAttribute('href', img[i].getAttribute('data-src'))
      wrapper.setAttribute('aria-label', 'illustration')
      wrapper.style.cssText =
        'width: 100%; display: flex; justify-content: center;'
      if (img[i].alt) wrapper.dataset.caption = img[i].alt
      wrapper.dataset.nolink = true
      img[i].before(wrapper)
      wrapper.append(img[i])
      var divWrap = document.createElement('div')
      divWrap.classList.add('gallery')
      wrapper.before(divWrap)
      divWrap.append(wrapper)
    }
    baguetteBox.run('.gallery')
  }
</script>
<script>
  loadScript(
    "/js/lib/lightbox/baguetteBox.min.js",
    addImgLayout
  )
</script>
 
     
     
    <script src="/js/main.js"></script> 
    
      <script> 
        loadScript('/js/lib/busuanzi.min.js') 
      </script>
     
    
      <script>
        var addLazyload = function () {
          var observer = lozad('.lozad', {
            load: function (el) {
              el.srcset = el.getAttribute('data-src')
            },
            loaded: function (el) {
              el.classList.add('loaded')
            },
          })
          observer.observe()
        }
      </script>
      <script>
        loadScript('/js/lib/lozad.min.js', addLazyload)
      </script>
    
    <script src="//instant.page/5.1.0" type="module"
      integrity="sha384-by67kQnR+pyfy8yWP4kPO12fHKRLHZPfEsiSXR8u2IKcTdxD805MGUXBzVPnkLHw"></script>
    
    
  </body>
</html>
