<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="戴铭">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="戴铭">
    
        <meta name="keywords" content="戴铭,戴铭的博客,iOS,Swift,移动开发,JavaScript,编译">
    
    <meta name="description" content="前滴滴出行技术专家。极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者。个人博客：戴铭的博客。微信公共号：starming-weixin。微博：@戴铭">
    <meta name="description" content="本篇还会持续更新，增加更多用 llvm 干的事情，直到本句话被删掉为止。欢迎关注本篇。 目前在做些编译相关调研。先前写过篇《深入剖析 iOS 编译 Clang &#x2F; LLVM》和《深入剖析 iOS 编译 Clang &#x2F; LLVM 直播的 Slides》，内容偏理论。本篇着重对 LLVM 的使用，理论内容会很少，主要是说下如何使用 llvm 来做些事情，会有详细的操作步骤和工程示例。 代码新陈代谢昨天">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 LLVM">
<meta property="og:url" content="http://ming1016.github.io/2022/06/10/use-llvm/index.html">
<meta property="og:site_name" content="戴铭的博客 - 星光社">
<meta property="og:description" content="本篇还会持续更新，增加更多用 llvm 干的事情，直到本句话被删掉为止。欢迎关注本篇。 目前在做些编译相关调研。先前写过篇《深入剖析 iOS 编译 Clang &#x2F; LLVM》和《深入剖析 iOS 编译 Clang &#x2F; LLVM 直播的 Slides》，内容偏理论。本篇着重对 LLVM 的使用，理论内容会很少，主要是说下如何使用 llvm 来做些事情，会有详细的操作步骤和工程示例。 代码新陈代谢昨天">
<meta property="og:locale">
<meta property="og:image" content="http://ming1016.github.io/uploads/use-llvm/01.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/use-llvm/02.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/use-llvm/03.png">
<meta property="article:published_time" content="2022-06-10T09:04:31.000Z">
<meta property="article:modified_time" content="2022-06-10T09:04:23.371Z">
<meta property="article:author" content="戴铭">
<meta property="article:tag" content="LLVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://ming1016.github.io/uploads/use-llvm/01.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/logo-starming.png">
    
    <title>使用 LLVM · 戴铭的博客 - 星光社</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20210823" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20210823" as="style">
    <link rel="stylesheet" href="/css/dark.css" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="/css/mobile.css?v=20210823" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20210823" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20210823" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>戴铭的博客 - 星光社</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">戴铭的博客 - 星光社</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">使用 LLVM</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg-starming.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                使用 LLVM
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        
        
            
        
        
        <span class="post-category" data-categories="Programming"">
            <i class="fas fa-folder post-category-icon"></i>
            <span class="post-category-text">
                Programming
            </span>
        </span>
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="LLVM">LLVM</a>
    
</div>

                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">17.9k</span>阅读时长: <span class="post-count reading-time">82 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2022/06/10</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <p><em>本篇还会持续更新，增加更多用 llvm 干的事情，直到本句话被删掉为止。欢迎关注本篇。</em></p>
<p>目前在做些编译相关调研。先前写过篇《<a href="https://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">深入剖析 iOS 编译 Clang / LLVM</a>》和《<a href="https://ming1016.github.io/2017/04/01/slides-of-deeply-analyse-llvm/">深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</a>》，内容偏理论。本篇着重对 LLVM 的使用，理论内容会很少，主要是说下如何使用 llvm 来做些事情，会有详细的操作步骤和工程示例。</p>
<h2 id="代码新陈代谢"><a href="#代码新陈代谢" class="headerlink" title="代码新陈代谢"></a>代码新陈代谢</h2><p>昨天看了昨天和今天 WWDC22 的 session，看到了苹果为包体积也做了很多工作，甚至不惜改 C ABI的 call convention 来达到此目的。</p>
<p>我很早前就做过一个方案，可以说是一个更好处理代码新陈代谢的方案，那就先说下个。</p>
<h3 id="方案总体介绍"><a href="#方案总体介绍" class="headerlink" title="方案总体介绍"></a>方案总体介绍</h3><p>静态检查无法分析真实使用场景里代码是不是真的用了，或用的是否多。</p>
<p>动态检查来说，以前检查的方式有通过埋点查看相应代码是否有用到，还可以通过类的 isInitialized 方法来统计类是否被用到。第一个方案成本高，第二个方案范围太大，如果类都很大，那么检查结果的意义就没了。因此，需要一个能够动态检查函数和代码块级别是否使用的方法。</p>
<h4 id="一些现有方案和其不可用的地方"><a href="#一些现有方案和其不可用的地方" class="headerlink" title="一些现有方案和其不可用的地方"></a>一些现有方案和其不可用的地方</h4><p>下面列两个已有可检查比类更小粒度的方案。</p>
<h5 id="gcov"><a href="#gcov" class="headerlink" title="gcov"></a>gcov</h5><p>clang 使用 -fprofile-instr-generate -fcoverage-mapping ，swiftc 使用 -profile-generate -profile-coverage-mapping 生成 .profraw 文件。llvm-profdata merge 转成 .profdata。编译时每个文件会用 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp">GCOVProfiling</a> 生成 .gcno 包含计数和源码的映射关系，运行时用的是 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/main/compiler-rt/lib/profile/GCDAProfiling.c">GCDAProfiling</a> 处理回调记录运行时执行了哪些代码。最后 llvm-cov 转成报告，生成工具是 <a target="_blank" rel="noopener" href="http://www.opensource.apple.com/source/gcc/gcc-5484/gcc/gcov.c">gcov</a>，生成的报告可以看到哪些代码有用到，哪些没有用。</p>
<p>gcov 对于线下测试够用，但无法放到线上使用。</p>
<h5 id="SanitizerCoverage-插桩回调函数"><a href="#SanitizerCoverage-插桩回调函数" class="headerlink" title="SanitizerCoverage 插桩回调函数"></a>SanitizerCoverage 插桩回调函数</h5><p>SanitizerCoverage 是 libfuzzer 使用的代码覆盖技术，使用 <code>-fsanitize-coverage=trace-pc-guard</code> 这个编译 flag 插入不同级别的桩，会在程序控制流图的每条边插入<code>__sanitizer_cov_trace_pc_guard</code>。</p>
<p>如果只对函数插桩，使用 <code>-fsanitize-coverage=func</code>,<code>trace-pc-guard</code>，只对基本块用 <code>-fsanite-coverage=bb</code>,<code>no-prune</code>,<code>trace-pc-guard</code>。swift 使用 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 编译 flags。</p>
<p>在回调函数 <code>__sanitizer_cov_trace_pc_guard_init</code> 和 <code>__sanitizer_cov_trace_pc_guard</code> 里实现自己要干的事情，比如对当前插桩地址符号化，运行后就可以得到运行时调用了哪些方法。</p>
<p><img src="/uploads/use-llvm/01.png" alt=""></p>
<p>使用 SanitizerCoverage 插桩，一个是编译会很慢，另一个是插入范围难控制，上线后各方面影响不可控。SanitizerCoverage 本是用于 fuzzing 测试的一个 llvm pass，因此可以了解 SanitizerCoverage 使用的技术，自建一个专门用于代码新陈代谢的 pass 用来解决 SanitizerCoverage 和 gcov 不好用的问题。</p>
<h4 id="自制可插入指令的-Pass"><a href="#自制可插入指令的-Pass" class="headerlink" title="自制可插入指令的 Pass"></a>自制可插入指令的 Pass</h4><p>之所以在编译中间层插入指令而不在编译 frontend 插入代码的原因是，这样做的话能用类似 llvm-mctoll 二进制转中间层 IR 代码的方式，可对第三方这样没有 frontend 源码而只有生成的二进制产物的库进行分析。</p>
<p>在函数中插入执行指令执行自定功能的方法是，用 IRBuilder 使用 SetInsertPoint 设置位置，CreateCall 插入指令，插入在块的初始位置，用的是 <code>dyn_cast&lt;BinaryOperator&gt;(&amp;I)</code> 。CreateCall 调用 LLVMContextFunctionCallee 来自 <code>F.getParent()-&gt;getOrInsertFunction</code>，其第一个参数就是要执行我们自定义函数的函数名，第二个参数 FunctionType 是通过 <code>paramTypes</code> 和 <code>Type::getVoidTy</code> 根据 LLVMContext 而来。 使用编译属性可以指定要控制的函数，pass 可用 getGlobalVariable 取到 <code>llvm.global.annotations</code> ，也就是所有编译属性。 </p>
<p><code>F.getName().front()</code> 为 <code>\x01</code> 表示的是 OC 方法，去掉这个前缀可得到方法名，<code>.contains(&quot;_block&quot;)</code> 是闭包函数。<code>F.getName().startswith(&quot;_Z&quot;)</code> 是 C++ 函数（<code>_Z</code>、<code>__Z</code>、<code>___Z</code> 都是）。使用 <code>F.getName()</code> 判读读取一个映射表进行对比，也可以达到通过编译属性设置控制指定函数的效果。映射表里设置需要线上验证的函数集合。然后，处理函数和块计数与源码的映射关系，编译加入处理自制 pass 记录运行时代码执行情况的回调。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>pass 代码编译生成 dylib 后，在 Xcode 中使用需要替换 clang 为编译 pass 的 clang，编译 pass 的版本也要对应上。在 xconfig 中设置构建命令选项 OTHER_CFLAGS OTHER_CPLUSPLUSFLAGS 是 -Xclang -load -Xclang $pass，CC CXX 设置为替换的 clang。调试是用的 opt，可换成 opt scheme，在 Edit Scheme 里设置 opt 的启动参数。</p>
<p>llvm 14 后只能使用 new pm，legcy pm(pass manager) 通过 Xlang 给 clang 传参，而 new pm 不行，new pm 的 pass 让 clang 加载，一种方法是使用 -fpass-plugin，另一种是把 pass 加到 clang 的 pipeline 里，重新构建对应版本的 clang。具体来说就是 PassBuilder 的回调 registerPipelineStartEPCallback 允许 ModulePassManager 使用 addPass 添加我们的 pass。</p>
<p>方案是这样，接下来的内容是偏实际的一些操作，你也可以跟着实践下，毕竟本篇是说怎么使用 LLVM 嘛。</p>
<p>先看看 gcov 的用法。</p>
<h3 id="生成代码覆盖率报告"><a href="#生成代码覆盖率报告" class="headerlink" title="生成代码覆盖率报告"></a>生成代码覆盖率报告</h3><p>命令行中开启代码覆盖率的编译选项，参看官方指南：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">Source-based Code Coverage</a> 。</p>
<p>通过一个例子实践下。</p>
<p>建个 C 代码文件 main.m ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hi there!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上代码覆盖率的编译参数进行编译。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -fprofile-instr-generate -fcoverage-mapping main.m -o mainCoverage</span><br></pre></td></tr></table></figure>
<p>运行生成的 mainCoverage 会生成 default.profraw 文件，自定义文件名使用 LLVM_PROFILE_FILE=”my.profraw” ./mainCoverage 命令。</p>
<p>对于 Swift 文件也没有问题，建一个 swift 文件 hi.swift </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hi()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hi</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hi&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span>()</span> &#123;</span><br><span class="line">    doNothing()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doNothing</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 swiftc 来编译</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swiftc -profile-generate -profile-coverage-mapping hi.swift</span><br></pre></td></tr></table></figure>
<p>从上面 clang 和 swiftc 的命令可以看出，clang 使用的是 -fprofile-instr-generate 和 -fcoverage-mapping 编译 flags，swiftc 使用的是 -profile-generate 和 -profile-coverage-mapping 编译 flags。</p>
<p>编译出的可执行文件 mainCoverage 和 hi 都会多出</p>
<p>生成代码覆盖率前建立索引，也就是生成 .profdata 文件。通过 xcrun 调用 llvm-prodata 命令。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-profdata merge -sparse my.profraw -o my.profdata</span><br></pre></td></tr></table></figure>
<p>合并多个 .profdata 文件使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">llvm-profdata merge one.profdata two.profdata -output all.profdata</span><br></pre></td></tr></table></figure>
<p>使用 <a target="_blank" rel="noopener" href="https://llvm.org/docs/CommandGuide/llvm-cov.html">llvm-cov</a> 命令生成行的报告</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-cov show ./mainCoverage -instr-profile=my.profdata</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1|       |#include &lt;stdio.h&gt;</span><br><span class="line"> 2|       |</span><br><span class="line"> 3|       |int main(int argc, char *argv[])</span><br><span class="line"> 4|      1|&#123;</span><br><span class="line"> 5|      1|    printf(&quot;hi there!\n&quot;);</span><br><span class="line"> 6|      1|    return 0;</span><br><span class="line"> 7|      1|&#125;</span><br><span class="line"> 8|       |</span><br><span class="line"> 9|      0|void foo() &#123;</span><br><span class="line">10|      0|	return;</span><br><span class="line">11|      0|&#125;</span><br></pre></td></tr></table></figure>
<p>上面的输出可以看到，9到11行是没有执行的。</p>
<p>从文件层面看覆盖率，可以通过下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-cov report ./mainCoverage -instr-profile=my.profdata</span><br></pre></td></tr></table></figure>
<p>输出的报告如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Filename                                  Regions    Missed Regions     Cover   Functions  Missed Functions  Executed       Lines      Missed Lines     Cover    Branches   Missed Branches     Cover</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">/Users/mingdai/Downloads/PTest/main.m           2                 1    50.00%           2                 1    50.00%           7                 3    57.14%           0                 0         -</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">TOTAL                                           2                 1    50.00%           2                 1    50.00%           7                 3    57.14%           0                 0         -</span><br></pre></td></tr></table></figure>
<p>生成 JSON 的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun llvm-cov export -format=text ./mainCoverage -instr-profile=my.profdata &gt; my.json</span><br></pre></td></tr></table></figure>
<p>从生成的 json 文件可以看到这个生成的报告有5个统计项，分别是函数、实例化、行、区域和分支。</p>
<p>更多报告生成选型参看 <a target="_blank" rel="noopener" href="https://llvm.org/docs/CommandGuide/llvm-cov.html">llvm-cov 官方说明</a> 。</p>
<h3 id="Xcode-配置生成代码覆盖率报告"><a href="#Xcode-配置生成代码覆盖率报告" class="headerlink" title="Xcode 配置生成代码覆盖率报告"></a>Xcode 配置生成代码覆盖率报告</h3><p>在 Xcode 里开启代码覆盖率，先选择”Edit Scheme…”，再在 Test 中的 Options 里勾上 Gather coverage for all targets 或 some targets。如下图<br><img src="/uploads/use-llvm/02.png" alt=""></p>
<p>在 Build Setting 中进行设置，添加 -profile-generate 和 -profile-coverage-mapping 编译 flags。<br><img src="/uploads/use-llvm/03.png" alt=""></p>
<p>调用 llvm profile 的 c 函数生成 .profraw 文件。代码见：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: - 代码覆盖率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">codeCoverageProfrawDump</span>(<span class="params">fileName</span>: <span class="type">String</span> <span class="operator">=</span> <span class="string">&quot;cc&quot;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> name <span class="operator">=</span> <span class="string">&quot;<span class="subst">\(fileName)</span>.profraw&quot;</span></span><br><span class="line">    <span class="keyword">let</span> fileManager <span class="operator">=</span> <span class="type">FileManager</span>.default</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> documentDirectory <span class="operator">=</span> <span class="keyword">try</span> fileManager.url(for: .documentDirectory, in: .userDomainMask, appropriateFor:<span class="literal">nil</span>, create:<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">let</span> filePath: <span class="type">NSString</span> <span class="operator">=</span> documentDirectory.appendingPathComponent(name).path <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">        __llvm_profile_set_filename(filePath.utf8String)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;File at: <span class="subst">\(String(cString: __llvm_profile_get_filename()))</span>&quot;</span>)</span><br><span class="line">        __llvm_profile_write_file()</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>codeCoverageProfrawDump 函数放到 applicationWillTerminate 里执行，就可以生成在本次操作完后的代码覆盖率。</p>
<p>通过 llvm-cov report 命令将 .profraw 和生成的 Mach-O 文件关联输出代码覆盖率的报告，完整实现和调试看，参看 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/SwiftPamphletApp">DaiMingCreationToolbox</a> 里的 FundationFunction.swift 和 SwiftPamphletAppApp.swift 文件。</p>
<h3 id="Fuzzing-介绍"><a href="#Fuzzing-介绍" class="headerlink" title="Fuzzing 介绍"></a>Fuzzing 介绍</h3><p>另外，llvm 还提供另一种覆盖率输出，编译参数是 -fprofile-arcs -ftest-coverage 和链接参数 -lgcov，运行程序后会生成 .gcda 和 .gcno 文件，使用 lcov 或 gcovr 就可以生成一个 html 来查看覆盖率。</p>
<p>之所以能够输出代码覆盖率，主要是 llvm 在编译期间给函数、基本块（IDA 中以指令跳转当分界线的每块代码）和边界（较基本块多了执行边界信息）插了桩。插桩的函数也有回调，如果想使用插桩函数的回调，有源码可以使用 SanitizerCoverage， 官方说明见：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a>。</p>
<p>SanitizerCoverage 用的是 ModulePass，是 llvm 提供的 ModulePass、CallGraphSCCPass、FunctionPass、LoopPass、RegionPass 这几个插桩 pass 中的一种。SanitizerCoverage 还应用在 llvm 的 Fuzz 生成器 <a target="_blank" rel="noopener" href="https://llvm.org/docs/LibFuzzer.html">libfuzzer</a> 上，libfuzzer 可以从硬件和 IR 层面进行插桩获取程序的覆盖率。</p>
<p>Fuzzing 生成器的概念最早是威斯康星大学 Barton Miller 教授在<a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf">他的课</a>上提出的，后应用于安全测试领域，比如 <a target="_blank" rel="noopener" href="https://rd.springer.com/content/pdf/10.1007%2F978-0-387-35413-2_16.pdf">PROTOS 测试集项目</a>、网络协议安全测试 SPIKE、最普遍应用的文件 Fuzzing 技术 Peach、语法模板 <a target="_blank" rel="noopener" href="https://github.com/MozillaSecurity/funfuzz">funfuzz</a> 和 Dom fuzz 的 <a target="_blank" rel="noopener" href="https://github.com/googleprojectzero/domato">Domato</a>、分析 llvm IR 符号执行平台 <a target="_blank" rel="noopener" href="http://klee.github.io/">Klee</a>、源码插桩和 QEMU 模式实现代码覆盖 fuzzing 的 AFL 和刚才我提到的 llvm 自带基于 SanitizerCoverage 的 libfuzzer、挖掘系统内核漏洞的系统函数调用模板 Fuzzing 库 syzkaller 和基于 libfuzzer 和 protobuf 做的 <a target="_blank" rel="noopener" href="https://github.com/google/libprotobuf-mutator">libprotobuf-mutator</a>、组合了 libFuzzer，<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus">AFL++</a> 和 <a target="_blank" rel="noopener" href="https://github.com/google/honggfuzz">Honggfuzz</a> 还有 ClusterFuzz 的平台 <a target="_blank" rel="noopener" href="https://github.com/google/oss-fuzz">OSS-Fuzz</a>。</p>
<p>其中 Spike 是网络协议开源 Fuzzing 工具，由 Dave Aitel 编写的，Dave Aitel 是《the Hacker’s Handbook》（《黑客防范手册》）和《the Shellcoder’s Handbook》（《黑客攻防技术宝典：系统实战篇》）的作者。网络协议分析工具主要是 WireShark 和应用层的 SockMon（特定进程、协议、IP、函数抓包），和 IDA、OD 等工具结合找到软件执行的网络命令分析数据包的处理过程。Spike 可以对数据发包收包，还可以构造数据包自动化做覆盖更大的测试。</p>
<p>QEMU 是 2003 年 Fabrice Bellard 做的虚拟机，包含很多架构和硬件设备的模拟执行，原理是 qemu TCG 模块把机器代码转成 llvm IR，这个过程叫做反编译，关于反编译可以参考这篇论文《<a target="_blank" rel="noopener" href="https://www.usenix.org/system/files/conference/usenixsecurity16/sec16_paper_andriesse.pdf">An In-Depth Analysis of Disassembly on Full-Scale x86/x64 Binaries</a>》。之所以可以做到反编译是因为机器指令和汇编指令是一一对应的，可以先将机器指令翻译成机器对应的汇编，IR 实际上就是一个不遵循硬件设计的指令集，和硬件相关的汇编会按照 IR 的设计翻译成机器无关的 IR 指令。这样做的好处就是无论是哪个机器上的可执行二进制文件都能够统一成一份标准的指令表示。IR 也可以设计成 DSL，比如 <a target="_blank" rel="noopener" href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a> 的 Sleigh 语言。</p>
<p>反编译后，再将得到的 IR 转成目标硬件设备可执行机器语言，IDA Pro 也是用的这个原理，IDA 的 IR 叫 microcode，IDA 的插件 <a target="_blank" rel="noopener" href="https://github.com/patois/genmc">genmc</a> 专门用来显示 microcode，<a target="_blank" rel="noopener" href="https://github.com/RolfRolles/HexRaysDeob">HexRaysDeob</a> 是利用 microcode 来做混淆的库。</p>
<p>qemu 做的是没有源码的二进制程序的分析，是一个完整的虚拟机工具，其中只有 tcg 模块的一部分功能就可以实现模拟 CPU 执行，执行过程中插入分析的代码就能够方便的访问寄存器，对地址或指令 hook，实现这些功能的库是 <a target="_blank" rel="noopener" href="https://github.com/unicorn-engine/unicorn">Unicorn</a>，还有功能更多些的 <a target="_blank" rel="noopener" href="https://github.com/qilingframework/qiling">Qiling</a>。Qiling 和 Unicorn 不同的是 Unicorn 只完成了 CPU 指令的仿真，而 Qiling 可以处理更高层次的动态库、系统调用、I/O 处理或 Mach-O 加载等，Qiling 还可以通过 Python 开发自己动态分析工具，运行时进行 hotpatch，支持 macOS。基于 qemu 还有可以访问执行的所有代码和数据做回放程序执行过程的 <a target="_blank" rel="noopener" href="https://github.com/panda-re/panda">PANDA</a>、虚拟地址消毒剂 <a target="_blank" rel="noopener" href="https://github.com/andreafioraldi/qasan">QASan</a>、组合 Klee 和 qemu 的 <a target="_blank" rel="noopener" href="https://s2e.systems/">S2E</a>。</p>
<p>能够使用 js 来开发免编译功能的 <a target="_blank" rel="noopener" href="https://frida.re/">Frida</a> 也可以用于 Fuzzing，在 iOS 平台上的 Fuzzing 参看<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-1.html">1</a>、<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-2.html">2</a>、<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2018/12/adventures-in-video-conferencing-part-3.html">3</a>，使用工具见 <a target="_blank" rel="noopener" href="https://github.com/googleprojectzero/iOS-messaging-tools/tree/master/iMessage">iOS-messaging-tools</a>。</p>
<p>更多 Fuzzing 资料可以参看 GitHub 上一份整理好的 <a target="_blank" rel="noopener" href="https://github.com/secfigo/Awesome-Fuzzing">Awesome-Fuzzing</a>。</p>
<p>可见 Fuzzing 生成器应用范围非常广，除了获取代码覆盖率，还能够进行网络安全分析和安全漏洞分析。本文主要是基于源码插桩，源码插桩库主要是 libfuzzer、AFL++、honggfuzz、riufuzz（honggfuzz 二次开发）。</p>
<p>AFL++ 在有源码情况下原理和 libfuzzer 差不多，只是底层不是用的 SanitizerCoverage，而是自实现的一个 pass，没有源码时 AFL++ 用的就是 qemu 中 TCG 模块的代码，在反编译为 IR 时进行插桩。更多 AFL++ 应用参见《<a target="_blank" rel="noopener" href="https://github.com/google/fuzzing/blob/master/docs/afl-based-fuzzers-overview.md">What is AFL and What is it Good for?</a>》</p>
<p>Fuzzing 除了代码覆盖率，还需要又能够创建更多输出条件，记录执行路径，目标和方向是找出程序运行时在什么输入条件和路径下会有问题。但仅是检测哪些代码有用到，实际上只要用上 Fuzzing 的代码覆盖率就可以了。</p>
<h3 id="SanitizerCoverage-插桩回调函数-1"><a href="#SanitizerCoverage-插桩回调函数-1" class="headerlink" title="SanitizerCoverage 插桩回调函数"></a>SanitizerCoverage 插桩回调函数</h3><p>那接下来实践下 libfuzzer 中实现代码覆盖率的 SanitizerCoverage 技术。</p>
<p>命令行执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -fembed-bitcode main.m -save-temps -v -fsanitize-coverage=trace-pc-guard</span><br></pre></td></tr></table></figure>
<p>使用 -fsanitize-coverage=trace-pc-guard 这个编译 flag 插入不同级别的桩，会在程序控制流图的每条边插入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__sanitizer_cov_trace_pc_guard(&amp;guard_variable)</span><br></pre></td></tr></table></figure>
<p>如果只对函数插桩，使用 <code>-fsanitize-coverage=func</code>,<code>trace-pc-guard</code>，只对基本块用 <code>-fsanite-coverage=bb</code>,<code>no-prune</code>,<code>trace-pc-guard</code>。swift 使用 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 编译 flags。</p>
<p>使用插桩函数回调，先在 Xcode 的 Other C Flags 里添加 <code>-fsanitize-coverage=trace-pc-guard</code>。swift 就是在 Other Swift Flags 里添加 <code>-sanitize-coverage=func</code> 和 <code>-sanitize=undefined</code> 。</p>
<p>在回调函数里实现自己要干的事情，比如对当前插桩地址符号化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span> *start,</span><br><span class="line">			   <span class="keyword">uint32_t</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint64_t</span> N;</span><br><span class="line">    <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> *x = start; x &lt; stop; x++)</span><br><span class="line"> ,*x = ++N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span> *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    Dl_info info;</span><br><span class="line">    dladdr(PC, &amp;info);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用了方法: %s \n&quot;</span>, info.dli_sname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后就可以得到运行时调用了哪些方法。</p>
<p>有了这些数据就可以统计哪些方法调用了，调用了多少次。通过和全源码对比，取差集能够找到运行中没有执行的方法和代码块。其实利用 Fuzzing 的概念还可以做很多分析的工作，全面数据化观测代码执行情况。可以到我的 <a target="_blank" rel="noopener" href="https://github.com/ming1016/GCDFetchFeed">GCDFetchFeed</a> 工程中，打开 AppDelegate.m 里的两个插桩回调方法的注释来试用。</p>
<p>停止试用插桩，可以用 <code>__attribute__((no_sanitize(&quot;coverage&quot;)))</code> 编译属性。或者通过黑名单或白名单，分别是 <code>-fsanitize-coverage-ignorelist=blocklist.txt</code> 和 <code>-fsanitize-coverage-allowlist=allowlist.txt</code>，范围可以试文件夹、单个文件或者单个方法。</p>
<p>allowlist.txt 示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 允许文件夹里所有文件</span><br><span class="line">src:bar/*</span><br><span class="line"># 特定源文件</span><br><span class="line">src:foo/a.cpp</span><br><span class="line"># 允许文件中所有函数</span><br><span class="line">fun:*</span><br></pre></td></tr></table></figure></p>
<p>blocklist.txt 示例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 禁用特定源文件</span><br><span class="line">src:bar/b.cpp</span><br><span class="line"># 禁用特定函数</span><br><span class="line">fun:*myFunc*</span><br></pre></td></tr></table></figure></p>
<p>上线前检查出的没有用到的代码，并不表示上线后用户不会用到，比如 AB 实验、用户特殊设置、不常见 Case 等。这就可以利用 allowlist.txt 将部分不确定的代码放到线上去检测，或者通过自动插入埋点灰度检测，这些不确定的代码不是主链路的，因此检测影响范围会很低。</p>
<p>SanitizerCoverage 本身是一个 llvm pass，代码在 llvm 工程的 llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp 路径下，那么怎么实现一个自定义的 pass 呢？</p>
<p>先把 llvm 装到本地。</p>
<h3 id="安装-LLVM"><a href="#安装-LLVM" class="headerlink" title="安装 LLVM"></a>安装 LLVM</h3><p>使用 homebrew，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install llvm@13</span><br></pre></td></tr></table></figure>
<p><code>@13</code> 表示 llvm 的版本。安装后使用路径在是 <code>/usr/local/opt/llvm/</code>，比如 cmake 构建编译环境可以使用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">LLVM_DIR=/usr/<span class="built_in">local</span>/opt/llvm/lib/cmake/llvm cmake ..</span></span><br></pre></td></tr></table></figure>
<p>可以用 Visual Studio Code 开发 pass，安装微软的 C/C++ 的 extension，在 C/C++ Configurations 里把 <code>/usr/local/opt/llvm/include/</code> 加入到包含路径中。</p>
<p>llvm 的更新使用 <code>brew upgrade llvm</code></p>
<p>llvm 也可以通过源码来安装，执行如下命令即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/llvm/llvm-project.git</span><br><span class="line">cd llvm-project</span><br><span class="line">git checkout release/14.x</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=host -DLLVM_ENABLE_PROJECTS=clang ../llvm</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure></p>
<p>这里的 cmake 参数 <code>-DLLVM_ENABLE_PROJECTS=clang</code> 表示也会构建 clang 工具。如果还要加上 lld 以在构建时能够用自己的 pass，可以直接加成 <code>-DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot;</code> 。</p>
<p>自定义安装目录的话，增加 <code>-DCMAKE_INSTALL_PREFIX=/home/user/custom-llvm</code> 。然后在设置路径 <code>export PATH=$PATH:/home/user/custom-llvm/bin</code> 。</p>
<p>-G 编译选项选择 Ninja 编译速度快。</p>
<p>各种设置整到一起：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G &quot;Ninja&quot; -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=host -DLLVM_ENABLE_PROJECTS=&quot;clang;lld&quot; -DCMAKE_INSTALL_PREFIX=/Users/mingdai/Downloads/PTest/my-llvm-bin ../llvm</span><br></pre></td></tr></table></figure>
<h3 id="自制-Pass"><a href="#自制-Pass" class="headerlink" title="自制 Pass"></a>自制 Pass</h3><h4 id="Pass-介绍"><a href="#Pass-介绍" class="headerlink" title="Pass 介绍"></a>Pass 介绍</h4><p>llvm 属于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multi-pass_compiler">multi-pass</a> 编译器，LLVM Pass 管理器是处理 pass 执行的注册和时序安排。曾有两个 pass 管理器，一个是 New Pass 管理器也叫 Pass 管理器，另一个是 Legacy Pass 管理器。New Pass 目前是默认的管理器，Legacy Pass 在 LLVM 14 中被废弃。Legacy 和 New 两个 pass 管理器在使用上最大的区别就是，Legacy 会注册一个新的命令选项，而 New Pass 只用定义一个 pass。另外 Legacy 需要实现 print 成员方法来打印，需要在通过 opt 通过传递 -analyze 命令行选项来运行，而 New Pass 管理器是不用的，只需要实现 printing pass。</p>
<p>总的来说<br>Legacy</p>
<ul>
<li>基于继承性</li>
<li>分析和打印 pass 之间没有区别</li>
<li>注册时加载所有需要的 pass</li>
<li>不变的 pass 执行调度</li>
<li>Transformation passes 定义了它们在执行前保证保留的内容</li>
</ul>
<p>Legacy 的 pass 类</p>
<ul>
<li><code>llvm::Pass</code><ul>
<li><code>llvm::ModulePass</code></li>
<li><code>llvm::FunctionPass</code></li>
<li><code>llvm::PassRegistry</code></li>
</ul>
</li>
</ul>
<p>New</p>
<ul>
<li>基于 CRTP、mixin 和 concept-model 的 idiom-based</li>
<li>在执行过程中，根据需要有条件的加载依赖的 pass（更快、更有效）</li>
<li>Transformation passes 在执行后返回它们所保留的内容</li>
</ul>
<p>New 的 pass 类</p>
<ul>
<li><code>llvm::PassInfoMixin&lt;DerivedT&gt;</code></li>
<li><code>llvm::AnalysisInfoMixin&lt;DerivedT&gt;</code></li>
<li><code>llvm::FunctionAnalysisManager</code><ul>
<li>别名类型 <code>llvm::AnalysisManager&lt;llvm::Function&gt;</code></li>
</ul>
</li>
<li><code>llvm::ModuleAnalysisManager</code><ul>
<li>别名类型 <code>llvm::AnalysisManager&lt;llvm::Module&gt;</code></li>
</ul>
</li>
<li><code>llvm::PreservedAnalysis</code></li>
</ul>
<p>LLVM Pass 可以对 LLVM IR 进行优化。优化表现在 Pass 可以对 IR 进行分析和转换，因此 Pass 主要也是分为分析（analysis）和转换（transform）两类。</p>
<p>分析里有数据流分析技术，分为以下三种：</p>
<ul>
<li>Reaching-Definition Analysis 到达定值分析</li>
<li>Live-Variable Analysis 活跃变量分析</li>
<li>Available-Expression Analysis 可用表达式分析</li>
</ul>
<p>一些常用的优化方法，比如删除计算结果不会使用的语句、删除归纳变量、删除公共子表达式、进入循环前就对不管循环多少次都是同样结果的表达式进行求值、快的操作替换慢操作、用可推导出值是常量的表达式来替代表达式等。</p>
<p>编写优化的几个方法。完整代码参看<a target="_blank" rel="noopener" href="https://github.com/Kiprey/Skr_Learning/tree/master/week7-8/Assignment1-Introduction_to_LLVM">这里</a>。</p>
<p>插入新指令：</p>
<ul>
<li>直接通过类或命名的构造函数。</li>
<li>使用 llvm::IRBuilder&lt;&gt; 模板类。</li>
</ul>
<p>删除指令：</p>
<ul>
<li>llvm::Instruction::eraseFromParent() 成员函数</li>
</ul>
<p>替换存在指令：</p>
<ul>
<li>llvm::ReplaceInstWithInst() 函数<ul>
<li>~#include “llvm/Transforms/Utils/BasicBlockUtils.h”~</li>
</ul>
</li>
</ul>
<p>直接改指令</p>
<ul>
<li>llvm::User::setOperand() 成员函数</li>
</ul>
<p>Value ⇒ ConstantInt 类型转换：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type <span class="keyword">_t</span>;</span><br><span class="line">ConstantInt* val = dyn_cast&lt;ConstantInt&gt;(<span class="keyword">_t</span>);</span><br></pre></td></tr></table></figure></p>
<p>获取 ConstantInt 类的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConstantInt* const_int;</span><br><span class="line"><span class="keyword">uint64_t</span> val = const_int-&gt;<span class="built_in">getZExtValue</span>();</span><br></pre></td></tr></table></figure>
<p>替换某个指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instruction inst;</span><br><span class="line"><span class="comment">// 替换，只是替换了引用，并没删</span></span><br><span class="line">inst.<span class="built_in">replaceAllUsesWith</span>(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">if</span>(inst-&gt;<span class="built_in">isSafeToRemove</span>())</span><br><span class="line">    inst-&gt;<span class="built_in">eraseFromParent</span>();</span><br></pre></td></tr></table></figure>
<p>对应的 IR 代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 执行前</span><br><span class="line">%12 = load i32, i32* %2, align 4</span><br><span class="line">%13 = add nsw i32 %12, 0</span><br><span class="line">store i32 %13, i32* %3, align 4</span><br><span class="line">; 只替换指令引用</span><br><span class="line">%12 = load i32, i32* %2, align 4</span><br><span class="line">%13 = add nsw i32 %12, 0          </span><br><span class="line">store i32 %12, i32* %3, align 4</span><br><span class="line">%12 = load i32, i32* %2, align 4</span><br><span class="line">store i32 %12, i32* %3, align 4</span><br><span class="line">Instruction referencing instruction not embedded in a basic block!</span><br><span class="line">  %12 = load i32, i32* %2, align 4</span><br><span class="line">  &lt;badref&gt; = add nsw i32 %12, 0</span><br></pre></td></tr></table></figure>
<p>建立新指令</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出第一个操作数</span></span><br><span class="line">Value* val = inst.<span class="built_in">getOperand</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 确定新指令的插入位置</span></span><br><span class="line">IRBuilder&lt;&gt; <span class="built_in">builder</span>(&amp;inst);</span><br><span class="line"><span class="comment">// val &lt;&lt; 1</span></span><br><span class="line">Value* newInst = builder.<span class="built_in">CreateShl</span>(val, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 替换指令</span></span><br><span class="line">inst.<span class="built_in">replaceAllUsesWith</span>(newInst);</span><br></pre></td></tr></table></figure>
<p>Analysis pass 的 print pass 是基于一个 Transformation pass，会请求原始 pass 分析的结果，并打印这些结果。会注册一个命令行选项 <code>print&lt;analysis-pass-name&gt;</code>。</p>
<p>实现 pass 要选择是 Analysis 还是 Transformation，也就是要对进行输入 IR 的分析还是进行转换来决定采用哪种。选择 Transformation 通常继承 PassInfoMixin。Analysis 继承 AnalysisInfoMixin。</p>
<p>pass 生成的插件分为动态和静态的。静态插件不需要在运行时用 -load-pass-plugin 选项进行加载，但需要在 llvm 工程中设置 CMake 重新构建 opt。</p>
<p>做自己 pass 前可以先了解下 llvm 内部的 <a target="_blank" rel="noopener" href="https://llvm.org/docs/Passes.html">pass</a> 示例，可以先从两个最基本的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/13.x/llvm/lib/Transforms/Hello">Hello</a> 和 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/release/13.x/llvm/examples/Bye">Bye</a> 来。比较实用的是一些做优化的 pass，这些 pass 也是学习写 pass ，了解编译器如何工作的重要资源。许多 pass 都实现了编译器开发理论中著名的概念。比如优化 memcpy 调用（比如用 memset 替换）的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp">memcpyopt</a> 、简化 CFG <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/tree/release/13.x/llvm/examples/IRTransforms">IRTransforms</a>、总是内联用 alwaysinline 修饰的函数的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/IPO/AlwaysInliner.cpp">always-inline</a> 、死代码消除的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/DCE.cpp">dce</a> 和删除未使用的循环的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/blob/release/14.x/llvm/lib/Transforms/Scalar/LoopDeletion.cpp">loop-deletion</a>。</p>
<h4 id="自制插入指令-pass"><a href="#自制插入指令-pass" class="headerlink" title="自制插入指令 pass"></a>自制插入指令 pass</h4><p>接下来，怎么在运行时插入指令来获取我们需要代码使用情况。完整代码可以在这里 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/MingPass">MingPass</a> 拉下代码参考进行修改调试。</p>
<p>个 pass 功能是在运行时环境直接在特定位置执行指定的函数。先写个要执行的函数，新建个文件 loglib.m，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runtimeLog</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;计算结果: %i\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再到 MingPass.cpp 中包含模块头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;llvm/IR/Module.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>会用到 Module::getOrInsertFunction 函数来给 loglib.m 的 runtimeLog 做声明。</p>
<p>更改 runOnFunction 函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从运行时库中获取函数</span></span><br><span class="line">    LLVMContext &amp;Context = F.<span class="built_in">getContext</span>();</span><br><span class="line">    std::vector&lt;Type*&gt; paramTypes = &#123;Type::<span class="built_in">getInt32Ty</span>(Context)&#125;;</span><br><span class="line">    Type *retType = Type::<span class="built_in">getVoidTy</span>(Context);</span><br><span class="line">    FunctionType *funcType = FunctionType::<span class="built_in">get</span>(retType, paramTypes, <span class="literal">false</span>);</span><br><span class="line">    FunctionCallee logFunc = F.<span class="built_in">getParent</span>()-&gt;<span class="built_in">getOrInsertFunction</span>(<span class="string">&quot;runtimeLog&quot;</span>, funcType);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;I : BB) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">auto</span> *op = dyn_cast&lt;BinaryOperator&gt;(&amp;I)) &#123;</span><br><span class="line">  IRBuilder&lt;&gt; <span class="built_in">builder</span>(op);</span><br><span class="line">              </span><br><span class="line">  <span class="comment">// 在 op 后面加入新指令</span></span><br><span class="line">  builder.<span class="built_in">SetInsertPoint</span>(&amp;BB, ++builder.<span class="built_in">GetInsertPoint</span>());</span><br><span class="line">  <span class="comment">// 在函数中插入新指令</span></span><br><span class="line">  Value* args[] = &#123;op&#125;;</span><br><span class="line">  builder.<span class="built_in">CreateCall</span>(logFunc, args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125; <span class="comment">// end if</span></span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 build 目录下 make 出 pass 的 so 后，链接 main.m 和 loglib.m 的产物成可执行文件，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clang -c loglib.m</span><br><span class="line">/usr/local/opt/llvm/bin/clang -flegacy-pass-manager -Xclang -load -Xclang build/src/libMingPass.so -c main.m</span><br><span class="line">clang main.o loglib.o</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<p>输入数字4后，打印如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">计算结果: 6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h4 id="更多自制-pass"><a href="#更多自制-pass" class="headerlink" title="更多自制 pass"></a>更多自制 pass</h4><p>可以在<a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/LeanLLVMPass">这里</a>查看，代码里有详细注释。</p>
<h4 id="IR"><a href="#IR" class="headerlink" title="IR"></a>IR</h4><p>你会发现开发 pass 需要更多的了解 IR，才可以更好的控制 LLVM 前端处理的高级语言。接下来我会说下那些高级语言的特性是怎么在 IR 里表现的。先介绍下 IR。</p>
<h5 id="IR-介绍"><a href="#IR-介绍" class="headerlink" title="IR 介绍"></a>IR 介绍</h5><p>LLVM IR(Intermediate Representation) 可以称为中间代码，是 LLVM 整个编译过程的中间表示。</p>
<p>llvm ir 的基础块里的指令是不可跳转到基础块的中间或尾部，只能从基础块的第一个指令进入基础块。</p>
<p>下面是 ir 的几个特点：</p>
<ul>
<li>llvm ir  不是机器代码而是生成机器代码之前的一种有些看起来像高级语言的，比如函数和强类型，有些看起来像低级程序集，比如分支和基本块。</li>
<li>llvm ir 是强类型。</li>
<li>llvm 没有 sign 和 unsign 整数区别。</li>
<li>全局符号用 @ 符号开头。</li>
<li>本地符号用 % 符号开头。</li>
<li>必须定义和声明所有符号。</li>
</ul>
<p>IR 指令</p>
<p><em>常用指令</em></p>
<ul>
<li>alloca：分配栈空间</li>
<li>load：从栈和全局内存读值</li>
<li>store：将值写到栈或全局内存</li>
<li>br：分支（条件或非条件）</li>
<li>call：调用函数</li>
<li>ret：从一个函数返回，可能会带上一个返回值</li>
<li>icmp/fcmp：比较整型或浮点值</li>
<li>add/sub/mul：整数二进制算术运算</li>
<li>fadd/fsub/fmul：浮点二进制算术运算</li>
<li>sdiv/udiv/fdiv：有符号位整数/无符号位整数/浮点除法</li>
<li>shl/shr：位向左/向右</li>
<li>lshr/ashr：逻辑/算术右移</li>
<li>and/or/xor：位逻辑运算（没有 <code>not</code>！）</li>
</ul>
<p><em>常用特殊 ir 指令</em></p>
<ul>
<li>select：根据一个没有 IR 级别分支的条件选择一个值。</li>
<li>phi：根据当前基本块前身选择一个值。</li>
<li>getelementpointer：获取数组或结构体里子元素的地址（不是值）。官方说明[[<a target="_blank" rel="noopener" href="https://llvm.org/docs/GetElementPtr.html][The">https://llvm.org/docs/GetElementPtr.html][The</a> Often Misunderstood GEP Instruction]]。</li>
<li>extractvalue：从一个数组或结构体中提取一个成员字段的值（不是地址）。</li>
<li>insertvalue：将一个值添加给数组或结构体的成员字段。</li>
</ul>
<p><em>ir 转换指令</em></p>
<ul>
<li>bitcast：将一个值转成给定类型而不改变它的位。</li>
<li>trunc/fptrunc：将一个类型的整数/浮点值截断为一个更小的整数/浮点类型。</li>
<li>zext/sext/fpext：将一个值扩展到一个更大的整数/浮点类型上。</li>
<li>fptoui/fptosi：将一个浮点值转换为无符号/有符号位的整数类型。</li>
<li>uitofp/sitofp：将一个无符号/有符号位整数值转换为浮点类型。</li>
<li>ptrtoint：将指针转成整数。</li>
<li>inttoptr：将整数值转成指针类型。</li>
</ul>
<p>ir 库的 header 地址在 ~include/llvm/IR~ ，源文件在 ~lib/IR~ ，文档 <a target="_blank" rel="noopener" href="https://llvm.org/doxygen/namespacellvm.html">llvm Namespace Reference</a>。所有类和函数都在 llvm 命名空间里。</p>
<p>主要基础类的说明如下：</p>
<ul>
<li>llvm::Module：ir 的容器类的最高级。</li>
<li>llvm::Value：所有可作为其他值或指令操作数的基类。<ul>
<li>llvm::Constant<ul>
<li>llvm::ConstantDataArray (Constants.h)</li>
<li>llvm::ConstantInt (Constants.h)</li>
<li>llvm::ConstantFP (Constants.h)</li>
<li>llvm::ConstantStruct (Constants.h)</li>
<li>llvm::ConstantPointerNull (Constants.h)</li>
<li>llvm::Function</li>
<li>llvm::GlobalVariable</li>
</ul>
</li>
<li>llvm::BasicBlock</li>
<li>llvm::Instruction<ul>
<li>Useful X-macro header: Instruction.def</li>
<li>llvm::BinaryOperator (InstrTypes.h)<ul>
<li>add, sub, mul, sdiv, udiv, srem, urem</li>
<li>fadd, fsub, fmul, fdiv, frem</li>
<li>shl, lshr, ashr, and, or, xor</li>
</ul>
</li>
<li>llvm::CmpInst (InstrTypes.h)<ul>
<li>llvm::ICmpInst (Instructions.h)</li>
<li>llvm::FCmpInst (Instructions.h)</li>
</ul>
</li>
<li>llvm::UnaryInstruction (InstrTypes.h)<ul>
<li>llvm::CastInst (Instrtypes.h)</li>
</ul>
</li>
<li>llvm::BitCastInst (Instructions.h)</li>
</ul>
</li>
</ul>
</li>
<li>llvm::Type：代表所有的 IR 数据类型，包括原始类型，结构类型和函数类型。</li>
</ul>
<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><p>下面 c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> variable = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    variable = variable * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> variable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 ir 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@variable = global i32 21</span><br><span class="line"></span><br><span class="line">define i32 @main() &#123;</span><br><span class="line">    %1 = load i32, i32* @variable  ; load the global variable</span><br><span class="line">    %2 = mul i32 %1, 2</span><br><span class="line">    store i32 %2, i32* @variable   ; store instruction to write to global variable</span><br><span class="line">    ret i32 %2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，你可以看到全局变量是 @ 字符前缀，main 函数也是 @ 符号作为前缀，因此 main 函数也是 llvm 中的全局变量。llvm 将全局变量看成指针，因此访问全局变量时，必须用 load 指令显示取消对全局变量的引用，同样的，你要用 store 指令显示存储全局变量的值。</p>
<h5 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h5><p>本地变量有两种，一种是临时变量，也可以说是寄存器，另一种是堆栈分配的局部变量。</p>
<p>临时变量或寄存器是通过为变量引入一个新的符号来创建的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%reg = add i32 4, 2</span><br></pre></td></tr></table></figure>
<p>堆栈分配的局部变量是通过在堆上分配变量来创建的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%stack = alloca i32</span><br></pre></td></tr></table></figure>
<p>几乎每条指令都会返回一个值，该值通常分配给一个临时变量。由于 llvm ir 的 SSA 形式，临时变量只能分配一次。因此下面的代码就会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%tmp = add i32 4, 2</span><br><span class="line">%tmp = add i32 4, 1  ; Error here</span><br></pre></td></tr></table></figure>
<p>为符合 SSA，一般会是下面的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%tmp.0 = add i32 4, 2</span><br><span class="line">%tmp.1 = add i32 4, 1  ; fine now</span><br></pre></td></tr></table></figure></p>
<p>简化为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%0 = add i32 4, 2</span><br><span class="line">%1 = add i32 4, 1</span><br></pre></td></tr></table></figure></p>
<p>这种局部变量的数量基本是无限的。因为真实机器的寄存器数量有限，因此编译器后端可能需要将其中一些临时寄存器放在堆栈上。</p>
<p>alloca 产生一个指向已分配类型的指针。必须要显示的使用 load 或 store 指令来分别读取和写入值。</p>
<h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><p>有两种常量，一种是不占用分配内存的常量，另一种是占用分配内存的常量。</p>
<p>不占用分配内存的常量没有等效 llvm ir，他们是在编译前端将常量值插入到使用他们的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%1 = add i32 %0, 17     ; 17 就是内联的常量</span><br></pre></td></tr></table></figure>
<p>占用分配内存的常量使用 constant 关键字定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@hello = internal constant [6 x i8] c&quot;hello\00&quot;</span><br><span class="line">%struct = type &#123; i32, i8 &#125;</span><br><span class="line">@struct_constant = internal constant %struct &#123; i32 16, i8 4 &#125;</span><br></pre></td></tr></table></figure>
<p>可以看出常量实际也是个全局变量，可见性可以用 private 和 internal 来限制，这样它在当前模式之外是不可见的。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>在 LLVM 中有两种实现字符串类型的方法：</p>
<ul>
<li>在 LLVM IR 中编写实现</li>
<li>用生成 IR 的高级语言编写实现</li>
</ul>
<p>LLVM IR 中有一个简单但有用的字符串类型。</p>
<p>我们将创建一个动态的、可变的字符串类型，它可以被添加，也可以插入，转换大小写等等，这取决于定义了哪些支持函数来操作字符串类型。</p>
<p>这一切都归结为为类制作合适的类型定义，然后定义一组丰富的函数来对类型定义进行操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    store i8* %output, i8** %1</span><br><span class="line"></span><br><span class="line">    ;this-&gt;maxlen = %value (value that was passed into @malloc is the new maxlen)</span><br><span class="line">    %4 = getelementptr %String* this, i32 0, i32 2</span><br><span class="line">    store i32 %value, i32* %4</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define fastcc void @String_Add_Char(%String* %this, i8 %value) &#123;</span><br><span class="line">    ; Check if we need to grow the string.</span><br><span class="line">    %1 = getelementptr %String* %this, i32 0, i32 1</span><br><span class="line">    %length = load i32* %1</span><br><span class="line">    %2 = getelementptr %String* %this, i32 0, i32 2</span><br><span class="line">    %maxlen = load i32* %2</span><br><span class="line">    ; if length == maxlen:</span><br><span class="line">    %3 = icmp eq i32 %length, %maxlen</span><br><span class="line">    br i1 %3, label %grow_begin, label %grow_close</span><br><span class="line"></span><br><span class="line">grow_begin:</span><br><span class="line">    %4 = getelementptr %String* %this, i32 0, i32 3</span><br><span class="line">    %factor = load i32* %4</span><br><span class="line">    %5 = add i32 %maxlen, %factor</span><br><span class="line">    call void @String_Resize(%String* %this, i32 %5)</span><br><span class="line">    br label %grow_close</span><br><span class="line"></span><br><span class="line">grow_close:</span><br><span class="line">    %6 = getelementptr %String* %this, i32 0, i32 0</span><br><span class="line">    %buffer = load i8** %6</span><br><span class="line">    %7 = getelementptr i8* %buffer, i32 %length</span><br><span class="line">    store i8 %value, i8* %7</span><br><span class="line">    %8 = add i32 %length, 1</span><br><span class="line">    store i32 %8, i32* %1</span><br><span class="line"></span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h5><p>下面的 c 代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> x;</span><br><span class="line">  <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对应的 ir 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%Foo = type &#123;</span><br><span class="line">    i64,       ; index 0 = x</span><br><span class="line">    double     ; index 1 = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 struct 的结构成员是从0开始的数字进行索引。</p>
<p>下面是嵌套结构的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FooBar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo x;</span><br><span class="line">    <span class="keyword">char</span>* c;</span><br><span class="line">    Foo* y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 ir 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%FooBar = type &#123;</span><br><span class="line">    %Foo,         ; index 0 = x</span><br><span class="line">    i8*,          ; index 1 = c</span><br><span class="line">    %Foo*         ; index 2 = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不完整结构类型，对于隐藏结构细节非常有用。比如下面的 c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">(struct Foo *)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对应的 ir 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%Foo = type opaque</span><br><span class="line">declare void @Bar(%Foo)</span><br></pre></td></tr></table></figure>
<p>ir 的结构成员是通过索引而不是名称来记录的，getelementptr(GEP) 是专门用来计算指向任何结构成员的指针。比如下面 c++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应 ir 是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%Foo = type &#123;</span><br><span class="line">    i32,        ; 0: a</span><br><span class="line">    i8*,        ; 1: b</span><br><span class="line">    double      ; 2: c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GEP 索引如 ir 代码中的注释所示。现在访问 b 成员，c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line"><span class="keyword">char</span> **bptr = &amp;foo.b;</span><br></pre></td></tr></table></figure>
<p>先在堆栈上使用 alloca 指令分配对象，访问 b 成员，使用 GEP 指令计算指向内存位置的指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%foo = alloca %Foo</span><br><span class="line">; char **bptr = &amp;foo.b</span><br><span class="line">%1 = getelementptr %Foo, %Foo* %foo, i32 0, i32 1</span><br></pre></td></tr></table></figure>
<p>如果创建一个 Foo 对象数组，如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo bar[<span class="number">100</span>];</span><br><span class="line">bar[<span class="number">17</span>].c = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p>
<p>会转成以下 ir 代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; Foo bar[100]</span><br><span class="line">%bar = alloca %Foo, i32 100</span><br><span class="line">; bar[17].c = 0.0</span><br><span class="line">%2 = getelementptr %Foo, %Foo* %bar, i32 17, i32 2</span><br><span class="line">store double 0.0, double* %2</span><br></pre></td></tr></table></figure></p>
<p>如上面代码所示，它首先会分配一个指向 100 个 Foo 对象的指针。然后用 GEP 指令检索数组中第17个条目的第二个元素。</p>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p>有九种不同类型的转换</p>
<ul>
<li>Bitwise casts (type casts)</li>
<li>Zero-extending casts (unsigned upcasts).</li>
<li>Sign-extending casts (signed upcasts).</li>
<li>Truncasting casts (signed and unsigned downcasts).</li>
<li>Floating-point extending casts (float upcasts).</li>
<li>Floating-point truncasting casts (float downcasts)</li>
<li>Pointer-to-integer casts.</li>
<li>Integer-to-pointer casts.</li>
<li>Address-space casts (pointer casts).</li>
</ul>
<p><em>Bitwise Casts</em><br>bitwise cast 是按位强制转换。比如可以将指向字节的指针位转换为指向某个结构的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125; Foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *foo = (Foo *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Foo));</span><br><span class="line">    foo.a = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">free</span>(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换成对应的 ir：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%Foo = type &#123; i32 &#125;</span><br><span class="line"></span><br><span class="line">declare i8* @malloc(i32)</span><br><span class="line">declare void @free(i8*)</span><br><span class="line"></span><br><span class="line">define void @allocate() nounwind &#123;</span><br><span class="line">    %1 = call i8* @malloc(i32 4)</span><br><span class="line">    %foo = bitcast i8* %1 to %Foo*</span><br><span class="line">    %2 = getelementptr %Foo, %Foo* %foo, i32 0, i32 0</span><br><span class="line">    store i32 12, i32* %2</span><br><span class="line">    call void @free(i8* %1)</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Zero-Extending Casts(Unsigned Upcasts)</em><br>比如下面的 c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uint8 byte = <span class="number">117</span>;</span><br><span class="line">uint32 word;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* The compiler automatically upcasts the byte to a word. */</span></span><br><span class="line">    word = byte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 zext 指令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@byte = global i8 117</span><br><span class="line">@word = global i32 0</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = load i8, i8* @byte</span><br><span class="line">    %2 = zext i8 %1 to i32</span><br><span class="line">    store i32 %2, i32* @word</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>Sign-Extending Casts (Signed Upcasts)</em><br>将 zext 替换成 sext 指令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@char = global i8 -17</span><br><span class="line">@int  = global i32 0</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = load i8, i8* @char</span><br><span class="line">    %2 = sext i8 %1 to i32</span><br><span class="line">    store i32 %2, i32* @int</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Truncating Casts (Signed and Unsigned Downcasts)</em><br>signed 和 unsigned 整数都使用相同的指令 trunc 来减少相关数字的大小。这是因为 llvm ir 假设所有有符号整数值都是二进制补码格式，因此 turn 注意处理这两种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@int = global i32 -1</span><br><span class="line">@char = global i8 0</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = load i32, i32* @int</span><br><span class="line">    %2 = trunc i32 %1 to i8</span><br><span class="line">    store i8 %2, i8* @char</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Floating-Point Extending Casts (Float Upcasts)</em><br>浮点数可以使用 fpext 指令进行扩展，比如下面的 c 代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> small = <span class="number">1.25</span>;</span><br><span class="line"><span class="keyword">double</span> large;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* The compiler inserts an implicit float upcast. */</span></span><br><span class="line">    large = small;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@small = global float 1.25</span><br><span class="line">@large = global double 0.0</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = load float, float* @small</span><br><span class="line">    %2 = fpext float %1 to double</span><br><span class="line">    store double %2, double* @large</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Floating-Point Truncating Casts (Float Downcasts)</em><br>浮点数可以截断为更小的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@large = global double 1.25</span><br><span class="line">@small = global float 0.0</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = load double, double* @large</span><br><span class="line">    %2 = fptrunc double %1 to float</span><br><span class="line">    store float %2, float* @small</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Pointer-to-Integer Casts</em><br>使用 ptrtoint 指令将指针类型转换为整数类型。</p>
<p><em>Integer-to-Pointer Casts</em><br>使用 inttoptr 指令将整数转换成指针。</p>
<h5 id="函数和声明"><a href="#函数和声明" class="headerlink" title="函数和声明"></a>函数和声明</h5><p>函数定义取决于 calling convention、excption-aware 和模块是否对外公开。</p>
<p>下面是一个简单的 c 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>会转换成<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define i32 @Bar() nounwind &#123;</span><br><span class="line">    ret i32 17</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>私有函数定义如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define private i32 @Foo() nounwind &#123;</span><br><span class="line">    ret i32 17</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ir 的私有函数只是 llvm 模块级的私有函数，并不是和高级语言 private 关键字定义的函数对应。</p>
<p>函数原型在 ir 里使用 declare 来声明：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bar</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>对应使用 declare 声明为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @Bar(i32 %value)</span><br></pre></td></tr></table></figure></p>
<p>可变参数的函数，要用省略号定义或声明它，然后需要使用特殊的函数调用语法。示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">declare i32 @printf(i8*, ...) nounwind</span><br><span class="line"></span><br><span class="line">@.textstr = internal constant [20 x i8] c&quot;Argument count: %d\0A\00&quot;</span><br><span class="line"></span><br><span class="line">define i32 @main(i32 %argc, i8** %argv) nounwind &#123;</span><br><span class="line">    ; printf(&quot;Argument count: %d\n&quot;, argc)</span><br><span class="line">    %1 = call i32 (i8*, ...) @printf(i8* getelementptr([20 x i8], [20 x i8]* @.textstr, i32 0, i32 0), i32 %argc)</span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数重载不是在 ir 里处理的，是在源语言上处理的。重载的函数名称不同，示例如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">function</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*b + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面 c 代码对应 ir 是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define i32 @_Z8functionii(i32 %a, i32 %b) #0 &#123;</span><br><span class="line">; [...]</span><br><span class="line">  ret i32 %5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define double @_Z8functionddd(double %a, double %b, double %x) #0 &#123;</span><br><span class="line">; [...]</span><br><span class="line">  ret double %8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见在 ir 里，重载函数的名称和功能都是不同的。</p>
<p>类或结构体通常是按值传递，在传递对象时隐式克隆对象。比如下面的 c 代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Point <span class="title">add_points</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">  Point p;</span><br><span class="line">  p.x = a.x + b.x;</span><br><span class="line">  p.y = a.y + b.y;</span><br><span class="line">  p.z = a.z + b.z;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应 ir 是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%struct.Point = type &#123; double, double, double &#125;</span><br><span class="line"></span><br><span class="line">define void @add_points(%struct.Point* noalias sret %agg.result,</span><br><span class="line">                        %struct.Point* byval align 8 %a,</span><br><span class="line">                        %struct.Point* byval align 8 %b) #0 &#123;</span><br><span class="line">; there is no alloca here for Point p;</span><br><span class="line">; p.x = a.x + b.x;</span><br><span class="line">  %1 = getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 0</span><br><span class="line">  %2 = load double, double* %1, align 8</span><br><span class="line">  %3 = getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 0</span><br><span class="line">  %4 = load double, double* %3, align 8</span><br><span class="line">  %5 = fadd double %2, %4</span><br><span class="line">  %6 = getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 0</span><br><span class="line">  store double %5, double* %6, align 8</span><br><span class="line">; p.y = a.y + b.y;</span><br><span class="line">  %7 = getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 1</span><br><span class="line">  %8 = load double, double* %7, align 8</span><br><span class="line">  %9 = getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 1</span><br><span class="line">  %10 = load double, double* %9, align 8</span><br><span class="line">  %11 = fadd double %8, %10</span><br><span class="line">  %12 = getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 1</span><br><span class="line">  store double %11, double* %12, align 8</span><br><span class="line">; p.z = a.z + b.z;</span><br><span class="line">  %13 = getelementptr inbounds %struct.Point, %struct.Point* %a, i32 0, i32 2</span><br><span class="line">  %14 = load double, double* %13, align 8</span><br><span class="line">  %15 = getelementptr inbounds %struct.Point, %struct.Point* %b, i32 0, i32 2</span><br><span class="line">  %16 = load double, double* %15, align 8</span><br><span class="line">  %17 = fadd double %14, %16</span><br><span class="line">  %18 = getelementptr inbounds %struct.Point, %struct.Point* %agg.result, i32 0, i32 2</span><br><span class="line">  store double %17, double* %18, align 8</span><br><span class="line">; there is no real returned value, because the previous stores directly wrote</span><br><span class="line">; to the caller allocated value via %agg.result</span><br><span class="line">  ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 add_points 函数返回的是 void，另外添加了一个参数，这个参数是指向返回结果的指针，有调用者来分配。这个指针是 noalias 属性，sret 属性表明这是返回值。参数是 byval 属性，表示他们是按值传递的结构。</p>
<p>下面代码是展示如何调用 add_points 函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Point a = &#123;<span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">  Point b = &#123;<span class="number">2.0</span>, <span class="number">8.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">  Point c = add_points(a, b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编成 ir 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #1 &#123;</span><br><span class="line">; these are the a, b, c in the scope of main</span><br><span class="line">  %a = alloca %struct.Point, align 8</span><br><span class="line">  %b = alloca %struct.Point, align 8</span><br><span class="line">  %c = alloca %struct.Point, align 8</span><br><span class="line">; these are copies, which are passed as arguments</span><br><span class="line">  %1 = alloca %struct.Point, align 8</span><br><span class="line">  %2 = alloca %struct.Point, align 8</span><br><span class="line">; copy the global initializer main::a to %a</span><br><span class="line">  %3 = bitcast %struct.Point* %a to i8*</span><br><span class="line">  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %3, i8* bitcast (%struct.Point* @main.a to i8*), i64 24, i32 8, i1 false)</span><br><span class="line">; copy the global initializer main::b to %b</span><br><span class="line">  %4 = bitcast %struct.Point* %b to i8*</span><br><span class="line">  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* bitcast (%struct.Point* @main.b to i8*), i64 24, i32 8, i1 false)</span><br><span class="line">; clone a to %1</span><br><span class="line">  %5 = bitcast %struct.Point* %1 to i8*</span><br><span class="line">  %6 = bitcast %struct.Point* %a to i8*</span><br><span class="line">  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %5, i8* %6, i64 24, i32 8, i1 false)</span><br><span class="line">; clone b to %1</span><br><span class="line">  %7 = bitcast %struct.Point* %2 to i8*</span><br><span class="line">  %8 = bitcast %struct.Point* %b to i8*</span><br><span class="line">  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 24, i32 8, i1 false)</span><br><span class="line">; call add_points with the cloned values</span><br><span class="line">  call void @add_points(%struct.Point* sret %c, %struct.Point* byval align 8 %1, %struct.Point* byval align 8 %2)</span><br><span class="line">  ; [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到调用者为返回值 %c 分配空间，并且确保在实际通过引用传递参数前克隆参数 a 和 b。</p>
<p>异常处理函数，可以返回一个指向异常实例的指针，创建一个 setjmp/longjmp 帧，或者简单指定 uwtable 属性。</p>
<p>函数指针的表达方式和 c 差不多，比如下面 c 代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*Function)(<span class="keyword">char</span> *buffer);</span><br></pre></td></tr></table></figure></p>
<p>对应 ir 为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Function = global i32(i8*)* null</span><br></pre></td></tr></table></figure></p>
<h5 id="Unions"><a href="#Unions" class="headerlink" title="Unions"></a>Unions</h5><p>llvm 不支持 unions，下面的 c++ 代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> *b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo Union;</span><br></pre></td></tr></table></figure></p>
<p>对应 ir 为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%union.Foo = type &#123; double &#125;</span><br><span class="line">@Union = %union.Foo &#123; 0.0 &#125;</span><br></pre></td></tr></table></figure></p>
<p>其它成员没有了，ir 要访问他们要用 bitcast 指令将指向 union 的指针转换为你想要的指针。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%1 = bitcast %union.Foo* @Union to i32*</span><br><span class="line">store i32 1, i32* %1</span><br><span class="line">%2 = bitcast %union.Foo* @Union to i8**</span><br><span class="line">store i8* null, i8** %2</span><br></pre></td></tr></table></figure></p>
<p>实际上 unions 只不过是一块使用不同隐式指针强制转换访问的内存。处理 unions 没有类型安全。前端语言需要对 unions 做支持，可以简单的分配 unions 的总大小，也就是最大成员的大小，然后根据需要生成代码来重新解释分配的内存。</p>
<h5 id="if-then-else-分支"><a href="#if-then-else-分支" class="headerlink" title="if-then-else 分支"></a>if-then-else 分支</h5><p>llvm ir 是按顺序执行的指令序列组成。这些指令组合在一起形成基本块，每个基本块都以改变程序控制流的指令结束。</p>
<p>下面是个简单的 if-then-else 分支：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ir 中，控制流是通过在基本块之间跳转实现的。这些基本块包含不改变控制流的指令序列。每个基本块都以改变程序控制流的指令结束。最常见的分支指令是 br。br 可以带上条件，然后它实现了一个简单的 if-then-else 。如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br i1 %cond, label %iftrue, label %iffalse</span><br></pre></td></tr></table></figure></p>
<p>br 也可以实现无条件跳转到某个目的地：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br label %dest</span><br></pre></td></tr></table></figure></p>
<p>前面的 c 函数对应的 ir 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval = alloca i32, align 4</span><br><span class="line">  %0 = icmp sgt i32 %a, %b</span><br><span class="line">  br i1 %0, label %btrue, label %bfalse</span><br><span class="line"></span><br><span class="line">btrue:                                      ; preds = %2</span><br><span class="line">  store i32 %a, i32* %retval, align 4</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">bfalse:                                     ; preds = %2</span><br><span class="line">  store i32 %b, i32* %retval, align 4</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:                                     ; preds = %btrue, %bfalse</span><br><span class="line">  %1 = load i32, i32* %retval, align 4</span><br><span class="line">  ret i32 %1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上代码所示，共有4个基本块，第一个是函数入口，使用 alloca 在堆栈上分配空间，用作较大的临时存储，然后使用 icmp 指令比较两个参数 %a 和 %b。结果是一个布尔标志 i1，将其用于 br 指令的条件。然后根据所采用的分支，将 %a 或 %b 存储到临时 %retval 变量中。每个分支都以无条件分支到最后一个基本块 %end 结束。来自 %retval 的值被加载并返回。</p>
<p>通过 opt -dot-cfg input.ll 可以获得 CFG 流程图。</p>
<p>select 指令可以进行更高级别优化，不生成分支，缩短代码，比如上面的 ir 代码优化后为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">  %1 = icmp sgt i32 %a, %b</span><br><span class="line">  %2 = select i1 %1, i32 %a, i32 %b</span><br><span class="line">  ret i32 %2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="静态单一赋值表（SSA-Form）和-PHI"><a href="#静态单一赋值表（SSA-Form）和-PHI" class="headerlink" title="静态单一赋值表（SSA Form）和 PHI"></a>静态单一赋值表（SSA Form）和 PHI</h5><p>下面是一个 c 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的 llvm ir 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %retval = alloca i32, align 4</span><br><span class="line">  %0 = icmp sgt i32 %a, %b</span><br><span class="line">  br i1 %0, label %btrue, label %bfalse</span><br><span class="line"></span><br><span class="line">btrue:                                      ; preds = %2</span><br><span class="line">  store i32 %a, i32* %retval, align 4</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">bfalse:                                     ; preds = %2</span><br><span class="line">  store i32 %b, i32* %retval, align 4</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:                                     ; preds = %btrue, %bfalse</span><br><span class="line">  %1 = load i32, i32* %retval, align 4</span><br><span class="line">  ret i32 %1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 max 函数使用 alloc 在堆栈上分配空间，其中存储了较大的值。在一个分支中，%a 被存储，而在另一个分支中，%b 被存储到堆栈分配的内存中。尽可能避免使用内存 load/store 操作，而是更多的使用寄存器。所以按下面方式来写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %0 = icmp sgt i32 %a, %b</span><br><span class="line">  br i1 %0, label %btrue, label %bfalse</span><br><span class="line"></span><br><span class="line">btrue:</span><br><span class="line">  %retval = %a</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">bfalse:</span><br><span class="line">  %retval = %b</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  ret i32 %retval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这不是有效的 LLVM IR，因为 LLVM IR 是静态单已分配形式，也就是 SSA。SSA 形式要求每个变量只分配一次。SSA 形式支持并简化了大量的编译器优化，并且是命令式编程语言解释器中中间表示的实际上的标准。</p>
<p>那怎么用 SSA 形式 LLVM IR 实现上述代码？答案是神奇的 phi 指令。phi 指令以 SSA 理论中使用的 φ 函数命名。这个函数会根据控制流神奇的选择正确的值。在 LLVM 中，你必须手动指定值的名称和前一个基本块。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">end:</span><br><span class="line">  %retval = phi i32 [%a, %btrue], [%b, %bfalse]</span><br></pre></td></tr></table></figure></p>
<p>这里我们指示 phi 指令在前一个基本块为 %btrue 时选择 %a。如果之前的基本块是 %bfalse，那么将使用 %b。然后将该值分配给一个新变量 %retval。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define i32 @max(i32 %a, i32 %b) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %0 = icmp sgt i32 %a, %b</span><br><span class="line">  br i1 %0, label %btrue, label %bfalse</span><br><span class="line"></span><br><span class="line">btrue:                                      ; preds = %2</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">bfalse:                                     ; preds = %2</span><br><span class="line">  br label %end</span><br><span class="line"></span><br><span class="line">end:                                     ; preds = %btrue, %bfalse</span><br><span class="line">  %retval = phi i32 [%a, %btrue], [%b, %bfalse]</span><br><span class="line">  ret i32 %retval</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>后端的 PHI</em></p>
<p>让我们看看 @max 函数现在如何映射到实际的机器代码。查看的是 x86 64 位生成的代码，用不同优化级别进行编译。非优化后端命令 llc -O0 -filetype=asm。得到的结果是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">max:                                    # @max</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">    cmpl    %esi, %edi                  # %edi = %a, %esi = %b</span><br><span class="line">    jle     .LBB0_2</span><br><span class="line"># %bb.1:                                # %btrue</span><br><span class="line">    movl    %edi, -4(%rsp)              # mov src, dst</span><br><span class="line">    jmp     .LBB0_3</span><br><span class="line">.LBB0_2:                                # %bfalse</span><br><span class="line">    movl    %esi, -4(%rsp)              # mov src, dst</span><br><span class="line">    jmp     .LBB0_3</span><br><span class="line">.LBB0_3:                                # %end</span><br><span class="line">    movl    -4(%rsp), %eax              # return value in eax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><br>参数 %a 和 %b 分别在 %edi 和 %esi 中传递。我们可以看到编译后端生成的代码使用堆栈来存储更大的值。因此，当我们编写 LLVM IR 时，编译器后端生成的代码并不是我们所想的。原因是编译器后端需要用真机指令来实现 phi 指令。通常这是通过分配给一个寄存器或存储到一个公共堆栈位置来完成的。通常编译器后端将使用堆栈来实现 phi 指令。但是，如果我们在后端使用更多优化，也就是 llc -O1，可以获得更优化的版本：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max:                                    # @max</span><br><span class="line"># %bb.0:                                # %entry</span><br><span class="line">    cmpl    %esi, %edi</span><br><span class="line">    jg      .LBB0_2</span><br><span class="line"># %bb.1:                                # %bfalse</span><br><span class="line">    movl    %esi, %edi</span><br><span class="line">.LBB0_2:                                # %end</span><br><span class="line">    movl    %edi, %eax</span><br><span class="line">    retq</span><br></pre></td></tr></table></figure><br>这里的 phi 函数是通过使用 %edi 寄存器实现的。在一个分支中，%edi 已经包含所需的值，所以什么都没发生。在另一个分支中，%esi 被复制到 %edi。在 %end 基本块中，%edi 包含来自两个分支的所需值。这更像是我们的想法。我们可以看到优化是需要在整个编译管道中的应用的东西。</p>
<h5 id="Lambda-函数"><a href="#Lambda-函数" class="headerlink" title="Lambda 函数"></a>Lambda 函数</h5><p>lambda 函数是一个匿名函数，它可以自由引用包含函数中的局部变量，也包括参数变量。Lambda 的实现和 Pascal 的嵌套函数一样，只是编译器负责为 lambda 函数生成内部名称。有几种不同的方法可以实现 lambda 函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> function = [a](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> x + a; &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">function</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的问题是 lambda 函数引用了调用者的一个局部变量，即 a，即使 lambda 函数是它自己的函数。这可以通过将局部变量作为隐式参数传递给 lambda 函数来轻松解决：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define internal i32 @lambda(i32 %a, i32 %x) &#123;</span><br><span class="line"> %1 = add i32 %a, %x</span><br><span class="line"> ret i32 %1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @foo(i32 %a) &#123;</span><br><span class="line"> %1 = call i32 @lambda(i32 %a, i32 10)</span><br><span class="line"> ret i32 %1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者，如果 lambda 函数使用多个变量，你可以将他们包装在一个结构中，然后将指针传递给 lambda 函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">integer_parse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c = <span class="built_in">integer_parse</span>();</span><br><span class="line">  <span class="keyword">auto</span> function = [a, b, c](<span class="keyword">int</span> x) &#123; <span class="built_in"><span class="keyword">return</span></span> (a + b - c) * x; &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">function</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应 IR 是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;lambda_func_1_cleaned.ll&#x27;</span><br><span class="line">source_filename = &quot;lambda_func_1_cleaned.ll&quot;</span><br><span class="line">target datalayout = &quot;e-m:e-i64:64-f80:128-n8:16:32:64-S128&quot;</span><br><span class="line">target triple = &quot;x86_64-unknown-linux-gnu&quot;</span><br><span class="line"></span><br><span class="line">%lambda_args = type &#123; i32, i32, i32 &#125;</span><br><span class="line"></span><br><span class="line">declare i32 @integer_parse()</span><br><span class="line"></span><br><span class="line">define i32 @lambda(%lambda_args* %args, i32 %x) &#123;</span><br><span class="line">  %1 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 0</span><br><span class="line">  %a = load i32, i32* %1</span><br><span class="line">  %2 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 1</span><br><span class="line">  %b = load i32, i32* %2</span><br><span class="line">  %3 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 2</span><br><span class="line">  %c = load i32, i32* %3</span><br><span class="line">  %4 = add i32 %a, %b</span><br><span class="line">  %5 = sub i32 %4, %c</span><br><span class="line">  %6 = mul i32 %5, %x</span><br><span class="line">  ret i32 %6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @foo(i32 %a, i32 %b) &#123;</span><br><span class="line">  %args = alloca %lambda_args</span><br><span class="line">  %1 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 0</span><br><span class="line">  store i32 %a, i32* %1</span><br><span class="line">  %2 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 1</span><br><span class="line">  store i32 %b, i32* %2</span><br><span class="line">  %c = call i32 @integer_parse()</span><br><span class="line">  %3 = getelementptr %lambda_args, %lambda_args* %args, i32 0, i32 2</span><br><span class="line">  store i32 %c, i32* %3</span><br><span class="line">  %4 = call i32 @lambda(%lambda_args* %args, i32 10)</span><br><span class="line">  ret i32 %4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然，这个主题有一些可能的变化：</p>
<ul>
<li>你可以将所有隐式作为参数参数当成参数来传递。</li>
<li>你可以将结构中所有隐式参数作为显示参数传递。</li>
<li>你可以传入一个指向调用者帧的指针，并让 lambda 函数从输入帧中提取参数和局部变量。</li>
</ul>
<h5 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器 Generators"></a>生成器 Generators</h5><p>生成器是一个函数，它以这样的一种方式重复生成一个值，使函数的状态在函数的重复调用中保持不变，包括函数在生产值时的局部偏移量。</p>
<p>实现生成器最直接的方法就是将其所有状态变量，包括参数、局部变量和返回值都包装到一个 ad-hoc 结构中，然后将该结构的地址传递给生成器。</p>
<p>某种程度上说，你需要在每次调用时跟踪你正在执行的生成器是哪个块。这可以通过多种方式完成。我们在这展示的方式是使用 LLVM 的 blockaddress 指令来保存下一个应该执行的本地代码块的地址。其它实现使用简单的状态变量，然后根据状态变量的值进行类似开关的调度。在这两种情况下，最终结果是相同的，也就是为生成器中的每个本地块执行不同的代码块。</p>
<p>重要的是将迭代器视为一种微线程，每当再次调用迭代器时，它就会恢复。换句话说，我们需要保存迭代器每次通过多远的地址，以便它可以恢复，就好像发生了微观线程切换一样。所以我们在返回指令之后保存指令的地址，这样我们就可以继续运行，就好像我们一开始就没有返回一样。</p>
<p>下面是一段简化的伪代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">generator <span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    yield <span class="number">1</span>;</span><br><span class="line">    yield <span class="number">2</span>;</span><br><span class="line">    yield <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foreach (<span class="keyword">int</span> i in <span class="built_in">foo</span>())</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Value: %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的 IR 如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">%foo_context = type &#123;</span><br><span class="line">    i8*,      ; 0: block (state)</span><br><span class="line">    i32       ; 1: value (result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @foo_setup(%foo_context* %context) nounwind &#123;</span><br><span class="line">    ; set up &#x27;block&#x27;</span><br><span class="line">    %1 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.yield1), i8** %1</span><br><span class="line"></span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; The boolean returned indicates if a result was available or not.</span><br><span class="line">; Once no more results are available, the caller is expected to not call</span><br><span class="line">; the iterator again.</span><br><span class="line">define i1 @foo_yield(%foo_context* %context) nounwind &#123;</span><br><span class="line">    ; dispatch to the active generator block</span><br><span class="line">    %1 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    %2 = load i8** %1</span><br><span class="line">    indirectbr i8* %2, [ label %.yield1, label %.yield2, label %.yield3, label %.done ]</span><br><span class="line"></span><br><span class="line">.yield1:</span><br><span class="line">    ; store the result value (1)</span><br><span class="line">    %3 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    store i32 1, i32* %3</span><br><span class="line"></span><br><span class="line">    ; make &#x27;block&#x27; point to next block to execute</span><br><span class="line">    %4 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.yield2), i8** %4</span><br><span class="line"></span><br><span class="line">    ret i1 1</span><br><span class="line"></span><br><span class="line">.yield2:</span><br><span class="line">    ; store the result value (2)</span><br><span class="line">    %5 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    store i32 2, i32* %5</span><br><span class="line"></span><br><span class="line">    ; make &#x27;block&#x27; point to next block to execute</span><br><span class="line">    %6 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.yield3), i8** %6</span><br><span class="line"></span><br><span class="line">    ret i1 1</span><br><span class="line"></span><br><span class="line">.yield3:</span><br><span class="line">    ; store the result value (3)</span><br><span class="line">    %7 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    store i32 3, i32* %7</span><br><span class="line"></span><br><span class="line">    ; make &#x27;block&#x27; point to next block to execute</span><br><span class="line">    %8 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.done), i8** %8</span><br><span class="line"></span><br><span class="line">    ret i1 1</span><br><span class="line"></span><br><span class="line">.done:</span><br><span class="line">    ret i1 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) nounwind</span><br><span class="line"></span><br><span class="line">@.string = internal constant [11 x i8] c&quot;Value: %d\0A\00&quot;</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    ; allocate and initialize generator context structure</span><br><span class="line">    %context = alloca %foo_context</span><br><span class="line">    call void @foo_setup(%foo_context* %context)</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.head:</span><br><span class="line">    ; foreach (int i in foo())</span><br><span class="line">    %1 = call i1 @foo_yield(%foo_context* %context)</span><br><span class="line">    br i1 %1, label %.body, label %.tail</span><br><span class="line"></span><br><span class="line">.body:</span><br><span class="line">    %2 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    %3 = load i32* %2</span><br><span class="line">    %4 = call i32 (i8*, ...)* @printf(i8* getelementptr([11 x i8]* @.string, i32 0, i32 0), i32 %3)</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.tail:</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个涉及局部变量的稍微复杂的示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">generator <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> after)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = start; index &lt; after; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            yield index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            yield index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foreach (<span class="keyword">int</span> i in <span class="built_in">foo</span>(<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Value: %d\n&quot;</span>, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成 IR 代码为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">%foo_context = type &#123;</span><br><span class="line">    i8*,      ; 0: block (state)</span><br><span class="line">    i32,      ; 1: start (argument)</span><br><span class="line">    i32,      ; 2: after (argument)</span><br><span class="line">    i32,      ; 3: index (local)</span><br><span class="line">    i32       ; 4: value (result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @foo_setup(%foo_context* %context, i32 %start, i32 %after) nounwind &#123;</span><br><span class="line">    ; set up &#x27;block&#x27;</span><br><span class="line">    %1 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.init), i8** %1</span><br><span class="line"></span><br><span class="line">    ; set up &#x27;start&#x27;</span><br><span class="line">    %2 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    store i32 %start, i32* %2</span><br><span class="line"></span><br><span class="line">    ; set up &#x27;after&#x27;</span><br><span class="line">    %3 = getelementptr %foo_context* %context, i32 0, i32 2</span><br><span class="line">    store i32 %after, i32* %3</span><br><span class="line"></span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i1 @foo_yield(%foo_context* %context) nounwind &#123;</span><br><span class="line">    ; dispatch to the active generator block</span><br><span class="line">    %1 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    %2 = load i8** %1</span><br><span class="line">   indirectbr i8* %2, [ label %.init, label %.loop_close, label %.end ]</span><br><span class="line"></span><br><span class="line">.init:</span><br><span class="line">    ; copy argument &#x27;start&#x27; to the local variable &#x27;index&#x27;</span><br><span class="line">    %3 = getelementptr %foo_context* %context, i32 0, i32 1</span><br><span class="line">    %start = load i32* %3</span><br><span class="line">    %4 = getelementptr %foo_context* %context, i32 0, i32 3</span><br><span class="line">    store i32 %start, i32* %4</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.head:</span><br><span class="line">    ; for (; index &lt; after; )</span><br><span class="line">    %5 = getelementptr %foo_context* %context, i32 0, i32 3</span><br><span class="line">    %index = load i32* %5</span><br><span class="line">    %6 = getelementptr %foo_context* %context, i32 0, i32 2</span><br><span class="line">    %after = load i32* %6</span><br><span class="line">    %again = icmp slt i32 %index, %after</span><br><span class="line">    br i1 %again, label %.loop_begin, label %.exit</span><br><span class="line"></span><br><span class="line">.loop_begin:</span><br><span class="line">    %7 = srem i32 %index, 2</span><br><span class="line">    %8 = icmp eq i32 %7, 0</span><br><span class="line">    br i1 %8, label %.even, label %.odd</span><br><span class="line"></span><br><span class="line">.even:</span><br><span class="line">    ; store &#x27;index + 1&#x27; in &#x27;value&#x27;</span><br><span class="line">    %9 = add i32 %index, 1</span><br><span class="line">    %10 = getelementptr %foo_context* %context, i32 0, i32 4</span><br><span class="line">    store i32 %9, i32* %10</span><br><span class="line"></span><br><span class="line">    ; make &#x27;block&#x27; point to the end of the loop (after the yield)</span><br><span class="line">    %11 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.loop_close), i8** %11</span><br><span class="line"></span><br><span class="line">    ret i1 1</span><br><span class="line"></span><br><span class="line">.odd:</span><br><span class="line">    ; store &#x27;index - 1&#x27; in value</span><br><span class="line">    %12 = sub i32 %index, 1</span><br><span class="line">    %13 = getelementptr %foo_context* %context, i32 0, i32 4</span><br><span class="line">    store i32 %12, i32* %13</span><br><span class="line"></span><br><span class="line">    ; make &#x27;block&#x27; point to the end of the loop (after the yield)</span><br><span class="line">    %14 = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.loop_close), i8** %14</span><br><span class="line"></span><br><span class="line">    ret i1 1</span><br><span class="line"></span><br><span class="line">.loop_close:</span><br><span class="line">    ; increment &#x27;index&#x27;</span><br><span class="line">    %15 = getelementptr %foo_context* %context, i32 0, i32 3</span><br><span class="line">    %16 = load i32* %15</span><br><span class="line">    %17 = add i32 %16, 1</span><br><span class="line">    store i32 %17, i32* %15</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.exit:</span><br><span class="line">    ; make &#x27;block&#x27; point to the %.end label</span><br><span class="line">    %x = getelementptr %foo_context* %context, i32 0, i32 0</span><br><span class="line">    store i8* blockaddress(@foo_yield, %.end), i8** %x</span><br><span class="line">    br label %.end</span><br><span class="line"></span><br><span class="line">.end:</span><br><span class="line">    ret i1 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare i32 @printf(i8*, ...) nounwind</span><br><span class="line"></span><br><span class="line">@.string = internal constant [11 x i8] c&quot;Value: %d\0A\00&quot;</span><br><span class="line"></span><br><span class="line">define i32 @main() nounwind &#123;</span><br><span class="line">    ; allocate and initialize generator context structure</span><br><span class="line">    %context = alloca %foo_context</span><br><span class="line">    call void @foo_setup(%foo_context* %context, i32 0, i32 5)</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.head:</span><br><span class="line">    ; foreach (int i in foo(0, 5))</span><br><span class="line">    %1 = call i1 @foo_yield(%foo_context* %context)</span><br><span class="line">    br i1 %1, label %.body, label %.tail</span><br><span class="line"></span><br><span class="line">.body:</span><br><span class="line">    %2 = getelementptr %foo_context* %context, i32 0, i32 4</span><br><span class="line">    %3 = load i32* %2</span><br><span class="line">    %4 = call i32 (i8*, ...)* @printf(i8* getelementptr([11 x i8]* @.string, i32 0, i32 0), i32 %3)</span><br><span class="line">    br label %.head</span><br><span class="line"></span><br><span class="line">.tail:</span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行上述操作的另一种可能方法是为每个状态生成一个 LLVM IR 函数，然后存储一个函数指针。</p>
<p>在上下文结构中，每当需要调用新的状态或函数时都会更新。</p>
<h5 id="面向对象结构"><a href="#面向对象结构" class="headerlink" title="面向对象结构"></a>面向对象结构</h5><p>接下来研究各种面向对象的结构，看怎么映射到 LLVM IR。</p>
<h5 id="类"><a href="#类" class="headerlink" title="类"></a>类</h5><p>一个类只不过是一个结构，它具有一组相关函数，这些函数接受一个隐式的第一个参数，即指向该结构的指针。因此将一个类映射到 LLVM IR 很简单：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>()</span><br><span class="line">    &#123;</span><br><span class="line"> _length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> _length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetLength</span><span class="params">(<span class="keyword">size_t</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> _length = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先将这段代码转换成两个独立的部分：</p>
<ul>
<li>结构定义</li>
<li>方法列表，包括构造函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">; The structure definition for class Foo.</span><br><span class="line">%Foo = type &#123; i32 &#125;</span><br><span class="line"></span><br><span class="line">; The default constructor for class Foo.</span><br><span class="line">define void @Foo_Create_Default(%Foo* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 0</span><br><span class="line">    store i32 0, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; The Foo::GetLength() method.</span><br><span class="line">define i32 @Foo_GetLength(%Foo* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 0</span><br><span class="line">    %2 = load i32, i32* %1</span><br><span class="line">    ret i32 %2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; The Foo::SetLength() method.</span><br><span class="line">define void @Foo_SetLength(%Foo* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 0</span><br><span class="line">    store i32 %value, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们确保调用了构造函数 Foo_Create_Default。</p>
<p>每当创建结构的实例时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%foo = alloca %Foo</span><br><span class="line">call void @Foo_Create_Default(%Foo* %foo)</span><br></pre></td></tr></table></figure>
<h5 id="虚拟方法"><a href="#虚拟方法" class="headerlink" title="虚拟方法"></a>虚拟方法</h5><p>虚方法只不过是编译器控制的函数指针。每个虚方法都记录在 vtable 中，它是给定类所需的所有函数指针的结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">virtal <span class="keyword">int</span> <span class="title">GetLengthTimesTwo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _length * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLength</span><span class="params">(<span class="keyword">size_t</span> value)</span> </span>&#123;</span><br><span class="line">    _length = value;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> _length;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  foo.<span class="built_in">setLength</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> foo.<span class="built_in">GetLengthTimesTwo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这变成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">%Foo_vtable_type = type &#123; i32(%Foo*)* &#125;</span><br><span class="line"></span><br><span class="line">%Foo = type &#123; %Foo_vtable_type*, i32 &#125;</span><br><span class="line"></span><br><span class="line">define i32 @Foo_GetLengthTimesTwo(%Foo* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 1</span><br><span class="line">    %2 = load i32, i32* %1</span><br><span class="line">    %3 = mul i32 %2, 2</span><br><span class="line">    ret i32 %3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Foo_vtable_data = global %Foo_vtable_type &#123;</span><br><span class="line">    i32(%Foo*)* @Foo_GetLengthTimesTwo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @Foo_Create_Default(%Foo* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 0</span><br><span class="line">    store %Foo_vtable_type* @Foo_vtable_data, %Foo_vtable_type** %1</span><br><span class="line">    %2 = getelementptr %Foo, %Foo* %this, i32 0, i32 1</span><br><span class="line">    store i32 0, i32* %2</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @Foo_SetLength(%Foo* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %this, i32 0, i32 1</span><br><span class="line">    store i32 %value, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @main(i32 %argc, i8** %argv) nounwind &#123;</span><br><span class="line">    %foo = alloca %Foo</span><br><span class="line">    call void @Foo_Create_Default(%Foo* %foo)</span><br><span class="line">    call void @Foo_SetLength(%Foo* %foo, i32 4)</span><br><span class="line">    %1 = getelementptr %Foo, %Foo* %foo, i32 0, i32 0</span><br><span class="line">    %2 = load %Foo_vtable_type*, %Foo_vtable_type** %1</span><br><span class="line">    %3 = getelementptr %Foo_vtable_type, %Foo_vtable_type* %2, i32 0, i32 0</span><br><span class="line">    %4 = load i32(%Foo*)*, i32(%Foo*)** %3</span><br><span class="line">    %5 = call i32 %4(%Foo* %foo)</span><br><span class="line">    ret i32 %5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意，一些 C++ 编译器将 _vtable 存储在结构中的负偏移量处，这样 memeset(this, 0, sizeof(*this))之类的东西就可以工作，即使在 OOP 上下文中应始终避免使用此类命令。</p>
<p><em>Rust 特征和 VTable</em><br>与 C++ 相比，Rust 确实具有完全不同的对象模型。但是，当涉及到动态调度的低级细节时，他们非常相似。我们将探讨 rust 文档中的一个示例，以及 rustc 编译器发出什么样的 llvm IR。rust 和 C++ 都使用虚拟方法进行动态调度。但是，在 rust 中，高级语言中没有虚拟方法之类的东西。相反，我们可以为我们的数据类型实现 trait，然后实现一个接口，该接口接受所有实现 trait 的数据类型并动态分派到正确的 trait 实现，也就是下面示例中 dyn Trait 语法。</p>
<p>编译器必须在运行时动态决定使用哪个函数。编译器只知道存储在 components 向量中的对象确实满足特征 Draw。作为对不太熟悉 rust 的人的附注：将对象包装在 Box 中本质上是将对象放在堆上，有点类似于 C++ 中的 unique_ptr 并有效地允许我们放置 trait 对象，也就是本例中为 dyn Drawable 在向量中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">; test::Screen::run</span><br><span class="line">; Function Attrs: nonlazybind uwtable</span><br><span class="line">define void @&quot;Screen::run&quot;(%Screen* %self) &#123;</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">;; (omitting the initial prologue and setup code)</span><br><span class="line">;; this is the start of the for loop in Screen::run calling the next method</span><br><span class="line">;; on the iterator for the first time and checking whether it is None (or</span><br><span class="line">;; null in llvm here)</span><br><span class="line">;; %5 contains the pointer to the first component in the vector here</span><br><span class="line">  %6 = icmp eq i64* %5, null</span><br><span class="line">  br i1 %6, label %end, label %forloop</span><br><span class="line"></span><br><span class="line">end:                                              ; preds = %forloop, %start</span><br><span class="line">  ret void</span><br><span class="line"></span><br><span class="line">forloop:                                          ; preds = %start, %forloop</span><br><span class="line">  %7 = phi i64* [ %next_component, %forloop ], [ %5, %start ]</span><br><span class="line">;; here the boxed pointer is retrieved and dereferenced to retrieve the</span><br><span class="line">;; vtable pointer</span><br><span class="line">  %8 = bitcast i64* %7 to &#123;&#125;**</span><br><span class="line">  %self_ptr = load &#123;&#125;*, &#123;&#125;** %8</span><br><span class="line">  %9 = getelementptr inbounds i64, i64* %7, i64 1</span><br><span class="line">  %vtable_ptr = bitcast i64* %9 to void (&#123;&#125;*)***</span><br><span class="line">  %vtable = load void (&#123;&#125;*)**, void (&#123;&#125;*)*** %vtable_ptr</span><br><span class="line">;; 3 is the index into the vtable struct, which refers to the draw implementation for this particular struct</span><br><span class="line">  %trait_method_ptr = getelementptr inbounds void (&#123;&#125;*)*, void (&#123;&#125;*)** %vtable, i64 3</span><br><span class="line">  %trait_method = load void (&#123;&#125;*)*, void (&#123;&#125;*)** %vmethod</span><br><span class="line">;; indirect call to trait method</span><br><span class="line">  call void %trait_method(&#123;&#125;* %self_ptr)</span><br><span class="line"></span><br><span class="line">;; retrieve the next object</span><br><span class="line">  %next_component = call i64* @&quot;&lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::next&quot;(&#123; i64*, i64* &#125;* %iter)</span><br><span class="line">  %14 = icmp eq i64* %next_component, null</span><br><span class="line">  br i1 %14, label %end, label %forloop</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 llvm 模块的全局变量中，我们可以看到如下所示的 vtable。Button 和 SelectBox 都有关联的 vtable。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@vtable.screen = private unnamed_addr constant</span><br><span class="line">  ;; the Type of the constant vtable structure</span><br><span class="line">  &#123; void (%SelectBox*)*, i64, i64, void (%SelectBox*)* &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    ;; first entry is the function to drop the object</span><br><span class="line">    void (%SelectBox*)* @&quot;core::ptr::drop_in_place&lt;test::SelectBox&gt;&quot;,  ;; destructor</span><br><span class="line">    i64 32, ;; size</span><br><span class="line">    i64 8,  ;; alignment</span><br><span class="line">    ;; last in the vtable is the pointer to the SelectBox::draw implementation</span><br><span class="line">    void (%SelectBox*)* @&quot;&lt;test::SelectBox as test::Draw&gt;::draw&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">;; the vtable for Button is structured basically the same</span><br><span class="line">@vtable.button = private unnamed_addr constant</span><br><span class="line">    &#123; void (%Button*)*, i64, i64, void (%Button*)* &#125;</span><br><span class="line">    &#123;</span><br><span class="line"> void (%Button*)* @&quot;core::ptr::drop_in_place&lt;test::Button&gt;&quot;,</span><br><span class="line"> i64 32, i64 8,</span><br><span class="line"> void (%Button*)* @&quot;&lt;test::Button as test::Draw&gt;::draw&quot;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这篇博文 <a target="_blank" rel="noopener" href="https://alschwalm.com/blog/static/2017/03/07/exploring-dynamic-dispatch-in-rust/">Exploring Dynamic Dispatch in Rust</a> 更详细的解释 vtable 和动态调度以及他们在 rust 和 C++ 中的区别。</p>
<h5 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h5><p>单继承非常简单：每个结构体或类在内存中按声明顺序依次排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">SetA</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">_a = value;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">     <span class="keyword">int</span> _a;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">SetB</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">SetA</span>(value);</span><br><span class="line">_b = value;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">     <span class="keyword">int</span> _b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里 a 和 b 将在内存中彼此跟随，因此从一个类继承只是一个简单的问题。</p>
<p>将基类声明为继承类中的第一个成员。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">%Base = type &#123;</span><br><span class="line">    i32         ; &#x27;_a&#x27; in class Base</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @Base_SetA(%Base* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Base, %Base* %this, i32 0, i32 0</span><br><span class="line">    store i32 %value, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%Derived = type &#123;</span><br><span class="line">    i32,        ; &#x27;_a&#x27; from class Base</span><br><span class="line">    i32         ; &#x27;_b&#x27; from class Derived</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @Derived_SetB(%Derived* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = bitcast %Derived* %this to %Base*</span><br><span class="line">    call void @Base_SetA(%Base* %1, i32 %value)</span><br><span class="line">    %2 = getelementptr %Derived, %Derived* %this, i32 0, i32 1</span><br><span class="line">    store i32 %value, i32* %2</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，基类简单的成为派生类的类型声明的普通成员。</p>
<p>然后编译器必须在派生类被引用为其基类时插入适当的类型转换，如上所示，使用 bitcast 运算符。</p>
<h5 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h5><p>多重继承也不是很难，只是在每个派生类内部按顺序排列多个继承的结构，同时考虑到多次继承的数据成员的重复性。</p>
<p>下面的 c++ 代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetA</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> _a = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>:</span> <span class="keyword">public</span> BaseA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetB</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> <span class="built_in">SetA</span>(value);</span><br><span class="line"> _b = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span></span><br><span class="line">    <span class="keyword">public</span> BaseA,</span><br><span class="line">    <span class="keyword">public</span> BaseB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetC</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"> <span class="built_in">SetB</span>(value);</span><br><span class="line"> _c = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Derived now has two &#x27;_a&#x27; members and one &#x27;_b&#x27; member.</span></span><br><span class="line">    <span class="keyword">int</span> _c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>等效 LLVM IR：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">%BaseA = type &#123;</span><br><span class="line">    i32         ; &#x27;_a&#x27; from BaseA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @BaseA_SetA(%BaseA* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %BaseA, %BaseA* %this, i32 0, i32 0</span><br><span class="line">    store i32 %value, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%BaseB = type &#123;</span><br><span class="line">    i32,        ; &#x27;_a&#x27; from BaseA</span><br><span class="line">    i32         ; &#x27;_b&#x27; from BaseB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @BaseB_SetB(%BaseB* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = bitcast %BaseB* %this to %BaseA*</span><br><span class="line">    call void @BaseA_SetA(%BaseA* %1, i32 %value)</span><br><span class="line">    %2 = getelementptr %BaseB, %BaseB* %this, i32 0, i32 1</span><br><span class="line">    store i32 %value, i32* %2</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%Derived = type &#123;</span><br><span class="line">    i32,        ; &#x27;_a&#x27; from BaseA</span><br><span class="line">    i32,        ; &#x27;_a&#x27; from BaseB</span><br><span class="line">    i32,        ; &#x27;_b&#x27; from BaseB</span><br><span class="line">    i32         ; &#x27;_c&#x27; from Derived</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @Derived_SetC(%Derived* %this, i32 %value) nounwind &#123;</span><br><span class="line">    %1 = bitcast %Derived* %this to %BaseB*</span><br><span class="line">    call void @BaseB_SetB(%BaseB* %1, i32 %value)</span><br><span class="line">    %2 = getelementptr %Derived, %Derived* %this, i32 0, i32 2</span><br><span class="line">    store i32 %value, i32* %2</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后，只要将 baseB 作为 BaseB 的实例引用，编译器就会提供所需的类型转换和指针算术。请注意，他所需要的只是从一个类到另一个类的位转换以及及时 getelementptr 的最后一个参数的调整。</p>
<h5 id="虚拟继承"><a href="#虚拟继承" class="headerlink" title="虚拟继承"></a>虚拟继承</h5><p>虚拟继承实际上非常简单，因为它要求将相同的基类合并到一个实例中。比如下面的 c++ 代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseB</span>:</span> <span class="keyword">public</span> BaseA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseC</span>:</span> <span class="keyword">public</span> BaseA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> BaseB,</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> BaseC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Dervied 将只包含一个 BaseA 实例，即使它的继承图规定它应该有两个继承。</p>
<p>结果如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>所以 a 的第二个实例被默认的忽略，因为它会导致 BaseA 的多个实例存在于 Derived 中。</p>
<h5 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h5><p>接口只不过是没有数据成员的基类，其中所有方法都是纯虚拟的，也就是没有主体。因此转化 IR 的方式和将虚拟成员函数转换为 LLVM IR 的方式是一样的。</p>
<h5 id="Boxing-和-Unboxing"><a href="#Boxing-和-Unboxing" class="headerlink" title="Boxing 和 Unboxing"></a>Boxing 和 Unboxing</h5><p>Boxing 是将非对象原始值转换成对象的过程。创建一个包装类，你可以用非对象值实例化和初始化它。</p>
<p>Unboxing 是 boxing 的逆过程。你通过从 box 对象中检索 box 的值，将一个完整的对象降级为一个纯标量值。</p>
<p>下面是 Boxing 和 Unboxing 对应的 IR 代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Boxee = global i32 17</span><br><span class="line"></span><br><span class="line">%Integer = type &#123; i32 &#125;</span><br><span class="line"></span><br><span class="line">define void @Integer_Create(%Integer* %this, i32 %value) nounwind &#123;</span><br><span class="line">    ; you might set up a vtable and associated virtual methods here</span><br><span class="line">    %1 = getelementptr %Integer, %Integer* %this, i32 0, i32 0</span><br><span class="line">    store i32 %value, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @Integer_GetValue(%Integer* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %Integer, %Integer* %this, i32 0, i32 0</span><br><span class="line">    %2 = load i32, i32* %1</span><br><span class="line">    ret i32 %2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define i32 @main() nounwind &#123;</span><br><span class="line">    ; box @Boxee in an instance of %Integer</span><br><span class="line">    %1 = load i32, i32* @Boxee</span><br><span class="line">    %2 = alloca %Integer</span><br><span class="line">    call void @Integer_Create(%Integer* %2, i32 %1)</span><br><span class="line"></span><br><span class="line">    ; unbox @Boxee from an instance of %Integer</span><br><span class="line">    %3 = call i32 @Integer_GetValue(%Integer* %2)</span><br><span class="line"></span><br><span class="line">    ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="New-运算符"><a href="#New-运算符" class="headerlink" title="New 运算符"></a>New 运算符</h5><p>new 运算符通常只不过是 C malloc 函数的类型安全版本，在 C++ 的某些实现中，它们可以互换调用，而不会导致看不见或不需要的副作用。</p>
<p><em>实例的 new 操作符</em><br>new X 对应的 llvm ir 代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">declare i8* @malloc(i32) nounwind</span><br><span class="line"></span><br><span class="line">%X = type &#123; i8 &#125;</span><br><span class="line"></span><br><span class="line">define void @X_Create_Default(%X* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %X, %X* %this, i32 0, i32 0</span><br><span class="line">    store i8 0, i8* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %1 = call i8* @malloc(i32 1)</span><br><span class="line">    %2 = bitcast i8* %1 to %X*</span><br><span class="line">    call void @X_Create_Default(%X* %2)</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>new X(Y,Z) 形式的调用是相同的，除了 X 和 Z 作为参数传递给构造函数。</p>
<p><em>数组的 new 运算符</em><br>代码 new X[100] 被映射到一个循环中，一次初始化每个数组元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">declare i8* @malloc(i32) nounwind</span><br><span class="line"></span><br><span class="line">%X = type &#123; i32 &#125;</span><br><span class="line"></span><br><span class="line">define void @X_Create_Default(%X* %this) nounwind &#123;</span><br><span class="line">    %1 = getelementptr %X, %X* %this, i32 0, i32 0</span><br><span class="line">    store i32 0, i32* %1</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define void @main() nounwind &#123;</span><br><span class="line">    %n = alloca i32                  ; %n = ptr to the number of elements in the array</span><br><span class="line">    store i32 100, i32* %n</span><br><span class="line"></span><br><span class="line">    %i = alloca i32                  ; %i = ptr to the loop index into the array</span><br><span class="line">    store i32 0, i32* %i</span><br><span class="line"></span><br><span class="line">    %1 = load i32, i32* %n           ; %1 = *%n</span><br><span class="line">    %2 = mul i32 %1, 4               ; %2 = %1 * sizeof(X)</span><br><span class="line">    %3 = call i8* @malloc(i32 %2)    ; %3 = malloc(100 * sizeof(X))</span><br><span class="line">    %4 = bitcast i8* %3 to %X*       ; %4 = (X*) %3</span><br><span class="line">    br label %.loop_head</span><br><span class="line"></span><br><span class="line">.loop_head:                         ; for (; %i &lt; %n; %i++)</span><br><span class="line">    %5 = load i32, i32* %i</span><br><span class="line">    %6 = load i32, i32* %n</span><br><span class="line">    %7 = icmp slt i32 %5, %6</span><br><span class="line">    br i1 %7, label %.loop_body, label %.loop_tail</span><br><span class="line"></span><br><span class="line">.loop_body:</span><br><span class="line">    %8 = getelementptr %X, %X* %4, i32 %5</span><br><span class="line">    call void @X_Create_Default(%X* %8)</span><br><span class="line"></span><br><span class="line">    %9 = add i32 %5, 1</span><br><span class="line">    store i32 %9, i32* %i</span><br><span class="line"></span><br><span class="line">    br label %.loop_head</span><br><span class="line"></span><br><span class="line">.loop_tail:</span><br><span class="line">    ret void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="C-调用-LLVM-接口"><a href="#C-调用-LLVM-接口" class="headerlink" title="C 调用 LLVM 接口"></a>C 调用 LLVM 接口</h3><p>项目在：<a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/CLLVMCase">CLLVMCase</a></p>
<p>这是代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int sum(int a, int b) &#123;</span></span><br><span class="line"><span class="comment">    return a + b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">,*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">csum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LLVMModuleRef <span class="keyword">module</span> = LLVMModuleCreateWithName(<span class="string">&quot;sum_module&quot;</span>);</span><br><span class="line">    LLVMTypeRef param_types[] = &#123;LLVMInt32Type(), LLVMInt32Type()&#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 函数参数依次是函数的类型，参数类型向量，函数数，表示函数是否可变的布尔值。</span></span><br><span class="line">    LLVMTypeRef ftype = LLVMFunctionType(LLVMInt32Type(), param_types, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    LLVMValueRef sum = LLVMAddFunction(<span class="keyword">module</span>, <span class="string">&quot;sum&quot;</span>, ftype);</span><br><span class="line">  </span><br><span class="line">    LLVMBasicBlockRef entry = LLVMAppendBasicBlock(sum, <span class="string">&quot;entry&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    LLVMBuilderRef builder = LLVMCreateBuilder();</span><br><span class="line">    LLVMPositionBuilderAtEnd(builder, entry);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// IR 的表现形式有三种，一种是内存中的对象集，一种是文本语言，比如汇编，一种是二进制编码字节 bitcode。</span></span><br><span class="line">  </span><br><span class="line">    LLVMValueRef tmp = LLVMBuildAdd(builder, LLVMGetParam(sum, <span class="number">0</span>), LLVMGetParam(sum, <span class="number">1</span>), <span class="string">&quot;tmp&quot;</span>);</span><br><span class="line">    LLVMBuildRet(builder, tmp);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">char</span> *error = <span class="literal">NULL</span>;</span><br><span class="line">    LLVMVerifyModule(<span class="keyword">module</span>, LLVMAbortProcessAction, &amp;error);</span><br><span class="line">    LLVMDisposeMessage(error);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 可执行引擎，如果支持 JIT 就用它，否则用 Interpreter。</span></span><br><span class="line">    LLVMExecutionEngineRef engine;</span><br><span class="line">    error = <span class="literal">NULL</span>;</span><br><span class="line">    LLVMLinkInMCJIT();</span><br><span class="line">    LLVMInitializeNativeTarget();</span><br><span class="line">    <span class="keyword">if</span> (LLVMCreateExecutionEngineForModule(&amp;engine, <span class="keyword">module</span>, &amp;error) != <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create execution engine: %s\n&quot;</span>, error);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line"> LLVMDisposeMessage(error);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="number">6</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// LLVM 提供了工厂函数来创建值，这些值可以被传递给函数。</span></span><br><span class="line">    LLVMGenericValueRef args[] = &#123;LLVMCreateGenericValueOfInt(LLVMInt32Type(), x, <span class="number">0</span>), LLVMCreateGenericValueOfInt(LLVMInt32Type(), y, <span class="number">0</span>)&#125;;</span><br><span class="line">  </span><br><span class="line">    LLVMInitializeNativeAsmPrinter();</span><br><span class="line">    LLVMInitializeNativeAsmParser();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    LLVMGenericValueRef result = LLVMRunFunction(engine, sum, <span class="number">2</span>, args);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, LLVMGenericValueToInt(result, <span class="number">0</span>));</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 生成 bitcode 文件</span></span><br><span class="line">    <span class="keyword">if</span> (LLVMWriteBitcodeToFile(<span class="keyword">module</span>, <span class="string">&quot;sum.bc&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not write bitcode to file\n&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    LLVMDisposeBuilder(builder);</span><br><span class="line">    LLVMDisposeExecutionEngine(engine);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Swift-调用-LLVM-接口"><a href="#Swift-调用-LLVM-接口" class="headerlink" title="Swift 调用 LLVM 接口"></a>Swift 调用 LLVM 接口</h3><p>llvm 的接口还可以通过 swift 来调用。</p>
<p>先创建一个 module.modulemap 文件，创建 LLVMC.h 和 LLVMC.c 文件，自动生成 SwiftLLVMCase-Bridging-Header.h。设置 header search paths 为 llvm 所在路径 ~/usr/local/opt/llvm/include~ ，library search paths 设置为 ~/usr/local/opt/llvm/lib~ 。将 ~/usr/local/opt/llvm/lib/libLLVM.dylib~ 加到 Linked Frameworks and Libraries 里。</p>
<p>module.modulemap 内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> llvm [extern_c] &#123;</span><br><span class="line">    header <span class="string">&quot;LLVMC.h&quot;</span></span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LLVMC.h 里设置要用到的 llvm 的头文件，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVMC_h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LLVMC_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Analysis.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitReader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/BitWriter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Core.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Disassembler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/ExecutionEngine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/IRReader.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Initialization.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Linker.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Object.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Support.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Target.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/TargetMachine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Transforms/IPO.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Transforms/PassManagerBuilder.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Transforms/Scalar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/Transforms/Vectorize.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;llvm-c/lto.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* LLVMC_h */</span></span></span><br></pre></td></tr></table></figure></p>
<p>在 swift 中写如下代码试试</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> llvm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hiIR</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> module <span class="operator">=</span> <span class="type">LLVMModuleCreateWithName</span>(<span class="string">&quot;HiModule&quot;</span>)</span><br><span class="line">    <span class="type">LLVMDumpModule</span>(module)</span><br><span class="line">    <span class="type">LLVMDisposeModule</span>(module)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hiIR()</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;HiModule&#x27;</span><br><span class="line">source_filename = &quot;HiModule&quot;</span><br></pre></td></tr></table></figure></p>
<p>下面一个简单的 c 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 llvm 的接口写对应的 IR 代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cSum</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="type">Module</span>(name: <span class="string">&quot;CSum&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bd <span class="operator">=</span> <span class="type">IRBuilder</span>(module: m)</span><br><span class="line">    <span class="keyword">let</span> f1 <span class="operator">=</span> bd.addFunction(<span class="string">&quot;sum&quot;</span>, type: <span class="type">FunctionType</span>([<span class="type">IntType</span>.int32, <span class="type">IntType</span>.int32], <span class="type">IntType</span>.int32))</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加基本块</span></span><br><span class="line">    <span class="keyword">let</span> entryBB <span class="operator">=</span> f1.appendBasicBlock(named: <span class="string">&quot;entry&quot;</span>)</span><br><span class="line">    bd.positionAtEnd(of: entryBB)</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> a <span class="operator">=</span> f1.parameters[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> b <span class="operator">=</span> f1.parameters[<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">let</span> tmp <span class="operator">=</span> bd.buildAdd(a, b)</span><br><span class="line">    bd.buildRet(tmp)</span><br><span class="line">  </span><br><span class="line">    m.dump()</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dump 出对应 IR 如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;CSum&#x27;</span><br><span class="line">source_filename = &quot;CSum&quot;</span><br><span class="line"></span><br><span class="line">define i32 @sum(i32 %0, i32 %1) &#123;</span><br><span class="line">entry:</span><br><span class="line">%2 = add i32 %0, %1</span><br><span class="line">ret i32 %2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于控制流函数，比如下面的 swift 函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">giveMeNumber</span>(<span class="keyword">_</span> <span class="params">isBig</span> : <span class="type">Bool</span>)</span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> re : <span class="type">Int</span></span><br><span class="line">    <span class="keyword">if</span> <span class="operator">!</span>isBig &#123;</span><br><span class="line"> <span class="comment">// the fibonacci series (sort of)</span></span><br><span class="line"> re <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">// the fibonacci series (sort of) backwards</span></span><br><span class="line"> re <span class="operator">=</span> <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 llvm 接口编写 IR，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">controlFlow</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> m <span class="operator">=</span> <span class="type">Module</span>(name: <span class="string">&quot;CF&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> bd <span class="operator">=</span> <span class="type">IRBuilder</span>(module: m)</span><br><span class="line">    <span class="keyword">let</span> f1 <span class="operator">=</span> bd.addFunction(<span class="string">&quot;calculateFibs&quot;</span>, type: <span class="type">FunctionType</span>([<span class="type">IntType</span>.int1], <span class="type">FloatType</span>.double))</span><br><span class="line">    <span class="keyword">let</span> entryBB <span class="operator">=</span> f1.appendBasicBlock(named: <span class="string">&quot;entry&quot;</span>)</span><br><span class="line">    bd.positionAtEnd(of: entryBB)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 给本地变量分配空间 let retVal : Double</span></span><br><span class="line">    <span class="keyword">let</span> local <span class="operator">=</span> bd.buildAlloca(type: <span class="type">FloatType</span>.double, name: <span class="string">&quot;local&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 条件比较 if !backward</span></span><br><span class="line">    <span class="keyword">let</span> test <span class="operator">=</span> bd.buildICmp(f1.parameters[<span class="number">0</span>], <span class="type">IntType</span>.int1.zero(), .equal)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 创建 block</span></span><br><span class="line">    <span class="keyword">let</span> thenBB <span class="operator">=</span> f1.appendBasicBlock(named: <span class="string">&quot;then&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> elseBB <span class="operator">=</span> f1.appendBasicBlock(named: <span class="string">&quot;else&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> mergeBB <span class="operator">=</span> f1.appendBasicBlock(named: <span class="string">&quot;merge&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    bd.buildCondBr(condition: test, then: thenBB, else: elseBB)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 指到 then block</span></span><br><span class="line">    bd.positionAtEnd(of: thenBB)</span><br><span class="line">    <span class="keyword">let</span> thenVal <span class="operator">=</span> <span class="type">FloatType</span>.double.constant(<span class="number">1</span><span class="operator">/</span><span class="number">89</span>)</span><br><span class="line">    bd.buildBr(mergeBB) <span class="comment">// 到 merge block</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 指到 else block</span></span><br><span class="line">    bd.positionAtEnd(of: elseBB)</span><br><span class="line">    <span class="keyword">let</span> elseVal <span class="operator">=</span> <span class="type">FloatType</span>.double.constant(<span class="number">1</span><span class="operator">/</span><span class="number">109</span>)</span><br><span class="line">    bd.buildBr(mergeBB) <span class="comment">// 到 merge block</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 指到 merge block</span></span><br><span class="line">    bd.positionAtEnd(of: mergeBB)</span><br><span class="line">    <span class="keyword">let</span> phi <span class="operator">=</span> bd.buildPhi(<span class="type">FloatType</span>.double, name: <span class="string">&quot;phi_example&quot;</span>)</span><br><span class="line">    phi.addIncoming([</span><br><span class="line"> (thenVal, thenBB),</span><br><span class="line"> (elseVal, elseBB)</span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">// 赋值给本地变量</span></span><br><span class="line">    bd.buildStore(phi, to: local)</span><br><span class="line">    <span class="keyword">let</span> ret <span class="operator">=</span> bd.buildLoad(local, type: <span class="type">FloatType</span>.double, name: <span class="string">&quot;ret&quot;</span>)</span><br><span class="line">    bd.buildRet(ret)</span><br><span class="line">  </span><br><span class="line">    m.dump()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出对应 IR 代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; ModuleID = &#x27;CF&#x27;</span><br><span class="line">source_filename = &quot;CF&quot;</span><br><span class="line"></span><br><span class="line">define double @giveMeNumber(i1 %0) &#123;</span><br><span class="line">entry:</span><br><span class="line">  %local = alloca i32, align 4</span><br><span class="line">  %1 = icmp eq i1 %0, false</span><br><span class="line">  br i1 %1, label %then, label %else</span><br><span class="line"></span><br><span class="line">then:                                             ; preds = %entry</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line">else:                                             ; preds = %entry</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line">merge:                                            ; preds = %else, %then</span><br><span class="line">  %phi_example = phi i32 [ 3, %then ], [ 4, %else ]</span><br><span class="line">  store i32 %phi_example, i32* %local, align 4</span><br><span class="line">  %ret = load i32, i32* %local, align 4</span><br><span class="line">  ret i32 %ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有完整代码 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/SwiftLLVMCase">SwiftLLVMCase</a>。</p>
<h2 id="解释执行-bitcode（IR）"><a href="#解释执行-bitcode（IR）" class="headerlink" title="解释执行 bitcode（IR）"></a>解释执行 bitcode（IR）</h2><p>IR 的表现形式有三种，一种是内存中的对象集，一种是文本语言，一种是二进制编码字节 bitcode。</p>
<p>对于 Intel 芯片可以通过 <a target="_blank" rel="noopener" href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-dynamic-binary-instrumentation-tool.html">Pin</a>，arm 架构可以用 <a target="_blank" rel="noopener" href="https://github.com/DynamoRIO/dynamorio">DynamoRIO</a>，目前 DynamoRIO 只支持 Window、Linux 和 Android 系统，对 macOS 的支持还在进行中。另一种方式是通过基于 llvm 的 interpreter 开发来实现解释执行 bitcode，llvm 用很多 C++ 的接口在内存中操作，将可读的文本文件解析到内存中，编译过程文本的 IR 不会生成，只会生成一种紧凑的二进制表示，也就是 bitcode。下面具体说下怎么做。</p>
<p>先构建一个支持 libffi 的 llvm。编译 llvm 源码时加上 libffi 的选项来打开 DLLVM_ENABLE_FFI 的选项打开 libffi，编译命令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -G Ninja -DLLVM_ENABLE_FFI:BOOL=ON ../llvm</span><br></pre></td></tr></table></figure></p>
<p>创建一个项目。cmake 文件里注意设置自己的编译生成的 llvm 路径，还有 llvm 源码路径，设置这个路径主要是为了用安装 llvm 时没有包含的 ExecutionEngine/Interpreter/Interpreter.h 头文件。</p>
<p>实现方式是通过访问 llvm 的 ExcutionEngine 进行 IR 指令解释执行。声明一个可访问 ExcutionEngine 内部的类 PInterpreter，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 public 访问内部</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PInterpreter</span> :</span> <span class="keyword">public</span> llvm::ExecutionEngine,</span><br><span class="line">       <span class="keyword">public</span> llvm::InstVisitor&lt;llvm::Interpreter&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    llvm::GenericValue ExitValue;</span><br><span class="line">    llvm::DataLayout TD;</span><br><span class="line">    llvm::IntrinsicLowering *IL;</span><br><span class="line">    std::vector&lt;llvm::ExecutionContext&gt; ECStack;</span><br><span class="line">    std::vector&lt;llvm::Function*&gt; AtExitHandlers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后声明要用的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MInterpreter</span> :</span> <span class="keyword">public</span> llvm::ExecutionEngine &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    llvm::Interpreter *interp;</span><br><span class="line">    PInterpreter *pItp;</span><br><span class="line">    llvm::Module *<span class="keyword">module</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MInterpreter</span><span class="params">(llvm::Module *M)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MInterpreter</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(llvm::Instruction &amp;I)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 入口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">runMain</span><span class="params">(std::vector&lt;std::string&gt; args,</span></span></span><br><span class="line"><span class="params"><span class="function">	  <span class="keyword">char</span> * <span class="keyword">const</span> *envp = <span class="number">0</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遵循 ExecutionEngine 接口</span></span><br><span class="line">    <span class="function">llvm::GenericValue <span class="title">runFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> llvm::Function *F,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">const</span> std::vector&lt;llvm::GenericValue&gt; &amp;ArgValues</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">getPointerToNamedFunction</span><span class="params">(<span class="keyword">const</span> std::string &amp;Name,</span></span></span><br><span class="line"><span class="params"><span class="function">		      <span class="keyword">bool</span> AbortOnFailure = <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">recompileAndRelinkFunction</span><span class="params">(llvm::Function *F)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">freeMachineCodeForFunction</span><span class="params">(llvm::Function *F)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">getPointerToFunction</span><span class="params">(llvm::Function *F)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">getPointerToBasicBlock</span><span class="params">(llvm::BasicBlock *BB)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上面代码所示，因为要执行 IR，所以用到获取 IR 的函数和基本块地址的方法，getPointerToFunction 和 getPointerToBasicBlock。最后再执行指令时，先打印出指令，然后进行执行，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MingInterpreter</span> :</span> <span class="keyword">public</span> MInterpreter &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MingInterpreter</span>(Module *M) : <span class="built_in">MInterpreter</span>(M) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Instruction &amp;I)</span> </span>&#123;</span><br><span class="line"> I.<span class="built_in">print</span>(<span class="built_in">errs</span>());</span><br><span class="line"> MInterpreter::<span class="built_in">execute</span>(I);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完整代码参看 <a target="_blank" rel="noopener" href="https://github.com/ming1016/DaiMingCreationToolbox/tree/main/Project/UseCompiler/MingInterpreter">MingInterpreter</a>。</p>
<p>项目是基于 c 语言，可以使用 llvm include 里的 llvm-c/ExecutionEngine.h 接口头文件，使用 c 来编写。OC 和 Swift 项目还需要根据各自语言特性进行开发完善解释功能。</p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>原文作者：<a href="http://ming1016.github.io">戴铭</a>
            <p>原文链接：<a href="http://ming1016.github.io/2022/06/10/use-llvm/">http://ming1016.github.io/2022/06/10/use-llvm/</a>
            <p>发表日期：<a href="http://ming1016.github.io/2022/06/10/use-llvm/">June 10th 2022, 5:04:31 pm</a>
            <p>更新日期：<a href="http://ming1016.github.io/2022/06/10/use-llvm/">June 10th 2022, 5:04:23 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2022/06/10/wwdc22-notes/" title="WWDC22 笔记">
                    <div class="prevTitle">WWDC22 笔记</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:ming1016@foxmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/ming1016" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/wechat-qcode.jpeg" />
                </span>
            
        
    
        
    
        
    
        
            
                <a href="https://weibo.com/allstarming" class="iconfont-archer weibo" target="_blank" title=weibo></a>
            
        
    
        
    
        
    
        
    
        
            
                <a href="https://twitter.com/daiming_cn" class="iconfont-archer twitter" target="_blank" title=twitter></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
        <div class="website-approve">
            
                <span id="icp-approve" class="icp-approve">
                    <a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备17011999号</a>
                </span>
            
            
                
                <img class="beian-img" src="/assets/beian.png" />
                <span id="beian-approve" class="beian-approve">
                    <a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=7011999" target="_blank">京公网安备 7011999号</a>
                </span>
            
        </div>
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%96%B0%E9%99%88%E4%BB%A3%E8%B0%A2"><span class="toc-number">1.</span> <span class="toc-text">代码新陈代谢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E6%80%BB%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">方案总体介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%8E%B0%E6%9C%89%E6%96%B9%E6%A1%88%E5%92%8C%E5%85%B6%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">1.1.1.</span> <span class="toc-text">一些现有方案和其不可用的地方</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#gcov"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">gcov</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E5%8F%AF%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4%E7%9A%84-Pass"><span class="toc-number">1.1.2.</span> <span class="toc-text">自制可插入指令的 Pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">1.2.</span> <span class="toc-text">生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode-%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A"><span class="toc-number">1.3.</span> <span class="toc-text">Xcode 配置生成代码覆盖率报告</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.</span> <span class="toc-text">Fuzzing 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SanitizerCoverage-%E6%8F%92%E6%A1%A9%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-1"><span class="toc-number">1.5.</span> <span class="toc-text">SanitizerCoverage 插桩回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-LLVM"><span class="toc-number">1.6.</span> <span class="toc-text">安装 LLVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%88%B6-Pass"><span class="toc-number">1.7.</span> <span class="toc-text">自制 Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pass-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">Pass 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%88%B6%E6%8F%92%E5%85%A5%E6%8C%87%E4%BB%A4-pass"><span class="toc-number">1.7.2.</span> <span class="toc-text">自制插入指令 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E8%87%AA%E5%88%B6-pass"><span class="toc-number">1.7.3.</span> <span class="toc-text">更多自制 pass</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IR"><span class="toc-number">1.7.4.</span> <span class="toc-text">IR</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IR-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.7.4.1.</span> <span class="toc-text">IR 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.4.2.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.4.3.</span> <span class="toc-text">本地变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.7.4.4.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.4.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.7.4.6.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.4.7.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.4.8.</span> <span class="toc-text">函数和声明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Unions"><span class="toc-number">1.7.4.9.</span> <span class="toc-text">Unions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#if-then-else-%E5%88%86%E6%94%AF"><span class="toc-number">1.7.4.10.</span> <span class="toc-text">if-then-else 分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E4%B8%80%E8%B5%8B%E5%80%BC%E8%A1%A8%EF%BC%88SSA-Form%EF%BC%89%E5%92%8C-PHI"><span class="toc-number">1.7.4.11.</span> <span class="toc-text">静态单一赋值表（SSA Form）和 PHI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Lambda-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.4.12.</span> <span class="toc-text">Lambda 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-Generators"><span class="toc-number">1.7.4.13.</span> <span class="toc-text">生成器 Generators</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.4.14.</span> <span class="toc-text">面向对象结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.7.4.15.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.4.16.</span> <span class="toc-text">虚拟方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.4.17.</span> <span class="toc-text">单一继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.4.18.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.7.4.19.</span> <span class="toc-text">虚拟继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-Interface"><span class="toc-number">1.7.4.20.</span> <span class="toc-text">接口 Interface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boxing-%E5%92%8C-Unboxing"><span class="toc-number">1.7.4.21.</span> <span class="toc-text">Boxing 和 Unboxing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#New-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.7.4.22.</span> <span class="toc-text">New 运算符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.8.</span> <span class="toc-text">C 调用 LLVM 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift-%E8%B0%83%E7%94%A8-LLVM-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.</span> <span class="toc-text">Swift 调用 LLVM 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-bitcode%EF%BC%88IR%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">解释执行 bitcode（IR）</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 57
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span>
            <a class="archive-post-title" href="/2022/06/10/use-llvm/">使用 LLVM</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span>
            <a class="archive-post-title" href="/2022/06/10/wwdc22-notes/">WWDC22 笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/25</span>
            <a class="archive-post-title" href="/2022/03/25/develop-with-swiftui/">在苹果加速器活动做的 SwiftUI 开发分享</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/26</span>
            <a class="archive-post-title" href="/2022/02/26/draw-in-2021/">2021年画的</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/10</span>
            <a class="archive-post-title" href="/2022/02/10/swift-evolutionary-path/">Swift 演进之路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/03</span>
            <a class="archive-post-title" href="/2022/01/03/develop-macos-with-swiftui-combine-concurrency-aysnc-await-actor/">如何用 SwiftUI + Combine + Swift Concurrency Aysnc/Await Actor 欢畅开发</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/23</span>
            <a class="archive-post-title" href="/2021/11/23/daiming-swift-pamphlet/">戴铭的 Swift 小册子 4.0</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/2021/07/24/my-little-idea-about-writing-technical-article/">我写技术文章的一点心得</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/13</span>
            <a class="archive-post-title" href="/2021/07/13/deeply-analyse-autolayout-slides/">深入剖析Auto Layout的幻灯片</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span>
            <a class="archive-post-title" href="/2021/06/08/wwdc2021-day1-note/">WWDC 2021 Day1 笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/22</span>
            <a class="archive-post-title" href="/2021/05/22/acfun-swift-practice/">A站 的 Swift 实践</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/21</span>
            <a class="archive-post-title" href="/2021/02/21/deeply-analyse-quickjs/">深入剖析 JavaScript 编译器/解释器引擎 QuickJS - 多了解些 JavaScript 语言</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2020 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/18</span>
            <a class="archive-post-title" href="/2020/12/18/thinking-in-how-to-speed-up-app/">App 启动提速实践和一些想法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/04</span>
            <a class="archive-post-title" href="/2020/05/04/draw-in-2020/">2020年涂图</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span>
            <a class="archive-post-title" href="/2020/04/12/why_write_study_ios_programming_with_daiming_book_and_draw_recently/">我为什么写了《跟戴铭学iOS编程》这本书</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/29</span>
            <a class="archive-post-title" href="/2020/03/29/apple-system-executable-file-macho/">Apple 操作系统可执行文件 Mach-O</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2020/01/05/kuaishou-unused-class-swiftui-note-binary-tree-interview/">在快手做分享、无用类检查、在广州做 SwiftUI 学习笔记分享、InfoQ二叉树视频</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2019 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span>
            <a class="archive-post-title" href="/2019/12/28/japan-travel/">日本游玩</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span>
            <a class="archive-post-title" href="/2019/12/07/how-to-analyze-startup-time-cost-in-ios/">如何对 iOS 启动阶段耗时进行分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/2019/12/06/draw-in-2019/">2019年涂图</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span>
            <a class="archive-post-title" href="/2019/07/29/ios-map/">iOS 开发舆图</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span>
            <a class="archive-post-title" href="/2019/06/19/white-dragon-class/">白龙班</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/17</span>
            <a class="archive-post-title" href="/2018/09/17/produce-slides-of-third-at-swift-conference/">这次swift大会分享准备的幻灯片和 demo</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span>
            <a class="archive-post-title" href="/2018/09/14/draw-with-procreate-in-ipad-during-pre-half-in-20182/">18年上半年procreate的练习图图</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/21</span>
            <a class="archive-post-title" href="/2018/04/21/deeply-analyse-javascriptcore/">深入剖析 JavaScriptCore</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span>
            <a class="archive-post-title" href="/2018/04/07/read-snapkit-and-masonry-source-code/">读 SnapKit 和 Masonry 自动布局框架源码</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span>
            <a class="archive-post-title" href="/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/">Swift 项目中涉及到 JSONDecoder，网络请求，泛型协议式编程的一些记录和想法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span>
            <a class="archive-post-title" href="/2018/01/24/why-swift/">Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/10</span>
            <a class="archive-post-title" href="/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/">GIAC 大会上分享的《Swift 将 Web 代码转成60帧满帧原生应用的方案及实践》的幻灯片</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span>
            <a class="archive-post-title" href="/2018/01/04/baimi/">白芈</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span>
            <a class="archive-post-title" href="/2018/01/04/huaye/">花野</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2017 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span>
            <a class="archive-post-title" href="/2017/10/24/how-do-i-improve-the-development/">在滴滴，我是如何指数级提升开发技术的？</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/16</span>
            <a class="archive-post-title" href="/2017/10/16/html-to-native-htn-development-record/">HTML 转原生 HTN 项目开发记录</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span>
            <a class="archive-post-title" href="/2017/10/11/deeply-analyse-webkit/">深入剖析 WebKit</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span>
            <a class="archive-post-title" href="/2017/06/20/deeply-ios-performance-optimization/">深入剖析 iOS 性能优化</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/12</span>
            <a class="archive-post-title" href="/2017/06/12/gmtc-ios-slimming-practice/">GMTC 上分享滴滴出行 iOS 端瘦身实践的 Slides</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span>
            <a class="archive-post-title" href="/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/">atSwift大会上分享《学习iOS编译原理能做哪些有意思的事情》的 Slides</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span>
            <a class="archive-post-title" href="/2017/04/01/build-static-analysis-program-smck-use-swift/">用 Swift 编写的工程代码静态分析命令行工具 smck</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span>
            <a class="archive-post-title" href="/2017/04/01/slides-of-deeply-analyse-llvm/">深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span>
            <a class="archive-post-title" href="/2017/03/01/deeply-analyse-llvm/">深入剖析 iOS 编译 Clang / LLVM</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2016 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span>
            <a class="archive-post-title" href="/2016/11/22/how-to-preload-web-in-ios/">iOS预加载Web页面方案</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span>
            <a class="archive-post-title" href="/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/">使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span>
            <a class="archive-post-title" href="/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/">15，16年iPad上使用Procreate画的</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span>
            <a class="archive-post-title" href="/2016/09/02/develop-rss-reader/">使用ReactiveCocoa开发RSS阅读器</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span>
            <a class="archive-post-title" href="/2016/08/09/how-to-use-reactivecocoa/">iOS函数响应式编程以及ReactiveCocoa的使用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span>
            <a class="archive-post-title" href="/2016/07/21/assembleview/">制作一个类似苹果VFL(Visual Format Language)的格式化语言来描述类似UIStackView那种布局思路，并解析生成页面</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span>
            <a class="archive-post-title" href="/2016/05/30/what-learn-from-reactivecocoa/">从 ReactiveCocoa 中能学到什么？不用此库也能学以致用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span>
            <a class="archive-post-title" href="/2016/05/23/try-to-decouple-with-demo/">竭尽全力的去解耦的一次实践，封装一个TableView和一些功能组合的控件</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/04</span>
            <a class="archive-post-title" href="/2016/04/04/tenth-middle-school/">十中</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span>
            <a class="archive-post-title" href="/2016/01/13/how-to-use-gcd/">细说 GCD（Grand Central Dispatch）如何用</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2015 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/2015/11/03/deeply-analyse-autolayout/">深入剖析Auto Layout，分析iOS各版本新增特性</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span>
            <a class="archive-post-title" href="/2015/11/02/draw-with-note-in-ipad-during-15/">15年用iPad上的备忘录画的</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span>
            <a class="archive-post-title" href="/2015/05/28/macos-app-i-used/">我用过的 macOS 应用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span>
            <a class="archive-post-title" href="/2015/04/02/draw-game-of-thrones-with-pencil-during-14/">整理了画的权利的游戏里的角色，有龙女，小恶魔等等</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span>
            <a class="archive-post-title" href="/2015/04/01/objc-runtime/">Objc Runtime 总结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span>
            <a class="archive-post-title" href="/2015/03/12/draw-practice-with-pencil-during-14-to-15/">14和15年间的铅笔画练习</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2014 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span>
            <a class="archive-post-title" href="/2014/03/01/black-star-blue-map/">黑星蓝图</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="iOS">
                <span class="iconfont-archer">&#xe606;</span>
                iOS
            </span>
        
            <span class="sidebar-tag-name" data-tags="Apple">
                <span class="iconfont-archer">&#xe606;</span>
                Apple
            </span>
        
            <span class="sidebar-tag-name" data-tags="Swift">
                <span class="iconfont-archer">&#xe606;</span>
                Swift
            </span>
        
            <span class="sidebar-tag-name" data-tags="AssembleView">
                <span class="iconfont-archer">&#xe606;</span>
                AssembleView
            </span>
        
            <span class="sidebar-tag-name" data-tags="Novel">
                <span class="iconfont-archer">&#xe606;</span>
                Novel
            </span>
        
            <span class="sidebar-tag-name" data-tags="Mach-O">
                <span class="iconfont-archer">&#xe606;</span>
                Mach-O
            </span>
        
            <span class="sidebar-tag-name" data-tags="smck">
                <span class="iconfont-archer">&#xe606;</span>
                smck
            </span>
        
            <span class="sidebar-tag-name" data-tags="Autolayout">
                <span class="iconfont-archer">&#xe606;</span>
                Autolayout
            </span>
        
            <span class="sidebar-tag-name" data-tags="JavaScript">
                <span class="iconfont-archer">&#xe606;</span>
                JavaScript
            </span>
        
            <span class="sidebar-tag-name" data-tags="Web">
                <span class="iconfont-archer">&#xe606;</span>
                Web
            </span>
        
            <span class="sidebar-tag-name" data-tags="编译">
                <span class="iconfont-archer">&#xe606;</span>
                编译
            </span>
        
            <span class="sidebar-tag-name" data-tags="RSSReader">
                <span class="iconfont-archer">&#xe606;</span>
                RSSReader
            </span>
        
            <span class="sidebar-tag-name" data-tags="macOS">
                <span class="iconfont-archer">&#xe606;</span>
                macOS
            </span>
        
            <span class="sidebar-tag-name" data-tags="Combine">
                <span class="iconfont-archer">&#xe606;</span>
                Combine
            </span>
        
            <span class="sidebar-tag-name" data-tags="SwiftUI">
                <span class="iconfont-archer">&#xe606;</span>
                SwiftUI
            </span>
        
            <span class="sidebar-tag-name" data-tags="Concurrency">
                <span class="iconfont-archer">&#xe606;</span>
                Concurrency
            </span>
        
            <span class="sidebar-tag-name" data-tags="LLVM">
                <span class="iconfont-archer">&#xe606;</span>
                LLVM
            </span>
        
            <span class="sidebar-tag-name" data-tags="Clang">
                <span class="iconfont-archer">&#xe606;</span>
                Clang
            </span>
        
            <span class="sidebar-tag-name" data-tags="Performance optimization">
                <span class="iconfont-archer">&#xe606;</span>
                Performance optimization
            </span>
        
            <span class="sidebar-tag-name" data-tags="Painting">
                <span class="iconfont-archer">&#xe606;</span>
                Painting
            </span>
        
            <span class="sidebar-tag-name" data-tags="Pencil">
                <span class="iconfont-archer">&#xe606;</span>
                Pencil
            </span>
        
            <span class="sidebar-tag-name" data-tags="GOT">
                <span class="iconfont-archer">&#xe606;</span>
                GOT
            </span>
        
            <span class="sidebar-tag-name" data-tags="iPad">
                <span class="iconfont-archer">&#xe606;</span>
                iPad
            </span>
        
            <span class="sidebar-tag-name" data-tags="Procreate">
                <span class="iconfont-archer">&#xe606;</span>
                Procreate
            </span>
        
            <span class="sidebar-tag-name" data-tags="WebKit">
                <span class="iconfont-archer">&#xe606;</span>
                WebKit
            </span>
        
            <span class="sidebar-tag-name" data-tags="Slides">
                <span class="iconfont-archer">&#xe606;</span>
                Slides
            </span>
        
            <span class="sidebar-tag-name" data-tags="Study">
                <span class="iconfont-archer">&#xe606;</span>
                Study
            </span>
        
            <span class="sidebar-tag-name" data-tags="GCD">
                <span class="iconfont-archer">&#xe606;</span>
                GCD
            </span>
        
            <span class="sidebar-tag-name" data-tags="UIWebView">
                <span class="iconfont-archer">&#xe606;</span>
                UIWebView
            </span>
        
            <span class="sidebar-tag-name" data-tags="NSURLProtocol">
                <span class="iconfont-archer">&#xe606;</span>
                NSURLProtocol
            </span>
        
            <span class="sidebar-tag-name" data-tags="ReactiveCocoa">
                <span class="iconfont-archer">&#xe606;</span>
                ReactiveCocoa
            </span>
        
            <span class="sidebar-tag-name" data-tags="Japan">
                <span class="iconfont-archer">&#xe606;</span>
                Japan
            </span>
        
            <span class="sidebar-tag-name" data-tags="APP">
                <span class="iconfont-archer">&#xe606;</span>
                APP
            </span>
        
            <span class="sidebar-tag-name" data-tags="runtime">
                <span class="iconfont-archer">&#xe606;</span>
                runtime
            </span>
        
            <span class="sidebar-tag-name" data-tags="swift">
                <span class="iconfont-archer">&#xe606;</span>
                swift
            </span>
        
            <span class="sidebar-tag-name" data-tags="Pattern">
                <span class="iconfont-archer">&#xe606;</span>
                Pattern
            </span>
        
            <span class="sidebar-tag-name" data-tags="book">
                <span class="iconfont-archer">&#xe606;</span>
                book
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="Programming">
            <span class="iconfont-archer">&#xe60a;</span>
            Programming
        </span>
    
        <span class="sidebar-category-name" data-categories="My-novel">
            <span class="iconfont-archer">&#xe60a;</span>
            My-novel
        </span>
    
        <span class="sidebar-category-name" data-categories="My-painting">
            <span class="iconfont-archer">&#xe60a;</span>
            My-painting
        </span>
    
        <span class="sidebar-category-name" data-categories="travel">
            <span class="iconfont-archer">&#xe60a;</span>
            travel
        </span>
    
        <span class="sidebar-category-name" data-categories="APP">
            <span class="iconfont-archer">&#xe60a;</span>
            APP
        </span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMeta = {
        url: "http://ming1016.github.io",
        root: "/",
        author: "戴铭"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20210823"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20210823"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20210823" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
