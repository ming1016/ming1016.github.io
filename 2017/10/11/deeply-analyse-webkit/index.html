<!DOCTYPE html>
<html>
<meta  lang="zh-Hans" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <link rel="icon" href="/img/logo-starming.png">
  <title>戴铭的博客</title>
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js" as="script">
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_vpj3dq9ceqa.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
  
  
  
  <link href="/js/lib/prism/prism.min.css" rel="stylesheet" data-prism="prism">
  
  
  
<link rel="stylesheet" href="/js/lib/prism/prism-line-numbers.min.css">

  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo-starming.png">
      
      <span class="navbar-logo-dsc">戴铭的博客</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">Home </a>
    
    <a href="/archives" class="navbar-menu-item">Archive </a>
    
    <a href="/tags" class="navbar-menu-item">Tags </a>
    
    <a href="/categories" class="navbar-menu-item">Categories </a>
    
    <a href="/about" class="navbar-menu-item">About </a>
    
    <a href="/friends" class="navbar-menu-item">Friends </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
  </div>
</nav>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      深入剖析 WebKit
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2017-10-11T03:42:25.000Z" style="display: flex; align-items: center;">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2017-10-11</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/Programming/" class="post-meta-link">Programming</a>
    
    
    
    <span class="dot"></span>
    <span>32.2k words</span>
    
  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Web/" class="post-meta-link">Web</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/WebKit/" class="post-meta-link">WebKit</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2 id="HTML-标准"><a href="#HTML-标准" class="headerlink" title="HTML 标准"></a>HTML 标准</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>HTML DOM 树的插入状态规范 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode">https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode</a></li>
<li>HTML Tokenize 规范 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a> <a target="_blank" rel="noopener" href="https://dev.w3.org/html5/spec-preview/tokenization.html">https://dev.w3.org/html5/spec-preview/tokenization.html</a></li>
<li>HTMLElement 堆栈规范 <a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a></li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。</p>
<p>1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。</p>
<p>1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。</p>
<p>1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。</p>
<p>2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。</p>
<p>2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。</p>
<p>2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio &#x2F; video 音频视频，3D&#x2F;graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。</p>
<p>完整的浏览器发展史可以在这里看：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>
<h2 id="WebKit-全貌"><a href="#WebKit-全貌" class="headerlink" title="WebKit 全貌"></a>WebKit 全貌</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。<br>先看看它的大模块：<br><img src="/uploads/deeply-analyse-webkit/45.png" alt="45" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/45.png" class="lozad post-image"><br>WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：<br><img src="/uploads/deeply-analyse-webkit/46.png" alt="46" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/46.png" class="lozad post-image"><br>整个 WebKit 架构，如下：<br><img src="/uploads/deeply-analyse-webkit/49.png" alt="49" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/49.png" class="lozad post-image"><br>实线部分是共享的，虚线部分会根据不同的平台有不同的实现。</p>
<p>下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图：<br><img src="/uploads/deeply-analyse-webkit/74.png" alt="74" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/74.png" class="lozad post-image"></p>
<p><img src="/uploads/deeply-analyse-webkit/01.png" alt="01" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/01.png" class="lozad post-image"></p>
<p>解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。</p>
<p>DOM Tree<br><img src="/uploads/deeply-analyse-webkit/02.png" alt="02" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/02.png" class="lozad post-image"><br>从网页 URL 到构建完 DOM 树的过程如图<br><img src="/uploads/deeply-analyse-webkit/47.png" alt="47" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/47.png" class="lozad post-image"></p>
<p>CSS Rule Tree<br><img src="/uploads/deeply-analyse-webkit/03.png" alt="03" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/03.png" class="lozad post-image"></p>
<p>通过上面的两个数构造的 Style Context Tree<br><img src="/uploads/deeply-analyse-webkit/04.png" alt="04" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/04.png" class="lozad post-image"></p>
<p>浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：<br><img src="/uploads/deeply-analyse-webkit/48.png" alt="48" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/48.png" class="lozad post-image"></p>
<p>计算每个 Node 的位置，执行 Layout 过程<br><img src="/uploads/deeply-analyse-webkit/05.png" alt="05" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/05.png" class="lozad post-image"></p>
<p>Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。</p>
<h3 id="WebKit-源代码结构说明"><a href="#WebKit-源代码结构说明" class="headerlink" title="WebKit 源代码结构说明"></a>WebKit 源代码结构说明</h3><ul>
<li>JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。</li>
<li>WebCore：浏览器渲染引擎，包含了各个核心模块。</li>
<li>WebCore&#x2F;css：CSS 解释器，CSS 规则等。</li>
<li>WebCore&#x2F;dom：各种 DOM 元素和 DOM Tree 结构相关的类。</li>
<li>WebCore&#x2F;html：HTML 解释器和各种 HTML 元素等相关内容。</li>
<li>WebCore&#x2F;rendering：Render Object 相关，还有页面渲染的样式和布局等。</li>
<li>WebCore&#x2F;inspector：网页调试工具。</li>
<li>WebCore&#x2F;loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。</li>
<li>WebCore&#x2F;page：页面相关的操作，页面结构和交互事件等。</li>
<li>WebCore&#x2F;platform：各个平台相关的代码，比如 iOS，Mac 等</li>
<li>WebCore&#x2F;storage：存储相关，比如 WebStorage，Index DB 等接口的实现。</li>
<li>WebCore&#x2F;workers：Worker 线程封装，提供 JS 多线程执行环境。</li>
<li>WebCore&#x2F;xml：XML 相关比如 XML Parser，XPath，XSLT 等。</li>
<li>WebCore&#x2F;accessibility：图形控件访问接口。</li>
<li>WebCore&#x2F;bindings：DOM 元素和 JS 绑定的接口。</li>
<li>WebCore&#x2F;bridge：C，JavaScript 和 Objective-C 的桥接。</li>
<li>WebCore&#x2F;editing：页面编辑相关，比如 DOM 修改，拼写检查等。</li>
<li>WebCore&#x2F;history：Page Cache 实现前进后退浏览记录等。</li>
<li>WebCore&#x2F;mathml：数学表达式在网页中的规范代码实现。</li>
<li>WebCore&#x2F;plugins：NPPlugin 的支持接口</li>
<li>WebCore&#x2F;svg：矢量图形的支持。</li>
<li>WebKit：平台相关的接口，每个目录都是不同的平台接口实现。</li>
<li>WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。</li>
<li>DumpRenderTree：用于生成 RenderTree</li>
<li>TestWebKitAPI：测试 WebKit 的 API 的测试代码</li>
</ul>
<h3 id="WebKit-代码风格"><a href="#WebKit-代码风格" class="headerlink" title="WebKit 代码风格"></a>WebKit 代码风格</h3><ul>
<li>内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。</li>
<li>代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。</li>
<li>代码编写风格：可以在官网查看到：<a target="_blank" rel="noopener" href="https://webkit.org/code-style-guidelines/">https://webkit.org/code-style-guidelines/</a> 想给 WebKit 做贡献的同学们可以好好看看了。</li>
</ul>
<h3 id="WebKit-的设计模式"><a href="#WebKit-的设计模式" class="headerlink" title="WebKit 的设计模式"></a>WebKit 的设计模式</h3><p>下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。</p>
<ul>
<li>单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。</li>
<li>工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。</li>
<li>观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。</li>
<li>组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。</li>
<li>命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。</li>
</ul>
<h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="/uploads/deeply-analyse-webkit/06.png" alt="06" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/06.png" class="lozad post-image"></p>
<ul>
<li>Frame：中心类，通过它找其它类</li>
<li>FrameLoader：加载资源用的</li>
<li>Document：具体实现是 HTMLDocument</li>
<li>Page：窗口的操作</li>
<li>EventHandler：输入事件的处理，比如键盘，鼠标，触屏等</li>
</ul>
<h4 id="WebCore-Frame"><a href="#WebCore-Frame" class="headerlink" title="WebCore::Frame"></a>WebCore::Frame</h4><p><img src="/uploads/deeply-analyse-webkit/29.png" alt="29" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/29.png" class="lozad post-image"></p>
<ul>
<li>FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。</li>
<li>FrameLoader：frame 的加载</li>
<li>NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。</li>
<li>DOMWindow：管理 DOM 相关的事件，属性和消息。</li>
<li>FrameView：Frame 的排版。</li>
<li>Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。</li>
<li>ScriptController：管理 js 脚本。</li>
<li>Editor：管理页面比如 copy，paste和输入等编辑操作。</li>
<li>SelectionController：管理 Frame 里的选择操作。</li>
<li>AnimationControlle：动画控制。</li>
<li>EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。</li>
</ul>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><img src="/uploads/deeply-analyse-webkit/43.png" alt="43" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/43.png" class="lozad post-image"><br>上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程：<br><img src="/uploads/deeply-analyse-webkit/44.png" alt="44" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/44.png" class="lozad post-image"></p>
<h3 id="Frame-的主要接口"><a href="#Frame-的主要接口" class="headerlink" title="Frame 的主要接口"></a>Frame 的主要接口</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)
&#123;
    ASSERT(page);
    ASSERT(client);
    return adoptRef(*new Frame(*page, ownerElement, *client));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。<br>初始调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">webPage::setView
webPage::setViewportSize
webPage::mainFrame
webPagePrivate::createMainFrame
webFrameData::webFrameData
Frame::create<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解析中发现 iframe 时的调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">FrameLoader::finishedLoading
HTMLDocumentParser::append
HTMLTreeBuilder::processToken
HTMLElementBase::openURL
SubFrameLoader::requestFrame
FrameLoaderClient::creatFrame
webFrameData::webFrameData
Frame::create<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Frame::createView(const IntSize&amp; viewportSize, const Color&amp; backgroundColor, bool transparent,
    const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,
    bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,
    ScrollbarMode verticalScrollbarMode, bool verticalLock)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。<br>调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">FrameLoader::commitProvisionalLoad
FrameLoader::transitionToCommitted
FrameLoaderClient::transitionToCommittedForNewPage
Frame::createView<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="setDocument"><a href="#setDocument" class="headerlink" title="setDocument"></a>setDocument</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>用来关联 Frame 和 Document 对象<br>Frame 初始化调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">WebFrame::webFrame
webFramePrivate::init
Frame::init
FrameLoader::init
DocumentWriter::begin
Frame::setDocument<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>js 脚本更改数据时的调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DocumentLoader::receivedData
DocumentLoader::commitLoad
FrameLoaderClient::committedLoad
DocumentLoader::commitData
DocumentWriter::setEncoding
DocumentWriter::willSetEncoding
FrameLoader::receivedFirstData
DocumentWriter::begin
FrameLoader::clear
Frame::setDocument<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h2><p>全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。</p>
<h3 id="Smart-ptr-智能指针"><a href="#Smart-ptr-智能指针" class="headerlink" title="Smart ptr 智能指针"></a>Smart ptr 智能指针</h3><p>对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。</p>
<p>智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。</p>
<p>智能指针的实现方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename T&gt;
class SmartPtr &#123;
    public:
        typedef T ValueType;
        typedef ValueType *PtrType;
        
        &#x2F;&#x2F;构造析构函数
        SmartPtr() :m_ptr(NULL) &#123;&#125;
        SmartPtr(PtrType ptr) :m_ptr(ptr) &#123;&#125;
        ~SmartPtr() &#123; 
            if(m_ptr) delete m_ptr; 
        &#125;
        
        &#x2F;&#x2F;拷贝构造函数
        SmartPtr(const SmartPtr&lt;T&gt;&amp; o); &#x2F;&#x2F;堆上分配的对象
        template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; o);
        
        &#x2F;&#x2F;拷贝赋值运算符
        template&lt;typename U&gt; SmartPtr&amp; operator &#x3D; (const SmartPtr&lt;U&gt;&amp; o);

        &#x2F;&#x2F;指针运算，是为了让智能指针在行为上更类似原生指针
        ValueType&amp; operator*() const &#123; 
            return *m_ptr; 
        &#125;
        PtrType operator-&gt;() const &#123;
            return m_ptr;
        &#125;

        &#x2F;&#x2F;逻辑运算符重载
        &#x2F;&#x2F;对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr)
        bool operator!() const &#123;
            return !m_ptr;
        &#125;

        &#x2F;&#x2F;转成 raw ptr
        operator PtrType() &#123;
            return m_ptr;
        &#125;
    private:
        PtrType m_ptr;
&#125;
&#x2F;&#x2F;创建智能指针对象格式
SmartPtr(new ValueType());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="RefPtr"><a href="#RefPtr" class="headerlink" title="RefPtr"></a>RefPtr</h3><p>RefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF&#x2F;Source&#x2F;wtf&#x2F;RefCounted.h 里。类模板的定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RefCountedBase &#123;
public:
    void ref() const
    &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
        ASSERT(!m_adoptionIsRequired);
#endif
        ++m_refCount;
    &#125;

    bool hasOneRef() const
    &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
        ASSERT(!m_deletionHasBegun);
#endif
        return m_refCount &#x3D;&#x3D; 1;
    &#125;

    unsigned refCount() const
    &#123;
        return m_refCount;
    &#125;

    void relaxAdoptionRequirement()
    &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
        ASSERT(m_adoptionIsRequired);
        m_adoptionIsRequired &#x3D; false;
#endif
    &#125;

protected:
    RefCountedBase()
        : m_refCount(1)
#if CHECK_REF_COUNTED_LIFECYCLE
        , m_deletionHasBegun(false)
        , m_adoptionIsRequired(true)
#endif
    &#123;
    &#125;

    ~RefCountedBase()
    &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
        ASSERT(m_deletionHasBegun);
        ASSERT(!m_adoptionIsRequired);
#endif
    &#125;

    &#x2F;&#x2F; Returns whether the pointer should be freed or not.
    bool derefBase() const
    &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
        ASSERT(!m_adoptionIsRequired);
#endif

        ASSERT(m_refCount);
        unsigned tempRefCount &#x3D; m_refCount - 1;
        if (!tempRefCount) &#123;
#if CHECK_REF_COUNTED_LIFECYCLE
            m_deletionHasBegun &#x3D; true;
#endif
            return true;
        &#125;
        m_refCount &#x3D; tempRefCount;
        return false;
    &#125;

#if CHECK_REF_COUNTED_LIFECYCLE
    bool deletionHasBegun() const
    &#123;
        return m_deletionHasBegun;
    &#125;
#endif

private:

#if CHECK_REF_COUNTED_LIFECYCLE
    friend void adopted(RefCountedBase*);
#endif

    mutable unsigned m_refCount;
#if CHECK_REF_COUNTED_LIFECYCLE
    mutable bool m_deletionHasBegun;
    mutable bool m_adoptionIsRequired;
#endif
&#125;;

template&lt;typename T&gt; class RefCounted : public RefCountedBase &#123;
    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;
public:
    void deref() const
    &#123;
        if (derefBase())
            delete static_cast&lt;const T*&gt;(this);
    &#125;

protected:
    RefCounted() &#123; &#125;
    ~RefCounted()
    &#123;
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted<CLASS>即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。</p>
<h3 id="Assert-断言的实现和应用"><a href="#Assert-断言的实现和应用" class="headerlink" title="Assert 断言的实现和应用"></a>Assert 断言的实现和应用</h3><p>断言在 WTF 里是这样定义的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define ASSERT(assertion) do &#123; \
    if (!(assertion)) &#123; \
        &#x2F;&#x2F;打印用
        WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
        &#x2F;&#x2F;重点
        CRASH(); \
    &#125; \
&#125; while (0)

#ifndef CRASH
#if defined(NDEBUG) &amp;&amp; OS(DARWIN)
&#x2F;&#x2F; Crash with a SIGTRAP i.e EXC_BREAKPOINT.
&#x2F;&#x2F; We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily
&#x2F;&#x2F; trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.
#define CRASH() do &#123; \
    &#x2F;&#x2F;直接 inline 汇编代码
    WTFBreakpointTrap(); \
    __builtin_unreachable(); \
&#125; while (0)
#else
#define CRASH() WTFCrash()
#endif
#endif &#x2F;&#x2F; !defined(CRASH)

&#x2F;&#x2F;根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏
#if CPU(X86_64) || CPU(X86)
#define WTFBreakpointTrap()  __asm__ volatile (&quot;int3&quot;)
#elif CPU(ARM_THUMB2)
#define WTFBreakpointTrap()  __asm__ volatile (&quot;bkpt #0&quot;)
#elif CPU(ARM64)
#define WTFBreakpointTrap()  __asm__ volatile (&quot;brk #0&quot;)
#else
#define WTFBreakpointTrap() WTFCrash() &#x2F;&#x2F; Not implemented.
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define WTF_MAKE_FAST_ALLOCATED \
public: \
    void* operator new(size_t, void* p) &#123; return p; &#125; \
    void* operator new[](size_t, void* p) &#123; return p; &#125; \
    \
    void* operator new(size_t size) \
    &#123; \
        return ::WTF::fastMalloc(size); \
    &#125; \
    \
    void operator delete(void* p) \
    &#123; \
        ::WTF::fastFree(p); \
    &#125; \
    \
    void* operator new[](size_t size) \
    &#123; \
        return ::WTF::fastMalloc(size); \
    &#125; \
    \
    void operator delete[](void* p) \
    &#123; \
        ::WTF::fastFree(p); \
    &#125; \
    void* operator new(size_t, NotNullTag, void* location) \
    &#123; \
        ASSERT(location); \
        return location; \
    &#125; \
private: \
typedef int __thisIsHereToForceASemicolonAfterThisMacro<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void* fastMalloc(size_t size)
&#123;
    ASSERT_IS_WITHIN_LIMIT(size);
    return bmalloc::api::malloc(size);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：<a target="_blank" rel="noopener" href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。</p>
<h4 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h4><p>WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, size_t inlineCapacity &#x3D; 0, typename OverflowHandler &#x3D; CrashOnOverflow, size_t minCapacity &#x3D; 16, typename Malloc &#x3D; FastMalloc&gt;
class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; &#123;
    WTF_MAKE_FAST_ALLOCATED;
private:
    &#x2F;&#x2F;VectorBuffer 是内部存储数据的容器
    typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;
    &#x2F;&#x2F;Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里
    typedef VectorTypeOperations&lt;T&gt; TypeOperations;

public:
    typedef T ValueType;
    &#x2F;&#x2F;iterator 直接使用的原生指针
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;

    Vector()
    &#123;
    &#125;

    &#x2F;&#x2F; Unlike in std::vector, this constructor does not initialize POD types.
    explicit Vector(size_t size)
        : Base(size, size)
    &#123;
        asanSetInitialBufferSizeTo(size);

        if (begin())
            TypeOperations::initialize(begin(), end());
    &#125;

    Vector(size_t size, const T&amp; val)
        : Base(size, size)
    &#123;
        asanSetInitialBufferSizeTo(size);

        if (begin())
            TypeOperations::uninitializedFill(begin(), end(), val);
    &#125;

    Vector(std::initializer_list&lt;T&gt; initializerList)
    &#123;
        reserveInitialCapacity(initializerList.size());

        asanSetInitialBufferSizeTo(initializerList.size());

        for (const auto&amp; element : initializerList)
            uncheckedAppend(element);
    &#125;

    ~Vector()
    &#123;
        if (m_size)
            TypeOperations::destruct(begin(), end());

        asanSetBufferSizeToFullCapacity(0);
    &#125;

    Vector(const Vector&amp;);
    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
    explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);

    Vector&amp; operator&#x3D;(const Vector&amp;);
    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
    Vector&amp; operator&#x3D;(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);

    Vector(Vector&amp;&amp;);
    Vector&amp; operator&#x3D;(Vector&amp;&amp;);
    
    &#x2F;&#x2F;返回 Vector 里元素个数
    size_t size() const &#123; return m_size; &#125;
    static ptrdiff_t sizeMemoryOffset() &#123; return OBJECT_OFFSETOF(Vector, m_size); &#125;
    
    &#x2F;&#x2F;返回的是 Vector 中的容量，容量随着元素增加和删除而变化
    size_t capacity() const &#123; return Base::capacity(); &#125;
    bool isEmpty() const &#123; return !size(); &#125;
    
    &#x2F;&#x2F;这里提供的是数组的访问功能
    T&amp; at(size_t i)
    &#123;
        if (UNLIKELY(i &gt;&#x3D; size()))
            OverflowHandler::overflowed();
        return Base::buffer()[i];
    &#125;
    const T&amp; at(size_t i) const 
    &#123;
        if (UNLIKELY(i &gt;&#x3D; size()))
            OverflowHandler::overflowed();
        return Base::buffer()[i];
    &#125;
    T&amp; at(Checked&lt;size_t&gt; i)
    &#123;
        RELEASE_ASSERT(i &lt; size());
        return Base::buffer()[i];
    &#125;
    const T&amp; at(Checked&lt;size_t&gt; i) const
    &#123;
        RELEASE_ASSERT(i &lt; size());
        return Base::buffer()[i];
    &#125;
    &#x2F;&#x2F;返回数组中第几个元素
    T&amp; operator[](size_t i) &#123; return at(i); &#125;
    const T&amp; operator[](size_t i) const &#123; return at(i); &#125;
    T&amp; operator[](Checked&lt;size_t&gt; i) &#123; return at(i); &#125;
    const T&amp; operator[](Checked&lt;size_t&gt; i) const &#123; return at(i); &#125;

    T* data() &#123; return Base::buffer(); &#125;
    const T* data() const &#123; return Base::buffer(); &#125;
    static ptrdiff_t dataMemoryOffset() &#123; return Base::bufferMemoryOffset(); &#125;
    &#x2F;&#x2F;迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。
    iterator begin() &#123; return data(); &#125;
    iterator end() &#123; return begin() + m_size; &#125;
    const_iterator begin() const &#123; return data(); &#125;
    const_iterator end() const &#123; return begin() + m_size; &#125;

    reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;
    reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;
    const_reverse_iterator rbegin() const &#123; return const_reverse_iterator(end()); &#125;
    const_reverse_iterator rend() const &#123; return const_reverse_iterator(begin()); &#125;

    T&amp; first() &#123; return at(0); &#125;
    const T&amp; first() const &#123; return at(0); &#125;
    T&amp; last() &#123; return at(size() - 1); &#125;
    const T&amp; last() const &#123; return at(size() - 1); &#125;
    
    T takeLast()
    &#123;
        T result &#x3D; WTFMove(last());
        removeLast();
        return result;
    &#125;
    
    &#x2F;&#x2F;O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好
    template&lt;typename U&gt; bool contains(const U&amp;) const;
    template&lt;typename U&gt; size_t find(const U&amp;) const;
    template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;
    template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;
    
    template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);
    
    &#x2F;&#x2F;实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力
    void shrink(size_t size);
    void grow(size_t size);
    void resize(size_t size);
    void resizeToFit(size_t size);
    void reserveCapacity(size_t newCapacity);
    bool tryReserveCapacity(size_t newCapacity);
    void reserveInitialCapacity(size_t initialCapacity);
    void shrinkCapacity(size_t newCapacity);
    void shrinkToFit() &#123; shrinkCapacity(size()); &#125;

    void clear() &#123; shrinkCapacity(0); &#125;

    void append(ValueType&amp;&amp; value) &#123; append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;
    template&lt;typename U&gt; void append(U&amp;&amp;);
    template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);
    template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);

    void uncheckedAppend(ValueType&amp;&amp; value) &#123; uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;
    template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);

    template&lt;typename U&gt; void append(const U*, size_t);
    template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
    template&lt;typename U&gt; bool tryAppend(const U*, size_t);

    template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
    template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
    template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;);

    void remove(size_t position);
    void remove(size_t position, size_t length);
    template&lt;typename U&gt; bool removeFirst(const U&amp;);
    template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex &#x3D; 0);
    template&lt;typename U&gt; unsigned removeAll(const U&amp;);
    template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex &#x3D; 0);

    void removeLast() 
    &#123;
        if (UNLIKELY(isEmpty()))
            OverflowHandler::overflowed();
        shrink(size() - 1); 
    &#125;

    void fill(const T&amp;, size_t);
    void fill(const T&amp; val) &#123; fill(val, size()); &#125;

    template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);

    MallocPtr&lt;T&gt; releaseBuffer();

    void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)
    &#123;
#if ASAN_ENABLED
        if (this &#x3D;&#x3D; std::addressof(other)) &#x2F;&#x2F; ASan will crash if we try to restrict access to the same buffer twice.
            return;
#endif

        &#x2F;&#x2F; Make it possible to copy inline buffers.
        asanSetBufferSizeToFullCapacity();
        other.asanSetBufferSizeToFullCapacity();

        Base::swap(other, m_size, other.m_size);
        std::swap(m_size, other.m_size);

        asanSetInitialBufferSizeTo(m_size);
        other.asanSetInitialBufferSizeTo(other.m_size);
    &#125;

    void reverse();

    void checkConsistency();

    template&lt;typename MapFunction, typename R &#x3D; typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;

private:
    void expandCapacity(size_t newMinCapacity);
    T* expandCapacity(size_t newMinCapacity, T*);
    bool tryExpandCapacity(size_t newMinCapacity);
    const T* tryExpandCapacity(size_t newMinCapacity, const T*);
    template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); 
    template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);
    template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);
    template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);

    void asanSetInitialBufferSizeTo(size_t);
    void asanSetBufferSizeToFullCapacity(size_t);
    void asanSetBufferSizeToFullCapacity() &#123; asanSetBufferSizeToFullCapacity(size()); &#125;

    void asanBufferSizeWillChangeTo(size_t);

    using Base::m_size;
    using Base::buffer;
    using Base::capacity;
    using Base::swap;
    using Base::allocateBuffer;
    using Base::deallocateBuffer;
    using Base::tryAllocateBuffer;
    using Base::shouldReallocateBuffer;
    using Base::reallocateBuffer;
    using Base::restoreInlineBufferIfNeeded;
    using Base::releaseBuffer;
#if ASAN_ENABLED
    using Base::endOfBuffer;
#endif
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h4><p>HashTable 实现代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">    template&lt;typename Key, typename Value, typename Extractor, typename HashFunctions, typename Traits, typename KeyTraits&gt;
    class HashTable &#123;
    public:
        typedef HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;
        typedef HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;
        typedef Traits ValueTraits;
        typedef Key KeyType;
        typedef Value ValueType;
        typedef IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;
        typedef HashTableAddResult&lt;iterator&gt; AddResult;

#if DUMP_HASHTABLE_STATS_PER_TABLE
        struct Stats &#123;
            Stats()
                : numAccesses(0)
                , numRehashes(0)
                , numRemoves(0)
                , numReinserts(0)
                , maxCollisions(0)
                , numCollisions(0)
                , collisionGraph()
            &#123;
            &#125;

            unsigned numAccesses;
            unsigned numRehashes;
            unsigned numRemoves;
            unsigned numReinserts;

            unsigned maxCollisions;
            unsigned numCollisions;
            unsigned collisionGraph[4096];

            void recordCollisionAtCount(unsigned count)
            &#123;
                if (count &gt; maxCollisions)
                    maxCollisions &#x3D; count;
                numCollisions++;
                collisionGraph[count]++;
            &#125;

            void dumpStats()
            &#123;
                dataLogF(&quot;\nWTF::HashTable::Stats dump\n\n&quot;);
                dataLogF(&quot;%d accesses\n&quot;, numAccesses);
                dataLogF(&quot;%d total collisions, average %.2f probes per access\n&quot;, numCollisions, 1.0 * (numAccesses + numCollisions) &#x2F; numAccesses);
                dataLogF(&quot;longest collision chain: %d\n&quot;, maxCollisions);
                for (unsigned i &#x3D; 1; i &lt;&#x3D; maxCollisions; i++) &#123;
                    dataLogF(&quot;  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n&quot;, collisionGraph[i], i, 100.0 * (collisionGraph[i] - collisionGraph[i+1]) &#x2F; numAccesses, 100.0 * collisionGraph[i] &#x2F; numAccesses);
                &#125;
                dataLogF(&quot;%d rehashes\n&quot;, numRehashes);
                dataLogF(&quot;%d reinserts\n&quot;, numReinserts);
            &#125;
        &#125;;
#endif

        HashTable();
        ~HashTable() 
        &#123;
            invalidateIterators(); 
            if (m_table)
                deallocateTable(m_table, m_tableSize);
#if CHECK_HASHTABLE_USE_AFTER_DESTRUCTION
            m_table &#x3D; (ValueType*)(uintptr_t)0xbbadbeef;
#endif
        &#125;

        HashTable(const HashTable&amp;);
        void swap(HashTable&amp;);
        HashTable&amp; operator&#x3D;(const HashTable&amp;);

        HashTable(HashTable&amp;&amp;);
        HashTable&amp; operator&#x3D;(HashTable&amp;&amp;);

        &#x2F;&#x2F; When the hash table is empty, just return the same iterator for end as for begin.
        &#x2F;&#x2F; This is more efficient because we don&#39;t have to skip all the empty and deleted
        &#x2F;&#x2F; buckets, and iterating an empty table is a common case that&#39;s worth optimizing.
        iterator begin() &#123; return isEmpty() ? end() : makeIterator(m_table); &#125;
        iterator end() &#123; return makeKnownGoodIterator(m_table + m_tableSize); &#125;
        const_iterator begin() const &#123; return isEmpty() ? end() : makeConstIterator(m_table); &#125;
        const_iterator end() const &#123; return makeKnownGoodConstIterator(m_table + m_tableSize); &#125;

        unsigned size() const &#123; return m_keyCount; &#125;
        unsigned capacity() const &#123; return m_tableSize; &#125;
        bool isEmpty() const &#123; return !m_keyCount; &#125;

        AddResult add(const ValueType&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); &#125;
        AddResult add(ValueType&amp;&amp; value) &#123; return add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); &#125;

        &#x2F;&#x2F; A special version of add() that finds the object by hashing and comparing
        &#x2F;&#x2F; with some other type, to avoid the cost of type conversion if the object is already
        &#x2F;&#x2F; in the table.
        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult add(T&amp;&amp; key, Extra&amp;&amp;);
        template&lt;typename HashTranslator, typename T, typename Extra&gt; AddResult addPassingHashCode(T&amp;&amp; key, Extra&amp;&amp;);

        iterator find(const KeyType&amp; key) &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;
        const_iterator find(const KeyType&amp; key) const &#123; return find&lt;IdentityTranslatorType&gt;(key); &#125;
        bool contains(const KeyType&amp; key) const &#123; return contains&lt;IdentityTranslatorType&gt;(key); &#125;

        template&lt;typename HashTranslator, typename T&gt; iterator find(const T&amp;);
        template&lt;typename HashTranslator, typename T&gt; const_iterator find(const T&amp;) const;
        template&lt;typename HashTranslator, typename T&gt; bool contains(const T&amp;) const;

        void remove(const KeyType&amp;);
        void remove(iterator);
        void removeWithoutEntryConsistencyCheck(iterator);
        void removeWithoutEntryConsistencyCheck(const_iterator);
        template&lt;typename Functor&gt;
        void removeIf(const Functor&amp;);
        void clear();

        static bool isEmptyBucket(const ValueType&amp; value) &#123; return isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); &#125;
        static bool isDeletedBucket(const ValueType&amp; value) &#123; return KeyTraits::isDeletedValue(Extractor::extract(value)); &#125;
        static bool isEmptyOrDeletedBucket(const ValueType&amp; value) &#123; return isEmptyBucket(value) || isDeletedBucket(value); &#125;

        ValueType* lookup(const Key&amp; key) &#123; return lookup&lt;IdentityTranslatorType&gt;(key); &#125;
        template&lt;typename HashTranslator, typename T&gt; ValueType* lookup(const T&amp;);
        template&lt;typename HashTranslator, typename T&gt; ValueType* inlineLookup(const T&amp;);

#if !ASSERT_DISABLED
        void checkTableConsistency() const;
#else
        static void checkTableConsistency() &#123; &#125;
#endif
#if CHECK_HASHTABLE_CONSISTENCY
        void internalCheckTableConsistency() const &#123; checkTableConsistency(); &#125;
        void internalCheckTableConsistencyExceptSize() const &#123; checkTableConsistencyExceptSize(); &#125;
#else
        static void internalCheckTableConsistencyExceptSize() &#123; &#125;
        static void internalCheckTableConsistency() &#123; &#125;
#endif

    private:
        static ValueType* allocateTable(unsigned size);
        static void deallocateTable(ValueType* table, unsigned size);

        typedef std::pair&lt;ValueType*, bool&gt; LookupType;
        typedef std::pair&lt;LookupType, unsigned&gt; FullLookupType;

        LookupType lookupForWriting(const Key&amp; key) &#123; return lookupForWriting&lt;IdentityTranslatorType&gt;(key); &#125;;
        template&lt;typename HashTranslator, typename T&gt; FullLookupType fullLookupForWriting(const T&amp;);
        template&lt;typename HashTranslator, typename T&gt; LookupType lookupForWriting(const T&amp;);

        template&lt;typename HashTranslator, typename T, typename Extra&gt; void addUniqueForInitialization(T&amp;&amp; key, Extra&amp;&amp;);

        template&lt;typename HashTranslator, typename T&gt; void checkKey(const T&amp;);

        void removeAndInvalidateWithoutEntryConsistencyCheck(ValueType*);
        void removeAndInvalidate(ValueType*);
        void remove(ValueType*);

        bool shouldExpand() const &#123; return (m_keyCount + m_deletedCount) * m_maxLoad &gt;&#x3D; m_tableSize; &#125;
        bool mustRehashInPlace() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize * 2; &#125;
        bool shouldShrink() const &#123; return m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; &#125;
        ValueType* expand(ValueType* entry &#x3D; nullptr);
        void shrink() &#123; rehash(m_tableSize &#x2F; 2, nullptr); &#125;

        ValueType* rehash(unsigned newTableSize, ValueType* entry);
        ValueType* reinsert(ValueType&amp;&amp;);

        static void initializeBucket(ValueType&amp; bucket);
        static void deleteBucket(ValueType&amp; bucket) &#123; hashTraitsDeleteBucket&lt;Traits&gt;(bucket); &#125;

        FullLookupType makeLookupResult(ValueType* position, bool found, unsigned hash)
            &#123; return FullLookupType(LookupType(position, found), hash); &#125;

        iterator makeIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize); &#125;
        const_iterator makeConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize); &#125;
        iterator makeKnownGoodIterator(ValueType* pos) &#123; return iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;
        const_iterator makeKnownGoodConstIterator(ValueType* pos) const &#123; return const_iterator(this, pos, m_table + m_tableSize, HashItemKnownGood); &#125;

#if !ASSERT_DISABLED
        void checkTableConsistencyExceptSize() const;
#else
        static void checkTableConsistencyExceptSize() &#123; &#125;
#endif

#if CHECK_HASHTABLE_ITERATORS
        void invalidateIterators();
#else
        static void invalidateIterators() &#123; &#125;
#endif

        static const unsigned m_maxLoad &#x3D; 2;
        static const unsigned m_minLoad &#x3D; 6;

        ValueType* m_table;
        unsigned m_tableSize;
        unsigned m_tableSizeMask;
        unsigned m_keyCount;
        unsigned m_deletedCount;

#if CHECK_HASHTABLE_ITERATORS
    public:
        &#x2F;&#x2F; All access to m_iterators should be guarded with m_mutex.
        mutable const_iterator* m_iterators;
        &#x2F;&#x2F; Use std::unique_ptr so HashTable can still be memmove&#39;d or memcpy&#39;ed.
        mutable std::unique_ptr&lt;Lock&gt; m_mutex;
#endif

#if DUMP_HASHTABLE_STATS_PER_TABLE
    public:
        mutable std::unique_ptr&lt;Stats&gt; m_stats;
#endif
    &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>完整具体的实现可以查看 WTF&#x2F;Source&#x2F;wtf&#x2F;HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF&#x2F;Source&#x2F;wtf&#x2F;MessageQueue.h 里有对消息队列的定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; The queue takes ownership of messages and transfer it to the new owner
&#x2F;&#x2F; when messages are fetched from the queue.
&#x2F;&#x2F; Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.
template&lt;typename DataType&gt;
class MessageQueue &#123;
    WTF_MAKE_NONCOPYABLE(MessageQueue);
public:
    MessageQueue() : m_killed(false) &#123; &#125;
    ~MessageQueue();

    void append(std::unique_ptr&lt;DataType&gt;);
    void appendAndKill(std::unique_ptr&lt;DataType&gt;);
    bool appendAndCheckEmpty(std::unique_ptr&lt;DataType&gt;);
    void prepend(std::unique_ptr&lt;DataType&gt;);

    std::unique_ptr&lt;DataType&gt; waitForMessage();
    std::unique_ptr&lt;DataType&gt; tryGetMessage();
    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; takeAllMessages();
    std::unique_ptr&lt;DataType&gt; tryGetMessageIgnoringKilled();
    template&lt;typename Predicate&gt;
    std::unique_ptr&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime);

    template&lt;typename Predicate&gt;
    void removeIf(Predicate&amp;&amp;);

    void kill();
    bool killed() const;

    &#x2F;&#x2F; The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time.
    bool isEmpty();

private:
    &#x2F;&#x2F;m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装
    mutable Lock m_mutex;
    
    &#x2F;&#x2F;Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程
    Condition m_condition;
    
    &#x2F;&#x2F;内部主要存储结构
    Deque&lt;std::unique_ptr&lt;DataType&gt;&gt; m_queue;
    bool m_killed;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I&#x2F;O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore&#x2F;platform&#x2F;network 里。如果是 iOS 就在 WebCore&#x2F;platform&#x2F;network&#x2F;iOS 里，如果 Mac 就在 WebCore&#x2F;platform&#x2F;network&#x2F;mac 里。</p>
<h3 id="Loader-的资源"><a href="#Loader-的资源" class="headerlink" title="Loader 的资源"></a>Loader 的资源</h3><p>网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型：</p>
<ul>
<li>HTML：页面主文件</li>
<li>JavaScript：单独的文件后者直接在 HTML 代码里</li>
<li>CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里</li>
<li>图片：各种编码图片比如 jpg 和 png</li>
<li>SVG：矢量图片</li>
<li>CSS Shader：为 CSS 带来 3D 图形特性</li>
<li>音频视频：多媒体资源以及视频字幕</li>
<li>字体：自定义的字体</li>
<li>XSL：对 XSLT 语言编写的文件支持</li>
</ul>
<p>WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。<br><img src="/uploads/deeply-analyse-webkit/50.png" alt="50" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/50.png" class="lozad post-image"></p>
<h3 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h3><p>加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。<br><img src="/uploads/deeply-analyse-webkit/07.png" alt="07" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/07.png" class="lozad post-image"><br><img src="/uploads/deeply-analyse-webkit/39.png" alt="39" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/39.png" class="lozad post-image"></p>
<ul>
<li>MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。</li>
<li>CacheResourceLoader：缓存资源读取。</li>
<li>资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。</li>
<li>DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。</li>
</ul>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="/uploads/deeply-analyse-webkit/08.png" alt="08" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/08.png" class="lozad post-image"></p>
<p>解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。</p>
<p>这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。</p>
<p>整个资源加载过程，这篇文章有详细的介绍：<a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/">https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/</a></p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p><img src="/uploads/deeply-analyse-webkit/30.png" alt="30" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/30.png" class="lozad post-image"><br><img src="/uploads/deeply-analyse-webkit/77.png" alt="77" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/77.png" class="lozad post-image"><br><img src="/uploads/deeply-analyse-webkit/78.png" alt="78" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/78.png" class="lozad post-image"></p>
<ul>
<li>Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。</li>
<li>SubFrameLoader：维护子 Frame。</li>
<li>DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。</li>
<li>DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。</li>
<li>HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。</li>
<li>ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。</li>
<li>SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。</li>
<li>FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。</li>
<li>PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。</li>
</ul>
<h3 id="FrameLoader-的主要接口"><a href="#FrameLoader-的主要接口" class="headerlink" title="FrameLoader 的主要接口"></a>FrameLoader 的主要接口</h3><h4 id="Frame-init"><a href="#Frame-init" class="headerlink" title="Frame::init"></a>Frame::init</h4><p>FrameLoader 自身的初始化。<br>初始化的调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)
WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)
Frame::init()
FrameLoader::init()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="FrameLoader-commitProvisionalLoad"><a href="#FrameLoader-commitProvisionalLoad" class="headerlink" title="FrameLoader::commitProvisionalLoad"></a>FrameLoader::commitProvisionalLoad</h4><p>提交 provisional 阶段时下载的数据<br>完成 Document loading 的调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DocumentLoader::finishLoading
DocumentLoader::commitIfReady
FrameLoader::commitProvisionalLoad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>资源数据接受提交调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ResourceLoader::didReceiveData
MainResourceLoader::addData
DocumentLoader::receiveData
DocumentLoader::commitLoad
DocumentLoader::commitIfReady
DocumentLoader::commitProvisionalLoad<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Frame-finishedLoading"><a href="#Frame-finishedLoading" class="headerlink" title="Frame::finishedLoading"></a>Frame::finishedLoading</h4><p>网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。<br>函数的调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ResourceLoader::didFinishLoading
MainResourceLoader::didFinishLoading
FrameLoader::finishedLoading
FrameLoader::init()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="FrameLoader-finishedParsing"><a href="#FrameLoader-finishedParsing" class="headerlink" title="FrameLoader::finishedParsing"></a>FrameLoader::finishedParsing</h4><p>完成解析时调用的接口<br>调用顺序</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">DocumentWritter::end
Document::finishParsing
Document::finishedParsing
FrameLoader::finishedParsing<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="FrameLoader-load-FrameLoadRequest-amp-amp-request"><a href="#FrameLoader-load-FrameLoadRequest-amp-amp-request" class="headerlink" title="FrameLoader::load(FrameLoadRequest&amp;&amp; request)"></a>FrameLoader::load(FrameLoadRequest&amp;&amp; request)</h4><p>加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;创建 DocumentLoader
void FrameLoader::load(FrameLoadRequest&amp;&amp; request)
&#123;
    if (m_inStopAllLoaders)
        return;

    if (!request.frameName().isEmpty()) &#123;
        Frame* frame &#x3D; findFrameForNavigation(request.frameName());
        if (frame) &#123;
            request.setShouldCheckNewWindowPolicy(false);
            if (&amp;frame-&gt;loader() !&#x3D; this) &#123;
                frame-&gt;loader().load(WTFMove(request));
                return;
            &#125;
        &#125;
    &#125;

    if (request.shouldCheckNewWindowPolicy()) &#123;
        NavigationAction action &#123; request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() &#125;;
        policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), nullptr, request.frameName(), [this] (const ResourceRequest&amp; request, FormState* formState, const String&amp; frameName, const NavigationAction&amp; action, bool shouldContinue) &#123;
            continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);
        &#125;);

        return;
    &#125;

    if (!request.hasSubstituteData())
        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));
    &#x2F;&#x2F;FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。
    Ref&lt;DocumentLoader&gt; loader &#x3D; m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());
    applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);

    load(loader.ptr());
&#125;

&#x2F;&#x2F;完善 request 信息
void FrameLoader::load(DocumentLoader* newDocumentLoader)
&#123;
    ResourceRequest&amp; r &#x3D; newDocumentLoader-&gt;request();
    &#x2F;&#x2F;ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。
    addExtraFieldsToMainResourceRequest(r);
    FrameLoadType type;

    if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) &#123;
        r.setCachePolicy(ReloadIgnoringCacheData);
        type &#x3D; FrameLoadType::Same;
    &#125; else if (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType &#x3D;&#x3D; FrameLoadType::Reload)
        type &#x3D; FrameLoadType::Reload;
    else if (m_loadType &#x3D;&#x3D; FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid())
        type &#x3D; FrameLoadType::RedirectWithLockedBackForwardList;
    else
        type &#x3D; FrameLoadType::Standard;

    if (m_documentLoader)
        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());
    
    if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;
        history().saveDocumentAndScrollState();
        ASSERT(type &#x3D;&#x3D; FrameLoadType::Standard);
        type &#x3D; FrameLoadType::Reload;
    &#125;
    loadWithDocumentLoader(newDocumentLoader, type, 0, AllowNavigationToInvalidURL::Yes);
&#125;

&#x2F;&#x2F;校验检查
void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
&#123;
    &#x2F;&#x2F; Retain because dispatchBeforeLoadEvent may release the last reference to it.
    Ref&lt;Frame&gt; protect(m_frame);

    ASSERT(m_client.hasWebView());
    ASSERT(m_frame.view());

    if (!isNavigationAllowed())
        return;

    if (m_frame.document())
        m_previousURL &#x3D; m_frame.document()-&gt;url();

    const URL&amp; newURL &#x3D; loader-&gt;request().url();
    &#x2F;&#x2F; Log main frame navigation types.
    if (m_frame.isMainFrame()) &#123;
        if (auto* page &#x3D; m_frame.page())
            page-&gt;mainFrameLoadStarted(newURL, type);
static_cast&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);
    &#125;

    policyChecker().setLoadType(type);
    bool isFormSubmission &#x3D; formState;

    const String&amp; httpMethod &#x3D; loader-&gt;request().httpMethod();

    if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) &#123;
        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader &#x3D; m_documentLoader;
        NavigationAction action &#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;;

        oldDocumentLoader-&gt;setTriggeringAction(action);
        oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());
        policyChecker().stopCheck();
        policyChecker().checkNavigationPolicy(loader-&gt;request(), false &#x2F;* didReceiveRedirectResponse *&#x2F;, oldDocumentLoader.get(), formState, [this] (const ResourceRequest&amp; request, FormState*, bool shouldContinue) &#123;
            continueFragmentScrollAfterNavigationPolicy(request, shouldContinue);
        &#125;);
        return;
    &#125;

    if (Frame* parent &#x3D; m_frame.tree().parent())
        loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());

    policyChecker().stopCheck();
    
    &#x2F;&#x2F;把 DocumentLoader 赋给 m_policyDocumentLoader
    setPolicyDocumentLoader(loader);
    
    &#x2F;&#x2F;将请求信息记在 loader.m_triggeringAction 中
    if (loader-&gt;triggeringAction().isEmpty())
        loader-&gt;setTriggeringAction(&#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;);

    if (Element* ownerElement &#x3D; m_frame.ownerElement()) &#123;
        if (!m_stateMachine.committedFirstRealDocumentLoad()
            &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) &#123;
            continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false, allowNavigationToInvalidURL);
            return;
        &#125;
    &#125;
    &#x2F;&#x2F;使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求
    policyChecker().checkNavigationPolicy(loader-&gt;request(), false &#x2F;* didReceiveRedirectResponse *&#x2F;, loader, formState, [this, allowNavigationToInvalidURL] (const ResourceRequest&amp; request, FormState* formState, bool shouldContinue) &#123;
        &#x2F;&#x2F;shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。
        continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL);
    &#125;);
&#125;

&#x2F;&#x2F;
void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp; request, FormState* formState, bool shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL)
&#123;
    &#x2F;&#x2F; If we loaded an alternate page to replace an unreachableURL, we&#39;ll get in here with a
    &#x2F;&#x2F; nil policyDataSource because loading the alternate page will have passed
    &#x2F;&#x2F; through this method already, nested; otherwise, policyDataSource should still be set.
    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());

    bool isTargetItem &#x3D; history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : false;

    bool urlIsDisallowed &#x3D; allowNavigationToInvalidURL &#x3D;&#x3D; AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();

    &#x2F;&#x2F; Three reasons we can&#39;t continue:
    &#x2F;&#x2F;    1) Navigation policy delegate said we can&#39;t so request is nil. A primary case of this 
    &#x2F;&#x2F;       is the user responding Cancel to the form repost nag sheet.
    &#x2F;&#x2F;    2) User responded Cancel to an alert popped up by the before unload event handler.
    &#x2F;&#x2F;    3) The request&#39;s URL is invalid and navigation to invalid URLs is disallowed.
    bool canContinue &#x3D; shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;

    if (!canContinue) &#123;
        &#x2F;&#x2F; If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we 
        &#x2F;&#x2F; need to report that the client redirect was cancelled.
        &#x2F;&#x2F; FIXME: The client should be told about ignored non-quick redirects, too.
        if (m_quickRedirectComing)
            clientRedirectCancelledOrFinished(false);

        setPolicyDocumentLoader(nullptr);

        &#x2F;&#x2F; If the navigation request came from the back&#x2F;forward menu, and we punt on it, we have the 
        &#x2F;&#x2F; problem that we have optimistically moved the b&#x2F;f cursor already, so move it back. For sanity,
        &#x2F;&#x2F; we only do this when punting a navigation for the target frame or top-level frame.  
        if ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) &#123;
            if (Page* page &#x3D; m_frame.page()) &#123;
                if (HistoryItem* resetItem &#x3D; m_frame.mainFrame().loader().history().currentItem()) &#123;
                    page-&gt;backForward().setCurrentItem(resetItem);
                    m_frame.loader().client().updateGlobalHistoryItemForPage();
                &#125;
            &#125;
        &#125;
        return;
    &#125;

    FrameLoadType type &#x3D; policyChecker().loadType();
    &#x2F;&#x2F; A new navigation is in progress, so don&#39;t clear the history&#39;s provisional item.
    stopAllLoaders(ShouldNotClearProvisionalItem);
    
    &#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()
    &#x2F;&#x2F; might detach the current FrameLoader, in which case we should bail on this newly defunct load. 
    if (!m_frame.page())
        return;
    
    &#x2F;&#x2F;把 DocumentLoader 赋值给 m_provisionalDocumentLoader
    setProvisionalDocumentLoader(m_policyDocumentLoader.get());
    m_loadType &#x3D; type;
    &#x2F;&#x2F;设置 FrameLoader 状态为 Provisional
    setState(FrameStateProvisional);

    setPolicyDocumentLoader(nullptr);

    if (isBackForwardLoadType(type)) &#123;
        auto&amp; diagnosticLoggingClient &#x3D; m_frame.page()-&gt;diagnosticLoggingClient();
        if (history().provisionalItem()-&gt;isInPageCache()) &#123;
            diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);
            loadProvisionalItemFromCachedPage();
            return;
        &#125;
        diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);
    &#125;

    if (!formState) &#123;
        continueLoadAfterWillSubmitForm();
        return;
    &#125;

    m_client.dispatchWillSubmitForm(*formState, [this] (PolicyAction action) &#123;
        policyChecker().continueLoadAfterWillSubmitForm(action);
    &#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。</p>
<h3 id="WebKit-网络处理"><a href="#WebKit-网络处理" class="headerlink" title="WebKit 网络处理"></a>WebKit 网络处理</h3><p>WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore&#x2F;platform&#x2F;network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。</p>
<h3 id="ResourceHandle-的相关类"><a href="#ResourceHandle-的相关类" class="headerlink" title="ResourceHandle 的相关类"></a>ResourceHandle 的相关类</h3><p><img src="/uploads/deeply-analyse-webkit/31.png" alt="31" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/31.png" class="lozad post-image"></p>
<ul>
<li>ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。</li>
<li>MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存</li>
<li>SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。</li>
<li>ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。</li>
</ul>
<h3 id="ResourceHandleClient"><a href="#ResourceHandleClient" class="headerlink" title="ResourceHandleClient"></a>ResourceHandleClient</h3><p>ResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class ResourceHandleClient &#123;
public:
    WEBCORE_EXPORT ResourceHandleClient();
    WEBCORE_EXPORT virtual ~ResourceHandleClient();

    WEBCORE_EXPORT virtual ResourceRequest willSendRequest(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);
    virtual void didSendData(ResourceHandle*, unsigned long long &#x2F;*bytesSent*&#x2F;, unsigned long long &#x2F;*totalBytesToBeSent*&#x2F;) &#123; &#125;
    
    &#x2F;&#x2F;收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功
    virtual void didReceiveResponse(ResourceHandle*, ResourceResponse&amp;&amp;) &#123; &#125;
    &#x2F;&#x2F;收到服务器端包含请求数据的响应包
    virtual void didReceiveData(ResourceHandle*, const char*, unsigned, int &#x2F;*encodedDataLength*&#x2F;) &#123; &#125;
    WEBCORE_EXPORT virtual void didReceiveBuffer(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, int encodedDataLength);
    &#x2F;&#x2F;接受过程结束
    virtual void didFinishLoading(ResourceHandle*) &#123; &#125;
    &#x2F;&#x2F;接受失败
    virtual void didFail(ResourceHandle*, const ResourceError&amp;) &#123; &#125;
    virtual void wasBlocked(ResourceHandle*) &#123; &#125;
    virtual void cannotShowURL(ResourceHandle*) &#123; &#125;

    virtual bool usesAsyncCallbacks() &#123; return false; &#125;

    virtual bool loadingSynchronousXHR() &#123; return false; &#125;

    &#x2F;&#x2F; Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready.
    WEBCORE_EXPORT virtual void willSendRequestAsync(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;);

    &#x2F;&#x2F; Client will call ResourceHandle::continueDidReceiveResponse() when ready.
    WEBCORE_EXPORT virtual void didReceiveResponseAsync(ResourceHandle*, ResourceResponse&amp;&amp;);

#if USE(PROTECTION_SPACE_AUTH_CALLBACK)
    &#x2F;&#x2F; Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready.
    WEBCORE_EXPORT virtual void canAuthenticateAgainstProtectionSpaceAsync(ResourceHandle*, const ProtectionSpace&amp;);
#endif
    &#x2F;&#x2F; Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.
#if USE(CFURLCONNECTION)
    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, CFCachedURLResponseRef);
#elif PLATFORM(COCOA)
    WEBCORE_EXPORT virtual void willCacheResponseAsync(ResourceHandle*, NSCachedURLResponse *);
#endif

#if USE(SOUP)
    virtual char* getOrCreateReadBuffer(size_t &#x2F;*requestedLength*&#x2F;, size_t&amp; &#x2F;*actualLength*&#x2F;) &#123; return 0; &#125;
#endif

    virtual bool shouldUseCredentialStorage(ResourceHandle*) &#123; return false; &#125;
    virtual void didReceiveAuthenticationChallenge(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;
#if USE(PROTECTION_SPACE_AUTH_CALLBACK)
    virtual bool canAuthenticateAgainstProtectionSpace(ResourceHandle*, const ProtectionSpace&amp;) &#123; return false; &#125;
#endif
    virtual void receivedCancellation(ResourceHandle*, const AuthenticationChallenge&amp;) &#123; &#125;

#if PLATFORM(IOS) || USE(CFURLCONNECTION)
    virtual RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) &#123; return nullptr; &#125;
#endif

#if USE(CFURLCONNECTION)
    virtual CFCachedURLResponseRef willCacheResponse(ResourceHandle*, CFCachedURLResponseRef response) &#123; return response; &#125;
#if PLATFORM(WIN)
    virtual bool shouldCacheResponse(ResourceHandle*, CFCachedURLResponseRef) &#123; return true; &#125;
#endif &#x2F;&#x2F; PLATFORM(WIN)

#elif PLATFORM(COCOA)
    virtual NSCachedURLResponse *willCacheResponse(ResourceHandle*, NSCachedURLResponse *response) &#123; return response; &#125;
#endif
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与 ResourceHandleClient 相关的类如下<br><img src="/uploads/deeply-analyse-webkit/80.png" alt="80" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/80.png" class="lozad post-image"></p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="/uploads/deeply-analyse-webkit/98.png" alt="98" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/98.png" class="lozad post-image"></p>
<p><img src="/uploads/deeply-analyse-webkit/32.png" alt="32" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/32.png" class="lozad post-image"></p>
<h4 id="MainResourceLoader-的加载顺序"><a href="#MainResourceLoader-的加载顺序" class="headerlink" title="MainResourceLoader 的加载顺序"></a>MainResourceLoader 的加载顺序</h4><p>MainResourceLoader 加载的是 html 文本资源。<br><img src="/uploads/deeply-analyse-webkit/79.png" alt="79" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/79.png" class="lozad post-image"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MainResourceLoader::load
MainResourceLoader::loadNow
MainResourceLoader::willSendRequest
ResourceLoader::willSendRequest &#x2F;&#x2F;基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。
PolicyChecker::checkNavigationPolicy &#x2F;&#x2F;检查 NavigationPolicy 可以过滤一些重复的请求
ResourceHandle::create 开始发网络请求
MainResourceLoader::didReceiveResponse &#x2F;&#x2F;主资源收到第一个 HTTP 的响应回调，处理 HTTP header
PolicyChecker:: checkContentPolicy &#x2F;&#x2F;进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求
MainResourceLoader::continueAfterContentPolicy &#x2F;&#x2F;看看 ContentPolicy 检查后是否有错误
ResourceLoader::didReceiveResponse &#x2F;&#x2F;基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient
MainResourceLoader::didReceiveData &#x2F;&#x2F;主资源开始接受 body 数据
ResourceLoader::didReceiveData &#x2F;&#x2F;基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient
MainResourceLoader::addData
DocumentLoader::receivedData
DocumentLoader::commitLoad
FrameLoader::commitProvisionalLoad &#x2F;&#x2F;从 provisional 状态到 Committed 状态
FrameLoaderClientQt::committedLoad
DocumentLoader::commitData
DocumentWriter::setEncoding
DocumentWriter::addData
DocumentParser::appendByte
DecodedDataDocumentParser::appendBytes &#x2F;&#x2F;编码处理
HTMLDocumentParser::append &#x2F;&#x2F;解析 HTML
MainResourceLoader::didFinishLoading
FrameLoader::finishedLoading
DocumentLoader::finishedLoading
FrameLoader::finishedLoadingDocument
DocumentWriter::end
Document::finishParsing
HTMLDocumentParser::finish<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。</p>
<p>在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ResourceLoader::addDataOrBuffer(const char* data, unsigned length, SharedBuffer* buffer, DataPayloadType dataPayloadType)
&#123;
    if (m_options.dataBufferingPolicy &#x3D;&#x3D; DoNotBufferData)
        return;

    if (!m_resourceData || dataPayloadType &#x3D;&#x3D; DataPayloadWholeResource) &#123;
        if (buffer)
            m_resourceData &#x3D; buffer;
        else
            m_resourceData &#x3D; SharedBuffer::create(data, length);
        return;
    &#125;
    
    if (buffer)
        m_resourceData-&gt;append(*buffer);
    else
        m_resourceData-&gt;append(data, length);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DocumentLoader::commitLoad(const char* data, int length)
&#123;
    &#x2F;&#x2F; Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource
    &#x2F;&#x2F; by starting a new load, so retain temporarily.
    RefPtr&lt;Frame&gt; protectedFrame(m_frame);
    Ref&lt;DocumentLoader&gt; protectedThis(*this);

    commitIfReady();
    FrameLoader* frameLoader &#x3D; DocumentLoader::frameLoader();
    if (!frameLoader)
        return;
#if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
    if (ArchiveFactory::isArchiveMimeType(response().mimeType()))
        return;
#endif
    &#x2F;&#x2F;FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态
    frameLoader-&gt;client().committedLoad(this, data, length);

    if (isMultipartReplacingLoad())
        frameLoader-&gt;client().didReplaceMultipartContent();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DocumentWriter::begin(const URL&amp; urlReference, bool dispatch, Document* ownerDocument)
&#123;
    &#x2F;&#x2F; We grab a local copy of the URL because it&#39;s easy for callers to supply
    &#x2F;&#x2F; a URL that will be deallocated during the execution of this function.
    &#x2F;&#x2F; For example, see &lt;https:&#x2F;&#x2F;bugs.webkit.org&#x2F;show_bug.cgi?id&#x3D;66360&gt;.
    URL url &#x3D; urlReference;

    &#x2F;&#x2F; Create a new document before clearing the frame, because it may need to
    &#x2F;&#x2F; inherit an aliased security context.
    &#x2F;&#x2F;创建了 Document 对象
    Ref&lt;Document&gt; document &#x3D; createDocument(url);
    
    &#x2F;&#x2F; If the new document is for a Plugin but we&#39;re supposed to be sandboxed from Plugins,
    &#x2F;&#x2F; then replace the document with one whose parser will ignore the incoming data (bug 39323)
    if (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins))
        document &#x3D; SinkDocument::create(m_frame, url);

    &#x2F;&#x2F; FIXME: Do we need to consult the content security policy here about blocked plug-ins?

    bool shouldReuseDefaultView &#x3D; m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url);
    if (shouldReuseDefaultView)
        document-&gt;takeDOMWindowFrom(m_frame-&gt;document());
    else
        document-&gt;createDOMWindow();

    &#x2F;&#x2F; Per &lt;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;upgrade-insecure-requests&#x2F;&gt;, we need to retain an ongoing set of upgraded
    &#x2F;&#x2F; requests in new navigation contexts. Although this information is present when we construct the
    &#x2F;&#x2F; Document object, it is discard in the subsequent &#39;clear&#39; statements below. So, we must capture it
    &#x2F;&#x2F; so we can restore it.
    HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade;
    if (auto* existingDocument &#x3D; m_frame-&gt;document())
        insecureNavigationRequestsToUpgrade &#x3D; existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade();
    
    m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView);
    clear();

    &#x2F;&#x2F; m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document.
    &#x2F;&#x2F; Bail out if document has no view.
    if (!document-&gt;view())
        return;

    if (!shouldReuseDefaultView)
        m_frame-&gt;script().updatePlatformScriptObjects();

    m_frame-&gt;loader().setOutgoingReferrer(url);
    m_frame-&gt;setDocument(document.copyRef());

    document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade));

    if (m_decoder)
        document-&gt;setDecoder(m_decoder.get());
    if (ownerDocument) &#123;
        document-&gt;setCookieURL(ownerDocument-&gt;cookieURL());
        document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy());
        document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode());
    &#125;

    m_frame-&gt;loader().didBeginDocument(dispatch);

    document-&gt;implicitOpen();

    &#x2F;&#x2F; We grab a reference to the parser so that we&#39;ll always send data to the
    &#x2F;&#x2F; original parser, even if the document acquires a new parser (e.g., via
    &#x2F;&#x2F; document.open).
    m_parser &#x3D; document-&gt;parser();

    if (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView())
        m_frame-&gt;view()-&gt;setContentsSize(IntSize());

    m_state &#x3D; StartedWritingState;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, const char* data, size_t length)
&#123;
    if (!length)
        return;
    
    &#x2F;&#x2F;解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。
    String decoded &#x3D; writer.createDecoderIfNeeded()-&gt;decode(data, length);
    if (decoded.isEmpty())
        return;
    &#x2F;&#x2F;解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步
    writer.reportDataReceived();
    append(decoded.releaseImpl());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。</p>
<p>下面看看解码的流程：<br><img src="/uploads/deeply-analyse-webkit/85.png" alt="85" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/85.png" class="lozad post-image"><br>decoder 的类图如下:<br><img src="/uploads/deeply-analyse-webkit/86.png" alt="86" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/86.png" class="lozad post-image"></p>
<h4 id="SubResourceLoader-的加载顺序"><a href="#SubResourceLoader-的加载顺序" class="headerlink" title="SubResourceLoader 的加载顺序"></a>SubResourceLoader 的加载顺序</h4><p>SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下：<br><img src="/uploads/deeply-analyse-webkit/81.png" alt="81" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/81.png" class="lozad post-image"></p>
<p>会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)
&#123;
    auto&amp; localName &#x3D; token.name();
    &#x2F;&#x2F; FIXME: This can&#39;t use HTMLConstructionSite::createElement because we
    &#x2F;&#x2F; have to pass the current form element.  We should rework form association
    &#x2F;&#x2F; to occur after construction to allow better code sharing here.
    &#x2F;&#x2F; http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;tree-construction.html#create-an-element-for-the-token
    Document&amp; ownerDocument &#x3D; ownerDocumentForCurrentNode();
    bool insideTemplateElement &#x3D; !ownerDocument.frame();
    &#x2F;&#x2F;将 tagName 和节点构造创建成 HTMLImageElement
    RefPtr&lt;Element&gt; element &#x3D; HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);
    if (UNLIKELY(!element)) &#123;
        auto* window &#x3D; ownerDocument.domWindow();
        if (customElementInterface &amp;&amp; window) &#123;
            auto* registry &#x3D; window-&gt;customElementRegistry();
            if (UNLIKELY(registry)) &#123;
                if (auto* elementInterface &#x3D; registry-&gt;findInterface(localName)) &#123;
                    *customElementInterface &#x3D; elementInterface;
                    return nullptr;
                &#125;
            &#125;
        &#125;

        QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI);
        if (Document::validateCustomElementName(localName) &#x3D;&#x3D; CustomElementNameValidationStatus::Valid) &#123;
            element &#x3D; HTMLElement::create(qualifiedName, ownerDocument);
            element-&gt;setIsCustomElementUpgradeCandidate();
        &#125; else
            element &#x3D; HTMLUnknownElement::create(qualifiedName, ownerDocument);
    &#125;
    ASSERT(element);

    &#x2F;&#x2F; FIXME: This is a hack to connect images to pictures before the image has
    &#x2F;&#x2F; been inserted into the document. It can be removed once asynchronous image
    &#x2F;&#x2F; loading is working.
    if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))
        downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));
    &#x2F;&#x2F;设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载
    setAttributes(*element, token, m_parserContentPolicy);
    ASSERT(element-&gt;isHTMLElement());
    return element;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HTMLImageElement::selectImageSource()
&#123;
    &#x2F;&#x2F; First look for the best fit source from our &lt;picture&gt; parent if we have one.
    ImageCandidate candidate &#x3D; bestFitSourceFromPictureElement();
    if (candidate.isEmpty()) &#123;
        &#x2F;&#x2F; If we don&#39;t have a &lt;picture&gt; or didn&#39;t find a source, then we use our own attributes.
        auto sourceSize &#x3D; SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).string(), document()).length();
        candidate &#x3D; bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);
    &#125;
    setBestFitURLAndDPRFromImageCandidate(candidate);
    &#x2F;&#x2F;updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源
    m_imageLoader.updateFromElementIgnoringPreviousError();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图：<br><img src="/uploads/deeply-analyse-webkit/33.png" alt="33" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/33.png" class="lozad post-image"></p>
<p>ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理<br><img src="/uploads/deeply-analyse-webkit/34.png" alt="34" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/34.png" class="lozad post-image"></p>
<ul>
<li>Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。</li>
<li>CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。</li>
<li>MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap &lt;String,CachedResource&gt; m_resources;</li>
</ul>
<p>在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum RevalidationPolicy &#123; Use, Revalidate, Reload, Load &#125;;
    RevalidationPolicy determineRevalidationPolicy(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption) const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RevalidationPolicy policy &#x3D; determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
switch (policy) &#123;
case Reload:
    memoryCache.remove(*resource);
    FALLTHROUGH;
case Load:
    if (resource)
        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());
    resource &#x3D; loadResource(type, WTFMove(request));
    break;
case Revalidate:
    if (resource)
        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());
    resource &#x3D; revalidateResource(WTFMove(request), *resource);
    break;
case Use:
    ASSERT(resource);
    if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) &#123;
        resource &#x3D; updateCachedResourceWithCurrentRequest(*resource, WTFMove(request));
        if (resource-&gt;status() !&#x3D; CachedResource::Status::Cached)
            policy &#x3D; Load;
    &#125; else &#123;
        ResourceError error;
        if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
            return makeUnexpected(WTFMove(error));
        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());
        loadTiming.setResponseEnd(MonotonicTime::now());

        memoryCache.resourceAccessed(*resource);

        if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) &#123;
            auto resourceTiming &#x3D; ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
            if (initiatorContext &#x3D;&#x3D; InitiatorContext::Worker) &#123;
                ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
                downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
            &#125; else &#123;
                ASSERT(initiatorContext &#x3D;&#x3D; InitiatorContext::Document);
                m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());
                m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
            &#125;
        &#125;

        if (forPreload &#x3D;&#x3D; ForPreload::No)
            resource-&gt;setLoadPriority(request.priority());
    &#125;
    break;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。</p>
<p>CachedResource 加载<br>CachedResource 实现了 RFC2616 <a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html</a> 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示：<br><img src="/uploads/deeply-analyse-webkit/35.png" alt="35" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/35.png" class="lozad post-image"></p>
<p>会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。</p>
<p>在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)
&#123;
    switch (type) &#123;
    case CachedResource::MainResource:
        return ResourceLoadPriority::VeryHigh;
    case CachedResource::CSSStyleSheet:
    case CachedResource::Script:
        return ResourceLoadPriority::High;
#if ENABLE(SVG_FONTS)
    case CachedResource::SVGFontResource:
#endif
    case CachedResource::MediaResource:
    case CachedResource::FontResource:
    case CachedResource::RawResource:
    case CachedResource::Icon:
        return ResourceLoadPriority::Medium;
    case CachedResource::ImageResource:
        return ResourceLoadPriority::Low;
#if ENABLE(XSLT)
    case CachedResource::XSLStyleSheet:
        return ResourceLoadPriority::High;
#endif
    case CachedResource::SVGDocumentResource:
        return ResourceLoadPriority::Low;
    case CachedResource::Beacon:
        return ResourceLoadPriority::VeryLow;
#if ENABLE(LINK_PREFETCH)
    case CachedResource::LinkPrefetch:
        return ResourceLoadPriority::VeryLow;
    case CachedResource::LinkSubresource:
        return ResourceLoadPriority::VeryLow;
#endif
#if ENABLE(VIDEO_TRACK)
    case CachedResource::TextTrackResource:
        return ResourceLoadPriority::Low;
#endif
    &#125;
    ASSERT_NOT_REACHED();
    return ResourceLoadPriority::Low;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader)
&#123;
    ASSERT(resourceLoader);

#if PLATFORM(IOS)
    &#x2F;&#x2F; If there&#39;s a web archive resource for this URL, we don&#39;t need to schedule the load since it will never touch the network.
    if (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) &#123;
        resourceLoader-&gt;startLoading();
        return;
    &#125;
#else
    if (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) &#123;
        resourceLoader-&gt;start();
        return;
    &#125;
#endif

&#x2F;&#x2F;根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里
#if PLATFORM(IOS)
    HostInformation* host &#x3D; hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);
#else
    HostInformation* host &#x3D; hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);
#endif

    ResourceLoadPriority priority &#x3D; resourceLoader-&gt;request().priority();

    bool hadRequests &#x3D; host-&gt;hasRequests();
    &#x2F;&#x2F;把优先级存放到 host 的 m_requestsPending 属性里
    host-&gt;schedule(resourceLoader, priority);

#if PLATFORM(COCOA) || USE(CFURLCONNECTION)
    if (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) &#123;
        &#x2F;&#x2F; Serve all requests at once to keep the pipeline full at the network layer.
        &#x2F;&#x2F; FIXME: Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms?
        servePendingRequests(host, ResourceLoadPriority::VeryLow);
        return;
    &#125;
#endif

&#x2F;&#x2F;这里就是如何根据优先级来进行安排的
#if PLATFORM(IOS)
    if ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority &#x3D;&#x3D; ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) &#123;
        &#x2F;&#x2F;重要资源立刻进行
        servePendingRequests(host, priority);
        return;
    &#125;
#else
    if (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority &#x3D;&#x3D; ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &#123;
        &#x2F;&#x2F;重要资源立刻进行
        servePendingRequests(host, priority);
        return;
    &#125;
#endif

    &#x2F;&#x2F; Handle asynchronously so early low priority requests don&#39;t
    &#x2F;&#x2F; get scheduled before later high priority ones.
    &#x2F;&#x2F;不重要的就延迟进行，然后根据优先级，由高到低依次加载
    scheduleServePendingRequests();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority)
&#123;
    auto priority &#x3D; ResourceLoadPriority::Highest;
    while (true) &#123;
        auto&amp; requestsPending &#x3D; host-&gt;requestsPending(priority);
        while (!requestsPending.isEmpty()) &#123;
            RefPtr&lt;ResourceLoader&gt; resourceLoader &#x3D; requestsPending.first();

            &#x2F;&#x2F; For named hosts - which are only http(s) hosts - we should always enforce the connection limit.
            &#x2F;&#x2F; For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn&#39;t done parsing 
            &#x2F;&#x2F; and we don&#39;t know all stylesheets yet.
            Document* document &#x3D; resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : 0;
            bool shouldLimitRequests &#x3D; !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded()));
            if (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority))
                return;

            requestsPending.removeFirst();
            host-&gt;addLoadInProgress(resourceLoader.get());
#if PLATFORM(IOS)
            if (!IOSApplication::isWebProcess()) &#123;
                resourceLoader-&gt;startLoading();
                return;
            &#125;
#endif
            &#x2F;&#x2F;在这个函数里创建了 ResourceHandle
            resourceLoader-&gt;start();
        &#125;
        if (priority &#x3D;&#x3D; minimumPriority)
            return;
        --priority;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void SubresourceLoader::didReceiveDataOrBuffer(const char* data, int length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, long long encodedDataLength, DataPayloadType dataPayloadType)
&#123;
    ASSERT(m_resource);

    if (m_resource-&gt;response().httpStatusCode() &gt;&#x3D; 400 &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())
        return;
    ASSERT(!m_resource-&gt;resourceToRevalidate());
    ASSERT(!m_resource-&gt;errorOccurred());
    ASSERT(m_state &#x3D;&#x3D; Initialized);
    &#x2F;&#x2F; Reference the object in this method since the additional processing can do
    &#x2F;&#x2F; anything including removing the last reference to this object; one example of this is 3266216.
    Ref&lt;SubresourceLoader&gt; protectedThis(*this);
    
    &#x2F;&#x2F;ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里
    ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);

    if (!m_loadingMultipartContent) &#123;
        if (auto* resourceData &#x3D; this-&gt;resourceData())
            m_resource-&gt;addDataBuffer(*resourceData);
        else
            m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以 image 为例如图所示：<br><img src="/uploads/deeply-analyse-webkit/36.png" alt="36" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/36.png" class="lozad post-image"></p>
<p>举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。</p>
<p>CacheImage 的加载过程如下图：<br><img src="/uploads/deeply-analyse-webkit/82.png" alt="82" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/82.png" class="lozad post-image"></p>
<p>具体调用方法顺序如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">HTMLImageElement::create &#x2F;&#x2F;解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象
ImageLoader::updateFromElementIgnoringPreviousError &#x2F;&#x2F;解析到 img 的 href 属性
ImageLoader::updateFromElement
CachedResourceLoader::requestImage
CachedResourceLoader::requestResource &#x2F;&#x2F;判断是否从缓存读取，还是网络获取
CachedResourceLoader::loadResource &#x2F;&#x2F;创建不同类型的 CachedResource，这里是 CachedImage
MemoryCache::add &#x2F;&#x2F;创建对应的 cache 项目
CachedImage::load
CachedResource::load
CachedResourceLoader::load
CachedResourceRequest::load
ResourceLoaderScheduler::scheduleSubresourceLoad
SubresourceLoader::create
ResourceLoadScheduler::requestTimerFired
ResourceLoader::start
ResourceHandle::create
ResourceLoader::didReceiveResponse &#x2F;&#x2F;收到 HTTP Header 的 response
SubresourceLoader::didiReceiveResponse
CachedResourceRequest::didReceiveResponse &#x2F;&#x2F;处理响应
ResourceLoader::didReceiveResponse
ResourceLoader::didReceiveData &#x2F;&#x2F;收到 body 数据
SubresourceLoader::didReceiveData
ResourceLoader::didReceiveData
ResourceLoader::addData
CachedResourceRequest::didReceiveData
ResourceLoader::didFinishLoading &#x2F;&#x2F;数据读取完成
SubresourceLoader::didFinishLoading
CachedResourceRequest::didFinishLoading
CachedResource::finish
CachedResourceLoader::loadDone
CachedImage::data &#x2F;&#x2F;创建 Image 对象，进行解码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以用下图概括下：<br><img src="/uploads/deeply-analyse-webkit/51.png" alt="51" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/51.png" class="lozad post-image"><br>一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。</p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。</p>
<h3 id="WebKit-的-Cache"><a href="#WebKit-的-Cache" class="headerlink" title="WebKit 的 Cache"></a>WebKit 的 Cache</h3><p>WebKit 主要有三种 Cache。</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (!m_frame.tree().parent() &amp;&amp; history().currentItem()) &#123;
    &#x2F;&#x2F; Check to see if we need to cache the page we are navigating away from into the back&#x2F;forward cache.
    &#x2F;&#x2F; We are doing this here because we know for sure that a new page is about to be loaded.
    PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());

    WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void PageCache::addIfCacheable(HistoryItem&amp; item, Page* page)
&#123;
    if (item.isInPageCache())
        return;

    if (!page || !canCache(*page))
        return;

    ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), &quot;Utility pages such as SVGImage pages should never go into PageCache&quot;);

    setPageCacheState(*page, Document::AboutToEnterPageCache);

    &#x2F;&#x2F; Focus the main frame, defocusing a focused subframe (if we have one). We do this here,
    &#x2F;&#x2F; before the page enters the page cache, while we still can dispatch DOM blur&#x2F;focus events.
    if (page-&gt;focusController().focusedFrame())
        page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());

    &#x2F;&#x2F; Fire the pagehide event in all frames.
    firePageHideEventRecursively(page-&gt;mainFrame());

    &#x2F;&#x2F; Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers
    &#x2F;&#x2F; could have altered the page in a way that could prevent caching.
    if (!canCache(*page)) &#123;
        setPageCacheState(*page, Document::NotInPageCache);
        return;
    &#125;

    destroyRenderTree(page-&gt;mainFrame());

    setPageCacheState(*page, Document::InPageCache);

    &#x2F;&#x2F; Make sure we no longer fire any JS events past this point.
    NoEventDispatchAssertion assertNoEventDispatch;
    &#x2F;&#x2F;创建一个新的 CachedPage 存放到 HistoryItem 里
    item.m_cachedPage &#x3D; std::make_unique&lt;CachedPage&gt;(*page);
    item.m_pruningReason &#x3D; PruningReason::None;
    &#x2F;&#x2F;将 HistoryItem 添加到 m_items 列表中
    m_items.add(&amp;item);
    
    &#x2F;&#x2F;检查是否有超过回收的限制，进行资源回收
    prune(PruningReason::ReachedMaxSize);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：<br><img src="/uploads/deeply-analyse-webkit/83.png" alt="83" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/83.png" class="lozad post-image"><br>Memory Cache 有三个比较重要的属性。</p>
<ul>
<li>m_resources：类型是 HashMap，key 是 url，值是 CacheResource。</li>
<li>m_allResources：采用的是 LRU 算法，类型是 Vector&lt;LRUList,32&gt; 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。</li>
<li>m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。</p>
<h2 id="HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><a href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token" class="headerlink" title="HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token"></a>HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</h2><h3 id="解析成-HTML-Token-的算法"><a href="#解析成-HTML-Token-的算法" class="headerlink" title="解析成 HTML Token 的算法"></a>解析成 HTML Token 的算法</h3><p><img src="/uploads/deeply-analyse-webkit/17.png" alt="17" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/17.png" class="lozad post-image"><br>初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。</p>
<p>在 Tag open state 状态时如果碰到 &#x2F; 字符那么就会创建 End tag token，同时状态变成 Tag name state。</p>
<p>在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。</p>
<p>HTMLToken 的所有类型定义在 HTMLToken.h 里</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum Type &#123;
    Uninitialized, &#x2F;&#x2F;默认类型
    DOCTYPE,       &#x2F;&#x2F;文档类型
    StartTag,      &#x2F;&#x2F;起始标签
    EndTag,        &#x2F;&#x2F;结束标签
    Comment,       &#x2F;&#x2F;注释
    Character,     &#x2F;&#x2F;元素内容
    EndOfFile,     &#x2F;&#x2F;文档结束
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">private:
    Type m_type;       &#x2F;&#x2F;那种类型

    DataVector m_data; &#x2F;&#x2F;根据类型来，不同类型内容不一样
    UChar m_data8BitCheck;

    &#x2F;&#x2F; For StartTag and EndTag
    bool m_selfClosing;            &#x2F;&#x2F;是否是自封闭
    AttributeList m_attributes;    &#x2F;&#x2F;属性列表
    Attribute* m_currentAttribute; &#x2F;&#x2F;当前属性

    &#x2F;&#x2F; For DOCTYPE
    std::unique_ptr&lt;DoctypeData&gt; m_doctypeData;

    unsigned m_attributeBaseOffset &#123; 0 &#125;; &#x2F;&#x2F; Changes across document.write() boundaries.
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型<br><img src="/uploads/deeply-analyse-webkit/28.png" alt="28" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/28.png" class="lozad post-image"></p>
<p>HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：<a target="_blank" rel="noopener" href="https://dev.w3.org/html5/spec-preview/tokenization.html">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;HTML 有限状态机的状态非空集合
enum State &#123;
    DataState, &#x2F;&#x2F;初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character
    CharacterReferenceInDataState,
    RCDATAState,
    CharacterReferenceInRCDATAState,
    RAWTEXTState,
    ScriptDataState,
    PLAINTEXTState,
    TagOpenState, &#x2F;&#x2F;碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里
    EndTagOpenState, &#x2F;&#x2F;TagOpenState 状态碰见 &#x2F; 进入。HTMLToken 的 type 为 endTag
    TagNameState, &#x2F;&#x2F;在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag

    RCDATALessThanSignState,
    RCDATAEndTagOpenState,
    RCDATAEndTagNameState,

    RAWTEXTLessThanSignState,
    RAWTEXTEndTagOpenState,
    RAWTEXTEndTagNameState,

    ScriptDataLessThanSignState,
    ScriptDataEndTagOpenState,
    ScriptDataEndTagNameState,
    ScriptDataEscapeStartState,
    ScriptDataEscapeStartDashState,
    ScriptDataEscapedState,
    ScriptDataEscapedDashState,
    ScriptDataEscapedDashDashState,
    ScriptDataEscapedLessThanSignState,
    ScriptDataEscapedEndTagOpenState,
    ScriptDataEscapedEndTagNameState,
    ScriptDataDoubleEscapeStartState,
    ScriptDataDoubleEscapedState,
    ScriptDataDoubleEscapedDashState,
    ScriptDataDoubleEscapedDashDashState,
    ScriptDataDoubleEscapedLessThanSignState,
    ScriptDataDoubleEscapeEndState,

    BeforeAttributeNameState, &#x2F;&#x2F;TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname
    AttributeNameState, &#x2F;&#x2F;BeforeAttributeNameState 碰见字母进入
    AfterAttributeNameState,
    BeforeAttributeValueState, &#x2F;&#x2F;AttributeNameState 状态碰到 &#x3D; 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的
    AttributeValueDoubleQuotedState, &#x2F;&#x2F;BeforeAttributeValueState 碰到 &quot; 符号
    AttributeValueSingleQuotedState, &#x2F;&#x2F;BeforeAttributeValueState 碰到 &#39; 符号
    AttributeValueUnquotedState,
    CharacterReferenceInAttributeValueState,
    AfterAttributeValueQuotedState, &#x2F;&#x2F; 再次碰到 &quot; 或 &#39; 符号。HTMLToken 记录属性的值
    SelfClosingStartTagState,
    BogusCommentState,
    ContinueBogusCommentState, &#x2F;&#x2F; Not in the HTML spec, used internally to track whether we started the bogus comment token.
    MarkupDeclarationOpenState, &#x2F;&#x2F;TagOpenState 后遇到! 比如&lt;!

    &#x2F;&#x2F;解析comment
    CommentStartState, &#x2F;&#x2F;MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT
    CommentStartDashState,
    CommentState, &#x2F;&#x2F;CommentStartState 碰到字母进入这个状态
    CommentEndDashState, &#x2F;&#x2F;在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容
    CommentEndState, &#x2F;&#x2F;在 CommentEndDashState 状态碰见 - 进入
    CommentEndBangState,

    &#x2F;&#x2F;解析 &lt;!DOCTYPE html PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD XHTML 1.0 Transitional&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;xhtml1&#x2F;DTD&#x2F;xhtml1-strict.dtd&quot;&gt; 这种标签
    DOCTYPEState, &#x2F;&#x2F;匹配到 DOCTYPE，&lt;!DOCTYPE
    BeforeDOCTYPENameState, &#x2F;&#x2F;DOCTYPE 状态后遇到空格
    DOCTYPENameState, &#x2F;&#x2F;BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html
    AfterDOCTYPENameState, &#x2F;&#x2F;DOCTYPENameState 遇到空格 &lt;!DOCTYPE html
    AfterDOCTYPEPublicKeywordState, &#x2F;&#x2F;AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC
    BeforeDOCTYPEPublicIdentifierState, &#x2F;&#x2F;AfterDOCTYPEPublicKeywordState 状态后碰到空格
    DOCTYPEPublicIdentifierDoubleQuotedState, &#x2F;&#x2F;BeforeDOCTYPEPublicIdentifierState 状态碰到 &quot; 进入
    DOCTYPEPublicIdentifierSingleQuotedState, &#x2F;&#x2F;BeforeDOCTYPEPublicIdentifierState 状态碰到 &#39; 进入
    AfterDOCTYPEPublicIdentifierState, &#x2F;&#x2F;再次遇到 &quot; 或 &#39; 。可将 HTMLToken 的 m_publicIdentifier 确定
    BetweenDOCTYPEPublicAndSystemIdentifiersState, 
    AfterDOCTYPESystemKeywordState,
    BeforeDOCTYPESystemIdentifierState,
    DOCTYPESystemIdentifierDoubleQuotedState,
    DOCTYPESystemIdentifierSingleQuotedState,
    AfterDOCTYPESystemIdentifierState,
    BogusDOCTYPEState,
    CDATASectionState,

    &#x2F;&#x2F; These CDATA states are not in the HTML5 spec, but we use them internally.
    CDATASectionRightSquareBracketState,
    CDATASectionDoubleRightSquareBracketState,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程：<br><img src="/uploads/deeply-analyse-webkit/55.png" alt="55" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/55.png" class="lozad post-image"></p>
<h2 id="HTML-语法解析"><a href="#HTML-语法解析" class="headerlink" title="HTML 语法解析"></a>HTML 语法解析</h2><h3 id="HTML-的语法定义"><a href="#HTML-的语法定义" class="headerlink" title="HTML 的语法定义"></a>HTML 的语法定义</h3><p>HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：<a target="_blank" rel="noopener" href="https://www.w3.org/TR/html4/strict.dtd">https://www.w3.org/TR/html4/strict.dtd</a></p>
<h3 id="相关类关系图"><a href="#相关类关系图" class="headerlink" title="相关类关系图"></a>相关类关系图</h3><p><img src="/uploads/deeply-analyse-webkit/09.png" alt="09" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/09.png" class="lozad post-image"></p>
<ul>
<li>Document 和 DocumentParser 相互引用</li>
<li>HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。</li>
<li>HTMLInputStream：解码后的字符流的保存，作为缓冲区。</li>
<li>HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。</li>
<li>HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。</li>
<li>HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用</li>
<li>HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。</li>
<li>HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="/uploads/deeply-analyse-webkit/10.png" alt="10" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/10.png" class="lozad post-image"></p>
<ul>
<li><p>DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。</p>
</li>
<li><p>HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。</p>
</li>
<li><p>把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements%E3%80%82HTMLConstructionSite">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite</a> 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。</p>
</li>
<li><p>然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。</p>
</li>
</ul>
<h3 id="Element-属性设置"><a href="#Element-属性设置" class="headerlink" title="Element 属性设置"></a>Element 属性设置</h3><p>是通过 Element::parserSetAttributes 来设置的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Element::parserSetAttributes(const Vector&lt;Attribute&gt;&amp; attributeVector)
&#123;
    ASSERT(!isConnected());
    ASSERT(!parentNode());
    ASSERT(!m_elementData);

    if (!attributeVector.isEmpty()) &#123;
        if (document().sharedObjectPool())
            m_elementData &#x3D; document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);
        else
            m_elementData &#x3D; ShareableElementData::createWithAttributes(attributeVector);

    &#125;

    parserDidSetAttributes();

    &#x2F;&#x2F; Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.
    for (const auto&amp; attribute : attributeVector)
        attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。</p>
<h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）<br><img src="/uploads/deeply-analyse-webkit/84.png" alt="84" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/84.png" class="lozad post-image"><br>相关类流程图：<br><img src="/uploads/deeply-analyse-webkit/87.png" alt="87" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/87.png" class="lozad post-image"></p>
<p>前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树</p>
<h3 id="DOM-标准规范"><a href="#DOM-标准规范" class="headerlink" title="DOM 标准规范"></a>DOM 标准规范</h3><p>Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：<br><img src="/uploads/deeply-analyse-webkit/52.png" alt="52" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/52.png" class="lozad post-image"><br>下面对各个 level 进行说明<br>DOM level 1</p>
<ul>
<li>Core：底层接口，接口支持 XML 等任何结构化文档。</li>
<li>HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。</li>
</ul>
<p>DOM level 2</p>
<ul>
<li>Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。</li>
<li>HTML：允许动态访问修改文档。</li>
<li>Views：文档的各种视图。</li>
<li>Events：鼠标事件等。</li>
<li>Style：可以修改 HTML 样式的一个属性。</li>
<li>Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。</li>
</ul>
<p>节点DOM level 3</p>
<ul>
<li>Core：加入了新接口 adoptNode 和 textContent。</li>
<li>Load and Save：加载 XML 转成 DOM 表示的文档结构。</li>
<li>Validation：验证文档有效性。</li>
<li>Events：加入键盘支持。</li>
<li>XPath：一种简单直观检索 DOM 节点的方式。</li>
</ul>
<p>DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore&#x2F;dom&#x2F;Document.idl 文件里</p>
<pre class="line-numbers language-idl" data-language="idl"><code class="language-idl">interface Document : Node &#123;
    readonly attribute DOMImplementation implementation; &#x2F;&#x2F; FIXME: Should be [SameObject].
    [ImplementedAs&#x3D;urlForBindings] readonly attribute USVString URL;
    [ImplementedAs&#x3D;urlForBindings] readonly attribute USVString documentURI;
    readonly attribute USVString origin;
    readonly attribute DOMString compatMode;
    [ImplementedAs&#x3D;characterSetWithUTF8Fallback] readonly attribute DOMString characterSet;
    [ImplementedAs&#x3D;characterSetWithUTF8Fallback] readonly attribute DOMString charset; &#x2F;&#x2F; Historical alias of .characterSet,
    [ImplementedAs&#x3D;characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; &#x2F;&#x2F; Historical alias of .characterSet.
    readonly attribute DOMString contentType;

    readonly attribute DocumentType? doctype;
    [DOMJIT&#x3D;Getter] readonly attribute Element? documentElement;

    HTMLCollection getElementsByTagName(DOMString qualifiedName);
    HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);
    HTMLCollection getElementsByClassName(DOMString classNames);

    [NewObject, MayThrowException, ImplementedAs&#x3D;createElementForBindings] Element createElement(DOMString localName); &#x2F;&#x2F; FIXME: missing options parameter.
    [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); &#x2F;&#x2F; FIXME: missing options parameter.
    [NewObject] DocumentFragment createDocumentFragment();
    [NewObject] Text createTextNode(DOMString data);
    [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data);
    [NewObject] Comment createComment(DOMString data);
    [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);

    [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep &#x3D; false);
    [CEReactions, MayThrowException] Node adoptNode(Node node);

    [NewObject, MayThrowException] Attr createAttribute(DOMString localName);
    [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName);

    [MayThrowException, NewObject] Event createEvent(DOMString type);

    [NewObject] Range createRange();

    &#x2F;&#x2F; NodeFilter.SHOW_ALL &#x3D; 0xFFFFFFFF.
    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow &#x3D; 0xFFFFFFFF, optional NodeFilter? filter &#x3D; null);
    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow &#x3D; 0xFFFFFFFF, optional NodeFilter? filter &#x3D; null);

    &#x2F;&#x2F; Extensions from HTML specification (https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;#the-document-object).
    [PutForwards&#x3D;href, Unforgeable] readonly attribute Location? location;
    [SetterMayThrowException] attribute USVString domain;
    readonly attribute USVString referrer;
    [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie;
    readonly attribute DOMString lastModified;
    readonly attribute DocumentReadyState readyState;

    &#x2F;&#x2F; DOM tree accessors.
    [CEReactions] attribute DOMString title;
    [CEReactions] attribute DOMString dir;
    [CEReactions, DOMJIT&#x3D;Getter, ImplementedAs&#x3D;bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body;
    readonly attribute HTMLHeadElement? head;
    readonly attribute HTMLCollection images; &#x2F;&#x2F; Should be [SameObject].
    readonly attribute HTMLCollection embeds; &#x2F;&#x2F; Should be [SameObject].
    readonly attribute HTMLCollection plugins; &#x2F;&#x2F; Should be [SameObject].
    readonly attribute HTMLCollection links; &#x2F;&#x2F; Should be [SameObject].
    readonly attribute HTMLCollection forms; &#x2F;&#x2F; Should be [SameObject].
    readonly attribute HTMLCollection scripts; &#x2F;&#x2F; Should be [SameObject].
    NodeList getElementsByName([AtomicString] DOMString elementName);
    readonly attribute HTMLScriptElement? currentScript; &#x2F;&#x2F; FIXME: Should return a HTMLOrSVGScriptElement.

    &#x2F;&#x2F; dynamic markup insertion
    &#x2F;&#x2F; FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure
    &#x2F;&#x2F; that the caller document matches those semantics. It is possible we should replace it with
    &#x2F;&#x2F; the existing &#39;incumbent document&#39; concept.
    [CEReactions, CallWith&#x3D;ResponsibleDocument, ImplementedAs&#x3D;openForBindings, MayThrowException] Document open(optional DOMString type &#x3D; &quot;text&#x2F;html&quot;, optional DOMString replace &#x3D; &quot;&quot;);
    [CallWith&#x3D;ActiveWindow&amp;FirstWindow, ImplementedAs&#x3D;openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features);
    [CEReactions, ImplementedAs&#x3D;closeForBindings, MayThrowException] void close();
    [CEReactions, CallWith&#x3D;ResponsibleDocument, MayThrowException] void write(DOMString... text);
    [CEReactions, CallWith&#x3D;ResponsibleDocument, MayThrowException] void writeln(DOMString... text);

    &#x2F;&#x2F; User interaction.
    readonly attribute DOMWindow? defaultView;
    boolean hasFocus();
    [CEReactions] attribute DOMString designMode;
    [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI &#x3D; false, optional DOMString? value &#x3D; null); &#x2F;&#x2F; FIXME: value should not be nullable.
    boolean queryCommandEnabled(DOMString commandId);
    boolean queryCommandIndeterm(DOMString commandId);
    boolean queryCommandState(DOMString commandId);
    boolean queryCommandSupported(DOMString commandId);
    DOMString queryCommandValue(DOMString commandId);

    &#x2F;&#x2F; Special event handler IDL attributes that only apply to Document objects.
    [LenientThis] attribute EventHandler onreadystatechange;

    &#x2F;&#x2F; Extensions from the CSSOM specification (https:&#x2F;&#x2F;drafts.csswg.org&#x2F;cssom&#x2F;#extensions-to-the-document-interface).
    &#x2F;&#x2F; FIXME: Should likely be moved to DocumentOrShadowRoot.
    readonly attribute StyleSheetList styleSheets; &#x2F;&#x2F; FIXME: Should be [SameObject].

    &#x2F;&#x2F; Extensions from the CSSOM-View specification (https:&#x2F;&#x2F;drafts.csswg.org&#x2F;cssom-view&#x2F;#extensions-to-the-document-interface).
    readonly attribute Element? scrollingElement;

    &#x2F;&#x2F; Extensions from Selection API (https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;selection-api&#x2F;#extensions-to-document-interface).
    &#x2F;&#x2F; FIXME: Should likely be moved to DocumentOrShadowRoot.
    DOMSelection? getSelection();

    &#x2F;&#x2F; XPath extensions (https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;DOM-Level-3-XPath&#x2F;xpath.html#XPathEvaluator).
    [MayThrowException] XPathExpression createExpression(optional DOMString expression &#x3D; &quot;undefined&quot;, optional XPathNSResolver? resolver); &#x2F;&#x2F; FIXME: Using &quot;undefined&quot; as default parameter value is wrong.
    XPathNSResolver createNSResolver(Node? nodeResolver);
    [MayThrowException] XPathResult evaluate(optional DOMString expression &#x3D; &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type &#x3D; 0, optional XPathResult? inResult); &#x2F;&#x2F; FIXME: Using &quot;undefined&quot; as default parameter value is wrong.

    &#x2F;&#x2F; Extensions from FullScreen API (https:&#x2F;&#x2F;fullscreen.spec.whatwg.org&#x2F;#api).
    &#x2F;&#x2F; FIXME: Should probably be unprefixed.
    [Conditional&#x3D;FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled;
    [Conditional&#x3D;FULLSCREEN_API, ImplementedAs&#x3D;webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement;
    [Conditional&#x3D;FULLSCREEN_API] void webkitExitFullscreen();
    [Conditional&#x3D;FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; &#x2F;&#x2F; Mozilla version.
    [Conditional&#x3D;FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; &#x2F;&#x2F; Mozilla version.
    [Conditional&#x3D;FULLSCREEN_API, ImplementedAs&#x3D;webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; &#x2F;&#x2F; Mozilla version.
    [Conditional&#x3D;FULLSCREEN_API] void webkitCancelFullScreen(); &#x2F;&#x2F; Mozilla version.
    [NotEnumerable, Conditional&#x3D;FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange;
    [NotEnumerable, Conditional&#x3D;FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror;

    &#x2F;&#x2F; Extensions from Pointer Lock API (https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;pointerlock&#x2F;#extensions-to-the-document-interface).
    [NotEnumerable, Conditional&#x3D;POINTER_LOCK] attribute EventHandler onpointerlockchange; &#x2F;&#x2F; FIXME: Should be enumerable.
    [NotEnumerable, Conditional&#x3D;POINTER_LOCK] attribute EventHandler onpointerlockerror; &#x2F;&#x2F; FIXME: Should be enumerable.
    [Conditional&#x3D;POINTER_LOCK] void exitPointerLock();

    &#x2F;&#x2F; Extensions from CSS Font Loading API (https:&#x2F;&#x2F;drafts.csswg.org&#x2F;css-font-loading&#x2F;#font-face-source).
    &#x2F;&#x2F; FIXME: Should be in a separate FontFaceSource interface.
    readonly attribute FontFaceSet fonts;

    &#x2F;&#x2F; Extensions from Page visibility API (https:&#x2F;&#x2F;www.w3.org&#x2F;TR&#x2F;page-visibility&#x2F;#sec-document-interface).
    readonly attribute boolean hidden;
    readonly attribute VisibilityState visibilityState;
    attribute EventHandler onvisibilitychange;

    &#x2F;&#x2F; FIXME: Those were dropped from the CSSOM specification.
    readonly attribute DOMString? preferredStylesheetSet;
    attribute DOMString? selectedStylesheetSet;

    &#x2F;&#x2F; FIXME: Those have been dropped from the DOM specification.
    readonly attribute DOMString? xmlEncoding;
    [SetterMayThrowException] attribute DOMString? xmlVersion;
    attribute boolean xmlStandalone;

    &#x2F;&#x2F; FIXME: Blink has already dropped this (https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;forum&#x2F;#!topic&#x2F;blink-dev&#x2F;s3ezjTuC8ig).
    CSSStyleDeclaration getOverrideStyle(optional Element? element &#x3D; null, optional DOMString pseudoElement &#x3D; &quot;undefined&quot;);

    &#x2F;&#x2F; FIXME: Should be moved to GlobalEventHandlers (http:&#x2F;&#x2F;w3c.github.io&#x2F;selection-api&#x2F;#extensions-to-globaleventhandlers).
    [NotEnumerable] attribute EventHandler onselectstart; &#x2F;&#x2F; FIXME: Should be enumerable.
    [NotEnumerable] attribute EventHandler onselectionchange; &#x2F;&#x2F; FIXME: Should be enumerable.

    &#x2F;&#x2F; Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet.
    Range caretRangeFromPoint(optional long x &#x3D; 0, optional long y &#x3D; 0);

    &#x2F;&#x2F; FIXME: This is not standard and has been dropped from Blink already.
    RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height);

    &#x2F;&#x2F; Non standard (https:&#x2F;&#x2F;developer.apple.com&#x2F;reference&#x2F;webkitjs&#x2F;document&#x2F;1633863-webkitgetnamedflows).
    [Conditional&#x3D;CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows();


    &#x2F;&#x2F; Obsolete features from https:&#x2F;&#x2F;html.spec.whatwg.org&#x2F;multipage&#x2F;obsolete.html

    [CEReactions] attribute [TreatNullAs&#x3D;EmptyString] DOMString fgColor;
    [CEReactions, ImplementedAs&#x3D;linkColorForBindings] attribute [TreatNullAs&#x3D;EmptyString] DOMString linkColor;
    [CEReactions] attribute [TreatNullAs&#x3D;EmptyString] DOMString vlinkColor;
    [CEReactions] attribute [TreatNullAs&#x3D;EmptyString] DOMString alinkColor;
    [CEReactions] attribute [TreatNullAs&#x3D;EmptyString] DOMString bgColor;

    readonly attribute HTMLCollection anchors; &#x2F;* [SameObject] *&#x2F;
    readonly attribute HTMLCollection applets; &#x2F;* [SameObject] *&#x2F;

    void clear();
    void captureEvents();
    void releaseEvents();

    [Replaceable] readonly attribute HTMLAllCollection all; &#x2F;* [SameObject] *&#x2F;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DOM-Tree-Token-的构造算法"><a href="#DOM-Tree-Token-的构造算法" class="headerlink" title="DOM Tree Token 的构造算法"></a>DOM Tree Token 的构造算法</h3><p>这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：<a target="_blank" rel="noopener" href="https://www.w3.org/TR/html5/syntax.html#html-parser">https://www.w3.org/TR/html5/syntax.html#html-parser</a></p>
<p><img src="/uploads/deeply-analyse-webkit/19.png" alt="19" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/19.png" class="lozad post-image"><br>当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。</p>
<p>具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。</p>
<p>接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。</p>
<p>再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。</p>
<h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>构建 DOM 的几个关键的类<br><img src="/uploads/deeply-analyse-webkit/53.png" alt="53" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/53.png" class="lozad post-image"></p>
<p><img src="/uploads/deeply-analyse-webkit/11.png" alt="11" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/11.png" class="lozad post-image"></p>
<ul>
<li>HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。</li>
<li>HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。</li>
<li>HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。</li>
<li>HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。</li>
</ul>
<p>构建 DOM 树的过程如下图：<br><img src="/uploads/deeply-analyse-webkit/54.png" alt="54" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/54.png" class="lozad post-image"></p>
<p>举个例子：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
			Hello World
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>example.png<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>转成 DOM Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/69.png" alt="69" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/69.png" class="lozad post-image"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">FetchRequest fetchRequest(m_request, FetchInitiatorTypeNames::document,
                            mainResourceLoadOptions);
  m_mainResource &#x3D;
      RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>DocumentLoader 的 commitData 会去处理 dataReceived 的数据块</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void DocumentLoader::commitData(const char* bytes, size_t length) &#123;
  ensureWriter(m_response.mimeType()); &#x2F;&#x2F;会初始化 HTMLDocumentParser 实例化 document 对象
  if (length)
    m_dataReceived &#x3D; true;
  m_writer-&gt;addData(bytes, length); &#x2F;&#x2F;给 Parser 解析，这里的bytes就是返回来的 html 文本代码
&#125;
&#x2F;&#x2F;ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次
void DocumentLoader::ensureWriter(const AtomicString&amp; mimeType, const KURL&amp; overridingURL) &#123;
  if (m_writer)
    return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>DOM Tree 已经被 W3 标准化了 <a target="_blank" rel="noopener" href="https://www.w3.org/DOM/DOMTR">Document Object Model (DOM) Technical Reports</a> 在 DOM Level 3 里 IDL 的定义在 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/">IDL Definitions</a></p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图：<br><img src="/uploads/deeply-analyse-webkit/56.png" alt="56" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/56.png" class="lozad post-image"></p>
<p>在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：<a target="_blank" rel="noopener" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode">http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode</a> 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a> 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。</p>
<p>需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：<a target="_blank" rel="noopener" href="https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements">https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements</a></p>
<p><img src="/uploads/deeply-analyse-webkit/37.png" alt="37" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/37.png" class="lozad post-image"></p>
<p>DOM Node 的数据结构<br><img src="/uploads/deeply-analyse-webkit/12.png" alt="12" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/12.png" class="lozad post-image"></p>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下：<br><img src="/uploads/deeply-analyse-webkit/75.png" alt="75" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/75.png" class="lozad post-image"></p>
<h4 id="构建-DOM-Tree-1"><a href="#构建-DOM-Tree-1" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h4><p>从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore&#x2F;html&#x2F;parser&#x2F;HTMLTreeBuilder.cpp 文件里。<br>constructtreefromToken</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)
&#123;
    switch (token.type()) &#123;
    case HTMLToken::Uninitialized:
        ASSERT_NOT_REACHED();
        break;
    case HTMLToken::DOCTYPE:
        m_shouldSkipLeadingNewline &#x3D; false;
        processDoctypeToken(WTFMove(token));
        break;
    case HTMLToken::StartTag:
        m_shouldSkipLeadingNewline &#x3D; false;
        processStartTag(WTFMove(token));
        break;
    case HTMLToken::EndTag:
        m_shouldSkipLeadingNewline &#x3D; false;
        processEndTag(WTFMove(token));
        break;
    case HTMLToken::Comment:
        m_shouldSkipLeadingNewline &#x3D; false;
        processComment(WTFMove(token));
        return;
    case HTMLToken::Character:
        processCharacter(WTFMove(token));
        break;
    case HTMLToken::EndOfFile:
        m_shouldSkipLeadingNewline &#x3D; false;
        processEndOfFile(WTFMove(token));
        break;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) &#123;
  HTMLHtmlElement* element &#x3D; HTMLHtmlElement::create(*m_document);
  attachLater(m_attachmentRoot, element);
  m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); &#x2F;&#x2F;push 到 HTMLStackItem 栈里
  executeQueuedTasks();
&#125;
&#x2F;&#x2F;通过 attachLater 创建 task
void HTMLConstructionSite::attachLater(ContainerNode* parent,
                                       Node* child,
                                       bool selfClosing) &#123;
  HTMLConstructionSiteTask task(HTMLConstructionSiteTask::Insert);
  task.parent &#x3D; parent;
  task.child &#x3D; child;
  task.selfClosing &#x3D; selfClosing;
  &#x2F;&#x2F;判断是否到达最深，512是最深
  if (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp;
      task.parent-&gt;parentNode())
    task.parent &#x3D; task.parent-&gt;parentNode();
  queueTask(task);
&#125;
&#x2F;&#x2F;executeQueued 添加子节点
void ContainerNode::parserAppendChild(Node* newChild) &#123;
  if (!checkParserAcceptChild(*newChild))
    return;
    AdoptAndAppendChild()(*this, *newChild, nullptr);
  &#125;
  notifyNodeInserted(*newChild, ChildrenChangeSourceParser);
&#125;
&#x2F;&#x2F;添加前会先检查是否支持子元素
void ContainerNode::appendChildCommon(Node&amp; child) &#123;
  child.setParentOrShadowHostNode(this);
  if (m_lastChild) &#123;
    child.setPreviousSibling(m_lastChild);
    m_lastChild-&gt;setNextSibling(&amp;child);
  &#125; else &#123;
    setFirstChild(&amp;child);
  &#125;
  setLastChild(&amp;child);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>闭标签会把元素 pop 出来</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">m_tree.openElements()-&gt;popUntilPopped(token-&gt;name());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="对错误的处理"><a href="#对错误的处理" class="headerlink" title="对错误的处理"></a>对错误的处理</h3><p>parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子</p>
<h4 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a></br> 问题</h4><p>一些网站会用 </br> 替代 <br>，处理的代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;
     reportError(MalformedBRError);
     t-&gt;beginTag &#x3D; true;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="stray-table"><a href="#stray-table" class="headerlink" title="stray table"></a>stray table</h4><p>stray table 是一个 table 包含了一个不在 table cell 的 table。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
		<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>inner table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>outer table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>WebKit 的处理</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (m_inStrayTableContent &amp;&amp; localName &#x3D;&#x3D; tableTag)
        popBlock(tableTag);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这样会处理成两个同级 table</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>outer table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>table</span><span class="token punctuation">></span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>tr</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>td</span><span class="token punctuation">></span></span>inner table<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>td</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>tr</span><span class="token punctuation">></span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>table</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="嵌套-form"><a href="#嵌套-form" class="headerlink" title="嵌套 form"></a>嵌套 form</h4><p>将一个 form 放到另一个 form 里。那么第二个 form 会被忽略</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (!m_currentFormElement) &#123;
        m_currentFormElement &#x3D; new HTMLFormElement(formTag,    m_document);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="过深的层级"><a href="#过深的层级" class="headerlink" title="过深的层级"></a>过深的层级</h4><p>同一个类型里只允许嵌套 20 个 tag。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName)
&#123;
unsigned i &#x3D; 0;
for (HTMLStackElem* curr &#x3D; m_blockStack;
         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName &#x3D;&#x3D; tagName;
     curr &#x3D; curr-&gt;next, i++) &#123; &#125;
return i !&#x3D; cMaxRedundantTagDepth;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="html-或-body-的-end-tags-缺失"><a href="#html-或-body-的-end-tags-缺失" class="headerlink" title="html 或 body 的 end tags 缺失"></a>html 或 body 的 end tags 缺失</h4><p>这些都会在 end() 是调用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (t-&gt;tagName &#x3D;&#x3D; htmlTag || t-&gt;tagName &#x3D;&#x3D; bodyTag )
        return;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-语法简介"><a href="#CSS-语法简介" class="headerlink" title="CSS 语法简介"></a>CSS 语法简介</h3><p>所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。</p>
<h4 id="CSS-declarations"><a href="#CSS-declarations" class="headerlink" title="CSS declarations"></a>CSS declarations</h4><p><img src="/uploads/deeply-analyse-webkit/40.png" alt="40" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/40.png" class="lozad post-image"><br>在这里可以找到 CSS  的不同的属性。</p>
<h4 id="CSS-declaration-blocks"><a href="#CSS-declaration-blocks" class="headerlink" title="CSS declaration blocks"></a>CSS declaration blocks</h4><p>使用大括号包起来。<br><img src="/uploads/deeply-analyse-webkit/41.png" alt="41" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/41.png" class="lozad post-image"></p>
<h4 id="CSS-selectors-and-rules"><a href="#CSS-selectors-and-rules" class="headerlink" title="CSS selectors and rules"></a>CSS selectors and rules</h4><p>在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。<br><img src="/uploads/deeply-analyse-webkit/42.png" alt="42" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/42.png" class="lozad post-image"></p>
<p>selector 可以分为以下类别</p>
<ul>
<li>Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。</li>
<li>Attribute selectors：属性选择器，通过属性匹配。</li>
<li>Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。</li>
<li>Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^&#x3D;http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。</li>
<li>Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。</li>
<li>Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。</li>
</ul>
<p>Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种</p>
<ul>
<li>[attr]：不论值是什么选择所有 attr 属性的元素。</li>
<li>[attr&#x3D;val]：按照 attr 属性的值为 val 的所有元素。</li>
<li>[attr~&#x3D;val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。</li>
</ul>
<p>还有 Substring value attribute selector 这样的伪正则选择器：</p>
<ul>
<li>[attr|&#x3D;val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。</li>
<li>[attr^&#x3D;val]：匹配选择以 val 开头的元素。</li>
<li>[attr$&#x3D;val]：匹配选择以 val 结尾的元素。</li>
<li>[attr*&#x3D;val]：匹配选择包含 val 的元素。</li>
</ul>
<p>Combinators 组合器有以下几种</p>
<ul>
<li>A,B： 匹配 A B 的任意元素。</li>
<li>A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。</li>
<li>A &gt; B：B 是 A 的直接子节点。</li>
<li>A + B：B 是 A 的兄弟节点。</li>
<li>A ~ B：B 是 A 兄弟节点中的任意一个。</li>
</ul>
<h4 id="CSS-statements"><a href="#CSS-statements" class="headerlink" title="CSS statements"></a>CSS statements</h4><p>CSS rule 只是 CSS statements 的一种。<br>其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。</p>
<ul>
<li>@charset：元数据</li>
<li>@import：元数据</li>
<li>@media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。</li>
<li>@supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。</li>
<li>@document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。</li>
<li>@font-face：描述性信息</li>
</ul>
<p>比如</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@import</span> <span class="token string">'starming.css'</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>表示向当前的 CSS 导入了 starming.css 文件。再举个例子：</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 801px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>
    <span class="token selector">body</span> <span class="token punctuation">&#123;</span>
        <span class="token property">margin</span><span class="token punctuation">:</span>0 auto<span class="token punctuation">;</span>
        <span class="token property">width</span><span class="token punctuation">:</span>800px<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个表示页面宽度超过801像素时才会运用 @-规则里的内容。</p>
<h4 id="Shorthand"><a href="#Shorthand" class="headerlink" title="Shorthand"></a>Shorthand</h4><p>有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。<br>比如</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">maring</span><span class="token punctuation">:</span> 20px 10px 10px 20px<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等效于</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">margin-top</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span>
<span class="token property">margin-right</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
<span class="token property">margin-bottom</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>
<span class="token property">margin-left</span><span class="token punctuation">:</span> 20px<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>再比如 background 属性</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">background</span><span class="token punctuation">:</span> black <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>starming-bg.png<span class="token punctuation">)</span></span> 20px 20px repeat-x fixed<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>和下面的属性设置等效</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token property">background-color</span><span class="token punctuation">:</span> black<span class="token punctuation">;</span>
<span class="token property">background-image</span><span class="token punctuation">:</span> <span class="token url"><span class="token function">url</span><span class="token punctuation">(</span>starming-bg.png<span class="token punctuation">)</span></span><span class="token punctuation">;</span>
<span class="token property">background-position</span><span class="token punctuation">:</span> 20px 20px<span class="token punctuation">;</span>
<span class="token property">background-repeat</span><span class="token punctuation">:</span> repeat-x<span class="token punctuation">;</span>
<span class="token property">background-scroll</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Value-and-unit"><a href="#Value-and-unit" class="headerlink" title="Value and unit"></a>Value and unit</h4><ul>
<li>absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1&#x2F;72 of an inch) 点，picas (12 points.) 十二点活字。</li>
<li>相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1&#x2F;100 和视图高度的 1&#x2F;100，但是支持没有 rem 那么好。</li>
<li>无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。</li>
<li>百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。</li>
<li>颜色：有165个不同关键字可用，具体见 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords</a> ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle">https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle</a></li>
<li>透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。</li>
<li>函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’);</li>
</ul>
<h4 id="验证-CSS-语法正确性"><a href="#验证-CSS-语法正确性" class="headerlink" title="验证 CSS 语法正确性"></a>验证 CSS 语法正确性</h4><p>可以通过 w3c 提供的服务 <a target="_blank" rel="noopener" href="http://jigsaw.w3.org/css-validator/">http://jigsaw.w3.org/css-validator/</a> 来验证，w3c 还提供了 html 的验证服务 <a target="_blank" rel="noopener" href="https://validator.w3.org/#validate_by_uri">https://validator.w3.org/#validate_by_uri</a></p>
<h3 id="CSS-BNF"><a href="#CSS-BNF" class="headerlink" title="CSS BNF"></a>CSS BNF</h3><p>CSS 语法 BNF</p>
<pre class="line-numbers language-none"><code class="language-none">ruleset
  : selector [ &#39;,&#39; S* selector ]*
    &#39;&#123;&#39; S* declaration [ &#39;;&#39; S* declaration ]* &#39;&#125;&#39; S*
  ;
selector
  : simple_selector [ combinator selector | S+ [ combinator selector ] ]
  ;
simple_selector
  : element_name [ HASH | class | attrib | pseudo ]*
  | [ HASH | class | attrib | pseudo ]+
  ;
class
  : &#39;.&#39; IDENT
  ;
element_name
  : IDENT | &#39;*&#39;
  ;
attrib
  : &#39;[&#39; S* IDENT S* [ [ &#39;&#x3D;&#39; | INCLUDES | DASHMATCH ] S*
    [ IDENT | STRING ] S* ] &#39;]&#39;
  ;
pseudo
  : &#39;:&#39; [ IDENT | FUNCTION S* [IDENT S*] &#39;)&#39; ]
  ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。<br><img src="/uploads/deeply-analyse-webkit/68.png" alt="68" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/68.png" class="lozad post-image"></p>
<h3 id="CSS-主要类与关系"><a href="#CSS-主要类与关系" class="headerlink" title="CSS 主要类与关系"></a>CSS 主要类与关系</h3><p><img src="/uploads/deeply-analyse-webkit/57.png" alt="57" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/57.png" class="lozad post-image"><br>上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。</p>
<p>StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。</p>
<p>CSS 文档结构的类图如下：<br><img src="/uploads/deeply-analyse-webkit/90.png" alt="90" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/90.png" class="lozad post-image"></p>
<h4 id="StyleRuleBase-类的继承关系"><a href="#StyleRuleBase-类的继承关系" class="headerlink" title="StyleRuleBase 类的继承关系"></a>StyleRuleBase 类的继承关系</h4><p>RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系<br><img src="/uploads/deeply-analyse-webkit/58.png" alt="58" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/58.png" class="lozad post-image"><br>我们来看看这些子类类型都是对应 CSS 里的什么</p>
<ul>
<li>StyleRule：常用的都是这个类型</li>
<li>StyleRuleImport：对应的是 @import</li>
<li>StyleRuleMedia：对应的是 @media</li>
<li>StyleRuleFontFace：对应的 @font-face</li>
<li>StyleRulePage：对应的 @page</li>
<li>StyleRuleKeyFrames：对应的 @-webkit-key-frames</li>
<li>StyleRuleRegion：分区域排版</li>
</ul>
<h4 id="StyleRule-类的结构"><a href="#StyleRule-类的结构" class="headerlink" title="StyleRule 类的结构"></a>StyleRule 类的结构</h4><p><img src="/uploads/deeply-analyse-webkit/59.png" alt="59" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/59.png" class="lozad post-image"></p>
<h3 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h3><p>WebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图：<br><img src="/uploads/deeply-analyse-webkit/91.png" alt="91" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/91.png" class="lozad post-image"></p>
<p>字符串转 tokens<br><img src="/uploads/deeply-analyse-webkit/13.png" alt="13" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/13.png" class="lozad post-image"></p>
<p>将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。<br>定义 matchType</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum MatchType &#123;
    Unknown,
    Tag,               &#x2F;&#x2F;比如 div
    Id,                &#x2F;&#x2F; #id
    Class,             &#x2F;&#x2F; .class
    PseudoClass,       &#x2F;&#x2F; :nth-child(2)
    PseudoElement,     &#x2F;&#x2F; ::first-line
    PagePseudoClass,   &#x2F;&#x2F;
    AttributeExact,    &#x2F;&#x2F; E[attr&#x3D;&quot;value&quot;]
    AttributeSet,      &#x2F;&#x2F; E[attr]
    AttributeHyphen,   &#x2F;&#x2F; E[attr|&#x3D;&quot;value&quot;]
    AttributeList,     &#x2F;&#x2F; E[attr~&#x3D;&quot;value&quot;]
    AttributeContain,  &#x2F;&#x2F; E[attr*&#x3D;&quot;value&quot;]
    AttributeBegin,    &#x2F;&#x2F; E[attr^&#x3D;&quot;value&quot;]
    AttributeEnd,      &#x2F;&#x2F; E[attr$&#x3D;&quot;value&quot;]
    FirstAttributeSelectorMatch &#x3D; AttributeExact,
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>定义 selectors 的 Relation 类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum RelationType &#123;
    SubSelector,       &#x2F;&#x2F; No combinator
    Descendant,        &#x2F;&#x2F; &quot;Space&quot; combinator
    Child,             &#x2F;&#x2F; &gt; combinator
    DirectAdjacent,    &#x2F;&#x2F; + combinator
    IndirectAdjacent,  &#x2F;&#x2F; ~ combinator
    &#x2F;&#x2F; Special cases for shadow DOM related selectors.
    ShadowPiercingDescendant,  &#x2F;&#x2F; &gt;&gt;&gt; combinator
    ShadowDeep,                &#x2F;&#x2F; &#x2F;deep&#x2F; combinator
    ShadowPseudo,              &#x2F;&#x2F; ::shadow pseudo element
    ShadowSlot                 &#x2F;&#x2F; ::slotted() pseudo element
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>CSS 的属性是 id 来标识的</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum CSSPropertyID &#123;
    CSSPropertyColor &#x3D; 15,
    CSSPropertyWidth &#x3D; 316,
    CSSPropertyMarginLeft &#x3D; 145,
    CSSPropertyMarginRight &#x3D; 146,
    CSSPropertyMarginTop &#x3D; 147,
    CSSPropertyMarkerEnd &#x3D; 148,
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认样式，Blink ua全部 CSS 样式：<a target="_blank" rel="noopener" href="http://yincheng.site/html/chrome-ua-css.html">http://yincheng.site/html/chrome-ua-css.html</a> 。w3c 的默认样式是：<a target="_blank" rel="noopener" href="https://www.w3.org/TR/CSS2/sample.html">https://www.w3.org/TR/CSS2/sample.html</a></p>
<p>接着会生成 hash map，分成四个类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">CompactRuleMap m_idRules;                    &#x2F;&#x2F;id
CompactRuleMap m_classRules;                 &#x2F;&#x2F;class
CompactRuleMap m_tagRules;                   &#x2F;&#x2F;标签
CompactRuleMap m_shadowPseudoElementRules;   &#x2F;&#x2F;伪类选择器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>CSS 解析完会触发  layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。</p>
<p>layout 会更新递归所有 DOM 元素</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void ContainerNode::attachLayoutTree(const AttachContext&amp; context) &#123;
  for (Node* child &#x3D; firstChild(); child; child &#x3D; child-&gt;nextSibling()) &#123;
    if (child-&gt;needsAttach())
      child-&gt;attachLayoutTree(childrenContext);
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;id
if (element.hasID()) 
  collectMatchingRulesForList(
      matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()),
      cascadeOrder, matchRequest);
&#x2F;&#x2F;class
if (element.isStyledElement() &amp;&amp; element.hasClass()) &#123; 
  for (size_t i &#x3D; 0; i &lt; element.classNames().size(); ++i)
    collectMatchingRulesForList(
        matchRequest.ruleSet-&gt;classRules(element.classNames()[i]),
        cascadeOrder, matchRequest);
&#125;
&#x2F;&#x2F;伪类
...
&#x2F;&#x2F;tag 和 selector
collectMatchingRulesForList(
    matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()),
    cascadeOrder, matchRequest);
&#x2F;&#x2F;通配符
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。</p>
<p>在 classRules 里会进行检验</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (!checkOne(context, subResult))
  return SelectorFailsLocally;
if (context.selector-&gt;isLastInTagHistory()) &#123; 
    return SelectorMatches;
&#125;
&#x2F;&#x2F;checkOne 的实现
switch (selector.match()) &#123; 
  case CSSSelector::Tag:
    return matchesTagName(element, selector.tagQName());
  case CSSSelector::Class:
    return element.hasClass() &amp;&amp;
           element.classNames().contains(selector.value());
  case CSSSelector::Id:
    return element.hasID() &amp;&amp;
           element.idForStyleResolution() &#x3D;&#x3D; selector.value();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch (relation) &#123; 
  case CSSSelector::Descendant:
    for (nextContext.element &#x3D; parentElement(context); nextContext.element;
         nextContext.element &#x3D; parentElement(nextContext)) &#123; 
      MatchStatus match &#x3D; matchSelector(nextContext, result);
      if (match &#x3D;&#x3D; SelectorMatches || match &#x3D;&#x3D; SelectorFailsCompletely)
        return match;
      if (nextSelectorExceedsScope(nextContext))
        return SelectorFailsCompletely;
    &#125; 
    return SelectorFailsCompletely;
      case CSSSelector::Child:
    &#x2F;&#x2F;...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。</p>
<h3 id="CSS-规则匹配"><a href="#CSS-规则匹配" class="headerlink" title="CSS 规则匹配"></a>CSS 规则匹配</h3><p>CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。</p>
<p>CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：<br><img src="/uploads/deeply-analyse-webkit/92.png" alt="92" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/92.png" class="lozad post-image"><br>匹配的流程图如下：<br><img src="/uploads/deeply-analyse-webkit/93.png" alt="93" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/93.png" class="lozad post-image"></p>
<h3 id="设置-style"><a href="#设置-style" class="headerlink" title="设置 style"></a>设置 style</h3><p>设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">style-&gt;inheritFrom(*state.parentStyle())
matchUARules(collector);
matchAuthorRules(*state.element(), collector);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (const CSSSelector* selector &#x3D; this; selector;
     selector &#x3D; selector-&gt;tagHistory()) &#123; 
  temp &#x3D; total + selector-&gt;specificityForOneSelector();
&#125;
return total;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>每个不同类型的 selector 的优先级如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch (m_match) &#123;
    case Id: 
      return 0x010000;
    case PseudoClass:
      return 0x000100;
    case Class:
    case PseudoElement:
    case AttributeExact:
    case AttributeSet:
    case AttributeList:
    case AttributeHyphen:
    case AttributeContain:
    case AttributeBegin:
    case AttributeEnd:
      return 0x000100;
    case Tag:
      return 0x000001;
    case Unknown:
      return 0;
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以看出 id 的优先级最大是 0x010000 &#x3D; 65536，类，属性，伪类优先级是 0x000100 &#x3D; 256，标签是 0x000001 &#x3D; 1</p>
<p>举个优先级计算的例子</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token comment">/*优先级为257 = 265 + 1*/</span>
<span class="token selector">.text h1</span><span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 8em<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*优先级为65537 = 65536 + 1*/</span>
<span class="token selector">#my-text h1</span><span class="token punctuation">&#123;</span>
    <span class="token property">font-size</span><span class="token punctuation">:</span> 16em<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。</p>
<p>目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。</p>
<p>排序规则</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static inline bool compareRules(const MatchedRule&amp; matchedRule1,
                                const MatchedRule&amp; matchedRule2) &#123;
  unsigned specificity1 &#x3D; matchedRule1.specificity();
  unsigned specificity2 &#x3D; matchedRule2.specificity();
  if (specificity1 !&#x3D; specificity2)
    return specificity1 &lt; specificity2;
 
  return matchedRule1.position() &lt; matchedRule2.position();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>规则和优先级完后就开始设置元素的 style 了：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">applyMatchedPropertiesAndCustomPropertyAnimations(
        state, collector.matchedResult(), element);

applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(
      state, matchResult.allRules(), false, applyInheritedOnly, needsApplyPass);
  for (auto range : ImportantAuthorRanges(matchResult)) &#123;
    applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(
        state, range, true, applyInheritedOnly, needsApplyPass);
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下：<br><img src="/uploads/deeply-analyse-webkit/14.png" alt="14" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/14.png" class="lozad post-image"></p>
<p><img src="/uploads/deeply-analyse-webkit/15.png" alt="15" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/15.png" class="lozad post-image"></p>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。</p>
<p>W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore&#x2F;page&#x2F;DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下：</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; Extensions from the CSSOM-View specification (https:&#x2F;&#x2F;drafts.csswg.org&#x2F;cssom-view&#x2F;#extensions-to-the-window-interface).
[NewObject] MediaQueryList matchMedia(CSSOMString query);
[Replaceable] readonly attribute Screen screen; &#x2F;&#x2F; FIXME: Should be [SameObject].

&#x2F;&#x2F; Browsing context (CSSOM-View).
void moveTo(optional unrestricted float x &#x3D; NaN, optional unrestricted float y &#x3D; NaN); &#x2F;&#x2F; FIXME: Parameters should be mandatory and of type long.
void moveBy(optional unrestricted float x &#x3D; NaN, optional unrestricted float y &#x3D; NaN); &#x2F;&#x2F; FIXME: Parameters should be mandatory and of type long.
void resizeTo(optional unrestricted float width &#x3D; NaN, optional unrestricted float height &#x3D; NaN); &#x2F;&#x2F; Parameters should be mandatory and of type long.
void resizeBy(optional unrestricted float x &#x3D; NaN, optional unrestricted float y &#x3D; NaN); &#x2F;&#x2F; FIXME: Parameters should be mandatory and of type long.

&#x2F;&#x2F; Viewport (CSSOM-View).
[Replaceable] readonly attribute long innerHeight;
[Replaceable] readonly attribute long innerWidth;

&#x2F;&#x2F; Viewport scrolling (CSSOM-View).
[Replaceable] readonly attribute double scrollX;
[Replaceable, ImplementedAs&#x3D;scrollX] readonly attribute double pageXOffset;
[Replaceable] readonly attribute double scrollY;
[Replaceable, ImplementedAs&#x3D;scrollY] readonly attribute double pageYOffset;
[ImplementedAs&#x3D;scrollTo] void scroll(optional ScrollToOptions options);
[ImplementedAs&#x3D;scrollTo] void scroll(unrestricted double x, unrestricted double y);
void scrollTo(optional ScrollToOptions options);
void scrollTo(unrestricted double x, unrestricted double y);
void scrollBy(optional ScrollToOptions option);
void scrollBy(unrestricted double x, unrestricted double y);

&#x2F;&#x2F; Client (CSSOM-View).
[Replaceable] readonly attribute long screenX;
[Replaceable] readonly attribute long screenY;
[Replaceable] readonly attribute long outerWidth;
[Replaceable] readonly attribute long outerHeight;
[Replaceable] readonly attribute double devicePixelRatio;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。</p>
<h2 id="RenderObject-Tree"><a href="#RenderObject-Tree" class="headerlink" title="RenderObject Tree"></a>RenderObject Tree</h2><p>当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。</p>
<p>整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。<br><img src="/uploads/deeply-analyse-webkit/64.png" alt="64" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/64.png" class="lozad post-image"><br>上图所示，WebKit 会先检查 DOM 节点是否需要新的  RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。</p>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>RenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下：<br><img src="/uploads/deeply-analyse-webkit/88.png" alt="88" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/88.png" class="lozad post-image"></p>
<p>RenderObject 被创建时创建时相关的类如下图所示：<br><img src="/uploads/deeply-analyse-webkit/62.png" alt="62" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/62.png" class="lozad post-image"><br>Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图：<br><img src="/uploads/deeply-analyse-webkit/89.png" alt="89" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/89.png" class="lozad post-image"></p>
<p>RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图：<br><img src="/uploads/deeply-analyse-webkit/63.png" alt="63" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/63.png" class="lozad post-image"></p>
<p>RenderObject 核心对象关系图如下：<br><img src="/uploads/deeply-analyse-webkit/94.png" alt="94" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/94.png" class="lozad post-image"></p>
<p>RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。</p>
<p>RenderObject 的继承关系图如下：<br><img src="/uploads/deeply-analyse-webkit/76.png" alt="76" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/76.png" class="lozad post-image"></p>
<p>RenderObject 的一些主要虚函数</p>
<ul>
<li>parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。</li>
<li>layout()，style()，enclosingBox() 这些计算和获取布局的函数。</li>
<li>isASubClass 类似这样判断那种子类类型的函数。</li>
<li>paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。</li>
</ul>
<p>RenderObject 用来构建 Render Tree 的相关方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">RenderElement* parent() const &#123; return m_parent; &#125;
bool isDescendantOf(const RenderObject*) const;

RenderObject* previousSibling() const &#123; return m_previous; &#125;
RenderObject* nextSibling() const &#123; return m_next; &#125;

&#x2F;&#x2F; Use RenderElement versions instead.
virtual RenderObject* firstChildSlow() const &#123; return nullptr; &#125;
virtual RenderObject* lastChildSlow() const &#123; return nullptr; &#125;

RenderObject* nextInPreOrder() const;
RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;
RenderObject* nextInPreOrderAfterChildren() const;
RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;
RenderObject* previousInPreOrder() const;
RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;
WEBCORE_EXPORT RenderObject* childAt(unsigned) const;

RenderObject* firstLeafChild() const;
RenderObject* lastLeafChild() const;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>RenderObject 用来布局相关的方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool needsLayout() const
&#123;
    return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()
        || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();
&#125;

bool selfNeedsLayout() const &#123; return m_bitfields.needsLayout(); &#125;
bool needsPositionedMovementLayout() const &#123; return m_bitfields.needsPositionedMovementLayout(); &#125;
bool needsPositionedMovementLayoutOnly() const
&#123;
    return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
        &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();
&#125;

bool posChildNeedsLayout() const &#123; return m_bitfields.posChildNeedsLayout(); &#125;
bool needsSimplifiedNormalFlowLayout() const &#123; return m_bitfields.needsSimplifiedNormalFlowLayout(); &#125;
bool normalChildNeedsLayout() const &#123; return m_bitfields.normalChildNeedsLayout(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。</p>
<p>RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。</p>
<p>RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。</p>
<p>RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。</p>
<p>RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：<br><img src="/uploads/deeply-analyse-webkit/95.png" alt="95" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/95.png" class="lozad post-image"><br>RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。</p>
<p>RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下：<br><img src="/uploads/deeply-analyse-webkit/96.png" alt="96" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/96.png" class="lozad post-image"></p>
<h3 id="StyleResolver"><a href="#StyleResolver" class="headerlink" title="StyleResolver"></a>StyleResolver</h3><p>RenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。<br><img src="/uploads/deeply-analyse-webkit/61.png" alt="61" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/61.png" class="lozad post-image"></p>
<p>规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：<br><img src="/uploads/deeply-analyse-webkit/60.png" alt="60" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/60.png" class="lozad post-image"><br>创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle &#x3D; 0, StyleSharingBehavior &#x3D; AllowStyleSharing,  
    RuleMatchingBehavior &#x3D; MatchAllRules, RenderRegion* regionForStyling &#x3D; 0);   
 ......  
  
PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle);  
  
PassRefPtr&lt;RenderStyle&gt; styleForPage(int pageIndex);  
PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement();  
PassRefPtr&lt;RenderStyle&gt; styleForText(Text*);  
  
static PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* &#x3D; 0);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。</p>
<h3 id="styleForElement-进行-CSS-选择和匹配"><a href="#styleForElement-进行-CSS-选择和匹配" class="headerlink" title="styleForElement 进行 CSS 选择和匹配"></a>styleForElement 进行 CSS 选择和匹配</h3><p>具体代码实现如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;保存 element
initElement(element);
initForStyleResolve(element, defaultParent);  
....  

&#x2F;&#x2F;规则匹配  
MatchResult matchResult;  
if (matchingBehavior &#x3D;&#x3D; MatchOnlyUserAgentRules)  
    matchUARules(matchResult);  
else  
    matchAllRules(matchResult, matchingBehavior !&#x3D; MatchAllRulesExcludingSMIL);  

&#x2F;&#x2F;将规则和 element 做映射
applyMatchedProperties(matchResult, element);

&#x2F;&#x2F;matchUARules
void StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules)  
&#123;
    m_matchedRules.clear();
    result.ranges.lastUARule &#x3D; result.matchedProperties.size() - 1;
    &#x2F;&#x2F;收集匹配规则
    collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, false);  
	&#x2F;&#x2F;规则排序
    sortAndTransferMatchedRules(result);  
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="RuleSet"><a href="#RuleSet" class="headerlink" title="RuleSet"></a>RuleSet</h3><p>matchUARules 的 RuleSet 代表 CSS 规则，比如</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span> <span class="token punctuation">&#123;</span> <span class="token property">background</span> <span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>RuleSet 的成员变量</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class RuleSet ... &#123;
.....
AtomRuleMap m_idRules;
AtomRuleMap m_classRules;
AtomRuleMap m_tagRules;
AtomRuleMap m_shadowPseudoElementRules;
...
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>sortAndTransferMatchedRules 是为了保证正确的匹配顺序。</p>
<p>RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void StyledElement::rebuildPresentationAttributeStyle()  
&#123;  
.....  
  
    RefPtr&lt;StylePropertySet&gt; style;
    if (cacheHash &amp;&amp; cacheIterator-&gt;value) &#123;  
        style &#x3D; cacheIterator-&gt;value-&gt;value;  
        presentationAttributeCacheCleaner().didHitPresentationAttributeCache();  
    &#125; else &#123;  
        style &#x3D; StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode);  
        unsigned size &#x3D; attributeCount();  
        for (unsigned i &#x3D; 0; i &lt; size; ++i) &#123;  
            const Attribute* attribute &#x3D; attributeItem(i);  
            collectStyleForPresentationAttribute(*attribute, style.get());  
        &#125;  
    &#125;  
  
    &#x2F;&#x2F; ImmutableElementAttributeData doesn&#39;t store presentation attribute style, so make sure we have a MutableElementAttributeData.  
    ElementAttributeData* attributeData &#x3D; mutableAttributeData();  
  
    attributeData-&gt;m_presentationAttributeStyleIsDirty &#x3D; false;  
    attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? 0 : style);  
....<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。</p>
<h3 id="Render-tree-和-DOM-tree-做对应"><a href="#Render-tree-和-DOM-tree-做对应" class="headerlink" title="Render tree 和 DOM tree 做对应"></a>Render tree 和 DOM tree 做对应</h3><p>其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。</p>
<p>有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的：<br><img src="/uploads/deeply-analyse-webkit/65.png" alt="65" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/65.png" class="lozad post-image"><br><img src="/uploads/deeply-analyse-webkit/73.png" alt="73" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/73.png" class="lozad post-image"></p>
<p>上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。</p>
<h3 id="构建-Render-Tree-的流程"><a href="#构建-Render-Tree-的流程" class="headerlink" title="构建 Render Tree 的流程"></a>构建 Render Tree 的流程</h3><p>解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。</p>
<h3 id="RenderLayer-Tree"><a href="#RenderLayer-Tree" class="headerlink" title="RenderLayer Tree"></a>RenderLayer Tree</h3><p>RenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件：</p>
<ul>
<li>HTMLElement 节点对应的 RenderBlock 节点。</li>
<li>有设置 relative，absolute，transform 的 CSS position 属性的。</li>
<li>透明效果的 RenderObject 节点。</li>
<li>节点有 overflow， apha mask 或反射效果的 RenderObject 节点。</li>
<li>设置了 CSS filter 属性的节点。</li>
<li>使用 Canvas 或 WebGL 的 RenderObject 节点。</li>
<li>Video 节点对应的 RenderObject 节点。</li>
</ul>
<p>RenderObject Tree 和 RenderLayer Tree 的关系如下图：<br><img src="/uploads/deeply-analyse-webkit/66.png" alt="66" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/66.png" class="lozad post-image"><br>接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示：<br><img src="/uploads/deeply-analyse-webkit/67.png" alt="67" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/67.png" class="lozad post-image"></p>
<h3 id="style-计算"><a href="#style-计算" class="headerlink" title="style 计算"></a>style 计算</h3><p>构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。</p>
<p>这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。</p>
<p>我们先看看 style 计算可能会有一些什么样问题</p>
<ul>
<li>Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。</li>
<li>如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。</li>
<li>应用规则涉及到比较复杂的层级规则。</li>
</ul>
<p>下面来说下如何解决这些问题</p>
<h4 id="共享-style-数据"><a href="#共享-style-数据" class="headerlink" title="共享 style 数据"></a>共享 style 数据</h4><p>WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的</p>
<ul>
<li>element 必须有相同的鼠标状态</li>
<li>都没有 id</li>
<li>tag 名能匹配上</li>
<li>class 属性能匹配上</li>
<li>一组映射的属性是相同的</li>
<li>链接状态能匹配上</li>
<li>focus 状态能匹配上</li>
<li>任何 element 都不会被属性 selectors 影响</li>
<li>elements 不能有 inline style 属性</li>
<li>不要使用兄弟 selectors</li>
</ul>
<h4 id="Rule-tree"><a href="#Rule-tree" class="headerlink" title="Rule tree"></a>Rule tree</h4><p>WebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。<br><img src="/uploads/deeply-analyse-webkit/70.png" alt="70" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/70.png" class="lozad post-image"></p>
<p>通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。</p>
<h4 id="可确定样式分到各个-structs-里"><a href="#可确定样式分到各个-structs-里" class="headerlink" title="可确定样式分到各个 structs 里"></a>可确定样式分到各个 structs 里</h4><p>一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。</p>
<p>rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。</p>
<h4 id="使用-rule-tree-计算-style-contexts"><a href="#使用-rule-tree-计算-style-contexts" class="headerlink" title="使用 rule tree 计算 style contexts"></a>使用 rule tree 计算 style contexts</h4><p>当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。</p>
<p>从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree  上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。</p>
<p>如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。</p>
<p>如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。</p>
<p>看个例子</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>err<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>div1<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>
                          this is a <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>big<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> big error <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
                          this is also a
                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>big<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> very  big  error<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span> error
                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>err<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>div2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>another error<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是 CSS 的定义</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>5px<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span>black<span class="token punctuation">&#125;</span>
<span class="token selector">.err</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">&#125;</span>
<span class="token selector">.big</span> <span class="token punctuation">&#123;</span><span class="token property">margin-top</span><span class="token punctuation">:</span>3px<span class="token punctuation">&#125;</span>
<span class="token selector">div span</span> <span class="token punctuation">&#123;</span><span class="token property">margin-bottom</span><span class="token punctuation">:</span>4px<span class="token punctuation">&#125;</span>
<span class="token selector">#div1</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">&#125;</span>
<span class="token selector">#div2</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>green<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree<br><img src="/uploads/deeply-analyse-webkit/71.png" alt="71" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/71.png" class="lozad post-image"></p>
<p>context tree：<br><img src="/uploads/deeply-analyse-webkit/72.png" alt="72" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/72.png" class="lozad post-image"></p>
<p>假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。</p>
<p>现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。</p>
<p>已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。</p>
<p>对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。</p>
<p>如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。</p>
<h4 id="比较容易匹配的-rules"><a href="#比较容易匹配的-rules" class="headerlink" title="比较容易匹配的 rules"></a>比较容易匹配的 rules</h4><p>下面是不同的 style rules 的来源：</p>
<ul>
<li>CSS rules，来自于 style sheets 或者在 style elements 里<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>blue<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>Inline style 属性<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span>blue</span><span class="token punctuation">"</span></span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
<li>HTML 视觉属性<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">bgcolor</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。</li>
</ul>
<p>如果是 class name 那么会添加到 class map 里。</p>
<p>这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。</p>
<p>下面举个例子</p>
<pre class="line-numbers language-css" data-language="css"><code class="language-css"><span class="token selector">p.error</span> <span class="token punctuation">&#123;</span><span class="token property">color</span><span class="token punctuation">:</span>red<span class="token punctuation">&#125;</span>
<span class="token selector">#messageDiv</span> <span class="token punctuation">&#123;</span><span class="token property">height</span><span class="token punctuation">:</span>50px<span class="token punctuation">&#125;</span>
<span class="token selector">div</span> <span class="token punctuation">&#123;</span><span class="token property">margin</span><span class="token punctuation">:</span>5px<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。</p>
<p>对于下面的 HTML</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>error<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>an error occurred <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span> messageDiv<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>this is a message<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">table div &#123;margin:5px&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。</p>
<h4 id="Style-sheet-的-cascade-排序"><a href="#Style-sheet-的-cascade-排序" class="headerlink" title="Style sheet 的 cascade 排序"></a>Style sheet 的 cascade 排序</h4><p>一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。</p>
<ul>
<li>浏览器的设置</li>
<li>用户的设置</li>
<li>网页里普通的设置</li>
<li>网页里重要的设置</li>
<li>用户重要的设置</li>
</ul>
<h4 id="CSS-specification"><a href="#CSS-specification" class="headerlink" title="CSS specification"></a>CSS specification</h4><p>selector 的 specifity 在 w3c 里有定义 <a target="_blank" rel="noopener" href="https://www.w3.org/TR/CSS2/cascade.html#specificity">https://www.w3.org/TR/CSS2/cascade.html#specificity</a></p>
<p>计算方法如下</p>
<ul>
<li>style attribute 数量 &#x3D;a</li>
<li>ID attribute 数量 &#x3D;b</li>
<li>其它的 attribute 和 pseudo-classes 数量 &#x3D;c</li>
<li>element names 和 pseudo-element 数量 &#x3D;d</li>
</ul>
<p>举个例子</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"> *             &#123;&#125;  /* a=0 b=0 c=0 d=0 -> specificity = 0,0,0,0 */
 li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -> specificity = 0,0,0,1 */
 li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -> specificity = 0,0,0,2 */
 ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -> specificity = 0,0,0,3 */
 h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -> specificity = 0,0,1,1 */
 ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -> specificity = 0,0,1,3 */
 li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -> specificity = 0,0,2,1 */
 #x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -> specificity = 0,1,0,0 */
 style=""          /* a=1 b=0 c=0 d=0 -> specificity = 1,0,0,0 */

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>HEAD</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>STYLE</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">
  <span class="token selector">#x97z</span> <span class="token punctuation">&#123;</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">&#125;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>STYLE</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>HEAD</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>BODY</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>P</span> <span class="token attr-name">ID</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span>x97z</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">color</span><span class="token punctuation">:</span> green</span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>BODY</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。</p>
<h4 id="Rules-排序"><a href="#Rules-排序" class="headerlink" title="Rules 排序"></a>Rules 排序</h4><p>这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static bool operator &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)
&#123;
    int spec1 &#x3D; r1.selector()-&gt;specificity();
    int spec2 &#x3D; r2.selector()-&gt;specificity();
    return (spec1 &#x3D;&#x3D; spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。</p>
<p>HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。</p>
<p>Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。</p>
<h3 id="Layout-处理过程"><a href="#Layout-处理过程" class="headerlink" title="Layout 处理过程"></a>Layout 处理过程</h3><p>完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">FrameView:: layout( bool allowSubtree) &#x2F;&#x2F; 栈 顶 
Document:: implicitClose() 
FrameLoader:: checkCallImplicitClose() 
FrameLoader:: checkCompleted() 
FrameLoader:: finishedParsing() 
Document:: finishedParsing() 
HTMLParser:: finished() 
HTMLTokenizer:: end() 
HTMLTokenizer:: finish() 
Document:: finishParsing() 
FrameLoader:: endIfNotLoadingMainResource() 
FrameLoader:: end() 
DocumentLoader:: finishedLoading() 
FrameLoader:: finishedLoading() 
MainResourceLoader:: didFinishLoading() 
ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void FrameView::layout(bool allowSubtree)
&#123;
    ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());

    LOG(Layout, &quot;FrameView %p (%dx%d) layout, main frameview %d, allowSubtree&#x3D;%d&quot;, this, size().width(), size().height(), frame().isMainFrame(), allowSubtree);
    &#x2F;&#x2F;判断是否已在 layout 过程中，避免多次 layout
    if (isInRenderTreeLayout()) &#123;
        LOG(Layout, &quot;  in layout, bailing&quot;);
        return;
    &#125;

    if (layoutDisallowed()) &#123;
        LOG(Layout, &quot;  layout is disallowed, bailing&quot;);
        return;
    &#125;

    &#x2F;&#x2F; Protect the view from being deleted during layout (in recalcStyle).
    Ref&lt;FrameView&gt; protectedThis(*this);

    &#x2F;&#x2F; Many of the tasks performed during layout can cause this function to be re-entered,
    &#x2F;&#x2F; so save the layout phase now and restore it on exit.
    SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout);

    &#x2F;&#x2F; Every scroll that happens during layout is programmatic.
    SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);

    bool inChildFrameLayoutWithFrameFlattening &#x3D; isInChildFrameWithFrameFlattening();

    if (inChildFrameLayoutWithFrameFlattening) &#123;
        if (!m_frameFlatteningViewSizeForMediaQuery) &#123;
            LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; this &lt;&lt; &quot; snapshotting size &quot; &lt;&lt;  ScrollView::layoutSize() &lt;&lt; &quot; for media queries&quot;);
            m_frameFlatteningViewSizeForMediaQuery &#x3D; ScrollView::layoutSize();
        &#125;
        startLayoutAtMainFrameViewIfNeeded(allowSubtree);
        &#x2F;&#x2F;获取 root。这个 root 就是 RenderView 对象
        RenderElement* root &#x3D; m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView();
        if (!root || !root-&gt;needsLayout())
            return;
    &#125;
    
    TraceScope tracingScope(LayoutStart, LayoutEnd);

#if PLATFORM(IOS)
    if (updateFixedPositionLayoutRect())
        allowSubtree &#x3D; false;
#endif
    &#x2F;&#x2F;也是避免多次触发，会把 layoutTimer 先停止
    m_layoutTimer.stop();
    m_delayedLayout &#x3D; false;
    m_setNeedsLayoutWasDeferred &#x3D; false;
    
    &#x2F;&#x2F;我们不应该在 painting 时进入 layout
    ASSERT(!isPainting());
    if (isPainting())
        return;

    InspectorInstrumentationCookie cookie &#x3D; InspectorInstrumentation::willLayout(frame());
    AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());
    
    if (!allowSubtree &amp;&amp; m_layoutRoot)
        convertSubtreeLayoutToFullLayout();

    ASSERT(frame().view() &#x3D;&#x3D; this);
    ASSERT(frame().document());

    Document&amp; document &#x3D; *frame().document();
    ASSERT(document.pageCacheState() &#x3D;&#x3D; Document::NotInPageCache);
    &#x2F;&#x2F;对样式先进行更新
    &#123;
        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);

        if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) &#123;
            &#x2F;&#x2F; This is a new top-level layout. If there are any remaining tasks from the previous
            &#x2F;&#x2F; layout, finish them now.
            SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);
            performPostLayoutTasks();
        &#125;

        m_layoutPhase &#x3D; InPreLayoutStyleUpdate;

        &#x2F;&#x2F; Viewport-dependent media queries may cause us to need completely different style information.
        auto* styleResolver &#x3D; document.styleScope().resolverIfExists();
        if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) &#123;
            LOG(Layout, &quot;  hasMediaQueriesAffectedByViewportChange, enqueueing style recalc&quot;);
            document.styleScope().didChangeStyleSheetEnvironment();
            &#x2F;&#x2F; FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds.
            InspectorInstrumentation::mediaQueryResultChanged(document);
        &#125;
        document.evaluateMediaQueryList();
        &#x2F;&#x2F; If there is any pagination to apply, it will affect the RenderView&#39;s style, so we should
        &#x2F;&#x2F; take care of that now.
        applyPaginationToViewport();
        &#x2F;&#x2F; Always ensure our style info is up-to-date. This can happen in situations where
        &#x2F;&#x2F; the layout beats any sort of style recalc update that needs to occur.
        document.updateStyleIfNeeded();
        &#x2F;&#x2F; If there is only one ref to this view left, then its going to be destroyed as soon as we exit,
        &#x2F;&#x2F; so there&#39;s no point to continuing to layout
        if (hasOneRef())
            return;

        &#x2F;&#x2F; Close block here so we can set up the font cache purge preventer, which we will still
        &#x2F;&#x2F; want in scope even after we want m_layoutSchedulingEnabled to be restored again.
        &#x2F;&#x2F; The next block sets m_layoutSchedulingEnabled back to false once again.
    &#125;

    m_layoutPhase &#x3D; InPreLayout;

    RenderLayer* layer &#x3D; nullptr;
    bool subtree &#x3D; false;
    RenderElement* root &#x3D; nullptr;

    ++m_nestedLayoutCount;

    &#123;
        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);

        autoSizeIfEnabled();
        &#x2F;&#x2F;重新设置 RenderView 对象，准备开始 layout
        root &#x3D; m_layoutRoot ? m_layoutRoot : document.renderView();
        if (!root)
            return;
        subtree &#x3D; m_layoutRoot;

        if (!m_layoutRoot) &#123;
            auto* body &#x3D; document.bodyOrFrameset();
            if (body &amp;&amp; body-&gt;renderer()) &#123;
                if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) &#123;
                    body-&gt;renderer()-&gt;setChildNeedsLayout();
                &#125; else if (is&lt;HTMLBodyElement&gt;(*body)) &#123;
                    if (!m_firstLayout &amp;&amp; m_size.height() !&#x3D; layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport())
                        body-&gt;renderer()-&gt;setChildNeedsLayout();
                &#125;
            &#125;

#if !LOG_DISABLED
            if (m_firstLayout &amp;&amp; !frame().ownerElement())
                LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs\n&quot;, this, document.timeSinceDocumentCreation().value());
#endif
        &#125;

        m_needsFullRepaint &#x3D; !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing());

        if (!subtree) &#123;
            ScrollbarMode hMode;
            ScrollbarMode vMode;    
            calculateScrollbarModesForLayout(hMode, vMode);

            if (m_firstLayout || (hMode !&#x3D; horizontalScrollbarMode() || vMode !&#x3D; verticalScrollbarMode())) &#123;
                if (m_firstLayout) &#123;
                    setScrollbarsSuppressed(true);

                    m_firstLayout &#x3D; false;
                    m_firstLayoutCallbackPending &#x3D; true;
                    m_lastViewportSize &#x3D; sizeForResizeEvent();
                    m_lastZoomFactor &#x3D; root-&gt;style().zoom();

                    &#x2F;&#x2F; Set the initial vMode to AlwaysOn if we&#39;re auto.
                    if (vMode &#x3D;&#x3D; ScrollbarAuto)
                        setVerticalScrollbarMode(ScrollbarAlwaysOn); &#x2F;&#x2F; This causes a vertical scrollbar to appear.
                    &#x2F;&#x2F; Set the initial hMode to AlwaysOff if we&#39;re auto.
                    if (hMode &#x3D;&#x3D; ScrollbarAuto)
                        setHorizontalScrollbarMode(ScrollbarAlwaysOff); &#x2F;&#x2F; This causes a horizontal scrollbar to disappear.
                    Page* page &#x3D; frame().page();
                    if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())
                        scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());
                    setScrollbarModes(hMode, vMode);
                    setScrollbarsSuppressed(false, true);
                &#125; else
                    setScrollbarModes(hMode, vMode);
            &#125;

            LayoutSize oldSize &#x3D; m_size;
            m_size &#x3D; layoutSize();

            if (oldSize !&#x3D; m_size) &#123;
                LOG(Layout, &quot;  layout size changed from %.3fx%.3f to %.3fx%.3f&quot;, oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat());
                m_needsFullRepaint &#x3D; true;
                if (!m_firstLayout) &#123;
                    RenderBox* rootRenderer &#x3D; document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;
                    auto* body &#x3D; document.bodyOrFrameset();
                    RenderBox* bodyRenderer &#x3D; rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;
                    if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())
                        bodyRenderer-&gt;setChildNeedsLayout();
                    else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())
                        rootRenderer-&gt;setChildNeedsLayout();
                &#125;
            &#125;

            m_layoutPhase &#x3D; InPreLayout;
        &#125;

        layer &#x3D; root-&gt;enclosingLayer();
        SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot);

        RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view());

        ASSERT(m_layoutPhase &#x3D;&#x3D; InPreLayout);
        m_layoutPhase &#x3D; InRenderTreeLayout;

        forceLayoutParentViewIfNeeded();

        ASSERT(m_layoutPhase &#x3D;&#x3D; InRenderTreeLayout);
#ifndef NDEBUG
        RenderTreeNeedsLayoutChecker checker(*root);
#endif
        &#x2F;&#x2F;从 RenderView 这个根级开始进行 layout。
        root-&gt;layout();
        ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());

#if ENABLE(TEXT_AUTOSIZING)
        if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) &#123;
            float minimumZoomFontSize &#x3D; frame().settings().minimumZoomFontSize();
            float textAutosizingWidth &#x3D; frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0;
            if (int overrideWidth &#x3D; frame().settings().textAutosizingWindowSizeOverride().width())
                textAutosizingWidth &#x3D; overrideWidth;

            LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize&#x3D;%.2f textAutosizingWidth&#x3D;%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);
            
            if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) &#123;
                root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);
                if (root-&gt;needsLayout())
                    root-&gt;layout();
            &#125;
        &#125;
#endif

        ASSERT(m_layoutPhase &#x3D;&#x3D; InRenderTreeLayout);
        m_layoutRoot &#x3D; nullptr;
        &#x2F;&#x2F; Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer.
    &#125;

    m_layoutPhase &#x3D; InViewSizeAdjust;

    bool neededFullRepaint &#x3D; m_needsFullRepaint;

    if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) &#123;
        adjustViewSize();
        &#x2F;&#x2F; FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by
        &#x2F;&#x2F; navigating away from the current document (see webkit.org&#x2F;b&#x2F;173329).
        if (hasOneRef())
            return;
    &#125;

    m_layoutPhase &#x3D; InPostLayout;

    m_needsFullRepaint &#x3D; neededFullRepaint;

    &#x2F;&#x2F; Now update the positions of all layers.
    if (m_needsFullRepaint)
        root-&gt;view().repaintRootContents();

    root-&gt;view().releaseProtectedRenderWidgets();

    ASSERT(!root-&gt;needsLayout());

    layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint));

    updateCompositingLayersAfterLayout();

    m_layoutPhase &#x3D; InPostLayerPositionsUpdatedAfterLayout;

    m_layoutCount++;

#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)
    if (AXObjectCache* cache &#x3D; root-&gt;document().existingAXObjectCache())
        cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);
#endif

#if ENABLE(DASHBOARD_SUPPORT)
    updateAnnotatedRegions();
#endif

#if ENABLE(IOS_TOUCH_EVENTS)
    document.setTouchEventRegionsNeedUpdate();
#endif

    updateCanBlitOnScrollRecursively();

    handleDeferredScrollUpdateAfterContentSizeChange();

    handleDeferredScrollbarsUpdateAfterDirectionChange();

    if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER))
        updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());

    frame().document()-&gt;markers().invalidateRectsForAllMarkers();

    if (!m_postLayoutTasksTimer.isActive()) &#123;
        if (!m_inSynchronousPostLayout) &#123;
            if (inChildFrameLayoutWithFrameFlattening)
                updateWidgetPositions();
            else &#123;
                SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);
                performPostLayoutTasks(); &#x2F;&#x2F; Calls resumeScheduledEvents().
            &#125;
        &#125;

        if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) &#123;
            &#x2F;&#x2F; If we need layout or are already in a synchronous call to postLayoutTasks(), 
            &#x2F;&#x2F; defer widget updates and event dispatch until after we return. postLayoutTasks()
            &#x2F;&#x2F; can make us need to update again, and we can get stuck in a nasty cycle unless
            &#x2F;&#x2F; we call it through the timer here.
            m_postLayoutTasksTimer.startOneShot(0_s);
        &#125;
        if (needsLayout())
            layout();
    &#125;

    InspectorInstrumentation::didLayout(cookie, *root);
    DebugPageOverlays::didLayout(frame());

    --m_nestedLayoutCount;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void RenderView::layoutContent(const LayoutState&amp; state)
&#123;
    UNUSED_PARAM(state);
    ASSERT(needsLayout());

    RenderBlockFlow::layout();
    if (hasRenderNamedFlowThreads())
        flowThreadController().layoutRenderNamedFlowThreads();
#ifndef NDEBUG
    checkLayoutState(state);
#endif
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)
&#123;
    ASSERT(needsLayout());
    &#x2F;&#x2F;当不需要布局子节点同时能 simplifiedLayout 重新布局成功
    if (!relayoutChildren &amp;&amp; simplifiedLayout())
        return;

    LayoutRepainter repainter(*this, checkForRepaintDuringLayout());
    &#x2F;&#x2F;重新计算逻辑宽度
    if (recomputeLogicalWidthAndColumnWidth())
        relayoutChildren &#x3D; true;

    rebuildFloatingObjectSetFromIntrudingFloats();

    &#x2F;&#x2F;先保留一份以前的高度为后面做对比用
    LayoutUnit previousHeight &#x3D; logicalHeight();
    &#x2F;&#x2F; FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),
    &#x2F;&#x2F; for consistency with other render classes?
    &#x2F;&#x2F;然后将 logicalHeight 设置为 0，避免累加以前的。
    setLogicalHeight(0);

    bool pageLogicalHeightChanged &#x3D; false;
    checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);

    const RenderStyle&amp; styleToUse &#x3D; style();
    LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);

    preparePaginationBeforeBlockLayout(relayoutChildren);
    if (!relayoutChildren)
        relayoutChildren &#x3D; namedFlowFragmentNeedsUpdate();

    &#x2F;&#x2F; We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track
    &#x2F;&#x2F; our current maximal positive and negative margins. These values are used when we
    &#x2F;&#x2F; are collapsed with adjacent blocks, so for example, if you have block A and B
    &#x2F;&#x2F; collapsing together, then you&#39;d take the maximal positive margin from both A and B
    &#x2F;&#x2F; and subtract it from the maximal negative margin from both A and B to get the
    &#x2F;&#x2F; true collapsed margin. This algorithm is recursive, so when we finish layout()
    &#x2F;&#x2F; our block knows its current maximal positive&#x2F;negative values.
    &#x2F;&#x2F;
    &#x2F;&#x2F; Start out by setting our margin values to our current margins. Table cells have
    &#x2F;&#x2F; no margins, so we don&#39;t fill in the values for table cells.
    bool isCell &#x3D; isTableCell();
    if (!isCell) &#123;
        initMaxMarginValues();
        
        setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());
        setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());
        setPaginationStrut(0);
    &#125;

    LayoutUnit repaintLogicalTop &#x3D; 0;
    LayoutUnit repaintLogicalBottom &#x3D; 0;
    LayoutUnit maxFloatLogicalBottom &#x3D; 0;
    if (!firstChild() &amp;&amp; !isAnonymousBlock())
        setChildrenInline(true);
    &#x2F;&#x2F;Inline 和 Block 的不同布局处理
    if (childrenInline())
        layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);
    else
        layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);

    &#x2F;&#x2F; Expand our intrinsic height to encompass floats.
    LayoutUnit toAdd &#x3D; borderAndPaddingAfter() + scrollbarLogicalHeight();
    if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())
        setLogicalHeight(lowestFloatLogicalBottom() + toAdd);
    
    if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) &#123;
        ASSERT(!shouldBreakAtLineToAvoidWidow());
        return;
    &#125;

    &#x2F;&#x2F; Calculate our new height. 计算新高
    LayoutUnit oldHeight &#x3D; logicalHeight();
    LayoutUnit oldClientAfterEdge &#x3D; clientLogicalBottom();

    &#x2F;&#x2F; Before updating the final size of the flow thread make sure a forced break is applied after the content.
    &#x2F;&#x2F; This ensures the size information is correctly computed for the last auto-height region receiving content.
    if (is&lt;RenderFlowThread&gt;(*this))
        downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);

    updateLogicalHeight();
    LayoutUnit newHeight &#x3D; logicalHeight();
    if (oldHeight !&#x3D; newHeight) &#123;
        if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) &#123;
            &#x2F;&#x2F; One of our children&#39;s floats may have become an overhanging float for us. We need to look for it.
            for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) &#123;
                if (blockFlow.isFloatingOrOutOfFlowPositioned())
                    continue;
                if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)
                    addOverhangingFloats(blockFlow, false);
            &#125;
        &#125;
    &#125;

    &#x2F;&#x2F;前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点
    bool heightChanged &#x3D; (previousHeight !&#x3D; newHeight);
    if (heightChanged)
        relayoutChildren &#x3D; true;

    layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());

    &#x2F;&#x2F;Add overflow from children (unless we&#39;re multi-column, since in that case all our child overflow is clipped anyway).
    computeOverflow(oldClientAfterEdge);
    
    statePusher.pop();

    fitBorderToLinesIfNeeded();

    if (view().layoutState()-&gt;m_pageLogicalHeight)
        setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop()));

    updateLayerTransform();

    &#x2F;&#x2F; Update our scroll information if we&#39;re overflow:auto&#x2F;scroll&#x2F;hidden now that we know if
    &#x2F;&#x2F; we overflow or not.
    updateScrollInfoAfterLayout();

    &#x2F;&#x2F; FIXME: This repaint logic should be moved into a separate helper function!
    &#x2F;&#x2F; Repaint with our new bounds if they are different from our old bounds.
    bool didFullRepaint &#x3D; repainter.repaintAfterLayout();
    if (!didFullRepaint &amp;&amp; repaintLogicalTop !&#x3D; repaintLogicalBottom &amp;&amp; (styleToUse.visibility() &#x3D;&#x3D; VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) &#123;
        &#x2F;&#x2F; FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines
        &#x2F;&#x2F; it had to lay out. We wouldn&#39;t need the hasOverflowClip() hack in that case either.
        LayoutUnit repaintLogicalLeft &#x3D; logicalLeftVisualOverflow();
        LayoutUnit repaintLogicalRight &#x3D; logicalRightVisualOverflow();
        if (hasOverflowClip()) &#123;
            &#x2F;&#x2F; If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn&#39;t propagate to our block&#39;s overflow.
            &#x2F;&#x2F; Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.
            &#x2F;&#x2F; layoutInlineChildren should be patched to compute the entire repaint rect.
            repaintLogicalLeft &#x3D; std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());
            repaintLogicalRight &#x3D; std::max(repaintLogicalRight, logicalRightLayoutOverflow());
        &#125;
        
        LayoutRect repaintRect;
        if (isHorizontalWritingMode())
            repaintRect &#x3D; LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);
        else
            repaintRect &#x3D; LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);

        if (hasOverflowClip()) &#123;
            &#x2F;&#x2F; Adjust repaint rect for scroll offset
            repaintRect.moveBy(-scrollPosition());

            &#x2F;&#x2F; Don&#39;t allow this rect to spill out of our overflow box.
            repaintRect.intersect(LayoutRect(LayoutPoint(), size()));
        &#125;

        &#x2F;&#x2F; Make sure the rect is still non-empty after intersecting for overflow above
        if (!repaintRect.isEmpty()) &#123;
            repaintRectangle(repaintRect); &#x2F;&#x2F; We need to do a partial repaint of our content.
            if (hasReflection())
                repaintRectangle(reflectedRect(repaintRect));
        &#125;
    &#125;

    clearNeedsLayout();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。</p>
<h3 id="Layout-Tree-创建"><a href="#Layout-Tree-创建" class="headerlink" title="Layout Tree 创建"></a>Layout Tree 创建</h3><p>Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是<a target="_blank" rel="noopener" href="https://skia.org/">Skia</a> 开源 2D 图形库做底层 Paint 引擎。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Document::finishedParsing() &#123;
      updateStyleAndLayoutTree();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>每个 Node 都会创建一个 LayoutObject，</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LayoutObject* newLayoutObject &#x3D; m_node-&gt;createLayoutObject(style);
parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="Layout-值的计算"><a href="#Layout-值的计算" class="headerlink" title="Layout 值的计算"></a>Layout 值的计算</h3><p>Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)
&#123;
    LayoutUnit oldPosMarginBefore &#x3D; maxPositiveMarginBefore();
    LayoutUnit oldNegMarginBefore &#x3D; maxNegativeMarginBefore();

    &#x2F;&#x2F; The child is a normal flow object. Compute the margins we will use for collapsing now.
    child.computeAndSetBlockDirectionMargins(*this);

    &#x2F;&#x2F; Try to guess our correct logical top position. In most cases this guess will
    &#x2F;&#x2F; be correct. Only if we&#39;re wrong (when we compute the real logical top position)
    &#x2F;&#x2F; will we have to potentially relayout.
    LayoutUnit estimateWithoutPagination;
    &#x2F;&#x2F;估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标
    LayoutUnit logicalTopEstimate &#x3D; estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);

    &#x2F;&#x2F; Cache our old rect so that we can dirty the proper repaint rects if the child moves.
    LayoutRect oldRect &#x3D; child.frameRect();
    LayoutUnit oldLogicalTop &#x3D; logicalTopForChild(child);

#if !ASSERT_DISABLED
    LayoutSize oldLayoutDelta &#x3D; view().layoutDelta();
#endif
    &#x2F;&#x2F; Position the child as though it didn&#39;t collapse with the top.
    &#x2F;&#x2F;先设置布局前 top 坐标
    setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);
    estimateRegionRangeForBoxChild(child);

    RenderBlockFlow* childBlockFlow &#x3D; is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : nullptr;
    bool markDescendantsWithFloats &#x3D; false;
    if (logicalTopEstimate !&#x3D; oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
        markDescendantsWithFloats &#x3D; true;
    else if (UNLIKELY(logicalTopEstimate.mightBeSaturated()))
        &#x2F;&#x2F; logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for
        &#x2F;&#x2F; very large elements. If it does the comparison with oldLogicalTop might yield a
        &#x2F;&#x2F; false negative as adding and removing margins, borders etc from a saturated number
        &#x2F;&#x2F; might yield incorrect results. If this is the case always mark for layout.
        markDescendantsWithFloats &#x3D; true;
    else if (!child.avoidsFloats() || child.shrinkToAvoidFloats()) &#123;
        &#x2F;&#x2F; If an element might be affected by the presence of floats, then always mark it for
        &#x2F;&#x2F; layout.
        LayoutUnit fb &#x3D; std::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());
        if (fb &gt; logicalTopEstimate)
            markDescendantsWithFloats &#x3D; true;
    &#125;

    if (childBlockFlow) &#123;
        if (markDescendantsWithFloats)
            childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
        if (!child.isWritingModeRoot())
            previousFloatLogicalBottom &#x3D; std::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());
    &#125;

    child.markForPaginationRelayoutIfNeeded();

    bool childHadLayout &#x3D; child.everHadLayout();
    &#x2F;&#x2F;对子节点进行布局
    bool childNeededLayout &#x3D; child.needsLayout();
    if (childNeededLayout)
        child.layout();

    &#x2F;&#x2F; Cache if we are at the top of the block right now.
    bool atBeforeSideOfBlock &#x3D; marginInfo.atBeforeSideOfBlock();

    &#x2F;&#x2F;保证 top 坐标和子节点布局后能够同步
    &#x2F;&#x2F; Now determine the correct ypos based off examination of collapsing margin
    &#x2F;&#x2F; values.
    LayoutUnit logicalTopBeforeClear &#x3D; collapseMargins(child, marginInfo);

    &#x2F;&#x2F; Now check for clear.
    LayoutUnit logicalTopAfterClear &#x3D; clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);
    
    bool paginated &#x3D; view().layoutState()-&gt;isPaginated();
    if (paginated)
        logicalTopAfterClear &#x3D; adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear &#x3D;&#x3D; logicalTopAfterClear);

    &#x2F;&#x2F;经过上面的子节点布局完后重新计算得到新高
    setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);

    &#x2F;&#x2F; Now we have a final top position. See if it really does end up being different from our estimate.
    &#x2F;&#x2F; clearFloatsIfNeeded can also mark the child as needing a layout even though we didn&#39;t move. This happens
    &#x2F;&#x2F; when collapseMargins dynamically adds overhanging floats because of a child with negative margins.
    if (logicalTopAfterClear !&#x3D; logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) &#123;
        if (child.shrinkToAvoidFloats()) &#123;
            &#x2F;&#x2F; The child&#39;s width depends on the line width. When the child shifts to clear an item, its width can
            &#x2F;&#x2F; change (because it has more available line width). So mark the item as dirty.
            child.setChildNeedsLayout(MarkOnlyThis);
        &#125;
        
        if (childBlockFlow) &#123;
            if (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())
                childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();
            child.markForPaginationRelayoutIfNeeded();
        &#125;
    &#125;

    if (updateRegionRangeForBoxChild(child))
        child.setNeedsLayout(MarkOnlyThis);

    &#x2F;&#x2F; In case our guess was wrong, relayout the child.
    child.layoutIfNeeded();

    &#x2F;&#x2F; We are no longer at the top of the block if we encounter a non-empty child.  
    &#x2F;&#x2F; This has to be done after checking for clear, so that margins can be reset if a clear occurred.
    if (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())
        marginInfo.setAtBeforeSideOfBlock(false);

    &#x2F;&#x2F; Now place the child in the correct left position
    &#x2F;&#x2F;计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。
    determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);

    &#x2F;&#x2F; Update our height now that the child has been placed in the correct position.
    setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));
    if (mustSeparateMarginAfterForChild(child)) &#123;
        setLogicalHeight(logicalHeight() + marginAfterForChild(child));
        marginInfo.clearMargin();
    &#125;
    &#x2F;&#x2F; If the child has overhanging floats that intrude into following siblings (or possibly out
    &#x2F;&#x2F; of this block), then the parent gets notified of the floats now.
    if (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())
        maxFloatLogicalBottom &#x3D; std::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));

    LayoutSize childOffset &#x3D; child.location() - oldRect.location();
    if (childOffset.width() || childOffset.height()) &#123;
        view().addLayoutDelta(childOffset);

        &#x2F;&#x2F; If the child moved, we have to repaint it as well as any floating&#x2F;positioned
        &#x2F;&#x2F; descendants. An exception is if we need a layout. In this case, we know we&#39;re going to
        &#x2F;&#x2F; repaint ourselves (and the child) anyway.
        if (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())
            child.repaintDuringLayoutIfMoved(oldRect);
    &#125;

    &#x2F;&#x2F;渲染
    if (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) &#123;
        child.repaint();
        child.repaintOverhangingFloats(true);
    &#125;

    if (paginated) &#123;
        if (RenderFlowThread* flowThread &#x3D; flowThreadContainingBlock())
            flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child);
        &#x2F;&#x2F; Check for an after page&#x2F;column break.
        LayoutUnit newHeight &#x3D; applyAfterBreak(child, logicalHeight(), marginInfo);
        if (newHeight !&#x3D; height())
            setLogicalHeight(newHeight);
    &#125;

    ASSERT(view().layoutDeltaMatches(oldLayoutDelta));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>判断值的类型是固定值还是百分比的方法</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">switch (length.type()) &#123;
  case Fixed:
    return LayoutUnit(length.value()); &#x2F;&#x2F;返回 LayoutUnit 封装的数据 1px &#x3D; 1 &lt;&lt; 6 &#x3D; 64 unit
  case Percent:
    &#x2F;&#x2F;maximumValue 是传进来的最大值
    return LayoutUnit(
        static_cast&lt;float&gt;(maximumValue * length.percent() &#x2F; 100.0f));
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算 margin 的值</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; CSS 2.1: &quot;If both &#39;margin-left&#39; and &#39;margin-right&#39; are &#39;auto&#39;, their used
&#x2F;&#x2F; values are equal. This horizontally centers the element with respect to
&#x2F;&#x2F; the edges of the containing block.&quot;
const ComputedStyle&amp; containingBlockStyle &#x3D; containingBlock-&gt;styleRef();
if (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) &#123;
  LayoutUnit centeredMarginBoxStart &#x3D; std::max(
      LayoutUnit(),
      (availableWidth - childWidth) &#x2F; 2); 
  marginStart &#x3D; centeredMarginBoxStart;
  marginEnd &#x3D; availableWidth - childWidth - marginStart;
  return;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Box Model 里</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">m_frameRect.setWidth(width);
m_marginBox.setStart(marginLeft);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>First line.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>Second one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>布局计算后带布局信息的 Render Tree 如下：</p>
<pre class="line-numbers language-none"><code class="language-none">RenderBlock &#123;HTML&#125; at (0, 0) size 640x480 
|—— RenderBody &#123;BODY&#125; at (0, 80) size 640x480 [bgcolor&#x3D;# FFFFFF] 
| |—— RenderBlock &#123;P&#125; at (0, 0) size 640x80 
| | |—— RenderText &#123;#text&#125; at (0, 0) size 48x24 &quot;First line.&quot; 
| | |—— RenderBR &#123;BR&#125; at (20, 20) size 0x0 
| | |—— RenderText &#123;#text&#125; at (0, 24) size 48x24 &quot;Second one.&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h3 id="Box-Model-数据结构"><a href="#Box-Model-数据结构" class="headerlink" title="Box Model 数据结构"></a>Box Model 数据结构</h3><p><img src="/uploads/deeply-analyse-webkit/16.png" alt="16" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/16.png" class="lozad post-image"><br>所有的 elements 都有 display 属性用来确定显示类型。属性值有</p>
<ul>
<li>block：生成一个 block box</li>
<li>inline：生成一个或多个 inline boxes</li>
<li>none：不生成 box</li>
</ul>
<p>默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：<a target="_blank" rel="noopener" href="http://www.w3.org/TR/CSS2/sample.html">http://www.w3.org/TR/CSS2/sample.html</a></p>
<h4 id="定位的方案"><a href="#定位的方案" class="headerlink" title="定位的方案"></a>定位的方案</h4><p>有三种方案</p>
<ul>
<li>Normal：由 render tree 来决定的位置。</li>
<li>Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。</li>
<li>Absolute：让其在 render tree 的位置和 DOM tree 不一样</li>
</ul>
<p>定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。</p>
<p>对于 float 的处理，首先需要判断宽度是否需要 fit content</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool LayoutBox::sizesLogicalWidthToFitContent(
    const Length&amp; logicalWidth) const &#123;
  if (isFloating() || isInlineBlockOrInlineTable())
    return true;
  ...
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。</p>
<p>对于 float:left 的计算</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束
while (logicalRightOffsetForPositioningFloat(
           logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) -
           floatLogicalLeft &lt;
       floatLogicalWidth) &#123;
  &#x2F;&#x2F;下移
  logicalTopOffset +&#x3D;
      std::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight);
  &#x2F;&#x2F;新的 floatLogicalLeft
  floatLogicalLeft &#x3D; logicalLeftOffsetForPositioningFloat(
      logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft);
  &#125;
&#125;
&#x2F;&#x2F;看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值
floatLogicalLeft &#x3D; std::max(
    logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="Box-类型"><a href="#Box-类型" class="headerlink" title="Box 类型"></a>Box 类型</h4><p>Block box：在浏览器的 window 里有自己的矩形<br><img src="/uploads/deeply-analyse-webkit/20.png" alt="20" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/20.png" class="lozad post-image"></p>
<p>Inline box：没有自己的 block，但是会在一个 block 里<br><img src="/uploads/deeply-analyse-webkit/21.png" alt="21" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/21.png" class="lozad post-image"></p>
<p>Block 是按照垂直排列，Inline 是按照水平来排列<br><img src="/uploads/deeply-analyse-webkit/22.png" alt="22" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/22.png" class="lozad post-image"></p>
<p>Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。<br><img src="/uploads/deeply-analyse-webkit/23.png" alt="23" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/23.png" class="lozad post-image"></p>
<p>下面举个例子看看 Inline  类型的例子，比如有如下的 html：</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>First line.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>Second one.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这段 html 的 Render Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/97.png" alt="97" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/97.png" class="lozad post-image"></p>
<h4 id="Position-类型"><a href="#Position-类型" class="headerlink" title="Position 类型"></a>Position 类型</h4><p>Relative：相对定位，先按照正常的定位然后根据设置的值再移动。<br><img src="/uploads/deeply-analyse-webkit/24.png" alt="24" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/24.png" class="lozad post-image"></p>
<p>Float：会被移动到左边或右边侧<br><img src="/uploads/deeply-analyse-webkit/25.png" alt="25" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/25.png" class="lozad post-image"></p>
<p>Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。<br><img src="/uploads/deeply-analyse-webkit/26.png" alt="26" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/26.png" class="lozad post-image"></p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。</p>
<pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>STYLE</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">
    <span class="token selector">div</span> <span class="token punctuation">&#123;</span> 
        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span> 
        <span class="token property">left</span><span class="token punctuation">:</span> 2in<span class="token punctuation">;</span> 
        <span class="token property">top</span><span class="token punctuation">:</span> 2in<span class="token punctuation">;</span> 
    <span class="token punctuation">&#125;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>STYLE</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>P</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DIV</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> 3<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span>red<span class="token punctuation">;</span> <span class="token property">width</span><span class="token punctuation">:</span> 1in<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 1in<span class="token punctuation">;</span> </span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DIV</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>DIV</span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">z-index</span><span class="token punctuation">:</span> 1<span class="token punctuation">;</span><span class="token property">background-color</span><span class="token punctuation">:</span>green<span class="token punctuation">;</span><span class="token property">width</span><span class="token punctuation">:</span> 2in<span class="token punctuation">;</span> <span class="token property">height</span><span class="token punctuation">:</span> 2in<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>DIV</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果如下：<br><img src="/uploads/deeply-analyse-webkit/27.png" alt="27" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/deeply-analyse-webkit/27.png" class="lozad post-image"></p>
<p>可以看到层级是按照 z-index 来排的。</p>
<h4 id="大小的计算"><a href="#大小的计算" class="headerlink" title="大小的计算"></a>大小的计算</h4><p>border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; More IE extensions.  clientWidth and clientHeight represent the interior of
&#x2F;&#x2F; an object excluding border and scrollbar.
LayoutUnit LayoutBox::clientWidth() const &#123;
  return m_frameRect.width() - borderLeft() - borderRight() -
         verticalScrollbarWidth();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>offsetWidth  是 frameRect 的宽度</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; IE extensions. Used to calculate offsetWidth&#x2F;Height.
LayoutUnit offsetWidth() const override &#123; return m_frameRect.width(); &#125;
LayoutUnit offsetHeight() const override &#123; return m_frameRect.height(); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>Margin 区域是用 LayoutRectOutsets </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LayoutUnit m_top;
LayoutUnit m_right;
LayoutUnit m_bottom;
LayoutUnit m_left;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置的计算，即 x 和 y 是通过下面两个函数计算得到</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 根据 margin 得到 y 值
LayoutUnit logicalTopBeforeClear &#x3D;
    collapseMargins(child, layoutInfo, childIsSelfCollapsing,
                    childDiscardMarginBefore, childDiscardMarginAfter);
&#x2F;&#x2F; 得到 x 值
determineLogicalLeftPositionForChild(child);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。</p>

  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://starming.com/about">戴铭</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://starming.com/2017/10/11/deeply-analyse-webkit/">https://starming.com/2017/10/11/deeply-analyse-webkit/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/2017/10/16/html-to-native-htn-development-record/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">Prev</div>
        
        <div class="nav-title">HTML 转原生 HTN 项目开发记录 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/2017/06/20/deeply-ios-performance-optimization/" class="nav-link">
      <div>
        <div class="nav-label">Next</div>
        
        <div class="nav-title">深入剖析 iOS 性能优化 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">HTML 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">1.1.</span> <span class="toc-text">HTML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">2.1.</span> <span class="toc-text">历史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebKit-%E5%85%A8%E8%B2%8C"><span class="toc-number">3.</span> <span class="toc-text">WebKit 全貌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">WebKit 源代码结构说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.3.</span> <span class="toc-text">WebKit 代码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">WebKit 的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">主要类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93"><span class="toc-number">3.5.1.</span> <span class="toc-text">整体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebCore-Frame"><span class="toc-number">3.5.2.</span> <span class="toc-text">WebCore::Frame</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E"><span class="toc-number">3.6.</span> <span class="toc-text">渲染引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frame-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.7.</span> <span class="toc-text">Frame 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create"><span class="toc-number">3.7.1.</span> <span class="toc-text">Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createView"><span class="toc-number">3.7.2.</span> <span class="toc-text">createView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDocument"><span class="toc-number">3.7.3.</span> <span class="toc-text">setDocument</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WTF"><span class="toc-number">4.</span> <span class="toc-text">WTF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">Smart ptr 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefPtr"><span class="toc-number">4.2.</span> <span class="toc-text">RefPtr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assert-%E6%96%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Assert 断言的实现和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">Vector 动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">HashTable 哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader"><span class="toc-number">5.</span> <span class="toc-text">Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">5.1.</span> <span class="toc-text">Loader 的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader"><span class="toc-number">5.2.</span> <span class="toc-text">FrameLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">类关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">FrameLoader 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-init"><span class="toc-number">5.3.1.</span> <span class="toc-text">Frame::init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-commitProvisionalLoad"><span class="toc-number">5.3.2.</span> <span class="toc-text">FrameLoader::commitProvisionalLoad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-finishedLoading"><span class="toc-number">5.3.3.</span> <span class="toc-text">Frame::finishedLoading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-finishedParsing"><span class="toc-number">5.3.4.</span> <span class="toc-text">FrameLoader::finishedParsing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-load-FrameLoadRequest-amp-amp-request"><span class="toc-number">5.3.5.</span> <span class="toc-text">FrameLoader::load(FrameLoadRequest&amp;&amp; request)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">WebKit 网络处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandle-%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">ResourceHandle 的相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandleClient"><span class="toc-number">5.6.</span> <span class="toc-text">ResourceHandleClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MainResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.1.</span> <span class="toc-text">MainResourceLoader 的加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.2.</span> <span class="toc-text">SubResourceLoader 的加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.8.</span> <span class="toc-text">资源的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84-Cache"><span class="toc-number">5.9.</span> <span class="toc-text">WebKit 的 Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Cache"><span class="toc-number">5.9.1.</span> <span class="toc-text">Page Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Cache"><span class="toc-number">5.9.2.</span> <span class="toc-text">Memory Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disk-Cache"><span class="toc-number">5.9.3.</span> <span class="toc-text">Disk Cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%88%90-Tag-%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84-HTML-Token"><span class="toc-number">6.</span> <span class="toc-text">HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%88%90-HTML-Token-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">解析成 HTML Token 的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">HTML 语法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">HTML 的语法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">相关类关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Element-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.4.</span> <span class="toc-text">Element 属性设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.5.</span> <span class="toc-text">资源加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree"><span class="toc-number">8.</span> <span class="toc-text">构建 DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83"><span class="toc-number">8.1.</span> <span class="toc-text">DOM 标准规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree-Token-%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">DOM Tree Token 的构造算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">关键类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree"><span class="toc-number">8.5.</span> <span class="toc-text">DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E8%8A%82%E7%82%B9"><span class="toc-number">8.5.1.</span> <span class="toc-text">Node 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLElement"><span class="toc-number">8.5.2.</span> <span class="toc-text">HTMLElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree-1"><span class="toc-number">8.5.3.</span> <span class="toc-text">构建 DOM Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">对错误的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">8.6.1.</span> <span class="toc-text"> 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stray-table"><span class="toc-number">8.6.2.</span> <span class="toc-text">stray table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-form"><span class="toc-number">8.6.3.</span> <span class="toc-text">嵌套 form</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">8.6.4.</span> <span class="toc-text">过深的层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html-%E6%88%96-body-%E7%9A%84-end-tags-%E7%BC%BA%E5%A4%B1"><span class="toc-number">8.6.5.</span> <span class="toc-text">html 或 body 的 end tags 缺失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">9.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">CSS 语法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declarations"><span class="toc-number">9.1.1.</span> <span class="toc-text">CSS declarations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declaration-blocks"><span class="toc-number">9.1.2.</span> <span class="toc-text">CSS declaration blocks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-selectors-and-rules"><span class="toc-number">9.1.3.</span> <span class="toc-text">CSS selectors and rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-statements"><span class="toc-number">9.1.4.</span> <span class="toc-text">CSS statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shorthand"><span class="toc-number">9.1.5.</span> <span class="toc-text">Shorthand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-and-unit"><span class="toc-number">9.1.6.</span> <span class="toc-text">Value and unit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-CSS-%E8%AF%AD%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">9.1.7.</span> <span class="toc-text">验证 CSS 语法正确性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-BNF"><span class="toc-number">9.2.</span> <span class="toc-text">CSS BNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%B8%BB%E8%A6%81%E7%B1%BB%E4%B8%8E%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.</span> <span class="toc-text">CSS 主要类与关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRuleBase-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.1.</span> <span class="toc-text">StyleRuleBase 类的继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRule-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.2.</span> <span class="toc-text">StyleRule 类的结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-CSS"><span class="toc-number">9.4.</span> <span class="toc-text">解析 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">9.5.</span> <span class="toc-text">CSS 规则匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-style"><span class="toc-number">9.6.</span> <span class="toc-text">设置 style</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-Object-Model-CSSOM"><span class="toc-number">9.7.</span> <span class="toc-text">CSS Object Model (CSSOM)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderObject-Tree"><span class="toc-number">10.</span> <span class="toc-text">RenderObject Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderObject"><span class="toc-number">10.1.</span> <span class="toc-text">RenderObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StyleResolver"><span class="toc-number">10.2.</span> <span class="toc-text">StyleResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#styleForElement-%E8%BF%9B%E8%A1%8C-CSS-%E9%80%89%E6%8B%A9%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">10.3.</span> <span class="toc-text">styleForElement 进行 CSS 选择和匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RuleSet"><span class="toc-number">10.4.</span> <span class="toc-text">RuleSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-tree-%E5%92%8C-DOM-tree-%E5%81%9A%E5%AF%B9%E5%BA%94"><span class="toc-number">10.5.</span> <span class="toc-text">Render tree 和 DOM tree 做对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-Render-Tree-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">10.6.</span> <span class="toc-text">构建 Render Tree 的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderLayer-Tree"><span class="toc-number">10.7.</span> <span class="toc-text">RenderLayer Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#style-%E8%AE%A1%E7%AE%97"><span class="toc-number">10.8.</span> <span class="toc-text">style 计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-style-%E6%95%B0%E6%8D%AE"><span class="toc-number">10.8.1.</span> <span class="toc-text">共享 style 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-tree"><span class="toc-number">10.8.2.</span> <span class="toc-text">Rule tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A1%AE%E5%AE%9A%E6%A0%B7%E5%BC%8F%E5%88%86%E5%88%B0%E5%90%84%E4%B8%AA-structs-%E9%87%8C"><span class="toc-number">10.8.3.</span> <span class="toc-text">可确定样式分到各个 structs 里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rule-tree-%E8%AE%A1%E7%AE%97-style-contexts"><span class="toc-number">10.8.4.</span> <span class="toc-text">使用 rule tree 计算 style contexts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E5%8C%B9%E9%85%8D%E7%9A%84-rules"><span class="toc-number">10.8.5.</span> <span class="toc-text">比较容易匹配的 rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Style-sheet-%E7%9A%84-cascade-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.6.</span> <span class="toc-text">Style sheet 的 cascade 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-specification"><span class="toc-number">10.8.7.</span> <span class="toc-text">CSS specification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.8.</span> <span class="toc-text">Rules 排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layout-%E5%B8%83%E5%B1%80"><span class="toc-number">11.</span> <span class="toc-text">Layout 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">Layout 处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-Tree-%E5%88%9B%E5%BB%BA"><span class="toc-number">11.2.</span> <span class="toc-text">Layout Tree 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.3.</span> <span class="toc-text">Layout 值的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Box-Model-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.</span> <span class="toc-text">Box Model 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">11.4.1.</span> <span class="toc-text">定位的方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.2.</span> <span class="toc-text">Box 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Position-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.3.</span> <span class="toc-text">Position 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-number">11.4.4.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.4.5.</span> <span class="toc-text">大小的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.4.6.</span> <span class="toc-text">位置</span></a></li></ol></li></ol></li></ol>
</div></main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/ming.jpeg" class="author-img">

<p class="author-name">戴铭</p>
<p class="author-description">极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>79</span>
    <span>Posts</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>8</span>
    <span>Categories</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>44</span>
    <span>Tags</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://weibo.com/allstarming">
        <i class="iconfont icon-sina society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/ming1016">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a href="mailto:ming1016@foxmail.com">
        <i class="iconfont icon-mail society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a href="/atom.xml">
        <i class="iconfont icon-chrome society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">HTML 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">1.1.</span> <span class="toc-text">HTML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">2.1.</span> <span class="toc-text">历史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebKit-%E5%85%A8%E8%B2%8C"><span class="toc-number">3.</span> <span class="toc-text">WebKit 全貌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">WebKit 源代码结构说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.3.</span> <span class="toc-text">WebKit 代码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">WebKit 的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">主要类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93"><span class="toc-number">3.5.1.</span> <span class="toc-text">整体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebCore-Frame"><span class="toc-number">3.5.2.</span> <span class="toc-text">WebCore::Frame</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E"><span class="toc-number">3.6.</span> <span class="toc-text">渲染引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frame-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.7.</span> <span class="toc-text">Frame 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create"><span class="toc-number">3.7.1.</span> <span class="toc-text">Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createView"><span class="toc-number">3.7.2.</span> <span class="toc-text">createView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDocument"><span class="toc-number">3.7.3.</span> <span class="toc-text">setDocument</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WTF"><span class="toc-number">4.</span> <span class="toc-text">WTF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">Smart ptr 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefPtr"><span class="toc-number">4.2.</span> <span class="toc-text">RefPtr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assert-%E6%96%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Assert 断言的实现和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">Vector 动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">HashTable 哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader"><span class="toc-number">5.</span> <span class="toc-text">Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">5.1.</span> <span class="toc-text">Loader 的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader"><span class="toc-number">5.2.</span> <span class="toc-text">FrameLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">类关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">FrameLoader 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-init"><span class="toc-number">5.3.1.</span> <span class="toc-text">Frame::init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-commitProvisionalLoad"><span class="toc-number">5.3.2.</span> <span class="toc-text">FrameLoader::commitProvisionalLoad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-finishedLoading"><span class="toc-number">5.3.3.</span> <span class="toc-text">Frame::finishedLoading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-finishedParsing"><span class="toc-number">5.3.4.</span> <span class="toc-text">FrameLoader::finishedParsing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-load-FrameLoadRequest-amp-amp-request"><span class="toc-number">5.3.5.</span> <span class="toc-text">FrameLoader::load(FrameLoadRequest&amp;&amp; request)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">WebKit 网络处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandle-%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">ResourceHandle 的相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandleClient"><span class="toc-number">5.6.</span> <span class="toc-text">ResourceHandleClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MainResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.1.</span> <span class="toc-text">MainResourceLoader 的加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.2.</span> <span class="toc-text">SubResourceLoader 的加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.8.</span> <span class="toc-text">资源的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84-Cache"><span class="toc-number">5.9.</span> <span class="toc-text">WebKit 的 Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Cache"><span class="toc-number">5.9.1.</span> <span class="toc-text">Page Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Cache"><span class="toc-number">5.9.2.</span> <span class="toc-text">Memory Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disk-Cache"><span class="toc-number">5.9.3.</span> <span class="toc-text">Disk Cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%88%90-Tag-%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84-HTML-Token"><span class="toc-number">6.</span> <span class="toc-text">HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%88%90-HTML-Token-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">解析成 HTML Token 的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">HTML 语法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">HTML 的语法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">相关类关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Element-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.4.</span> <span class="toc-text">Element 属性设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.5.</span> <span class="toc-text">资源加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree"><span class="toc-number">8.</span> <span class="toc-text">构建 DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83"><span class="toc-number">8.1.</span> <span class="toc-text">DOM 标准规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree-Token-%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">DOM Tree Token 的构造算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">关键类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree"><span class="toc-number">8.5.</span> <span class="toc-text">DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E8%8A%82%E7%82%B9"><span class="toc-number">8.5.1.</span> <span class="toc-text">Node 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLElement"><span class="toc-number">8.5.2.</span> <span class="toc-text">HTMLElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree-1"><span class="toc-number">8.5.3.</span> <span class="toc-text">构建 DOM Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">对错误的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">8.6.1.</span> <span class="toc-text"> 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stray-table"><span class="toc-number">8.6.2.</span> <span class="toc-text">stray table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-form"><span class="toc-number">8.6.3.</span> <span class="toc-text">嵌套 form</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">8.6.4.</span> <span class="toc-text">过深的层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html-%E6%88%96-body-%E7%9A%84-end-tags-%E7%BC%BA%E5%A4%B1"><span class="toc-number">8.6.5.</span> <span class="toc-text">html 或 body 的 end tags 缺失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">9.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">CSS 语法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declarations"><span class="toc-number">9.1.1.</span> <span class="toc-text">CSS declarations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declaration-blocks"><span class="toc-number">9.1.2.</span> <span class="toc-text">CSS declaration blocks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-selectors-and-rules"><span class="toc-number">9.1.3.</span> <span class="toc-text">CSS selectors and rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-statements"><span class="toc-number">9.1.4.</span> <span class="toc-text">CSS statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shorthand"><span class="toc-number">9.1.5.</span> <span class="toc-text">Shorthand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-and-unit"><span class="toc-number">9.1.6.</span> <span class="toc-text">Value and unit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-CSS-%E8%AF%AD%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">9.1.7.</span> <span class="toc-text">验证 CSS 语法正确性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-BNF"><span class="toc-number">9.2.</span> <span class="toc-text">CSS BNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%B8%BB%E8%A6%81%E7%B1%BB%E4%B8%8E%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.</span> <span class="toc-text">CSS 主要类与关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRuleBase-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.1.</span> <span class="toc-text">StyleRuleBase 类的继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRule-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.2.</span> <span class="toc-text">StyleRule 类的结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-CSS"><span class="toc-number">9.4.</span> <span class="toc-text">解析 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">9.5.</span> <span class="toc-text">CSS 规则匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-style"><span class="toc-number">9.6.</span> <span class="toc-text">设置 style</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-Object-Model-CSSOM"><span class="toc-number">9.7.</span> <span class="toc-text">CSS Object Model (CSSOM)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderObject-Tree"><span class="toc-number">10.</span> <span class="toc-text">RenderObject Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderObject"><span class="toc-number">10.1.</span> <span class="toc-text">RenderObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StyleResolver"><span class="toc-number">10.2.</span> <span class="toc-text">StyleResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#styleForElement-%E8%BF%9B%E8%A1%8C-CSS-%E9%80%89%E6%8B%A9%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">10.3.</span> <span class="toc-text">styleForElement 进行 CSS 选择和匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RuleSet"><span class="toc-number">10.4.</span> <span class="toc-text">RuleSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-tree-%E5%92%8C-DOM-tree-%E5%81%9A%E5%AF%B9%E5%BA%94"><span class="toc-number">10.5.</span> <span class="toc-text">Render tree 和 DOM tree 做对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-Render-Tree-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">10.6.</span> <span class="toc-text">构建 Render Tree 的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderLayer-Tree"><span class="toc-number">10.7.</span> <span class="toc-text">RenderLayer Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#style-%E8%AE%A1%E7%AE%97"><span class="toc-number">10.8.</span> <span class="toc-text">style 计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-style-%E6%95%B0%E6%8D%AE"><span class="toc-number">10.8.1.</span> <span class="toc-text">共享 style 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-tree"><span class="toc-number">10.8.2.</span> <span class="toc-text">Rule tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A1%AE%E5%AE%9A%E6%A0%B7%E5%BC%8F%E5%88%86%E5%88%B0%E5%90%84%E4%B8%AA-structs-%E9%87%8C"><span class="toc-number">10.8.3.</span> <span class="toc-text">可确定样式分到各个 structs 里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rule-tree-%E8%AE%A1%E7%AE%97-style-contexts"><span class="toc-number">10.8.4.</span> <span class="toc-text">使用 rule tree 计算 style contexts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E5%8C%B9%E9%85%8D%E7%9A%84-rules"><span class="toc-number">10.8.5.</span> <span class="toc-text">比较容易匹配的 rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Style-sheet-%E7%9A%84-cascade-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.6.</span> <span class="toc-text">Style sheet 的 cascade 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-specification"><span class="toc-number">10.8.7.</span> <span class="toc-text">CSS specification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.8.</span> <span class="toc-text">Rules 排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layout-%E5%B8%83%E5%B1%80"><span class="toc-number">11.</span> <span class="toc-text">Layout 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">Layout 处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-Tree-%E5%88%9B%E5%BB%BA"><span class="toc-number">11.2.</span> <span class="toc-text">Layout Tree 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.3.</span> <span class="toc-text">Layout 值的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Box-Model-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.</span> <span class="toc-text">Box Model 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">11.4.1.</span> <span class="toc-text">定位的方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.2.</span> <span class="toc-text">Box 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Position-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.3.</span> <span class="toc-text">Position 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-number">11.4.4.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.4.5.</span> <span class="toc-text">大小的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.4.6.</span> <span class="toc-text">位置</span></a></li></ol></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>Categories</div>
  <div class="categories-list">
    
      <a href="/categories/Programming">
        <div class="categories-list-item">
          Programming
          <span class="categories-list-item-badge">50</span>
        </div>
      </a>
    
      <a href="/categories/My-novel">
        <div class="categories-list-item">
          My-novel
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/My-painting">
        <div class="categories-list-item">
          My-painting
          <span class="categories-list-item-badge">8</span>
        </div>
      </a>
    
      <a href="/categories/Podcast">
        <div class="categories-list-item">
          Podcast
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/App">
        <div class="categories-list-item">
          App
          <span class="categories-list-item-badge">11</span>
        </div>
      </a>
    
      <a href="/categories/travel">
        <div class="categories-list-item">
          travel
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/macOS">
        <div class="categories-list-item">
          macOS
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/AI">
        <div class="categories-list-item">
          AI
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>hot tags</div>
  <div class="tags-list">
    
    <a href="\tags\iOS" title="iOS"><div class="tags-list-item">iOS</div></a>
    
    <a href="\tags\Swift" title="Swift"><div class="tags-list-item">Swift</div></a>
    
    <a href="\tags\Apple" title="Apple"><div class="tags-list-item">Apple</div></a>
    
    <a href="\tags\SwiftUI" title="SwiftUI"><div class="tags-list-item">SwiftUI</div></a>
    
    <a href="\tags\Painting" title="Painting"><div class="tags-list-item">Painting</div></a>
    
    <a href="\tags\App" title="App"><div class="tags-list-item">App</div></a>
    
    <a href="\tags\Slides" title="Slides"><div class="tags-list-item">Slides</div></a>
    
    <a href="\tags\iPad" title="iPad"><div class="tags-list-item">iPad</div></a>
    
    <a href="\tags\Procreate" title="Procreate"><div class="tags-list-item">Procreate</div></a>
    
    <a href="\tags\LLVM" title="LLVM"><div class="tags-list-item">LLVM</div></a>
    
    <a href="\tags\Performance optimization" title="Performance optimization"><div class="tags-list-item">Performance optimization</div></a>
    
    <a href="\tags\Web" title="Web"><div class="tags-list-item">Web</div></a>
    
    <a href="\tags\Novel" title="Novel"><div class="tags-list-item">Novel</div></a>
    
    <a href="\tags\Manga" title="Manga"><div class="tags-list-item">Manga</div></a>
    
    <a href="\tags\Podcast" title="Podcast"><div class="tags-list-item">Podcast</div></a>
    
    <a href="\tags\macOS" title="macOS"><div class="tags-list-item">macOS</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">
  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>TOC</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E6%A0%87%E5%87%86"><span class="toc-number">1.</span> <span class="toc-text">HTML 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">1.1.</span> <span class="toc-text">HTML</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2"><span class="toc-number">2.1.</span> <span class="toc-text">历史</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebKit-%E5%85%A8%E8%B2%8C"><span class="toc-number">3.</span> <span class="toc-text">WebKit 全貌</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">WebKit 源代码结构说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-number">3.3.</span> <span class="toc-text">WebKit 代码风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">WebKit 的设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">主要类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93"><span class="toc-number">3.5.1.</span> <span class="toc-text">整体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebCore-Frame"><span class="toc-number">3.5.2.</span> <span class="toc-text">WebCore::Frame</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E"><span class="toc-number">3.6.</span> <span class="toc-text">渲染引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frame-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.7.</span> <span class="toc-text">Frame 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Create"><span class="toc-number">3.7.1.</span> <span class="toc-text">Create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createView"><span class="toc-number">3.7.2.</span> <span class="toc-text">createView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDocument"><span class="toc-number">3.7.3.</span> <span class="toc-text">setDocument</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WTF"><span class="toc-number">4.</span> <span class="toc-text">WTF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Smart-ptr-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">Smart ptr 智能指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefPtr"><span class="toc-number">4.2.</span> <span class="toc-text">RefPtr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assert-%E6%96%AD%E8%A8%80%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Assert 断言的实现和应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">4.5.1.</span> <span class="toc-text">Vector 动态数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashTable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">HashTable 哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader"><span class="toc-number">5.</span> <span class="toc-text">Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loader-%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">5.1.</span> <span class="toc-text">Loader 的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader"><span class="toc-number">5.2.</span> <span class="toc-text">FrameLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.2.</span> <span class="toc-text">类关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FrameLoader-%E7%9A%84%E4%B8%BB%E8%A6%81%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">FrameLoader 的主要接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-init"><span class="toc-number">5.3.1.</span> <span class="toc-text">Frame::init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-commitProvisionalLoad"><span class="toc-number">5.3.2.</span> <span class="toc-text">FrameLoader::commitProvisionalLoad</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-finishedLoading"><span class="toc-number">5.3.3.</span> <span class="toc-text">Frame::finishedLoading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-finishedParsing"><span class="toc-number">5.3.4.</span> <span class="toc-text">FrameLoader::finishedParsing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FrameLoader-load-FrameLoadRequest-amp-amp-request"><span class="toc-number">5.3.5.</span> <span class="toc-text">FrameLoader::load(FrameLoadRequest&amp;&amp; request)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">WebKit 网络处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandle-%E7%9A%84%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">ResourceHandle 的相关类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceHandleClient"><span class="toc-number">5.6.</span> <span class="toc-text">ResourceHandleClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="toc-number">5.7.</span> <span class="toc-text">加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MainResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.1.</span> <span class="toc-text">MainResourceLoader 的加载顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SubResourceLoader-%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.7.2.</span> <span class="toc-text">SubResourceLoader 的加载顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.8.</span> <span class="toc-text">资源的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebKit-%E7%9A%84-Cache"><span class="toc-number">5.9.</span> <span class="toc-text">WebKit 的 Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page-Cache"><span class="toc-number">5.9.1.</span> <span class="toc-text">Page Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memory-Cache"><span class="toc-number">5.9.2.</span> <span class="toc-text">Memory Cache</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Disk-Cache"><span class="toc-number">5.9.3.</span> <span class="toc-text">Disk Cache</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%8D%E6%B3%95%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E6%9E%90%E6%88%90-Tag-%E4%B8%BA%E5%8D%95%E4%BD%8D%E7%9A%84-HTML-Token"><span class="toc-number">6.</span> <span class="toc-text">HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E6%88%90-HTML-Token-%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">解析成 HTML Token 的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-number">7.</span> <span class="toc-text">HTML 语法解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-%E7%9A%84%E8%AF%AD%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">7.1.</span> <span class="toc-text">HTML 的语法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">7.2.</span> <span class="toc-text">相关类关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">解析过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Element-%E5%B1%9E%E6%80%A7%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.4.</span> <span class="toc-text">Element 属性设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.5.</span> <span class="toc-text">资源加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree"><span class="toc-number">8.</span> <span class="toc-text">构建 DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83"><span class="toc-number">8.1.</span> <span class="toc-text">DOM 标准规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree-Token-%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">DOM Tree Token 的构造算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">关键类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-Tree"><span class="toc-number">8.5.</span> <span class="toc-text">DOM Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E8%8A%82%E7%82%B9"><span class="toc-number">8.5.1.</span> <span class="toc-text">Node 节点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLElement"><span class="toc-number">8.5.2.</span> <span class="toc-text">HTMLElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-Tree-1"><span class="toc-number">8.5.3.</span> <span class="toc-text">构建 DOM Tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%94%99%E8%AF%AF%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">8.6.</span> <span class="toc-text">对错误的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">8.6.1.</span> <span class="toc-text"> 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stray-table"><span class="toc-number">8.6.2.</span> <span class="toc-text">stray table</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97-form"><span class="toc-number">8.6.3.</span> <span class="toc-text">嵌套 form</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">8.6.4.</span> <span class="toc-text">过深的层级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#html-%E6%88%96-body-%E7%9A%84-end-tags-%E7%BC%BA%E5%A4%B1"><span class="toc-number">8.6.5.</span> <span class="toc-text">html 或 body 的 end tags 缺失</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">9.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">CSS 语法简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declarations"><span class="toc-number">9.1.1.</span> <span class="toc-text">CSS declarations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-declaration-blocks"><span class="toc-number">9.1.2.</span> <span class="toc-text">CSS declaration blocks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-selectors-and-rules"><span class="toc-number">9.1.3.</span> <span class="toc-text">CSS selectors and rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-statements"><span class="toc-number">9.1.4.</span> <span class="toc-text">CSS statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shorthand"><span class="toc-number">9.1.5.</span> <span class="toc-text">Shorthand</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Value-and-unit"><span class="toc-number">9.1.6.</span> <span class="toc-text">Value and unit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-CSS-%E8%AF%AD%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">9.1.7.</span> <span class="toc-text">验证 CSS 语法正确性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-BNF"><span class="toc-number">9.2.</span> <span class="toc-text">CSS BNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%B8%BB%E8%A6%81%E7%B1%BB%E4%B8%8E%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.</span> <span class="toc-text">CSS 主要类与关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRuleBase-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">9.3.1.</span> <span class="toc-text">StyleRuleBase 类的继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StyleRule-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">9.3.2.</span> <span class="toc-text">StyleRule 类的结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-CSS"><span class="toc-number">9.4.</span> <span class="toc-text">解析 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E8%A7%84%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">9.5.</span> <span class="toc-text">CSS 规则匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-style"><span class="toc-number">9.6.</span> <span class="toc-text">设置 style</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-Object-Model-CSSOM"><span class="toc-number">9.7.</span> <span class="toc-text">CSS Object Model (CSSOM)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderObject-Tree"><span class="toc-number">10.</span> <span class="toc-text">RenderObject Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderObject"><span class="toc-number">10.1.</span> <span class="toc-text">RenderObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StyleResolver"><span class="toc-number">10.2.</span> <span class="toc-text">StyleResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#styleForElement-%E8%BF%9B%E8%A1%8C-CSS-%E9%80%89%E6%8B%A9%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">10.3.</span> <span class="toc-text">styleForElement 进行 CSS 选择和匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RuleSet"><span class="toc-number">10.4.</span> <span class="toc-text">RuleSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Render-tree-%E5%92%8C-DOM-tree-%E5%81%9A%E5%AF%B9%E5%BA%94"><span class="toc-number">10.5.</span> <span class="toc-text">Render tree 和 DOM tree 做对应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-Render-Tree-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">10.6.</span> <span class="toc-text">构建 Render Tree 的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RenderLayer-Tree"><span class="toc-number">10.7.</span> <span class="toc-text">RenderLayer Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#style-%E8%AE%A1%E7%AE%97"><span class="toc-number">10.8.</span> <span class="toc-text">style 计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB-style-%E6%95%B0%E6%8D%AE"><span class="toc-number">10.8.1.</span> <span class="toc-text">共享 style 数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rule-tree"><span class="toc-number">10.8.2.</span> <span class="toc-text">Rule tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%A1%AE%E5%AE%9A%E6%A0%B7%E5%BC%8F%E5%88%86%E5%88%B0%E5%90%84%E4%B8%AA-structs-%E9%87%8C"><span class="toc-number">10.8.3.</span> <span class="toc-text">可确定样式分到各个 structs 里</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rule-tree-%E8%AE%A1%E7%AE%97-style-contexts"><span class="toc-number">10.8.4.</span> <span class="toc-text">使用 rule tree 计算 style contexts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AE%B9%E6%98%93%E5%8C%B9%E9%85%8D%E7%9A%84-rules"><span class="toc-number">10.8.5.</span> <span class="toc-text">比较容易匹配的 rules</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Style-sheet-%E7%9A%84-cascade-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.6.</span> <span class="toc-text">Style sheet 的 cascade 排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSS-specification"><span class="toc-number">10.8.7.</span> <span class="toc-text">CSS specification</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rules-%E6%8E%92%E5%BA%8F"><span class="toc-number">10.8.8.</span> <span class="toc-text">Rules 排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Layout-%E5%B8%83%E5%B1%80"><span class="toc-number">11.</span> <span class="toc-text">Layout 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">11.1.</span> <span class="toc-text">Layout 处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-Tree-%E5%88%9B%E5%BB%BA"><span class="toc-number">11.2.</span> <span class="toc-text">Layout Tree 创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Layout-%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.3.</span> <span class="toc-text">Layout 值的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Box-Model-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">11.4.</span> <span class="toc-text">Box Model 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">11.4.1.</span> <span class="toc-text">定位的方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Box-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.2.</span> <span class="toc-text">Box 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Position-%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.4.3.</span> <span class="toc-text">Position 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-number">11.4.4.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">11.4.5.</span> <span class="toc-text">大小的计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE"><span class="toc-number">11.4.6.</span> <span class="toc-text">位置</span></a></li></ol></li></ol></li></ol>
  </article>
  
  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>Recent Posts</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-05-05</div>
        <a href="/2025/05/05/pamphlet-app667/"><div class="recent-posts-item-content">憋了个大招！《戴铭的小册子》6.6.7 版：不止搞开发，这次玩儿大了！</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-03-06</div>
        <a href="/2025/03/06/letsvision25-ai-improve-ios-skill/"><div class="recent-posts-item-content">使用 AI 突破 iOS 开发者能力边界</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-02-18</div>
        <a href="/2025/02/18/macos-app-i-used/"><div class="recent-posts-item-content">2025 年我正在使用的 macOS 应用</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2025-01-21</div>
        <a href="/2025/01/21/ios-conf-sg-25-share/"><div class="recent-posts-item-content">我在 iOS Conf SG 25 的演讲</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      <div class="footer-dsc">
        <span>Copyright ©
          
          2014 -
          
          2025
        </span>
        <a href="/" class="footer-link">戴铭的博客 </a>
      </div>
    </div>

    
    
    
    <div class="BbeiAn-info">
      <a target="_blank" rel="noopener" href="http://www.beian.miit.gov.cn/">京ICP备2024068292号-1 </a>
    </div>
    
    <div class="BbeiAn-info">
      <span style="padding-left: 25px;background: url(/img/beian.png) no-repeat left center"></span>
      <a target="_blank" rel="noopener" href="https://beian.mps.gov.cn/#/query/webSearch?code=11010802044427 ">京公网安备11010802044427
      </a>
      <br />
    </div>
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton" >
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget">
  <i class="iconfont icon-weather button-icon"></i>
</a>

  
  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('data-fslightbox', 'gallery');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('style', 'width: 100%; display: flex; justify-content: center;');
      img[i].parentElement.insertBefore(wrapper, img[i]);
      wrapper.appendChild(img[i]);
    }
    refreshFsLightbox();
  }
</script>
<script>loadScript("//cdn.jsdelivr.net/npm/fslightbox@3.1.0/index.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>