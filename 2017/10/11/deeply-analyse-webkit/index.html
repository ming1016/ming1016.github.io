<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Web,WebKit," />





  <link rel="alternate" href="/atom.xml" title="星光社 - 戴铭的博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/uploads/logo.png?v=5.1.1" />






<meta name="description" content="HTML 标准HTML HTML DOM 树的插入状态规范 https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode HTML Tokenize 规范 https://html.spec.whatwg.org/multipage/parsing.html#tokenization https://dev.w3.or">
<meta name="keywords" content="Web,WebKit">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析 WebKit">
<meta property="og:url" content="http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/index.html">
<meta property="og:site_name" content="星光社 - 戴铭的博客">
<meta property="og:description" content="HTML 标准HTML HTML DOM 树的插入状态规范 https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode HTML Tokenize 规范 https://html.spec.whatwg.org/multipage/parsing.html#tokenization https://dev.w3.or">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/45.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/46.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/49.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/74.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/01.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/02.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/47.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/03.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/04.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/48.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/05.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/06.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/29.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/43.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/44.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/50.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/07.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/39.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/08.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/30.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/77.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/78.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/31.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/80.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/98.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/32.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/79.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/85.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/86.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/81.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/33.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/34.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/35.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/36.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/82.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/51.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/83.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/17.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/28.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/55.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/09.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/10.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/84.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/87.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/52.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/19.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/53.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/11.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/54.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/69.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/56.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/37.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/12.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/75.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/40.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/41.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/42.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/68.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/57.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/90.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/58.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/59.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/91.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/13.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/92.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/93.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/14.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/15.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/64.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/88.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/62.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/89.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/63.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/94.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/76.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/95.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/96.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/61.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/60.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/65.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/73.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/66.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/67.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/70.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/71.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/72.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/16.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/20.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/21.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/22.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/23.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/97.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/24.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/25.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/26.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/27.png">
<meta property="og:updated_time" content="2017-10-23T05:11:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入剖析 WebKit">
<meta name="twitter:description" content="HTML 标准HTML HTML DOM 树的插入状态规范 https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode HTML Tokenize 规范 https://html.spec.whatwg.org/multipage/parsing.html#tokenization https://dev.w3.or">
<meta name="twitter:image" content="http://ming1016.github.io/uploads/deeply-analyse-webkit/45.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/"/>





  <title>深入剖析 WebKit | 星光社 - 戴铭的博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">星光社 - 戴铭的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="戴铭">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/251980?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星光社 - 戴铭的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入剖析 WebKit</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T11:42:25+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Programming</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="HTML-标准"><a href="#HTML-标准" class="headerlink" title="HTML 标准"></a>HTML 标准</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>HTML DOM 树的插入状态规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-insertion-mode</a></li>
<li>HTML Tokenize 规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#tokenization" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#tokenization</a> <a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="external">https://dev.w3.org/html5/spec-preview/tokenization.html</a></li>
<li>HTMLElement 堆栈规范 <a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a></li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p>1990年 Berners-Lee 发明了 WorldWideWeb 浏览器，后改名 Nexus，在1991年公布了源码。</p>
<p>1993年 Marc Andreessen 的团队开发了 Mosaic，1994年推出我们熟悉的 Netscape Navigator 网景浏览器，在最火爆的时候曾占是绝大多数人的选择。同时他还成立了网景公司。</p>
<p>1995年微软推出了 Internet Explorer 浏览器，简称 IE，通过免费绑定进 Windows 95 系统最终替代了 Netscape，赢得了浏览器大战。</p>
<p>1998年网景公司成立了 Mozilla 基金会组织，同时开源浏览器代码，2004年推出有多标签和支持扩展的 Firefox 火狐浏览器开始慢慢的占领市场份额。</p>
<p>2003年苹果发布了 Safari 浏览器，2005年放出了核心源码 WebKit。</p>
<p>2008年 Google 以苹果的 WebKit 为内核，建立了新的项目 Chromium，在此基础上开发了自己浏览器 Chrome。</p>
<p>2012年 WHATWG 和 W3C 推出 HTML5 技术规范。HTML5 包含了10大类别，offline 离线，storage 存储，connectivity 连接，file access 文件访问，semantics 语义，audio / video 音频视频，3D/graphics 3D和图形，presentation 展示，performance 性能和 Nuts and bolts 其它。</p>
<p>完整的浏览器发展史可以在这里看：<a href="https://en.wikipedia.org/wiki/Timeline_of_web_browsers" target="_blank" rel="external">https://en.wikipedia.org/wiki/Timeline_of_web_browsers</a></p>
<h2 id="WebKit-全貌"><a href="#WebKit-全貌" class="headerlink" title="WebKit 全貌"></a>WebKit 全貌</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>可以看到浏览器技术的发展到了后期基本都是基于 WebKit 开发的，那么我们就来了解下 WebKit 吧。先看看它的全貌。<br>先看看它的大模块：<br><img src="/uploads/deeply-analyse-webkit/45.png" alt="45"><br>WebKit 为了能够具有 Chromium 那样的多进程优点而推出了 WebKit2 抽象出一组新的编程接口，下面是 WebKit2 的进程结构模型：<br><img src="/uploads/deeply-analyse-webkit/46.png" alt="46"><br>整个 WebKit 架构，如下：<br><img src="/uploads/deeply-analyse-webkit/49.png" alt="49"><br>实线部分是共享的，虚线部分会根据不同的平台有不同的实现。</p>
<p>下面是 WebKit 最核心最复杂的排版引擎 WebCore 的结构图：<br><img src="/uploads/deeply-analyse-webkit/74.png" alt="74"></p>
<p><img src="/uploads/deeply-analyse-webkit/01.png" alt="01"></p>
<p>解析后会产生 DOM Tree，解析 CSS 会产生 CSS Rule Tree，Javascript 会通过 DOM API 和 CSS Object Model（CSSOM） API 来操作 DOM Tree 和 CSS Rule Tree。</p>
<p>DOM Tree<br><img src="/uploads/deeply-analyse-webkit/02.png" alt="02"><br>从网页 URL 到构建完 DOM 树的过程如图<br><img src="/uploads/deeply-analyse-webkit/47.png" alt="47"></p>
<p>CSS Rule Tree<br><img src="/uploads/deeply-analyse-webkit/03.png" alt="03"></p>
<p>通过上面的两个数构造的 Style Context Tree<br><img src="/uploads/deeply-analyse-webkit/04.png" alt="04"></p>
<p>浏览器引擎最后会 通过 DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。这个过程如下：<br><img src="/uploads/deeply-analyse-webkit/48.png" alt="48"></p>
<p>计算每个 Node 的位置，执行 Layout 过程<br><img src="/uploads/deeply-analyse-webkit/05.png" alt="05"></p>
<p>Compute style 是计算 CSS 样式，layout 是定位坐标和大小，各种 position，overflow，z-index 等。这些箭头表示动态修改了 DOM 属性和 CSS 属性会导致 Layout 执行。</p>
<h3 id="WebKit-源代码结构说明"><a href="#WebKit-源代码结构说明" class="headerlink" title="WebKit 源代码结构说明"></a>WebKit 源代码结构说明</h3><ul>
<li>JavaScriptCore：默认 JavaScript 引擎，Google 已经使用了 V8 作为其 Chromium 的 JS 引擎。</li>
<li>WebCore：浏览器渲染引擎，包含了各个核心模块。</li>
<li>WebCore/css：CSS 解释器，CSS 规则等。</li>
<li>WebCore/dom：各种 DOM 元素和 DOM Tree 结构相关的类。</li>
<li>WebCore/html：HTML 解释器和各种 HTML 元素等相关内容。</li>
<li>WebCore/rendering：Render Object 相关，还有页面渲染的样式和布局等。</li>
<li>WebCore/inspector：网页调试工具。</li>
<li>WebCore/loader：主资源和派生资源的加载相关实现，还有派生资源的 Memory Cache 等。</li>
<li>WebCore/page：页面相关的操作，页面结构和交互事件等。</li>
<li>WebCore/platform：各个平台相关的代码，比如 iOS，Mac 等</li>
<li>WebCore/storage：存储相关，比如 WebStorage，Index DB 等接口的实现。</li>
<li>WebCore/workers：Worker 线程封装，提供 JS 多线程执行环境。</li>
<li>WebCore/xml：XML 相关比如 XML Parser，XPath，XSLT 等。</li>
<li>WebCore/accessibility：图形控件访问接口。</li>
<li>WebCore/bindings：DOM 元素和 JS 绑定的接口。</li>
<li>WebCore/bridge：C，JavaScript 和 Objective-C 的桥接。</li>
<li>WebCore/editing：页面编辑相关，比如 DOM 修改，拼写检查等。</li>
<li>WebCore/history：Page Cache 实现前进后退浏览记录等。</li>
<li>WebCore/mathml：数学表达式在网页中的规范代码实现。</li>
<li>WebCore/plugins：NPPlugin 的支持接口</li>
<li>WebCore/svg：矢量图形的支持。</li>
<li>WebKit：平台相关的接口，每个目录都是不同的平台接口实现。</li>
<li>WTF：基础类库，类似 C++ 的 STL 库，有比如字符串操作，智能指针，线程等。</li>
<li>DumpRenderTree：用于生成 RenderTree</li>
<li>TestWebKitAPI：测试 WebKit 的 API 的测试代码</li>
</ul>
<h3 id="WebKit-代码风格"><a href="#WebKit-代码风格" class="headerlink" title="WebKit 代码风格"></a>WebKit 代码风格</h3><ul>
<li>内存管理：使用的引用计数，在 RefCounted 模板类里有 ref() 加和 unref() 减来进行控制，很多类都是继承了这个模板类。后期加入了 RefPtr 和 PassRefPtr 智能指针模板类，采用的是重载赋值操作符的方式能够自动完成计数加减，这样基本没有内存泄漏的可能。</li>
<li>代码自动生成：C++ 对象到 JS 对象的 Binding 实现使用的是代码自动生成，用 Perl 脚本 根据 IDL 接口描述文件完成代码自动生成。还有部分 CSS 和 HTML 解析也用到了，这样 CSS 属性值和 HTML 标签属性的添加也够节省大量时间，需要修改 .in 配置文件即可。</li>
<li>代码编写风格：可以在官网查看到：<a href="https://webkit.org/code-style-guidelines/" target="_blank" rel="external">https://webkit.org/code-style-guidelines/</a> 想给 WebKit 做贡献的同学们可以好好看看了。</li>
</ul>
<h3 id="WebKit-的设计模式"><a href="#WebKit-的设计模式" class="headerlink" title="WebKit 的设计模式"></a>WebKit 的设计模式</h3><p>下面可以看看在 WebKit 里使用了哪些设计模式，是如何使用的。</p>
<ul>
<li>单例：WebKit 里的 Loader 管理 CacheResource 就是单例模式。</li>
<li>工厂模式：可以在 WebKit 源码里搜索结尾是 Factory 的代码，它们一般都是用的工厂模式。</li>
<li>观察者模式：名称结尾是 Client 都是观察者模式，比如 FrameLoaderClient 可以看成是观察者类，被观察者 FrameLoader 会向 Client 观察者类通知自身状态的变化。</li>
<li>组合模式：用于树状结构对象，比如 DOM Tree，Render Tree，组成它们的类 ContainerNode 和 RenderObject 可以看成组合模式。</li>
<li>命令模式：DOM 模块的 Event 类和 Editing 模块的 Command 类都是命令模式。</li>
</ul>
<h3 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h3><h4 id="整体"><a href="#整体" class="headerlink" title="整体"></a>整体</h4><p><img src="/uploads/deeply-analyse-webkit/06.png" alt="06"></p>
<ul>
<li>Frame：中心类，通过它找其它类</li>
<li>FrameLoader：加载资源用的</li>
<li>Document：具体实现是 HTMLDocument</li>
<li>Page：窗口的操作</li>
<li>EventHandler：输入事件的处理，比如键盘，鼠标，触屏等</li>
</ul>
<h4 id="WebCore-Frame"><a href="#WebCore-Frame" class="headerlink" title="WebCore::Frame"></a>WebCore::Frame</h4><p><img src="/uploads/deeply-analyse-webkit/29.png" alt="29"></p>
<ul>
<li>FrameTree：管理父 Frame 和子 Frame 的关系，比如 main frame 里的 iframe。</li>
<li>FrameLoader：frame 的加载</li>
<li>NavigationScheduler：主要用来管理页面跳转，比如重定向，meta refresh 等。</li>
<li>DOMWindow：管理 DOM 相关的事件，属性和消息。</li>
<li>FrameView：Frame 的排版。</li>
<li>Document：用来管理 DOM 里的 node，每个 tag 都会有对应的 DOM node 关联。</li>
<li>ScriptController：管理 js 脚本。</li>
<li>Editor：管理页面比如 copy，paste和输入等编辑操作。</li>
<li>SelectionController：管理 Frame 里的选择操作。</li>
<li>AnimationControlle：动画控制。</li>
<li>EventHandler：处理事件比如鼠标，按键，滚动和 resize 等事件。</li>
</ul>
<h3 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h3><p><img src="/uploads/deeply-analyse-webkit/43.png" alt="43"><br>上图可以看到渲染引擎处于浏览器三层结构的最上层。下面是渲染的过程：<br><img src="/uploads/deeply-analyse-webkit/44.png" alt="44"></p>
<h3 id="Frame-的主要接口"><a href="#Frame-的主要接口" class="headerlink" title="Frame 的主要接口"></a>Frame 的主要接口</h3><h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)</div><div class="line">&#123;</div><div class="line">    ASSERT(page);</div><div class="line">    ASSERT(client);</div><div class="line">    <span class="keyword">return</span> adoptRef(*<span class="keyword">new</span> Frame(*page, ownerElement, *client));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Frame::create 里会调用到 Frame 的构造函数，创建 Frame 对象。<br>初始调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">webPage::setView</div><div class="line">webPage::setViewportSize</div><div class="line">webPage::mainFrame</div><div class="line">webPagePrivate::createMainFrame</div><div class="line">webFrameData::webFrameData</div><div class="line">Frame::create</div></pre></td></tr></table></figure></p>
<p>解析中发现 iframe 时的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">FrameLoader::finishedLoading</div><div class="line">HTMLDocumentParser::append</div><div class="line">HTMLTreeBuilder::processToken</div><div class="line">HTMLElementBase::openURL</div><div class="line">SubFrameLoader::requestFrame</div><div class="line">FrameLoaderClient::creatFrame</div><div class="line">webFrameData::webFrameData</div><div class="line">Frame::create</div></pre></td></tr></table></figure></p>
<h4 id="createView"><a href="#createView" class="headerlink" title="createView"></a>createView</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Frame::createView(<span class="keyword">const</span> IntSize&amp; viewportSize, <span class="keyword">const</span> Color&amp; backgroundColor, <span class="keyword">bool</span> transparent,</div><div class="line">    <span class="keyword">const</span> IntSize&amp; fixedLayoutSize, <span class="keyword">const</span> IntRect&amp; fixedVisibleContentRect,</div><div class="line">    <span class="keyword">bool</span> useFixedLayout, ScrollbarMode horizontalScrollbarMode, <span class="keyword">bool</span> horizontalLock,</div><div class="line">    ScrollbarMode verticalScrollbarMode, <span class="keyword">bool</span> verticalLock)</div></pre></td></tr></table></figure>
<p>会创建出用于排版的 FrameView 对象。需要一些和排版相关的信息，比如初始 viewport 的大小，背景色，滚动条模式等，完成创建调用 Frame::setView 设置为当前 FrameView。<br>调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FrameLoader::commitProvisionalLoad</div><div class="line">FrameLoader::transitionToCommitted</div><div class="line">FrameLoaderClient::transitionToCommittedForNewPage</div><div class="line">Frame::createView</div></pre></td></tr></table></figure></p>
<h4 id="setDocument"><a href="#setDocument" class="headerlink" title="setDocument"></a>setDocument</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)</div></pre></td></tr></table></figure>
<p>用来关联 Frame 和 Document 对象<br>Frame 初始化调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">WebFrame::webFrame</div><div class="line">webFramePrivate::init</div><div class="line">Frame::init</div><div class="line">FrameLoader::init</div><div class="line">DocumentWriter::begin</div><div class="line">Frame::setDocument</div></pre></td></tr></table></figure></p>
<p>js 脚本更改数据时的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">DocumentLoader::receivedData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">FrameLoaderClient::committedLoad</div><div class="line">DocumentLoader::commitData</div><div class="line">DocumentWriter::setEncoding</div><div class="line">DocumentWriter::willSetEncoding</div><div class="line">FrameLoader::receivedFirstData</div><div class="line">DocumentWriter::begin</div><div class="line">FrameLoader::clear</div><div class="line">Frame::setDocument</div></pre></td></tr></table></figure></p>
<h2 id="WTF"><a href="#WTF" class="headerlink" title="WTF"></a>WTF</h2><p>全称是 Web Template Library，是 WebKit 的基础库，实现了智能指针，字符串和 Container，提供跨平台原子操作，时间和线程的封装，能够高效的对内存进行管理。WebCore 里都是 WTF 的代码而没有 STL。</p>
<h3 id="Smart-ptr-智能指针"><a href="#Smart-ptr-智能指针" class="headerlink" title="Smart ptr 智能指针"></a>Smart ptr 智能指针</h3><p>对原生指针的封装，这样 C++ 可以自动化的实现资源管理和指针衍生操作比如拷贝，引用计数，autoLocker 和 Lazy evaluation 等。</p>
<p>智能指针主要就是实现动态分配对象的内存并且能自动回收，原理就是智能指针的对象会作为栈上分配的自动变量在退出作用域时被自动析构。</p>
<p>智能指针的实现方式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> T ValueType;</div><div class="line">        <span class="keyword">typedef</span> ValueType *PtrType;</div><div class="line">        </div><div class="line">        <span class="comment">//构造析构函数</span></div><div class="line">        SmartPtr() :m_ptr(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">        SmartPtr(PtrType ptr) :m_ptr(ptr) &#123;&#125;</div><div class="line">        ~SmartPtr() &#123; </div><div class="line">            <span class="keyword">if</span>(m_ptr) <span class="keyword">delete</span> m_ptr; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//拷贝构造函数</span></div><div class="line">        SmartPtr(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; o); <span class="comment">//堆上分配的对象</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; o);</div><div class="line">        </div><div class="line">        <span class="comment">//拷贝赋值运算符</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; SmartPtr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; o);</div><div class="line"></div><div class="line">        <span class="comment">//指针运算，是为了让智能指针在行为上更类似原生指针</span></div><div class="line">        ValueType&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; </div><div class="line">            <span class="keyword">return</span> *m_ptr; </div><div class="line">        &#125;</div><div class="line">        PtrType <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123;</div><div class="line">            <span class="keyword">return</span> m_ptr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//逻辑运算符重载</span></div><div class="line">        <span class="comment">//对指针是否为空的简洁判断 if(!ptr)，如果定义了 operator!() 智能指针就可以用 if(!SmartPtr)</span></div><div class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!() <span class="keyword">const</span> &#123;</div><div class="line">            <span class="keyword">return</span> !m_ptr;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//转成 raw ptr</span></div><div class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">PtrType</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> m_ptr;</div><div class="line">        &#125;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        PtrType m_ptr;</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建智能指针对象格式</span></div><div class="line">SmartPtr(<span class="keyword">new</span> ValueType());</div></pre></td></tr></table></figure></p>
<h3 id="RefPtr"><a href="#RefPtr" class="headerlink" title="RefPtr"></a>RefPtr</h3><p>RefPtr 需要操作对象来引用计数，包含 ref() 和 deref() 方法的类对象才可以由 RefPtr 引用。为了不让 RefPtr 引用的类都用手工去添加 ref() 和 deref() WTF 提供了 RefCounted 类模板，在 WTF/Source/wtf/RefCounted.h 里。类模板的定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCountedBase</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ref</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        ++m_refCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasOneRef</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT(!m_deletionHasBegun);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        <span class="keyword">return</span> m_refCount == <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">refCount</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> m_refCount;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relaxAdoptionRequirement</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(m_adoptionIsRequired);</div><div class="line">        m_adoptionIsRequired = <span class="literal">false</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    RefCountedBase()</div><div class="line">        : m_refCount(<span class="number">1</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        , m_deletionHasBegun(<span class="literal">false</span>)</div><div class="line">        , m_adoptionIsRequired(<span class="literal">true</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~RefCountedBase()</div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT(m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Returns whether the pointer should be freed or not.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">derefBase</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);</div><div class="line">        ASSERT(!m_adoptionIsRequired);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        ASSERT(m_refCount);</div><div class="line">        <span class="keyword">unsigned</span> tempRefCount = m_refCount - <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (!tempRefCount) &#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">            m_deletionHasBegun = <span class="literal">true</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        m_refCount = tempRefCount;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deletionHasBegun</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> m_deletionHasBegun;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">adopted</span><span class="params">(RefCountedBase*)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">unsigned</span> m_refCount;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_REF_COUNTED_LIFECYCLE</span></div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_deletionHasBegun;</div><div class="line">    <span class="keyword">mutable</span> <span class="keyword">bool</span> m_adoptionIsRequired;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">RefCounted</span> :</span> <span class="keyword">public</span> RefCountedBase &#123;</div><div class="line">    WTF_MAKE_NONCOPYABLE(RefCounted); WTF_MAKE_FAST_ALLOCATED;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deref</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (derefBase())</div><div class="line">            <span class="keyword">delete</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> T*&gt;(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    RefCounted() &#123; &#125;</div><div class="line">    ~RefCounted()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面可以看到 RefCounted 类定义有 RefCountedBase 类和 RefCounted 类，RefCounted 类会被大量继承，任何类如果想被 RefPtr 引用只需要继承 RefCounted<class>即可。在 RefPtr.h 里可以看到 refIfNotNull 和 derefIfNotNull 定义了计数的增加和减少。</class></p>
<h3 id="Assert-断言的实现和应用"><a href="#Assert-断言的实现和应用" class="headerlink" title="Assert 断言的实现和应用"></a>Assert 断言的实现和应用</h3><p>断言在 WTF 里是这样定义的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSERT(assertion) do &#123; \</span></div><div class="line">    <span class="meta-keyword">if</span> (!(assertion)) &#123; \</div><div class="line">        <span class="comment">//打印用</span></div><div class="line">        WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \</div><div class="line">        <span class="comment">//重点</span></div><div class="line">        CRASH(); \</div><div class="line">    &#125; \</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CRASH</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(NDEBUG) &amp;&amp; OS(DARWIN)</span></div><div class="line"><span class="comment">// Crash with a SIGTRAP i.e EXC_BREAKPOINT.</span></div><div class="line"><span class="comment">// We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily</span></div><div class="line"><span class="comment">// trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRASH() do &#123; \</span></div><div class="line">    <span class="comment">//直接 inline 汇编代码</span></div><div class="line">    WTFBreakpointTrap(); \</div><div class="line">    __builtin_unreachable(); \</div><div class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> CRASH() WTFCrash()</span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !defined(CRASH)</span></span></div><div class="line"></div><div class="line"><span class="comment">//根据不同 CPU 定义不同的 WTFBreakpointTrap() 汇编宏</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CPU(X86_64) || CPU(X86)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"int3"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> CPU(ARM_THUMB2)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"bkpt #0"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> CPU(ARM64)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap()  __asm__ volatile (<span class="meta-string">"brk #0"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTFBreakpointTrap() WTFCrash() <span class="comment">// Not implemented.</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>WTF 提供的内存管理和 STL 类似，为容器和应用提供内存分配接口。先看 WTF_MAKE_FAST_ALLOCATED 这个宏<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> WTF_MAKE_FAST_ALLOCATED \</span></div><div class="line">public: \</div><div class="line">    void* operator new(size_t, void* p) &#123; return p; &#125; \</div><div class="line">    void* operator new[](size_t, void* p) &#123; return p; &#125; \</div><div class="line">    \</div><div class="line">    void* operator new(size_t size) \</div><div class="line">    &#123; \</div><div class="line">        return ::WTF::fastMalloc(size); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void operator delete(void* p) \</div><div class="line">    &#123; \</div><div class="line">        ::WTF::fastFree(p); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void* operator new[](size_t size) \</div><div class="line">    &#123; \</div><div class="line">        return ::WTF::fastMalloc(size); \</div><div class="line">    &#125; \</div><div class="line">    \</div><div class="line">    void operator delete[](void* p) \</div><div class="line">    &#123; \</div><div class="line">        ::WTF::fastFree(p); \</div><div class="line">    &#125; \</div><div class="line">    void* operator new(size_t, NotNullTag, void* location) \</div><div class="line">    &#123; \</div><div class="line">        ASSERT(location); \</div><div class="line">        return location; \</div><div class="line">    &#125; \</div><div class="line">private: \</div><div class="line">typedef int __thisIsHereToForceASemicolonAfterThisMacro</div></pre></td></tr></table></figure></p>
<p>这个宏定义了 operator new 和 operator delete。operator new 是直接调用 fastMalloc 完成内存分配，下面看看 fastMalloc 的实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">fastMalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></div><div class="line">&#123;</div><div class="line">    ASSERT_IS_WITHIN_LIMIT(size);</div><div class="line">    <span class="keyword">return</span> bmalloc::api::<span class="built_in">malloc</span>(size);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 WTF 使用了 bmalloc 来 malloc，这个 bmalloc 被苹果号称在性能上要远超于 TCMalloc 和 STL 里在 malloc 之上实现一个内存池的的思路也完全不一样。关于 TCMalloc 的实现和原理可以参看：<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html" target="_blank" rel="external">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> 。关于 STL 内存管理的实现可以在 《STL 源码分析》第二章里有详细说明。</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>WTF 里很多的容器，比如 BlockStack，Deque，Vector 和 HashTable。</p>
<h4 id="Vector-动态数组"><a href="#Vector-动态数组" class="headerlink" title="Vector 动态数组"></a>Vector 动态数组</h4><p>WTF 里的 Vector 和 STL 里的 Vector 一样也是一种数据结构，相当于动态数组，当不知道需要的数组规模多大时可以达到最大节约空间的目的，那么看看 WTF 是如何实现 Vector 的吧，关键地方我在代码里做了注释说明。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, size_t inlineCapacity = 0, typename OverflowHandler = CrashOnOverflow, size_t minCapacity = 16, typename Malloc = FastMalloc&gt;</div><div class="line">class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; &#123;</div><div class="line">    WTF_MAKE_FAST_ALLOCATED;</div><div class="line">private:</div><div class="line">    //VectorBuffer 是内部存储数据的容器</div><div class="line">    typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</div><div class="line">    //Vector 里元素的初始化，复制和移动这些操作都在 VectorTypeOperations 里</div><div class="line">    typedef VectorTypeOperations&lt;T&gt; TypeOperations;</div><div class="line"></div><div class="line">public:</div><div class="line">    typedef T ValueType;</div><div class="line">    //iterator 直接使用的原生指针</div><div class="line">    typedef T* iterator;</div><div class="line">    typedef const T* const_iterator;</div><div class="line">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</div><div class="line">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</div><div class="line"></div><div class="line">    Vector()</div><div class="line">    &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Unlike in std::vector, this constructor does not initialize POD types.</div><div class="line">    explicit Vector(size_t size)</div><div class="line">        : Base(size, size)</div><div class="line">    &#123;</div><div class="line">        asanSetInitialBufferSizeTo(size);</div><div class="line"></div><div class="line">        if (begin())</div><div class="line">            TypeOperations::initialize(begin(), end());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(size_t size, const T&amp; val)</div><div class="line">        : Base(size, size)</div><div class="line">    &#123;</div><div class="line">        asanSetInitialBufferSizeTo(size);</div><div class="line"></div><div class="line">        if (begin())</div><div class="line">            TypeOperations::uninitializedFill(begin(), end(), val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(std::initializer_list&lt;T&gt; initializerList)</div><div class="line">    &#123;</div><div class="line">        reserveInitialCapacity(initializerList.size());</div><div class="line"></div><div class="line">        asanSetInitialBufferSizeTo(initializerList.size());</div><div class="line"></div><div class="line">        for (const auto&amp; element : initializerList)</div><div class="line">            uncheckedAppend(element);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~Vector()</div><div class="line">    &#123;</div><div class="line">        if (m_size)</div><div class="line">            TypeOperations::destruct(begin(), end());</div><div class="line"></div><div class="line">        asanSetBufferSizeToFullCapacity(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Vector(const Vector&amp;);</div><div class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</div><div class="line">    explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</div><div class="line"></div><div class="line">    Vector&amp; operator=(const Vector&amp;);</div><div class="line">    template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</div><div class="line">    Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</div><div class="line"></div><div class="line">    Vector(Vector&amp;&amp;);</div><div class="line">    Vector&amp; operator=(Vector&amp;&amp;);</div><div class="line">    </div><div class="line">    //返回 Vector 里元素个数</div><div class="line">    size_t size() const &#123; return m_size; &#125;</div><div class="line">    static ptrdiff_t sizeMemoryOffset() &#123; return OBJECT_OFFSETOF(Vector, m_size); &#125;</div><div class="line">    </div><div class="line">    //返回的是 Vector 中的容量，容量随着元素增加和删除而变化</div><div class="line">    size_t capacity() const &#123; return Base::capacity(); &#125;</div><div class="line">    bool isEmpty() const &#123; return !size(); &#125;</div><div class="line">    </div><div class="line">    //这里提供的是数组的访问功能</div><div class="line">    T&amp; at(size_t i)</div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(i &gt;= size()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    const T&amp; at(size_t i) const </div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(i &gt;= size()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    T&amp; at(Checked&lt;size_t&gt; i)</div><div class="line">    &#123;</div><div class="line">        RELEASE_ASSERT(i &lt; size());</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    const T&amp; at(Checked&lt;size_t&gt; i) const</div><div class="line">    &#123;</div><div class="line">        RELEASE_ASSERT(i &lt; size());</div><div class="line">        return Base::buffer()[i];</div><div class="line">    &#125;</div><div class="line">    //返回数组中第几个元素</div><div class="line">    T&amp; operator[](size_t i) &#123; return at(i); &#125;</div><div class="line">    const T&amp; operator[](size_t i) const &#123; return at(i); &#125;</div><div class="line">    T&amp; operator[](Checked&lt;size_t&gt; i) &#123; return at(i); &#125;</div><div class="line">    const T&amp; operator[](Checked&lt;size_t&gt; i) const &#123; return at(i); &#125;</div><div class="line"></div><div class="line">    T* data() &#123; return Base::buffer(); &#125;</div><div class="line">    const T* data() const &#123; return Base::buffer(); &#125;</div><div class="line">    static ptrdiff_t dataMemoryOffset() &#123; return Base::bufferMemoryOffset(); &#125;</div><div class="line">    //迭代功能的实现，获取 begin 和 end，Vector 元素有了插入和删除操作都需要重新 begin 和 end。</div><div class="line">    iterator begin() &#123; return data(); &#125;</div><div class="line">    iterator end() &#123; return begin() + m_size; &#125;</div><div class="line">    const_iterator begin() const &#123; return data(); &#125;</div><div class="line">    const_iterator end() const &#123; return begin() + m_size; &#125;</div><div class="line"></div><div class="line">    reverse_iterator rbegin() &#123; return reverse_iterator(end()); &#125;</div><div class="line">    reverse_iterator rend() &#123; return reverse_iterator(begin()); &#125;</div><div class="line">    const_reverse_iterator rbegin() const &#123; return const_reverse_iterator(end()); &#125;</div><div class="line">    const_reverse_iterator rend() const &#123; return const_reverse_iterator(begin()); &#125;</div><div class="line"></div><div class="line">    T&amp; first() &#123; return at(0); &#125;</div><div class="line">    const T&amp; first() const &#123; return at(0); &#125;</div><div class="line">    T&amp; last() &#123; return at(size() - 1); &#125;</div><div class="line">    const T&amp; last() const &#123; return at(size() - 1); &#125;</div><div class="line">    </div><div class="line">    T takeLast()</div><div class="line">    &#123;</div><div class="line">        T result = WTFMove(last());</div><div class="line">        removeLast();</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //O(n) 遍历查找的操作，所以数据量大时查找用 hashtable 效果会更好</div><div class="line">    template&lt;typename U&gt; bool contains(const U&amp;) const;</div><div class="line">    template&lt;typename U&gt; size_t find(const U&amp;) const;</div><div class="line">    template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;</div><div class="line">    template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;</div><div class="line">    </div><div class="line">    template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);</div><div class="line">    </div><div class="line">    //实现 STL 里的方法，这里的 insert，append 和 resize 等操作的时候会通过 reserveCapacity 或 tryReserveCapacity 来进行空间扩展达到动态数组的能力</div><div class="line">    void shrink(size_t size);</div><div class="line">    void grow(size_t size);</div><div class="line">    void resize(size_t size);</div><div class="line">    void resizeToFit(size_t size);</div><div class="line">    void reserveCapacity(size_t newCapacity);</div><div class="line">    bool tryReserveCapacity(size_t newCapacity);</div><div class="line">    void reserveInitialCapacity(size_t initialCapacity);</div><div class="line">    void shrinkCapacity(size_t newCapacity);</div><div class="line">    void shrinkToFit() &#123; shrinkCapacity(size()); &#125;</div><div class="line"></div><div class="line">    void clear() &#123; shrinkCapacity(0); &#125;</div><div class="line"></div><div class="line">    void append(ValueType&amp;&amp; value) &#123; append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</div><div class="line">    template&lt;typename U&gt; void append(U&amp;&amp;);</div><div class="line">    template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);</div><div class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);</div><div class="line"></div><div class="line">    void uncheckedAppend(ValueType&amp;&amp; value) &#123; uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); &#125;</div><div class="line">    template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);</div><div class="line"></div><div class="line">    template&lt;typename U&gt; void append(const U*, size_t);</div><div class="line">    template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);</div><div class="line">    template&lt;typename U&gt; bool tryAppend(const U*, size_t);</div><div class="line"></div><div class="line">    template&lt;typename U&gt; void insert(size_t position, const U*, size_t);</div><div class="line">    template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);</div><div class="line">    template&lt;typename U, size_t c&gt; void insertVector(size_t position, const Vector&lt;U, c&gt;&amp;);</div><div class="line"></div><div class="line">    void remove(size_t position);</div><div class="line">    void remove(size_t position, size_t length);</div><div class="line">    template&lt;typename U&gt; bool removeFirst(const U&amp;);</div><div class="line">    template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);</div><div class="line">    template&lt;typename U&gt; unsigned removeAll(const U&amp;);</div><div class="line">    template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);</div><div class="line"></div><div class="line">    void removeLast() </div><div class="line">    &#123;</div><div class="line">        if (UNLIKELY(isEmpty()))</div><div class="line">            OverflowHandler::overflowed();</div><div class="line">        shrink(size() - 1); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void fill(const T&amp;, size_t);</div><div class="line">    void fill(const T&amp; val) &#123; fill(val, size()); &#125;</div><div class="line"></div><div class="line">    template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);</div><div class="line"></div><div class="line">    MallocPtr&lt;T&gt; releaseBuffer();</div><div class="line"></div><div class="line">    void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</div><div class="line">    &#123;</div><div class="line">#if ASAN_ENABLED</div><div class="line">        if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.</div><div class="line">            return;</div><div class="line">#endif</div><div class="line"></div><div class="line">        // Make it possible to copy inline buffers.</div><div class="line">        asanSetBufferSizeToFullCapacity();</div><div class="line">        other.asanSetBufferSizeToFullCapacity();</div><div class="line"></div><div class="line">        Base::swap(other, m_size, other.m_size);</div><div class="line">        std::swap(m_size, other.m_size);</div><div class="line"></div><div class="line">        asanSetInitialBufferSizeTo(m_size);</div><div class="line">        other.asanSetInitialBufferSizeTo(other.m_size);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    void reverse();</div><div class="line"></div><div class="line">    void checkConsistency();</div><div class="line"></div><div class="line">    template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;</div><div class="line"></div><div class="line">private:</div><div class="line">    void expandCapacity(size_t newMinCapacity);</div><div class="line">    T* expandCapacity(size_t newMinCapacity, T*);</div><div class="line">    bool tryExpandCapacity(size_t newMinCapacity);</div><div class="line">    const T* tryExpandCapacity(size_t newMinCapacity, const T*);</div><div class="line">    template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*); </div><div class="line">    template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);</div><div class="line">    template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);</div><div class="line">    template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);</div><div class="line"></div><div class="line">    void asanSetInitialBufferSizeTo(size_t);</div><div class="line">    void asanSetBufferSizeToFullCapacity(size_t);</div><div class="line">    void asanSetBufferSizeToFullCapacity() &#123; asanSetBufferSizeToFullCapacity(size()); &#125;</div><div class="line"></div><div class="line">    void asanBufferSizeWillChangeTo(size_t);</div><div class="line"></div><div class="line">    using Base::m_size;</div><div class="line">    using Base::buffer;</div><div class="line">    using Base::capacity;</div><div class="line">    using Base::swap;</div><div class="line">    using Base::allocateBuffer;</div><div class="line">    using Base::deallocateBuffer;</div><div class="line">    using Base::tryAllocateBuffer;</div><div class="line">    using Base::shouldReallocateBuffer;</div><div class="line">    using Base::reallocateBuffer;</div><div class="line">    using Base::restoreInlineBufferIfNeeded;</div><div class="line">    using Base::releaseBuffer;</div><div class="line">#if ASAN_ENABLED</div><div class="line">    using Base::endOfBuffer;</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="HashTable-哈希表"><a href="#HashTable-哈希表" class="headerlink" title="HashTable 哈希表"></a>HashTable 哈希表</h4><p>HashTable 实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> Extractor, <span class="keyword">typename</span> HashFunctions, <span class="keyword">typename</span> Traits, <span class="keyword">typename</span> KeyTraits&gt;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">typedef</span> HashTableIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; iterator;</div><div class="line">        <span class="keyword">typedef</span> HashTableConstIterator&lt;Key, Value, Extractor, HashFunctions, Traits, KeyTraits&gt; const_iterator;</div><div class="line">        <span class="keyword">typedef</span> Traits ValueTraits;</div><div class="line">        <span class="keyword">typedef</span> Key KeyType;</div><div class="line">        <span class="keyword">typedef</span> Value ValueType;</div><div class="line">        <span class="keyword">typedef</span> IdentityHashTranslator&lt;ValueTraits, HashFunctions&gt; IdentityTranslatorType;</div><div class="line">        <span class="keyword">typedef</span> HashTableAddResult&lt;iterator&gt; AddResult;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DUMP_HASHTABLE_STATS_PER_TABLE</span></div><div class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Stats</span> &#123;</span></div><div class="line">            Stats()</div><div class="line">                : numAccesses(<span class="number">0</span>)</div><div class="line">                , numRehashes(<span class="number">0</span>)</div><div class="line">                , numRemoves(<span class="number">0</span>)</div><div class="line">                , numReinserts(<span class="number">0</span>)</div><div class="line">                , maxCollisions(<span class="number">0</span>)</div><div class="line">                , numCollisions(<span class="number">0</span>)</div><div class="line">                , collisionGraph()</div><div class="line">            &#123;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">unsigned</span> numAccesses;</div><div class="line">            <span class="keyword">unsigned</span> numRehashes;</div><div class="line">            <span class="keyword">unsigned</span> numRemoves;</div><div class="line">            <span class="keyword">unsigned</span> numReinserts;</div><div class="line"></div><div class="line">            <span class="keyword">unsigned</span> maxCollisions;</div><div class="line">            <span class="keyword">unsigned</span> numCollisions;</div><div class="line">            <span class="keyword">unsigned</span> collisionGraph[<span class="number">4096</span>];</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">recordCollisionAtCount</span><span class="params">(<span class="keyword">unsigned</span> count)</span></span></div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span> (count &gt; maxCollisions)</div><div class="line">                    maxCollisions = count;</div><div class="line">                numCollisions++;</div><div class="line">                collisionGraph[count]++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">dumpStats</span><span class="params">()</span></span></div><div class="line">            &#123;</div><div class="line">                dataLogF(<span class="string">"\nWTF::HashTable::Stats dump\n\n"</span>);</div><div class="line">                dataLogF(<span class="string">"%d accesses\n"</span>, numAccesses);</div><div class="line">                dataLogF(<span class="string">"%d total collisions, average %.2f probes per access\n"</span>, numCollisions, <span class="number">1.0</span> * (numAccesses + numCollisions) / numAccesses);</div><div class="line">                dataLogF(<span class="string">"longest collision chain: %d\n"</span>, maxCollisions);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt;= maxCollisions; i++) &#123;</div><div class="line">                    dataLogF(<span class="string">"  %d lookups with exactly %d collisions (%.2f%% , %.2f%% with this many or more)\n"</span>, collisionGraph[i], i, <span class="number">100.0</span> * (collisionGraph[i] - collisionGraph[i+<span class="number">1</span>]) / numAccesses, <span class="number">100.0</span> * collisionGraph[i] / numAccesses);</div><div class="line">                &#125;</div><div class="line">                dataLogF(<span class="string">"%d rehashes\n"</span>, numRehashes);</div><div class="line">                dataLogF(<span class="string">"%d reinserts\n"</span>, numReinserts);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        HashTable();</div><div class="line">        ~HashTable() </div><div class="line">        &#123;</div><div class="line">            invalidateIterators(); </div><div class="line">            <span class="keyword">if</span> (m_table)</div><div class="line">                deallocateTable(m_table, m_tableSize);</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_USE_AFTER_DESTRUCTION</span></div><div class="line">            m_table = (ValueType*)(<span class="keyword">uintptr_t</span>)<span class="number">0xbbadbeef</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        HashTable(<span class="keyword">const</span> HashTable&amp;);</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(HashTable&amp;)</span></span>;</div><div class="line">        HashTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> HashTable&amp;);</div><div class="line"></div><div class="line">        HashTable(HashTable&amp;&amp;);</div><div class="line">        HashTable&amp; <span class="keyword">operator</span>=(HashTable&amp;&amp;);</div><div class="line"></div><div class="line">        <span class="comment">// When the hash table is empty, just return the same iterator for end as for begin.</span></div><div class="line">        <span class="comment">// This is more efficient because we don't have to skip all the empty and deleted</span></div><div class="line">        <span class="comment">// buckets, and iterating an empty table is a common case that's worth optimizing.</span></div><div class="line">        <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isEmpty() ? end() : makeIterator(m_table); &#125;</div><div class="line">        <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> makeKnownGoodIterator(m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> isEmpty() ? end() : makeConstIterator(m_table); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> makeKnownGoodConstIterator(m_table + m_tableSize); &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount; &#125;</div><div class="line">        <span class="function"><span class="keyword">unsigned</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_tableSize; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> !m_keyCount; &#125;</div><div class="line"></div><div class="line">        <span class="function">AddResult <span class="title">add</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), value); &#125;</div><div class="line">        <span class="function">AddResult <span class="title">add</span><span class="params">(ValueType&amp;&amp; value)</span> </span>&#123; <span class="keyword">return</span> add&lt;IdentityTranslatorType&gt;(Extractor::extract(value), WTFMove(value)); &#125;</div><div class="line"></div><div class="line">        <span class="comment">// A special version of add() that finds the object by hashing and comparing</span></div><div class="line">        <span class="comment">// with some other type, to avoid the cost of type conversion if the object is already</span></div><div class="line">        <span class="comment">// in the table.</span></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function">AddResult <span class="title">add</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function">AddResult <span class="title">addPassingHashCode</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> </span>&#123; <span class="keyword">return</span> find&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> find&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> KeyType&amp; key)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> contains&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> T&amp;)</span> <span class="keyword">const</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> T&amp;)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> KeyType&amp;)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(iterator)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeWithoutEntryConsistencyCheck</span><span class="params">(iterator)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeWithoutEntryConsistencyCheck</span><span class="params">(const_iterator)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Functor&gt;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeIf</span><span class="params">(<span class="keyword">const</span> Functor&amp;)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEmptyBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> isHashTraitsEmptyValue&lt;KeyTraits&gt;(Extractor::extract(value)); &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isDeletedBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> KeyTraits::isDeletedValue(Extractor::extract(value)); &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isEmptyOrDeletedBucket</span><span class="params">(<span class="keyword">const</span> ValueType&amp; value)</span> </span>&#123; <span class="keyword">return</span> isEmptyBucket(value) || isDeletedBucket(value); &#125;</div><div class="line"></div><div class="line">        <span class="function">ValueType* <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> </span>&#123; <span class="keyword">return</span> lookup&lt;IdentityTranslatorType&gt;(key); &#125;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">ValueType* <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">ValueType* <span class="title">inlineLookup</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkTableConsistency</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTableConsistency</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_CONSISTENCY</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">internalCheckTableConsistency</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; checkTableConsistency(); &#125;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">internalCheckTableConsistencyExceptSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; checkTableConsistencyExceptSize(); &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalCheckTableConsistencyExceptSize</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">internalCheckTableConsistency</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="function"><span class="keyword">static</span> ValueType* <span class="title">allocateTable</span><span class="params">(<span class="keyword">unsigned</span> size)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocateTable</span><span class="params">(ValueType* table, <span class="keyword">unsigned</span> size)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;ValueType*, <span class="keyword">bool</span>&gt; LookupType;</div><div class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;LookupType, <span class="keyword">unsigned</span>&gt; FullLookupType;</div><div class="line"></div><div class="line">        <span class="function">LookupType <span class="title">lookupForWriting</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> </span>&#123; <span class="keyword">return</span> lookupForWriting&lt;IdentityTranslatorType&gt;(key); &#125;;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">FullLookupType <span class="title">fullLookupForWriting</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function">LookupType <span class="title">lookupForWriting</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Extra&gt; <span class="function"><span class="keyword">void</span> <span class="title">addUniqueForInitialization</span><span class="params">(T&amp;&amp; key, Extra&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">template</span>&lt;<span class="keyword">typename</span> HashTranslator, <span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">checkKey</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeAndInvalidateWithoutEntryConsistencyCheck</span><span class="params">(ValueType*)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeAndInvalidate</span><span class="params">(ValueType*)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(ValueType*)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">shouldExpand</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (m_keyCount + m_deletedCount) * m_maxLoad &gt;= m_tableSize; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">mustRehashInPlace</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount * m_minLoad &lt; m_tableSize * <span class="number">2</span>; &#125;</div><div class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">shouldShrink</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_keyCount * m_minLoad &lt; m_tableSize &amp;&amp; m_tableSize &gt; KeyTraits::minimumTableSize; &#125;</div><div class="line">        <span class="function">ValueType* <span class="title">expand</span><span class="params">(ValueType* entry = <span class="literal">nullptr</span>)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span> </span>&#123; rehash(m_tableSize / <span class="number">2</span>, <span class="literal">nullptr</span>); &#125;</div><div class="line"></div><div class="line">        <span class="function">ValueType* <span class="title">rehash</span><span class="params">(<span class="keyword">unsigned</span> newTableSize, ValueType* entry)</span></span>;</div><div class="line">        <span class="function">ValueType* <span class="title">reinsert</span><span class="params">(ValueType&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initializeBucket</span><span class="params">(ValueType&amp; bucket)</span></span>;</div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteBucket</span><span class="params">(ValueType&amp; bucket)</span> </span>&#123; hashTraitsDeleteBucket&lt;Traits&gt;(bucket); &#125;</div><div class="line"></div><div class="line">        <span class="function">FullLookupType <span class="title">makeLookupResult</span><span class="params">(ValueType* position, <span class="keyword">bool</span> found, <span class="keyword">unsigned</span> hash)</span></span></div><div class="line">            &#123; <span class="keyword">return</span> FullLookupType(LookupType(position, found), hash); &#125;</div><div class="line"></div><div class="line">        <span class="function">iterator <span class="title">makeIterator</span><span class="params">(ValueType* pos)</span> </span>&#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">makeConstIterator</span><span class="params">(ValueType* pos)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize); &#125;</div><div class="line">        <span class="function">iterator <span class="title">makeKnownGoodIterator</span><span class="params">(ValueType* pos)</span> </span>&#123; <span class="keyword">return</span> iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</div><div class="line">        <span class="function">const_iterator <span class="title">makeKnownGoodConstIterator</span><span class="params">(ValueType* pos)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_iterator(<span class="keyword">this</span>, pos, m_table + m_tableSize, HashItemKnownGood); &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">checkTableConsistencyExceptSize</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTableConsistencyExceptSize</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_ITERATORS</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">invalidateIterators</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invalidateIterators</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> m_maxLoad = <span class="number">2</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> m_minLoad = <span class="number">6</span>;</div><div class="line"></div><div class="line">        ValueType* m_table;</div><div class="line">        <span class="keyword">unsigned</span> m_tableSize;</div><div class="line">        <span class="keyword">unsigned</span> m_tableSizeMask;</div><div class="line">        <span class="keyword">unsigned</span> m_keyCount;</div><div class="line">        <span class="keyword">unsigned</span> m_deletedCount;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_HASHTABLE_ITERATORS</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="comment">// All access to m_iterators should be guarded with m_mutex.</span></div><div class="line">        <span class="keyword">mutable</span> const_iterator* m_iterators;</div><div class="line">        <span class="comment">// Use std::unique_ptr so HashTable can still be memmove'd or memcpy'ed.</span></div><div class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Lock&gt; m_mutex;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DUMP_HASHTABLE_STATS_PER_TABLE</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">        <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Stats&gt; m_stats;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p>
<p>完整具体的实现可以查看 WTF/Source/wtf/HashTable.h。这里需要注意的是 HashTable 是线性存储空间的起始地址是 bengin 和 end 来表示的，capacity 存储空间不足时会使用 doubleHash 的方法来扩容，将原空间大小变成两倍。调用 begin 或 end 时会创建 HashTable 的 const_iterator，它维持了一个指向 value_type 的指针，所以 iterator 的自增和自减就是指针的自增自减，这点比 STL 的 HashMap 采用数组加链表实现要简单。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>WebKit 对线程的处理就是在一个 loop 循环里处理消息队列，在 WTF/Source/wtf/MessageQueue.h 里有对消息队列的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The queue takes ownership of messages and transfer it to the new owner</span></div><div class="line"><span class="comment">// when messages are fetched from the queue.</span></div><div class="line"><span class="comment">// Essentially, MessageQueue acts as a queue of std::unique_ptr&lt;DataType&gt;.</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> DataType&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> &#123;</span></div><div class="line">    WTF_MAKE_NONCOPYABLE(MessageQueue);</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MessageQueue() : m_killed(<span class="literal">false</span>) &#123; &#125;</div><div class="line">    ~MessageQueue();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendAndKill</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">appendAndCheckEmpty</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepend</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;)</span></span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; waitForMessage();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; tryGetMessage();</div><div class="line">    Deque&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;&gt; takeAllMessages();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; tryGetMessageIgnoringKilled();</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt; waitForMessageFilteredWithTimeout(MessageQueueWaitResult&amp;, Predicate&amp;&amp;, WallTime absoluteTime);</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeIf</span><span class="params">(Predicate&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">killed</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// The result of isEmpty() is only valid if no other thread is manipulating the queue at the same time.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">//m_mutex 是访问 Deque 的互斥锁，是对 pthread_mutex_t 类型的一个封装</span></div><div class="line">    <span class="keyword">mutable</span> Lock m_mutex;</div><div class="line">    </div><div class="line">    <span class="comment">//Condition 是对 pthread_cond_t 类型的封装，m_condition 提供了挂起线程</span></div><div class="line">    Condition m_condition;</div><div class="line">    </div><div class="line">    <span class="comment">//内部主要存储结构</span></div><div class="line">    Deque&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataType&gt;&gt; m_queue;</div><div class="line">    <span class="keyword">bool</span> m_killed;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看出 MessageQueue 是通过 pthread_mutex_t 来保证线程安全的。WebKit 在运行时会有很多线程，有网络资源加载的线程，解析页面布局的线程，绘制线程，I/O 线程，解码线程等线程。最核心的是解析页面布局线程，其它线程都由它触发，所以可以称为主线程，这个线程在 Mac 端是 MainThread 定义和实现的，在 iOS 端是 WebCoreThread 定义实现的。这些定义比如 callOnMainThread 就是其它异步线程做回调时调用的函数。</p>
<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>主要作用就是加载资源，有 MainResourceLoader 和 SubResourceLoader。加载的资源有来自网络，本地或者缓存的。Loader 模块本身是平台无关的，只是将需要获得资源的请求传给平台相关的网络模块，接受网络模块返回资源。平台相关的网络模块在 WebCore/platform/network 里。如果是 iOS 就在 WebCore/platform/network/iOS 里，如果 Mac 就在 WebCore/platform/network/mac 里。</p>
<h3 id="Loader-的资源"><a href="#Loader-的资源" class="headerlink" title="Loader 的资源"></a>Loader 的资源</h3><p>网页本身就是一种资源，同时网页还需要其它的一些资源，比如图片，视频，js 代码等。下面是主要资源的类型：</p>
<ul>
<li>HTML：页面主文件</li>
<li>JavaScript：单独的文件后者直接在 HTML 代码里</li>
<li>CSS：同 JavaScript 一样可以是单独文件也可以直接写在 HTML 代码里</li>
<li>图片：各种编码图片比如 jpg 和 png</li>
<li>SVG：矢量图片</li>
<li>CSS Shader：为 CSS 带来 3D 图形特性</li>
<li>音频视频：多媒体资源以及视频字幕</li>
<li>字体：自定义的字体</li>
<li>XSL：对 XSLT 语言编写的文件支持</li>
</ul>
<p>WebKit 里会有不同的类来表示这些资源，它们都会有个共同的基类 CachedResource。如下图所示，其中 HTML 的资源类型是 CachedRawResource 类，类型叫 MainResource 类。<br><img src="/uploads/deeply-analyse-webkit/50.png" alt="50"></p>
<h3 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h3><p>加载的入口，最终会调到异步 load 过程。主要是提供一个下载一个 Frame 的一些接口。任何一个页面都需要至少一个 mainframe，因此 load 一般都是从 load 一个 mainframe 开始。<br><img src="/uploads/deeply-analyse-webkit/07.png" alt="07"><br><img src="/uploads/deeply-analyse-webkit/39.png" alt="39"></p>
<ul>
<li>MainResourceLoader：加载资源，html 也是资源，还有 css，javascript 和 image 等这些是 SubresourceLoader 来管理的。</li>
<li>CacheResourceLoader：缓存资源读取。</li>
<li>资源加载和缓存是由 ResourceLoader 和 Cache 这两个独立性高的模块来实现。</li>
<li>DocumentWriter：辅助类，将获取的数据写到 writer 里，会创建 DOM 树的根节点 HTMLDocument 对象，作为一个缓冲区进行 DocumentParser 解析操作，同时该类还包含了文档字符解码类和 HTMLDocumentParser 类。</li>
</ul>
<h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><p><img src="/uploads/deeply-analyse-webkit/08.png" alt="08"></p>
<p>解析前会创建不同的 Dcoument，DocumentLoader 的 commitData 第一次收到数据时会调 DcumentWriter 的 begin，这个 begin 会调用 DocumentWriter::createDocument 创建一个 Document 对象。</p>
<p>这里创建的对象会根据 URL 来创建不同的 Document，这里有 HTMLDocument ，详细实现可以看看 DOMImplementation::createDocument 的实现。</p>
<p>整个资源加载过程，这篇文章有详细的介绍：<a href="https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/" target="_blank" rel="external">https://hacks.mozilla.org/2017/09/building-the-dom-faster-speculative-parsing-async-defer-and-preload/</a></p>
<h4 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h4><p><img src="/uploads/deeply-analyse-webkit/30.png" alt="30"><br><img src="/uploads/deeply-analyse-webkit/77.png" alt="77"><br><img src="/uploads/deeply-analyse-webkit/78.png" alt="78"></p>
<ul>
<li>Frame 和 FrameLoaderClient：在 Frame 的构造函数中调用 FrameLoader 的构造函数需要传入 Frame 指针和 FrameLoaderClient 指针。一般作为不同平台适配代码，控制 WebKit 的使用逻辑。FrameLoader 会把加载过程的状态，还有结果等信息传递给 FrameLoaderClient，这样的话 FrameLoaderClient 就能够掌控 FrameLoader 的动作。</li>
<li>SubFrameLoader：维护子 Frame。</li>
<li>DocumentWriter：有一个 m_writer 对象在 Frame 的数据 load 完成时进行下一步比如解码处理。</li>
<li>DocumentLoader：FrameLoader 会维护三个 DocumentLoader。m_policyDocumentLoader 是 policy check 的阶段。m_provisionalDocumentLoader 会负责 startLoadingMainResource 的调用。m_documentLoader 是数据到了后使用的，前一个 Frame 的 DocumentLoader 不能再用。</li>
<li>HistoryController：管理历史记录，保存和恢复 Document 和 Page 的状态到 HistoryItem，维护浏览页面的前进后退队列，这样就可以实现前进和后退等操作。FrameLoader 通过 HistoryController 来操作 m_backForwardController 对象。</li>
<li>ResourceLoadNotifier：当 ResourceLoader 有变化时来通知 FrameLoader，用于它们之间的通信。</li>
<li>SubframeLoader：用来控制 MainFrame 里的 iframe 的加载。</li>
<li>FrameLoaderStateMachine：描述 FrameLoader 处理 DocumentLoader 的节点的状态，看是在创建状态还是显示状态。</li>
<li>PolicyChecker：对 FrameLoader 做校验，有三种，第一种 NewWindow Policy，指对新开 tab 或 window 时校验。第二种 NavigationPolicy 是对页面请求的校验。第三种 ContentPolicy 是对请求收到的数据判断 Mime type 等的校验。PolicyChecker 会提供对应几口，由 FrameLoaderClient 来对这些请求校验确定是否继续加载或者做其它操作。</li>
</ul>
<h3 id="FrameLoader-的主要接口"><a href="#FrameLoader-的主要接口" class="headerlink" title="FrameLoader 的主要接口"></a>FrameLoader 的主要接口</h3><h4 id="Frame-init"><a href="#Frame-init" class="headerlink" title="Frame::init"></a>Frame::init</h4><p>FrameLoader 自身的初始化。<br>初始化的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WebFrame::WebFrame(webPage* parent,WebFrameData *frameData)</div><div class="line">WebFramePrivate::init(WebFrame* webframe,WebFrameData* frameData)</div><div class="line">Frame::init()</div><div class="line">FrameLoader::init()</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-commitProvisionalLoad"><a href="#FrameLoader-commitProvisionalLoad" class="headerlink" title="FrameLoader::commitProvisionalLoad"></a>FrameLoader::commitProvisionalLoad</h4><p>提交 provisional 阶段时下载的数据<br>完成 Document loading 的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DocumentLoader::finishLoading</div><div class="line">DocumentLoader::commitIfReady</div><div class="line">FrameLoader::commitProvisionalLoad</div></pre></td></tr></table></figure></p>
<p>资源数据接受提交调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ResourceLoader::didReceiveData</div><div class="line">MainResourceLoader::addData</div><div class="line">DocumentLoader::receiveData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">DocumentLoader::commitIfReady</div><div class="line">DocumentLoader::commitProvisionalLoad</div></pre></td></tr></table></figure></p>
<h4 id="Frame-finishedLoading"><a href="#Frame-finishedLoading" class="headerlink" title="Frame::finishedLoading"></a>Frame::finishedLoading</h4><p>网络加载完成的接口，作用是通知 DocumentLoader 和 DocumentWriter 已经完成，可以进行后面的提交数据和解析工作。<br>函数的调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ResourceLoader::didFinishLoading</div><div class="line">MainResourceLoader::didFinishLoading</div><div class="line">FrameLoader::finishedLoading</div><div class="line">FrameLoader::init()</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-finishedParsing"><a href="#FrameLoader-finishedParsing" class="headerlink" title="FrameLoader::finishedParsing"></a>FrameLoader::finishedParsing</h4><p>完成解析时调用的接口<br>调用顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DocumentWritter::end</div><div class="line">Document::finishParsing</div><div class="line">Document::finishedParsing</div><div class="line">FrameLoader::finishedParsing</div></pre></td></tr></table></figure></p>
<h4 id="FrameLoader-load-FrameLoadRequest-amp-amp-request"><a href="#FrameLoader-load-FrameLoadRequest-amp-amp-request" class="headerlink" title="FrameLoader::load(FrameLoadRequest&amp;&amp; request)"></a>FrameLoader::load(FrameLoadRequest&amp;&amp; request)</h4><p>加载请求，将 Frame 相关的数据封装成 ResourceRequest 作为参数带入，这个接口会创建出 DocumentLoader。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建 DocumentLoader</span></div><div class="line"><span class="keyword">void</span> FrameLoader::load(FrameLoadRequest&amp;&amp; request)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (m_inStopAllLoaders)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!request.frameName().isEmpty()) &#123;</div><div class="line">        Frame* frame = findFrameForNavigation(request.frameName());</div><div class="line">        <span class="keyword">if</span> (frame) &#123;</div><div class="line">            request.setShouldCheckNewWindowPolicy(<span class="literal">false</span>);</div><div class="line">            <span class="keyword">if</span> (&amp;frame-&gt;loader() != <span class="keyword">this</span>) &#123;</div><div class="line">                frame-&gt;loader().load(WTFMove(request));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (request.shouldCheckNewWindowPolicy()) &#123;</div><div class="line">        NavigationAction action &#123; request.requester(), request.resourceRequest(), InitiatedByMainFrame::Unknown, NavigationType::Other, request.shouldOpenExternalURLsPolicy() &#125;;</div><div class="line">        policyChecker().checkNewWindowPolicy(WTFMove(action), request.resourceRequest(), <span class="literal">nullptr</span>, request.frameName(), [<span class="keyword">this</span>] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">const</span> String&amp; frameName, <span class="keyword">const</span> NavigationAction&amp; action, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">            continueLoadAfterNewWindowPolicy(request, formState, frameName, action, shouldContinue, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Suppress);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!request.hasSubstituteData())</div><div class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</div><div class="line">    <span class="comment">//FrameLoader 使用空 SubStituteData 来创建 DocumentLoader 完成 MainResource 的加载。</span></div><div class="line">    Ref&lt;DocumentLoader&gt; loader = m_client.createDocumentLoader(request.resourceRequest(), request.substituteData());</div><div class="line">    applyShouldOpenExternalURLsPolicyToNewDocumentLoader(m_frame, loader, request);</div><div class="line"></div><div class="line">    load(loader.ptr());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//完善 request 信息</span></div><div class="line"><span class="keyword">void</span> FrameLoader::load(DocumentLoader* newDocumentLoader)</div><div class="line">&#123;</div><div class="line">    ResourceRequest&amp; r = newDocumentLoader-&gt;request();</div><div class="line">    <span class="comment">//ResourceRequest 包含了 HTTP Header 的内容，addExtraFieldsToMainResourceRequest 这个方法会添加一些类似 Cookie 策略，User Agent，Cache-Control，Content-type 等信息。</span></div><div class="line">    addExtraFieldsToMainResourceRequest(r);</div><div class="line">    FrameLoadType type;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;originalRequest().url())) &#123;</div><div class="line">        r.setCachePolicy(ReloadIgnoringCacheData);</div><div class="line">        type = FrameLoadType::Same;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shouldTreatURLAsSameAsCurrent(newDocumentLoader-&gt;unreachableURL()) &amp;&amp; m_loadType == FrameLoadType::Reload)</div><div class="line">        type = FrameLoadType::Reload;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m_loadType == FrameLoadType::RedirectWithLockedBackForwardList &amp;&amp; !newDocumentLoader-&gt;unreachableURL().isEmpty() &amp;&amp; newDocumentLoader-&gt;substituteData().isValid())</div><div class="line">        type = FrameLoadType::RedirectWithLockedBackForwardList;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        type = FrameLoadType::Standard;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_documentLoader)</div><div class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</div><div class="line">        history().saveDocumentAndScrollState();</div><div class="line">        ASSERT(type == FrameLoadType::Standard);</div><div class="line">        type = FrameLoadType::Reload;</div><div class="line">    &#125;</div><div class="line">    loadWithDocumentLoader(newDocumentLoader, type, <span class="number">0</span>, AllowNavigationToInvalidURL::Yes);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//校验检查</span></div><div class="line"><span class="keyword">void</span> FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, FormState* formState, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Retain because dispatchBeforeLoadEvent may release the last reference to it.</span></div><div class="line">    Ref&lt;Frame&gt; protect(m_frame);</div><div class="line"></div><div class="line">    ASSERT(m_client.hasWebView());</div><div class="line">    ASSERT(m_frame.view());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!isNavigationAllowed())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_frame.document())</div><div class="line">        m_previousURL = m_frame.document()-&gt;url();</div><div class="line"></div><div class="line">    <span class="keyword">const</span> URL&amp; newURL = loader-&gt;request().url();</div><div class="line">    <span class="comment">// Log main frame navigation types.</span></div><div class="line">    <span class="keyword">if</span> (m_frame.isMainFrame()) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* page = m_frame.page())</div><div class="line">            page-&gt;mainFrameLoadStarted(newURL, type);</div><div class="line"><span class="keyword">static_cast</span>&lt;MainFrame&amp;&gt;(m_frame).performanceLogging().didReachPointOfInterest(PerformanceLogging::MainFrameLoadStarted);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    policyChecker().setLoadType(type);</div><div class="line">    <span class="keyword">bool</span> isFormSubmission = formState;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> String&amp; httpMethod = loader-&gt;request().httpMethod();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker().loadType(), newURL)) &#123;</div><div class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</div><div class="line">        NavigationAction action &#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;;</div><div class="line"></div><div class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</div><div class="line">        oldDocumentLoader-&gt;setLastCheckedRequest(ResourceRequest());</div><div class="line">        policyChecker().stopCheck();</div><div class="line">        policyChecker().checkNavigationPolicy(loader-&gt;request(), <span class="literal">false</span> <span class="comment">/* didReceiveRedirectResponse */</span>, oldDocumentLoader.get(), formState, [<span class="keyword">this</span>] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState*, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">            continueFragmentScrollAfterNavigationPolicy(request, shouldContinue);</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Frame* parent = m_frame.tree().parent())</div><div class="line">        loader-&gt;setOverrideEncoding(parent-&gt;loader().documentLoader()-&gt;overrideEncoding());</div><div class="line"></div><div class="line">    policyChecker().stopCheck();</div><div class="line">    </div><div class="line">    <span class="comment">//把 DocumentLoader 赋给 m_policyDocumentLoader</span></div><div class="line">    setPolicyDocumentLoader(loader);</div><div class="line">    </div><div class="line">    <span class="comment">//将请求信息记在 loader.m_triggeringAction 中</span></div><div class="line">    <span class="keyword">if</span> (loader-&gt;triggeringAction().isEmpty())</div><div class="line">        loader-&gt;setTriggeringAction(&#123; *m_frame.document(), loader-&gt;request(), InitiatedByMainFrame::Unknown, policyChecker().loadType(), isFormSubmission &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (Element* ownerElement = m_frame.ownerElement()) &#123;</div><div class="line">        <span class="keyword">if</span> (!m_stateMachine.committedFirstRealDocumentLoad()</div><div class="line">            &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().<span class="built_in">string</span>())) &#123;</div><div class="line">            continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, <span class="literal">false</span>, allowNavigationToInvalidURL);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//使用 loader.m_triggeringAction 做校验，处理空白等，用来决定怎么处理请求</span></div><div class="line">    policyChecker().checkNavigationPolicy(loader-&gt;request(), <span class="literal">false</span> <span class="comment">/* didReceiveRedirectResponse */</span>, loader, formState, [<span class="keyword">this</span>, allowNavigationToInvalidURL] (<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">bool</span> shouldContinue) &#123;</div><div class="line">        <span class="comment">//shouldContinue 的不同流程会不同，formState 是用来判断 HTMLFormElement 表单 FormSubmissionTrigger 枚举状态的，这样也会有不同的流程，接下来看看 continueLoadAfterNavigationPolicy 会怎么去处理这些参数不同的值吧。</span></div><div class="line">        continueLoadAfterNavigationPolicy(request, formState, shouldContinue, allowNavigationToInvalidURL);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">void</span> FrameLoader::continueLoadAfterNavigationPolicy(<span class="keyword">const</span> ResourceRequest&amp; request, FormState* formState, <span class="keyword">bool</span> shouldContinue, AllowNavigationToInvalidURL allowNavigationToInvalidURL)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// If we loaded an alternate page to replace an unreachableURL, we'll get in here with a</span></div><div class="line">    <span class="comment">// nil policyDataSource because loading the alternate page will have passed</span></div><div class="line">    <span class="comment">// through this method already, nested; otherwise, policyDataSource should still be set.</span></div><div class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> isTargetItem = history().provisionalItem() ? history().provisionalItem()-&gt;isTargetItem() : <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> urlIsDisallowed = allowNavigationToInvalidURL == AllowNavigationToInvalidURL::No &amp;&amp; !request.url().isValid();</div><div class="line"></div><div class="line">    <span class="comment">// Three reasons we can't continue:</span></div><div class="line">    <span class="comment">//    1) Navigation policy delegate said we can't so request is nil. A primary case of this </span></div><div class="line">    <span class="comment">//       is the user responding Cancel to the form repost nag sheet.</span></div><div class="line">    <span class="comment">//    2) User responded Cancel to an alert popped up by the before unload event handler.</span></div><div class="line">    <span class="comment">//    3) The request's URL is invalid and navigation to invalid URLs is disallowed.</span></div><div class="line">    <span class="keyword">bool</span> canContinue = shouldContinue &amp;&amp; shouldClose() &amp;&amp; !urlIsDisallowed;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!canContinue) &#123;</div><div class="line">        <span class="comment">// If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we </span></div><div class="line">        <span class="comment">// need to report that the client redirect was cancelled.</span></div><div class="line">        <span class="comment">// <span class="doctag">FIXME:</span> The client should be told about ignored non-quick redirects, too.</span></div><div class="line">        <span class="keyword">if</span> (m_quickRedirectComing)</div><div class="line">            clientRedirectCancelledOrFinished(<span class="literal">false</span>);</div><div class="line"></div><div class="line">        setPolicyDocumentLoader(<span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">        <span class="comment">// If the navigation request came from the back/forward menu, and we punt on it, we have the </span></div><div class="line">        <span class="comment">// problem that we have optimistically moved the b/f cursor already, so move it back. For sanity,</span></div><div class="line">        <span class="comment">// we only do this when punting a navigation for the target frame or top-level frame.  </span></div><div class="line">        <span class="keyword">if</span> ((isTargetItem || m_frame.isMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker().loadType())) &#123;</div><div class="line">            <span class="keyword">if</span> (Page* page = m_frame.page()) &#123;</div><div class="line">                <span class="keyword">if</span> (HistoryItem* resetItem = m_frame.mainFrame().loader().history().currentItem()) &#123;</div><div class="line">                    page-&gt;backForward().setCurrentItem(resetItem);</div><div class="line">                    m_frame.loader().client().updateGlobalHistoryItemForPage();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FrameLoadType type = policyChecker().loadType();</div><div class="line">    <span class="comment">// A new navigation is in progress, so don't clear the history's provisional item.</span></div><div class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</div><div class="line">    </div><div class="line">    <span class="comment">// &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</span></div><div class="line">    <span class="comment">// might detach the current FrameLoader, in which case we should bail on this newly defunct load. </span></div><div class="line">    <span class="keyword">if</span> (!m_frame.page())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//把 DocumentLoader 赋值给 m_provisionalDocumentLoader</span></div><div class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</div><div class="line">    m_loadType = type;</div><div class="line">    <span class="comment">//设置 FrameLoader 状态为 Provisional</span></div><div class="line">    setState(FrameStateProvisional);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(<span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isBackForwardLoadType(type)) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; diagnosticLoggingClient = m_frame.page()-&gt;diagnosticLoggingClient();</div><div class="line">        <span class="keyword">if</span> (history().provisionalItem()-&gt;isInPageCache()) &#123;</div><div class="line">            diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultPass, ShouldSample::Yes);</div><div class="line">            loadProvisionalItemFromCachedPage();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::pageCacheKey(), DiagnosticLoggingKeys::retrievalKey(), DiagnosticLoggingResultFail, ShouldSample::Yes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!formState) &#123;</div><div class="line">        continueLoadAfterWillSubmitForm();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_client.dispatchWillSubmitForm(*formState, [<span class="keyword">this</span>] (PolicyAction action) &#123;</div><div class="line">        policyChecker().continueLoadAfterWillSubmitForm(action);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着在 continueLoadAfterWillSubmitForm() 方法里 m_provisionalDocumentLoader 会做些准备工作并将状态设置成正在加载资源的状态。在 prepareForLoadStart 中抛出加载状态，回调给 FrameLoaderClient，调用 DocumentLoader 的 startLoadingMainResource。</p>
<h3 id="WebKit-网络处理"><a href="#WebKit-网络处理" class="headerlink" title="WebKit 网络处理"></a>WebKit 网络处理</h3><p>WebKit 资源的加载都是由其移植方实现的，网络部分代码都在 WebCore/platform/network 里，里面包含了 HTTP Header，MIME，状态码等信息的处理。</p>
<h3 id="ResourceHandle-的相关类"><a href="#ResourceHandle-的相关类" class="headerlink" title="ResourceHandle 的相关类"></a>ResourceHandle 的相关类</h3><p><img src="/uploads/deeply-analyse-webkit/31.png" alt="31"></p>
<ul>
<li>ResouceHandleClient：跟网络传输过程相关，是网络事件对应的回调。</li>
<li>MainResourceLoader：主资源，指的 HTML 页面，会立刻发起，下载失败会向用户报错。没有缓存</li>
<li>SubResourceLoader：派生资源，HTML 页面里内嵌的图片和脚本链接等，会通过 ResourceScheduler 这个类来管理资源加载调度。下载失败不向用户报错。有缓存机制，通过 ResourceCach 保存 CSS JS 等资源原始数据以及解码后的图片数据，一方面可以节省流量一方面可以节省解码时间。</li>
<li>ResourceLoader：是主资源和派生资源加载器的基类，会通过 ResourceNotifier 将回调传给 FrameLoaderClient。</li>
</ul>
<h3 id="ResourceHandleClient"><a href="#ResourceHandleClient" class="headerlink" title="ResourceHandleClient"></a>ResourceHandleClient</h3><p>ResourceHandleClient 定义了一些对应网络加载事件回调处理的虚函数。下面就是 ResourceHandleClient 的定义<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceHandleClient</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="title">ResourceHandleClient</span><span class="params">()</span></span>;</div><div class="line">    WEBCORE_EXPORT <span class="keyword">virtual</span> ~ResourceHandleClient();</div><div class="line"></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> ResourceRequest <span class="title">willSendRequest</span><span class="params">(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didSendData</span><span class="params">(ResourceHandle*, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="comment">/*bytesSent*/</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="comment">/*totalBytesToBeSent*/</span>)</span> </span>&#123; &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//收到服务器端第一个响应包，通过里面的 HTTP Header 可以判断是否成功</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveResponse</span><span class="params">(ResourceHandle*, ResourceResponse&amp;&amp;)</span> </span>&#123; &#125;</div><div class="line">    <span class="comment">//收到服务器端包含请求数据的响应包</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveData</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span>, <span class="keyword">int</span> <span class="comment">/*encodedDataLength*/</span>)</span> </span>&#123; &#125;</div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveBuffer</span><span class="params">(ResourceHandle*, Ref&lt;SharedBuffer&gt;&amp;&amp;, <span class="keyword">int</span> encodedDataLength)</span></span>;</div><div class="line">    <span class="comment">//接受过程结束</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didFinishLoading</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line">    <span class="comment">//接受失败</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didFail</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ResourceError&amp;)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">wasBlocked</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cannotShowURL</span><span class="params">(ResourceHandle*)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">usesAsyncCallbacks</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">loadingSynchronousXHR</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueWillSendRequest() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willSendRequestAsync</span><span class="params">(ResourceHandle*, ResourceRequest&amp;&amp;, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Client will call ResourceHandle::continueDidReceiveResponse() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveResponseAsync</span><span class="params">(ResourceHandle*, ResourceResponse&amp;&amp;)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(PROTECTION_SPACE_AUTH_CALLBACK)</span></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueCanAuthenticateAgainstProtectionSpace() when ready.</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">canAuthenticateAgainstProtectionSpaceAsync</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ProtectionSpace&amp;)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// Client will pass an updated request using ResourceHandle::continueWillCacheResponse() when ready.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(CFURLCONNECTION)</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willCacheResponseAsync</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> PLATFORM(COCOA)</span></div><div class="line">    <span class="function">WEBCORE_EXPORT <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">willCacheResponseAsync</span><span class="params">(ResourceHandle*, NSCachedURLResponse *)</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(SOUP)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">getOrCreateReadBuffer</span><span class="params">(<span class="keyword">size_t</span> <span class="comment">/*requestedLength*/</span>, <span class="keyword">size_t</span>&amp; <span class="comment">/*actualLength*/</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">shouldUseCredentialStorage</span><span class="params">(ResourceHandle*)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">didReceiveAuthenticationChallenge</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> AuthenticationChallenge&amp;)</span> </span>&#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(PROTECTION_SPACE_AUTH_CALLBACK)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">canAuthenticateAgainstProtectionSpace</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> ProtectionSpace&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">receivedCancellation</span><span class="params">(ResourceHandle*, <span class="keyword">const</span> AuthenticationChallenge&amp;)</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS) || USE(CFURLCONNECTION)</span></div><div class="line">    <span class="keyword">virtual</span> RetainPtr&lt;CFDictionaryRef&gt; connectionProperties(ResourceHandle*) &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> USE(CFURLCONNECTION)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> CFCachedURLResponseRef <span class="title">willCacheResponse</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef response)</span> </span>&#123; <span class="keyword">return</span> response; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(WIN)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">shouldCacheResponse</span><span class="params">(ResourceHandle*, CFCachedURLResponseRef)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PLATFORM(WIN)</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> PLATFORM(COCOA)</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> NSCachedURLResponse *<span class="title">willCacheResponse</span><span class="params">(ResourceHandle*, NSCachedURLResponse *response)</span> </span>&#123; <span class="keyword">return</span> response; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>与 ResourceHandleClient 相关的类如下<br><img src="/uploads/deeply-analyse-webkit/80.png" alt="80"></p>
<h3 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h3><p><img src="/uploads/deeply-analyse-webkit/98.png" alt="98"></p>
<p><img src="/uploads/deeply-analyse-webkit/32.png" alt="32"></p>
<h4 id="MainResourceLoader-的加载顺序"><a href="#MainResourceLoader-的加载顺序" class="headerlink" title="MainResourceLoader 的加载顺序"></a>MainResourceLoader 的加载顺序</h4><p>MainResourceLoader 加载的是 html 文本资源。<br><img src="/uploads/deeply-analyse-webkit/79.png" alt="79"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">MainResourceLoader::load</div><div class="line">MainResourceLoader::loadNow</div><div class="line">MainResourceLoader::willSendRequest</div><div class="line">ResourceLoader::willSendRequest <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient 这样可以操作 ResourceRequest 来做些设置 request header 的操作。</span></div><div class="line">PolicyChecker::checkNavigationPolicy <span class="comment">//检查 NavigationPolicy 可以过滤一些重复的请求</span></div><div class="line">ResourceHandle::create 开始发网络请求</div><div class="line">MainResourceLoader::didReceiveResponse <span class="comment">//主资源收到第一个 HTTP 的响应回调，处理 HTTP header</span></div><div class="line">PolicyChecker:: checkContentPolicy <span class="comment">//进行 ContentPolicy 的检查，通过 dispatchDecidePolicyForMIMEType 来判断是否是下载的请求</span></div><div class="line">MainResourceLoader::continueAfterContentPolicy <span class="comment">//看看 ContentPolicy 检查后是否有错误</span></div><div class="line">ResourceLoader::didReceiveResponse <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span></div><div class="line">MainResourceLoader::didReceiveData <span class="comment">//主资源开始接受 body 数据</span></div><div class="line">ResourceLoader::didReceiveData <span class="comment">//基类 ResourceLoader 会将回调通过 ResourceNotifier 传给 FrameLoaderClient</span></div><div class="line">MainResourceLoader::addData</div><div class="line">DocumentLoader::receivedData</div><div class="line">DocumentLoader::commitLoad</div><div class="line">FrameLoader::commitProvisionalLoad <span class="comment">//从 provisional 状态到 Committed 状态</span></div><div class="line">FrameLoaderClientQt::committedLoad</div><div class="line">DocumentLoader::commitData</div><div class="line">DocumentWriter::setEncoding</div><div class="line">DocumentWriter::addData</div><div class="line">DocumentParser::appendByte</div><div class="line">DecodedDataDocumentParser::appendBytes <span class="comment">//编码处理</span></div><div class="line">HTMLDocumentParser::append <span class="comment">//解析 HTML</span></div><div class="line">MainResourceLoader::didFinishLoading</div><div class="line">FrameLoader::finishedLoading</div><div class="line">DocumentLoader::finishedLoading</div><div class="line">FrameLoader::finishedLoadingDocument</div><div class="line">DocumentWriter::end</div><div class="line">Document::finishParsing</div><div class="line">HTMLDocumentParser::finish</div></pre></td></tr></table></figure>
<p>在收到第一个响应包后会回调给 MainResourceLoader 的 didReceiveResponse 函数处理 Header 使用 PolicyChecker 的 checkContentPolicy 做校验，当 PolicyAction 为 PolicyUse 回调给 MainResourceLoader 的 continueAfterContentPolicy。结果 ResourceResponse 会通过 ResourceNotifier 通知给外部接受回调的不同平台的 FrameLoaderClient。</p>
<p>在收到后面的带数据的响应包会回调给 MainResourceLoader 的 didReceiveData，通过 ResourceLoader 的 addDataOrBuffer 把收到的数据存到 m_resourceData 里。下面是 addDataOrBuffer 方法的实现代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ResourceLoader::addDataOrBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">unsigned</span> length, SharedBuffer* buffer, DataPayloadType dataPayloadType)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (m_options.dataBufferingPolicy == DoNotBufferData)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_resourceData || dataPayloadType == DataPayloadWholeResource) &#123;</div><div class="line">        <span class="keyword">if</span> (buffer)</div><div class="line">            m_resourceData = buffer;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_resourceData = SharedBuffer::create(data, length);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (buffer)</div><div class="line">        m_resourceData-&gt;append(*buffer);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        m_resourceData-&gt;append(data, length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收到的 receiveData 会进入到 DocumentLoader 的 commitLoad 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentLoader::commitLoad(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> length)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource</span></div><div class="line">    <span class="comment">// by starting a new load, so retain temporarily.</span></div><div class="line">    RefPtr&lt;Frame&gt; protectedFrame(m_frame);</div><div class="line">    Ref&lt;DocumentLoader&gt; protectedThis(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    commitIfReady();</div><div class="line">    FrameLoader* frameLoader = DocumentLoader::frameLoader();</div><div class="line">    <span class="keyword">if</span> (!frameLoader)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)</span></div><div class="line">    <span class="keyword">if</span> (ArchiveFactory::isArchiveMimeType(response().mimeType()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">//FrameLoader 通过 transitionToCommitted 从 Provisional 的状态变为 Committed 状态</span></div><div class="line">    frameLoader-&gt;client().committedLoad(<span class="keyword">this</span>, data, length);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (isMultipartReplacingLoad())</div><div class="line">        frameLoader-&gt;client().didReplaceMultipartContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随后 DocumentLoader 执行 commitData 将前面的内容进行编码 encoding，这些数据会通过 DocumentParser 来解码，解码后的数据 会创建 HTMLDocument 和 Document 对象，后通过 DocumentWriter 传给 DocumentParser。这个过程会在 DocumentWriter 的 begin 方法里完成，具体实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentWriter::begin(<span class="keyword">const</span> URL&amp; urlReference, <span class="keyword">bool</span> dispatch, Document* ownerDocument)</div><div class="line">&#123;</div><div class="line">    <span class="comment">// We grab a local copy of the URL because it's easy for callers to supply</span></div><div class="line">    <span class="comment">// a URL that will be deallocated during the execution of this function.</span></div><div class="line">    <span class="comment">// For example, see &lt;https://bugs.webkit.org/show_bug.cgi?id=66360&gt;.</span></div><div class="line">    URL url = urlReference;</div><div class="line"></div><div class="line">    <span class="comment">// Create a new document before clearing the frame, because it may need to</span></div><div class="line">    <span class="comment">// inherit an aliased security context.</span></div><div class="line">    <span class="comment">//创建了 Document 对象</span></div><div class="line">    Ref&lt;Document&gt; document = createDocument(url);</div><div class="line">    </div><div class="line">    <span class="comment">// If the new document is for a Plugin but we're supposed to be sandboxed from Plugins,</span></div><div class="line">    <span class="comment">// then replace the document with one whose parser will ignore the incoming data (bug 39323)</span></div><div class="line">    <span class="keyword">if</span> (document-&gt;isPluginDocument() &amp;&amp; document-&gt;isSandboxed(SandboxPlugins))</div><div class="line">        document = SinkDocument::create(m_frame, url);</div><div class="line"></div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> Do we need to consult the content security policy here about blocked plug-ins?</span></div><div class="line"></div><div class="line">    <span class="keyword">bool</span> shouldReuseDefaultView = m_frame-&gt;loader().stateMachine().isDisplayingInitialEmptyDocument() &amp;&amp; m_frame-&gt;document()-&gt;isSecureTransitionTo(url);</div><div class="line">    <span class="keyword">if</span> (shouldReuseDefaultView)</div><div class="line">        document-&gt;takeDOMWindowFrom(m_frame-&gt;document());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        document-&gt;createDOMWindow();</div><div class="line"></div><div class="line">    <span class="comment">// Per &lt;http://www.w3.org/TR/upgrade-insecure-requests/&gt;, we need to retain an ongoing set of upgraded</span></div><div class="line">    <span class="comment">// requests in new navigation contexts. Although this information is present when we construct the</span></div><div class="line">    <span class="comment">// Document object, it is discard in the subsequent 'clear' statements below. So, we must capture it</span></div><div class="line">    <span class="comment">// so we can restore it.</span></div><div class="line">    HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; insecureNavigationRequestsToUpgrade;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span>* existingDocument = m_frame-&gt;document())</div><div class="line">        insecureNavigationRequestsToUpgrade = existingDocument-&gt;contentSecurityPolicy()-&gt;takeNavigationRequestsToUpgrade();</div><div class="line">    </div><div class="line">    m_frame-&gt;loader().clear(document.ptr(), !shouldReuseDefaultView, !shouldReuseDefaultView);</div><div class="line">    clear();</div><div class="line"></div><div class="line">    <span class="comment">// m_frame-&gt;loader().clear() might fire unload event which could remove the view of the document.</span></div><div class="line">    <span class="comment">// Bail out if document has no view.</span></div><div class="line">    <span class="keyword">if</span> (!document-&gt;view())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!shouldReuseDefaultView)</div><div class="line">        m_frame-&gt;script().updatePlatformScriptObjects();</div><div class="line"></div><div class="line">    m_frame-&gt;loader().setOutgoingReferrer(url);</div><div class="line">    m_frame-&gt;setDocument(document.copyRef());</div><div class="line"></div><div class="line">    document-&gt;contentSecurityPolicy()-&gt;setInsecureNavigationRequestsToUpgrade(WTFMove(insecureNavigationRequestsToUpgrade));</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_decoder)</div><div class="line">        document-&gt;setDecoder(m_decoder.get());</div><div class="line">    <span class="keyword">if</span> (ownerDocument) &#123;</div><div class="line">        document-&gt;setCookieURL(ownerDocument-&gt;cookieURL());</div><div class="line">        document-&gt;setSecurityOriginPolicy(ownerDocument-&gt;securityOriginPolicy());</div><div class="line">        document-&gt;setStrictMixedContentMode(ownerDocument-&gt;isStrictMixedContentMode());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_frame-&gt;loader().didBeginDocument(dispatch);</div><div class="line"></div><div class="line">    document-&gt;implicitOpen();</div><div class="line"></div><div class="line">    <span class="comment">// We grab a reference to the parser so that we'll always send data to the</span></div><div class="line">    <span class="comment">// original parser, even if the document acquires a new parser (e.g., via</span></div><div class="line">    <span class="comment">// document.open).</span></div><div class="line">    m_parser = document-&gt;parser();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_frame-&gt;view() &amp;&amp; m_frame-&gt;loader().client().hasHTMLView())</div><div class="line">        m_frame-&gt;view()-&gt;setContentsSize(IntSize());</div><div class="line"></div><div class="line">    m_state = StartedWritingState;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Document 对象时 DOM 树的根节点，m_writer 在 addData 时会用 DocumentParser 来解码，这个解码是在 DecodedDataDocumentParser 的 appendBytes 里做的。代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DecodedDataDocumentParser::appendBytes(DocumentWriter&amp; writer, <span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> length)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!length)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//解码 Loader 模块传来的字节流，解码后的 String 会被 HTMLDocumentParser 的 HTMLInputStream 所持有。</span></div><div class="line">    String decoded = writer.createDecoderIfNeeded()-&gt;decode(data, length);</div><div class="line">    <span class="keyword">if</span> (decoded.isEmpty())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="comment">//解码成功会交给 Parser 处理生成 DOM Tree，形成 Parser 和 MainResourceLoader 同步</span></div><div class="line">    writer.reportDataReceived();</div><div class="line">    append(decoded.releaseImpl());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>数据接收完毕会回调 MainResourceLoader 的 didFinishLoading。接下来再调用 FrameLoader 的 finishedLoading 和 finishedLoadingDocument，调用 DocumentWriter 的 end。最后调用 Document 的 finishParsing，这样 MainResource 的加载完成。</p>
<p>下面看看解码的流程：<br><img src="/uploads/deeply-analyse-webkit/85.png" alt="85"><br>decoder 的类图如下:<br><img src="/uploads/deeply-analyse-webkit/86.png" alt="86"></p>
<h4 id="SubResourceLoader-的加载顺序"><a href="#SubResourceLoader-的加载顺序" class="headerlink" title="SubResourceLoader 的加载顺序"></a>SubResourceLoader 的加载顺序</h4><p>SubResourceLoader 加载的都是派生资源，加载派生资源的时序图如下：<br><img src="/uploads/deeply-analyse-webkit/81.png" alt="81"></p>
<p>会在创建 HTMLElement 设置 src 属性时会判断 tagName 是否是 img，是的话就会触发 SubResourceLoader。设置属性和判断的代码在 HTMLConstructionSite 这个类里，具体实现代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">RefPtr&lt;Element&gt; HTMLConstructionSite::createHTMLElementOrFindCustomElementInterface(AtomicHTMLToken&amp; token, JSCustomElementInterface** customElementInterface)</div><div class="line">&#123;</div><div class="line">    auto&amp; localName = token.name();</div><div class="line">    // FIXME: This can't use HTMLConstructionSite::createElement because we</div><div class="line">    // have to pass the current form element.  We should rework form association</div><div class="line">    // to occur after construction to allow better code sharing here.</div><div class="line">    // http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#create-an-element-for-the-token</div><div class="line">    Document&amp; ownerDocument = ownerDocumentForCurrentNode();</div><div class="line">    bool insideTemplateElement = !ownerDocument.frame();</div><div class="line">    //将 tagName 和节点构造创建成 HTMLImageElement</div><div class="line">    RefPtr&lt;Element&gt; element = HTMLElementFactory::createKnownElement(localName, ownerDocument, insideTemplateElement ? nullptr : form(), true);</div><div class="line">    if (UNLIKELY(!element)) &#123;</div><div class="line">        auto* window = ownerDocument.domWindow();</div><div class="line">        if (customElementInterface &amp;&amp; window) &#123;</div><div class="line">            auto* registry = window-&gt;customElementRegistry();</div><div class="line">            if (UNLIKELY(registry)) &#123;</div><div class="line">                if (auto* elementInterface = registry-&gt;findInterface(localName)) &#123;</div><div class="line">                    *customElementInterface = elementInterface;</div><div class="line">                    return nullptr;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        QualifiedName qualifiedName(nullAtom(), localName, xhtmlNamespaceURI);</div><div class="line">        if (Document::validateCustomElementName(localName) == CustomElementNameValidationStatus::Valid) &#123;</div><div class="line">            element = HTMLElement::create(qualifiedName, ownerDocument);</div><div class="line">            element-&gt;setIsCustomElementUpgradeCandidate();</div><div class="line">        &#125; else</div><div class="line">            element = HTMLUnknownElement::create(qualifiedName, ownerDocument);</div><div class="line">    &#125;</div><div class="line">    ASSERT(element);</div><div class="line"></div><div class="line">    // FIXME: This is a hack to connect images to pictures before the image has</div><div class="line">    // been inserted into the document. It can be removed once asynchronous image</div><div class="line">    // loading is working.</div><div class="line">    if (is&lt;HTMLPictureElement&gt;(currentNode()) &amp;&amp; is&lt;HTMLImageElement&gt;(*element))</div><div class="line">        downcast&lt;HTMLImageElement&gt;(*element).setPictureElement(&amp;downcast&lt;HTMLPictureElement&gt;(currentNode()));</div><div class="line">    //设置属性，这里会判断是否是 src，如果 element 的 tagName 是 img 就会触发派生资源下载</div><div class="line">    setAttributes(*element, token, m_parserContentPolicy);</div><div class="line">    ASSERT(element-&gt;isHTMLElement());</div><div class="line">    return element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 HTMLImageElement 这个类里会用 parseAttribute 方法处理，在这个方法里判断到属性是 srcAttr 时会触发 selectImageSource 方法，方法实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLImageElement::selectImageSource()</div><div class="line">&#123;</div><div class="line">    <span class="comment">// First look for the best fit source from our &lt;picture&gt; parent if we have one.</span></div><div class="line">    ImageCandidate candidate = bestFitSourceFromPictureElement();</div><div class="line">    <span class="keyword">if</span> (candidate.isEmpty()) &#123;</div><div class="line">        <span class="comment">// If we don't have a &lt;picture&gt; or didn't find a source, then we use our own attributes.</span></div><div class="line">        <span class="keyword">auto</span> sourceSize = SizesAttributeParser(attributeWithoutSynchronization(sizesAttr).<span class="built_in">string</span>(), document()).length();</div><div class="line">        candidate = bestFitSourceForImageAttributes(document().deviceScaleFactor(), attributeWithoutSynchronization(srcAttr), attributeWithoutSynchronization(srcsetAttr), sourceSize);</div><div class="line">    &#125;</div><div class="line">    setBestFitURLAndDPRFromImageCandidate(candidate);</div><div class="line">    <span class="comment">//updateFromElementIgnoringPreviousError 是 ImageLoader 类的一个方法，它会调用 updateFromElement 方法来判断资源来源</span></div><div class="line">    m_imageLoader.updateFromElementIgnoringPreviousError();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SubResourceLoader 主要是转给 SubResourceLoaderClient 类来完成，如下图：<br><img src="/uploads/deeply-analyse-webkit/33.png" alt="33"></p>
<p>ResourceLoadScheduler 会对 SubResourceLoader 进行调度管理<br><img src="/uploads/deeply-analyse-webkit/34.png" alt="34"></p>
<ul>
<li>Document：会创建拥有一个 CachedResourceLoader 类的对象实例 m_cachedResourceLoader，这个类有访问派生资源的接口，比如 requestImage，requestCSSStyleSheet，requestUserCSSStyleSheet，requestScript，requestFont，requestXSLStyleSheet，requestLinkPrefetch 等。这里 requestImage 有条件判断，这样外部实现接口就可以通过设置不加载图片，达到很多浏览器里提供那种无图模式了。</li>
<li>CacheResourceLoader：会创建 CachedResourceRequest 对象发请求。在它的构造函数里会传入一个 CachedResource 对象作为参数。还会通过 m_requests 来记录资源请求数量，这样就可以把加载状态回调出去了。</li>
<li>MemoryCache：会维护一个 HashMap ，里面的 value 存储 CachedResource 类缓存的内容。HashMap 定义为 HashMap <string,cachedresource> m_resources;</string,cachedresource></li>
</ul>
<p>在 CachedResourceLoader 里会通过 resourceForUrl 在 Memory Cache 里找对应 url 对应的缓存资源，determineRevalidationPolicy 会返回一个枚举值用来确定用哪种方式加载资源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> RevalidationPolicy &#123; Use, Revalidate, Reload, Load &#125;;</div><div class="line">    <span class="function">RevalidationPolicy <span class="title">determineRevalidationPolicy</span><span class="params">(CachedResource::Type, CachedResourceRequest&amp;, CachedResource* existingResource, ForPreload, DeferOption)</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>可以看到 RevalidationPolicy 有四种，Use，Revalidate，Reload 和 Load。Use 表示资源已经在缓存里可以直接使用。Revalidate 表示缓存资源已失效，需删除旧资源，重新在缓存里加新资源。Reload 表示已缓存但由于资源类型不同或者 Cache-control:no-cache 设置不用 Cache 的情况需要重新加载。Load 表示缓存里没有，需直接加载。这段逻辑处理在 CachedResourceLoader 里的 requestResource 里有实现，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);</div><div class="line"><span class="keyword">switch</span> (policy) &#123;</div><div class="line"><span class="keyword">case</span> Reload:</div><div class="line">    memoryCache.remove(*resource);</div><div class="line">    FALLTHROUGH;</div><div class="line"><span class="keyword">case</span> Load:</div><div class="line">    <span class="keyword">if</span> (resource)</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</div><div class="line">    resource = loadResource(type, WTFMove(request));</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> Revalidate:</div><div class="line">    <span class="keyword">if</span> (resource)</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</div><div class="line">    resource = revalidateResource(WTFMove(request), *resource);</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> Use:</div><div class="line">    ASSERT(resource);</div><div class="line">    <span class="keyword">if</span> (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) &#123;</div><div class="line">        resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request));</div><div class="line">        <span class="keyword">if</span> (resource-&gt;status() != CachedResource::Status::Cached)</div><div class="line">            policy = Load;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ResourceError error;</div><div class="line">        <span class="keyword">if</span> (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))</div><div class="line">            <span class="keyword">return</span> makeUnexpected(WTFMove(error));</div><div class="line">        logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</div><div class="line">        loadTiming.setResponseEnd(MonotonicTime::now());</div><div class="line"></div><div class="line">        memoryCache.resourceAccessed(*resource);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) &#123;</div><div class="line">            <span class="keyword">auto</span> resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());</div><div class="line">            <span class="keyword">if</span> (initiatorContext == InitiatorContext::Worker) &#123;</div><div class="line">                ASSERT(is&lt;CachedRawResource&gt;(resource.get()));</div><div class="line">                downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ASSERT(initiatorContext == InitiatorContext::Document);</div><div class="line">                m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());</div><div class="line">                m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (forPreload == ForPreload::No)</div><div class="line">            resource-&gt;setLoadPriority(request.priority());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 CachedResourceLoader 的 loadResource 方法里会通过工厂方法 createResource 来创建不同的 CacheResource。</p>
<p>CachedResource 加载<br>CachedResource 实现了 RFC2616 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" target="_blank" rel="external">https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html</a> 的 w3c 缓存标准，根据资源类型还派生出不同的子类如图所示：<br><img src="/uploads/deeply-analyse-webkit/35.png" alt="35"></p>
<p>会有一个 CachedResourceClient 的集合 m_clients 来记录所有的 CachedResource，同时 CachedResourceClientWalker 这个接口可以遍历这个集合。 CacheResource 会通过 CachedResourceClient::notifyFinished 接口来在数据都到位后来进行通知。</p>
<p>在 CachedResource 里 type 枚举定义了派生资源的类型，通过 defaultPriorityForResourceType 函数方法的返回可以看到各资源加载的优先级具体定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">ResourceLoadPriority CachedResource::defaultPriorityForResourceType(Type type)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (type) &#123;</div><div class="line">    <span class="keyword">case</span> CachedResource::MainResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryHigh;</div><div class="line">    <span class="keyword">case</span> CachedResource::CSSStyleSheet:</div><div class="line">    <span class="keyword">case</span> CachedResource::Script:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::High;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(SVG_FONTS)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::SVGFontResource:</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">case</span> CachedResource::MediaResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::FontResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::RawResource:</div><div class="line">    <span class="keyword">case</span> CachedResource::Icon:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Medium;</div><div class="line">    <span class="keyword">case</span> CachedResource::ImageResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(XSLT)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::XSLStyleSheet:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::High;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="keyword">case</span> CachedResource::SVGDocumentResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line">    <span class="keyword">case</span> CachedResource::Beacon:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(LINK_PREFETCH)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::LinkPrefetch:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line">    <span class="keyword">case</span> CachedResource::LinkSubresource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::VeryLow;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> ENABLE(VIDEO_TRACK)</span></div><div class="line">    <span class="keyword">case</span> CachedResource::TextTrackResource:</div><div class="line">        <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    &#125;</div><div class="line">    ASSERT_NOT_REACHED();</div><div class="line">    <span class="keyword">return</span> ResourceLoadPriority::Low;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个加载的安排是通过 WebResourceLoadScheduler 里的 scheduleLoad 通过上面返回的优先级来的。当然这些实现和平台是相关的会根据不同平台有不同的处理，具体处理如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WebResourceLoadScheduler::scheduleLoad(ResourceLoader* resourceLoader)</div><div class="line">&#123;</div><div class="line">    ASSERT(resourceLoader);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    <span class="comment">// If there's a web archive resource for this URL, we don't need to schedule the load since it will never touch the network.</span></div><div class="line">    <span class="keyword">if</span> (!isSuspendingPendingRequests() &amp;&amp; resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;iOSOriginalRequest().url())) &#123;</div><div class="line">        resourceLoader-&gt;startLoading();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (resourceLoader-&gt;documentLoader()-&gt;archiveResourceForURL(resourceLoader-&gt;request().url())) &#123;</div><div class="line">        resourceLoader-&gt;start();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//根据 url 创建 host，然后加到 ResourceLoadSchedule 的 m_hosts 属性里</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;iOSOriginalRequest().url(), CreateIfNotFound);</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    HostInformation* host = hostForURL(resourceLoader-&gt;url(), CreateIfNotFound);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    ResourceLoadPriority priority = resourceLoader-&gt;request().priority();</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> hadRequests = host-&gt;hasRequests();</div><div class="line">    <span class="comment">//把优先级存放到 host 的 m_requestsPending 属性里</span></div><div class="line">    host-&gt;schedule(resourceLoader, priority);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(COCOA) || USE(CFURLCONNECTION)</span></div><div class="line">    <span class="keyword">if</span> (ResourceRequest::resourcePrioritiesEnabled() &amp;&amp; !isSuspendingPendingRequests()) &#123;</div><div class="line">        <span class="comment">// Serve all requests at once to keep the pipeline full at the network layer.</span></div><div class="line">        <span class="comment">// <span class="doctag">FIXME:</span> Does this code do anything useful, given that we also set maxRequestsInFlightPerHost to effectively unlimited on these platforms?</span></div><div class="line">        servePendingRequests(host, ResourceLoadPriority::VeryLow);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line"><span class="comment">//这里就是如何根据优先级来进行安排的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">    <span class="keyword">if</span> ((priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;iOSOriginalRequest().url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &amp;&amp; !isSuspendingPendingRequests()) &#123;</div><div class="line">        <span class="comment">//重要资源立刻进行</span></div><div class="line">        servePendingRequests(host, priority);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="keyword">if</span> (priority &gt; ResourceLoadPriority::Low || !resourceLoader-&gt;url().protocolIsInHTTPFamily() || (priority == ResourceLoadPriority::Low &amp;&amp; !hadRequests)) &#123;</div><div class="line">        <span class="comment">//重要资源立刻进行</span></div><div class="line">        servePendingRequests(host, priority);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"></div><div class="line">    <span class="comment">// Handle asynchronously so early low priority requests don't</span></div><div class="line">    <span class="comment">// get scheduled before later high priority ones.</span></div><div class="line">    <span class="comment">//不重要的就延迟进行，然后根据优先级，由高到低依次加载</span></div><div class="line">    scheduleServePendingRequests();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>servePendingRequests 有两个重载实现，第一个会根据 host 来遍历，然后由第二个重载来具体实现，具体代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WebResourceLoadScheduler::servePendingRequests(HostInformation* host, ResourceLoadPriority minimumPriority)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> priority = ResourceLoadPriority::Highest;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">auto</span>&amp; requestsPending = host-&gt;requestsPending(priority);</div><div class="line">        <span class="keyword">while</span> (!requestsPending.isEmpty()) &#123;</div><div class="line">            RefPtr&lt;ResourceLoader&gt; resourceLoader = requestsPending.first();</div><div class="line"></div><div class="line">            <span class="comment">// For named hosts - which are only http(s) hosts - we should always enforce the connection limit.</span></div><div class="line">            <span class="comment">// For non-named hosts - everything but http(s) - we should only enforce the limit if the document isn't done parsing </span></div><div class="line">            <span class="comment">// and we don't know all stylesheets yet.</span></div><div class="line">            Document* document = resourceLoader-&gt;frameLoader() ? resourceLoader-&gt;frameLoader()-&gt;frame().document() : <span class="number">0</span>;</div><div class="line">            <span class="keyword">bool</span> shouldLimitRequests = !host-&gt;name().isNull() || (document &amp;&amp; (document-&gt;parsing() || !document-&gt;haveStylesheetsLoaded()));</div><div class="line">            <span class="keyword">if</span> (shouldLimitRequests &amp;&amp; host-&gt;limitRequests(priority))</div><div class="line">                <span class="keyword">return</span>;</div><div class="line"></div><div class="line">            requestsPending.removeFirst();</div><div class="line">            host-&gt;addLoadInProgress(resourceLoader.get());</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> PLATFORM(IOS)</span></div><div class="line">            <span class="keyword">if</span> (!IOSApplication::isWebProcess()) &#123;</div><div class="line">                resourceLoader-&gt;startLoading();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">            <span class="comment">//在这个函数里创建了 ResourceHandle</span></div><div class="line">            resourceLoader-&gt;start();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (priority == minimumPriority)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        --priority;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加载完数据后，处理过程和 MainResource 类似，SubResourceLoader 会作为 ResourceHandle 的接受者，会接受 ResourceHandle 的回调，和 MainResource 不同的只是 Memeory Cache 部分，这部分的实现是在 SubResourceLoader 的 didReceiveData 里。实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> SubresourceLoader::didReceiveDataOrBuffer(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">int</span> length, RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, <span class="keyword">long</span> <span class="keyword">long</span> encodedDataLength, DataPayloadType dataPayloadType)</div><div class="line">&#123;</div><div class="line">    ASSERT(m_resource);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (m_resource-&gt;response().httpStatusCode() &gt;= <span class="number">400</span> &amp;&amp; !m_resource-&gt;shouldIgnoreHTTPStatusCodeErrors())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    ASSERT(!m_resource-&gt;resourceToRevalidate());</div><div class="line">    ASSERT(!m_resource-&gt;errorOccurred());</div><div class="line">    ASSERT(m_state == Initialized);</div><div class="line">    <span class="comment">// Reference the object in this method since the additional processing can do</span></div><div class="line">    <span class="comment">// anything including removing the last reference to this object; one example of this is 3266216.</span></div><div class="line">    Ref&lt;SubresourceLoader&gt; protectedThis(*<span class="keyword">this</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//ResourceLoader 里会掉 addDataOrBuffer 会把数据存在 SubResourceLoader 的 m_resourceData 里</span></div><div class="line">    ResourceLoader::didReceiveDataOrBuffer(data, length, buffer.copyRef(), encodedDataLength, dataPayloadType);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!m_loadingMultipartContent) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span>* resourceData = <span class="keyword">this</span>-&gt;resourceData())</div><div class="line">            m_resource-&gt;addDataBuffer(*resourceData);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_resource-&gt;addData(buffer ? buffer-&gt;data() : data, buffer ? buffer-&gt;size() : length);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以 image 为例如图所示：<br><img src="/uploads/deeply-analyse-webkit/36.png" alt="36"></p>
<p>举个例子 image 加载的顺序。DocLoader 是负责子资源的加载，要加载一个图像，首先 DocLoader 要检查 Cache 中是否有对应的 CacheImage 对象，如果有就不用再次下载和解码直接用之。不在会创建一个新的 CacheImage 对象，这个 CacheImage 会要求 Loader 对象创建 SubresourceLoader 来启动网络请求。</p>
<p>CacheImage 的加载过程如下图：<br><img src="/uploads/deeply-analyse-webkit/82.png" alt="82"></p>
<p>具体调用方法顺序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">HTMLImageElement::create <span class="comment">//解析到 img 标签 会创建 HTMLImageElement 对象，里面包含 HTMLImageLoader 对象</span></div><div class="line">ImageLoader::updateFromElementIgnoringPreviousError <span class="comment">//解析到 img 的 href 属性</span></div><div class="line">ImageLoader::updateFromElement</div><div class="line">CachedResourceLoader::requestImage</div><div class="line">CachedResourceLoader::requestResource <span class="comment">//判断是否从缓存读取，还是网络获取</span></div><div class="line">CachedResourceLoader::loadResource <span class="comment">//创建不同类型的 CachedResource，这里是 CachedImage</span></div><div class="line">MemoryCache::add <span class="comment">//创建对应的 cache 项目</span></div><div class="line">CachedImage::load</div><div class="line">CachedResource::load</div><div class="line">CachedResourceLoader::load</div><div class="line">CachedResourceRequest::load</div><div class="line">ResourceLoaderScheduler::scheduleSubresourceLoad</div><div class="line">SubresourceLoader::create</div><div class="line">ResourceLoadScheduler::requestTimerFired</div><div class="line">ResourceLoader::start</div><div class="line">ResourceHandle::create</div><div class="line">ResourceLoader::didReceiveResponse <span class="comment">//收到 HTTP Header 的 response</span></div><div class="line">SubresourceLoader::didiReceiveResponse</div><div class="line">CachedResourceRequest::didReceiveResponse <span class="comment">//处理响应</span></div><div class="line">ResourceLoader::didReceiveResponse</div><div class="line">ResourceLoader::didReceiveData <span class="comment">//收到 body 数据</span></div><div class="line">SubresourceLoader::didReceiveData</div><div class="line">ResourceLoader::didReceiveData</div><div class="line">ResourceLoader::addData</div><div class="line">CachedResourceRequest::didReceiveData</div><div class="line">ResourceLoader::didFinishLoading <span class="comment">//数据读取完成</span></div><div class="line">SubresourceLoader::didFinishLoading</div><div class="line">CachedResourceRequest::didFinishLoading</div><div class="line">CachedResource::finish</div><div class="line">CachedResourceLoader::loadDone</div><div class="line">CachedImage::data <span class="comment">//创建 Image 对象，进行解码</span></div></pre></td></tr></table></figure></p>
<p>可以用下图概括下：<br><img src="/uploads/deeply-analyse-webkit/51.png" alt="51"><br>一般的资源加载都是异步执行，但是碰到 JavaScript 文件加载时会阻碍主线程的渲染，这时 WebKit 会在阻碍时去后面收集其它资源的 URL 发并发请求，这样对加载速度会有一定的优化。</p>
<h3 id="资源的生命周期"><a href="#资源的生命周期" class="headerlink" title="资源的生命周期"></a>资源的生命周期</h3><p>资源池采用的是 Least Recent Used 最少使用算法 LRU。通过 HTTP 协议规范中更新规范来确定下次是否需要更新资源。具体做法是先判断资源是否在资源池里，在的话就发一个 HTTP 请求带上一些信息比如资源的修改时间，然后服务器根据这个信息判断是否有更新，如果没有更新就返回 304 状态码，这样就直接使用资源池的原资源，不然就下载最新资源。</p>
<h3 id="WebKit-的-Cache"><a href="#WebKit-的-Cache" class="headerlink" title="WebKit 的 Cache"></a>WebKit 的 Cache</h3><p>WebKit 主要有三种 Cache。</p>
<h4 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h4><p>对浏览页面的缓存用来使页面历史操作加速。单例模式，会有页面上限，会缓存 DOM Tree，Render Tree。在打开一个新页面的时候会在 FrameLoader 的 commitProvisionalLoad 方法里把前一个页面加入 Page Cache。截取相关代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!m_frame.tree().parent() &amp;&amp; history().currentItem()) &#123;</div><div class="line">    <span class="comment">// Check to see if we need to cache the page we are navigating away from into the back/forward cache.</span></div><div class="line">    <span class="comment">// We are doing this here because we know for sure that a new page is about to be loaded.</span></div><div class="line">    PageCache::singleton().addIfCacheable(*history().currentItem(), m_frame.page());</div><div class="line"></div><div class="line">    WebCore::jettisonExpensiveObjectsOnTopLevelNavigation();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>PageCache 的 addIfCacheable 会对缓存进行管理，实现代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PageCache::addIfCacheable(HistoryItem&amp; item, Page* page)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (item.isInPageCache())</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!page || !canCache(*page))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    ASSERT_WITH_MESSAGE(!page-&gt;isUtilityPage(), <span class="string">"Utility pages such as SVGImage pages should never go into PageCache"</span>);</div><div class="line"></div><div class="line">    setPageCacheState(*page, Document::AboutToEnterPageCache);</div><div class="line"></div><div class="line">    <span class="comment">// Focus the main frame, defocusing a focused subframe (if we have one). We do this here,</span></div><div class="line">    <span class="comment">// before the page enters the page cache, while we still can dispatch DOM blur/focus events.</span></div><div class="line">    <span class="keyword">if</span> (page-&gt;focusController().focusedFrame())</div><div class="line">        page-&gt;focusController().setFocusedFrame(&amp;page-&gt;mainFrame());</div><div class="line"></div><div class="line">    <span class="comment">// Fire the pagehide event in all frames.</span></div><div class="line">    firePageHideEventRecursively(page-&gt;mainFrame());</div><div class="line"></div><div class="line">    <span class="comment">// Check that the page is still page-cacheable after firing the pagehide event. The JS event handlers</span></div><div class="line">    <span class="comment">// could have altered the page in a way that could prevent caching.</span></div><div class="line">    <span class="keyword">if</span> (!canCache(*page)) &#123;</div><div class="line">        setPageCacheState(*page, Document::NotInPageCache);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    destroyRenderTree(page-&gt;mainFrame());</div><div class="line"></div><div class="line">    setPageCacheState(*page, Document::InPageCache);</div><div class="line"></div><div class="line">    <span class="comment">// Make sure we no longer fire any JS events past this point.</span></div><div class="line">    NoEventDispatchAssertion assertNoEventDispatch;</div><div class="line">    <span class="comment">//创建一个新的 CachedPage 存放到 HistoryItem 里</span></div><div class="line">    item.m_cachedPage = <span class="built_in">std</span>::make_unique&lt;CachedPage&gt;(*page);</div><div class="line">    item.m_pruningReason = PruningReason::None;</div><div class="line">    <span class="comment">//将 HistoryItem 添加到 m_items 列表中</span></div><div class="line">    m_items.add(&amp;item);</div><div class="line">    </div><div class="line">    <span class="comment">//检查是否有超过回收的限制，进行资源回收</span></div><div class="line">    prune(PruningReason::ReachedMaxSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当 Page 的 goBack 方法调用时会调用 FrameLoader 的 loadDifferentDocumentItem，同时加载类型设置为 FrameLoadTypeBack，然后页面将会从 Page Cache 里恢复。</p>
<h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><p>使得相同 url 的资源能够快速获得。单例模式，在浏览器打开时创建，关闭时释放。关联类结构图如下：<br><img src="/uploads/deeply-analyse-webkit/83.png" alt="83"><br>Memory Cache 有三个比较重要的属性。</p>
<ul>
<li>m_resources：类型是 HashMap，key 是 url，值是 CacheResource。</li>
<li>m_allResources：采用的是 LRU 算法，类型是 Vector<lrulist,32> 有 32 个向量，具体实现是在 MemeoryCache 的 lruListFor。回收资源是通过 MemoryCache 里的 prune 来的，会从链表尾开始进行回收直到空间大小达标为止。</lrulist,32></li>
<li>m_liveDecodedResource：类型为 LRUList，解码后的数据会记录在里面。</li>
</ul>
<h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p>根据 HTTP 的头信息来设置缓存。属于持久化缓存存储，重新打开浏览器还能节省下载的流量和时间浪费。使用的也是 LRU 算法来控制缓存磁盘空间大小。具体实现是由平台相关代码来完成。</p>
<h2 id="HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><a href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token" class="headerlink" title="HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token"></a>HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</h2><h3 id="解析成-HTML-Token-的算法"><a href="#解析成-HTML-Token-的算法" class="headerlink" title="解析成 HTML Token 的算法"></a>解析成 HTML Token 的算法</h3><p><img src="/uploads/deeply-analyse-webkit/17.png" alt="17"><br>初始状态是 Data state，碰到 &lt; 字符状态变为 Tag open state，下个字符为字母时就创建 Start tag token，状态变成 Tag name state，到 &gt; 字符状态变成 Data state，中间的字符都会被加到 token name 里。</p>
<p>在 Tag open state 状态时如果碰到 / 字符那么就会创建 End tag token，同时状态变成 Tag name state。</p>
<p>在 WebKit 中有两个类是专门做词法分析的，一个是做标记的 HTMLToken，另一个是词法解析器 HTMLTokenizer 类，解析任务就是要把字节流解析成一个个 HTMLToken 给语法解析器分析。在 html 解析中一个 element 对应 三个 HTMLToken，一个是起始标签，一个是 element 内容，一个是结束标签 HTMLToken。在 DOM 树上起始结束标签对应一个 element node，内容是另一个 node。</p>
<p>HTMLToken 的所有类型定义在 HTMLToken.h 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Type &#123;</div><div class="line">    Uninitialized, <span class="comment">//默认类型</span></div><div class="line">    DOCTYPE,       <span class="comment">//文档类型</span></div><div class="line">    StartTag,      <span class="comment">//起始标签</span></div><div class="line">    EndTag,        <span class="comment">//结束标签</span></div><div class="line">    Comment,       <span class="comment">//注释</span></div><div class="line">    Character,     <span class="comment">//元素内容</span></div><div class="line">    EndOfFile,     <span class="comment">//文档结束</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来看看 HTMLToken 的成员变量，HTMLTokenizer 类会解析出的这样的结构体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    Type m_type;       <span class="comment">//那种类型</span></div><div class="line"></div><div class="line">    DataVector m_data; <span class="comment">//根据类型来，不同类型内容不一样</span></div><div class="line">    UChar m_data8BitCheck;</div><div class="line"></div><div class="line">    <span class="comment">// For StartTag and EndTag</span></div><div class="line">    <span class="keyword">bool</span> m_selfClosing;            <span class="comment">//是否是自封闭</span></div><div class="line">    AttributeList m_attributes;    <span class="comment">//属性列表</span></div><div class="line">    Attribute* m_currentAttribute; <span class="comment">//当前属性</span></div><div class="line"></div><div class="line">    <span class="comment">// For DOCTYPE</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DoctypeData&gt; m_doctypeData;</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> m_attributeBaseOffset &#123; <span class="number">0</span> &#125;; <span class="comment">// Changes across document.write() boundaries.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在说 HTMLTokenizer 具体解析实现之前我们先了解下有限状态机。先看看数学模型<br><img src="/uploads/deeply-analyse-webkit/28.png" alt="28"></p>
<p>HTMLTokenizer 里的 processToken 方法具体实现了整个状态机，实现主要是根据 w3c 的 tokenization 标准来实现的：<a href="https://dev.w3.org/html5/spec-preview/tokenization.html" target="_blank" rel="external">https://dev.w3.org/html5/spec-preview/tokenization.html</a> 。html 的字符集合就是数学模型里的字母表，状态的非空集合都定义在 HTMLTokenizer.h 的 state 枚举里。state 枚举值 DataState 表示初始状态。processToken 里对不同 state 所做的 case 处理就是状态转移函数。下面是 HTMLTokenizer 里的 state 枚举：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//HTML 有限状态机的状态非空集合</span></div><div class="line"><span class="keyword">enum</span> State &#123;</div><div class="line">    DataState, <span class="comment">//初始状态，一般最开始和其它地方碰到 &gt; 符号为截止再次进入这个状态。碰到字母需要设置 HTMLToken 的 type 为 character</span></div><div class="line">    CharacterReferenceInDataState,</div><div class="line">    RCDATAState,</div><div class="line">    CharacterReferenceInRCDATAState,</div><div class="line">    RAWTEXTState,</div><div class="line">    ScriptDataState,</div><div class="line">    PLAINTEXTState,</div><div class="line">    TagOpenState, <span class="comment">//碰到 &lt; 符号。如果前面的 DataState 有值需要提取值到 HTMLToken 的 m_data 里</span></div><div class="line">    EndTagOpenState, <span class="comment">//TagOpenState 状态碰见 / 进入。HTMLToken 的 type 为 endTag</span></div><div class="line">    TagNameState, <span class="comment">//在 TagOpenState 或 EndTagOpenState 状态碰到字母。HTMLToken 的 type 为 StartTag</span></div><div class="line"></div><div class="line">    RCDATALessThanSignState,</div><div class="line">    RCDATAEndTagOpenState,</div><div class="line">    RCDATAEndTagNameState,</div><div class="line"></div><div class="line">    RAWTEXTLessThanSignState,</div><div class="line">    RAWTEXTEndTagOpenState,</div><div class="line">    RAWTEXTEndTagNameState,</div><div class="line"></div><div class="line">    ScriptDataLessThanSignState,</div><div class="line">    ScriptDataEndTagOpenState,</div><div class="line">    ScriptDataEndTagNameState,</div><div class="line">    ScriptDataEscapeStartState,</div><div class="line">    ScriptDataEscapeStartDashState,</div><div class="line">    ScriptDataEscapedState,</div><div class="line">    ScriptDataEscapedDashState,</div><div class="line">    ScriptDataEscapedDashDashState,</div><div class="line">    ScriptDataEscapedLessThanSignState,</div><div class="line">    ScriptDataEscapedEndTagOpenState,</div><div class="line">    ScriptDataEscapedEndTagNameState,</div><div class="line">    ScriptDataDoubleEscapeStartState,</div><div class="line">    ScriptDataDoubleEscapedState,</div><div class="line">    ScriptDataDoubleEscapedDashState,</div><div class="line">    ScriptDataDoubleEscapedDashDashState,</div><div class="line">    ScriptDataDoubleEscapedLessThanSignState,</div><div class="line">    ScriptDataDoubleEscapeEndState,</div><div class="line"></div><div class="line">    BeforeAttributeNameState, <span class="comment">//TagNameState 碰到空格。HTMLToken 的 m_data 会记录前面的 tagname</span></div><div class="line">    AttributeNameState, <span class="comment">//BeforeAttributeNameState 碰见字母进入</span></div><div class="line">    AfterAttributeNameState,</div><div class="line">    BeforeAttributeValueState, <span class="comment">//AttributeNameState 状态碰到 = 会进入，同时会在 HTMLToken 属性列表里增加一个属性，属性名为前面状态记录的</span></div><div class="line">    AttributeValueDoubleQuotedState, <span class="comment">//BeforeAttributeValueState 碰到 " 符号</span></div><div class="line">    AttributeValueSingleQuotedState, <span class="comment">//BeforeAttributeValueState 碰到 ' 符号</span></div><div class="line">    AttributeValueUnquotedState,</div><div class="line">    CharacterReferenceInAttributeValueState,</div><div class="line">    AfterAttributeValueQuotedState, <span class="comment">// 再次碰到 " 或 ' 符号。HTMLToken 记录属性的值</span></div><div class="line">    SelfClosingStartTagState,</div><div class="line">    BogusCommentState,</div><div class="line">    ContinueBogusCommentState, <span class="comment">// Not in the HTML spec, used internally to track whether we started the bogus comment token.</span></div><div class="line">    MarkupDeclarationOpenState, <span class="comment">//TagOpenState 后遇到! 比如&lt;!</span></div><div class="line"></div><div class="line">    <span class="comment">//解析comment</span></div><div class="line">    CommentStartState, <span class="comment">//MarkupDeclarationOpenState 状态后跟了两个 - 比如 &lt;!-- 。HTMLToken 的 type 为 COMMENT</span></div><div class="line">    CommentStartDashState,</div><div class="line">    CommentState, <span class="comment">//CommentStartState 碰到字母进入这个状态</span></div><div class="line">    CommentEndDashState, <span class="comment">//在 CommentState 状态碰见 - 进入。HTMLToken 的 m_data 为 前面记录的 comment 内容</span></div><div class="line">    CommentEndState, <span class="comment">//在 CommentEndDashState 状态碰见 - 进入</span></div><div class="line">    CommentEndBangState,</div><div class="line"></div><div class="line">    <span class="comment">//解析 &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; 这种标签</span></div><div class="line">    DOCTYPEState, <span class="comment">//匹配到 DOCTYPE，&lt;!DOCTYPE</span></div><div class="line">    BeforeDOCTYPENameState, <span class="comment">//DOCTYPE 状态后遇到空格</span></div><div class="line">    DOCTYPENameState, <span class="comment">//BeforeDOCTYPENameState 状态遇到字母，提取 html。HTMLToken 的 m_data 为 html</span></div><div class="line">    AfterDOCTYPENameState, <span class="comment">//DOCTYPENameState 遇到空格 &lt;!DOCTYPE html</span></div><div class="line">    AfterDOCTYPEPublicKeywordState, <span class="comment">//AfterDOCTYPENameState 后匹配到 public。&lt;!DOCTYPE html PUBLIC</span></div><div class="line">    BeforeDOCTYPEPublicIdentifierState, <span class="comment">//AfterDOCTYPEPublicKeywordState 状态后碰到空格</span></div><div class="line">    DOCTYPEPublicIdentifierDoubleQuotedState, <span class="comment">//BeforeDOCTYPEPublicIdentifierState 状态碰到 " 进入</span></div><div class="line">    DOCTYPEPublicIdentifierSingleQuotedState, <span class="comment">//BeforeDOCTYPEPublicIdentifierState 状态碰到 ' 进入</span></div><div class="line">    AfterDOCTYPEPublicIdentifierState, <span class="comment">//再次遇到 " 或 ' 。可将 HTMLToken 的 m_publicIdentifier 确定</span></div><div class="line">    BetweenDOCTYPEPublicAndSystemIdentifiersState, </div><div class="line">    AfterDOCTYPESystemKeywordState,</div><div class="line">    BeforeDOCTYPESystemIdentifierState,</div><div class="line">    DOCTYPESystemIdentifierDoubleQuotedState,</div><div class="line">    DOCTYPESystemIdentifierSingleQuotedState,</div><div class="line">    AfterDOCTYPESystemIdentifierState,</div><div class="line">    BogusDOCTYPEState,</div><div class="line">    CDATASectionState,</div><div class="line"></div><div class="line">    <span class="comment">// These CDATA states are not in the HTML5 spec, but we use them internally.</span></div><div class="line">    CDATASectionRightSquareBracketState,</div><div class="line">    CDATASectionDoubleRightSquareBracketState,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>词法解析主要接口是 nextToken 函数，下图展示了 HTMLTokenizer 的主要工作流程：<br><img src="/uploads/deeply-analyse-webkit/55.png" alt="55"></p>
<h2 id="HTML-语法解析"><a href="#HTML-语法解析" class="headerlink" title="HTML 语法解析"></a>HTML 语法解析</h2><h3 id="HTML-的语法定义"><a href="#HTML-的语法定义" class="headerlink" title="HTML 的语法定义"></a>HTML 的语法定义</h3><p>HTML 的语法规范是由 w3c 组织创建和定义的。语法语句可以使用正式的比如 BNF 来定义，不过对于 html 这种会在创建后允许再插入代码的语言 w3c 使用了 DTD 来定义 HTML，定义的文件可以在这里：<a href="https://www.w3.org/TR/html4/strict.dtd" target="_blank" rel="external">https://www.w3.org/TR/html4/strict.dtd</a></p>
<h3 id="相关类关系图"><a href="#相关类关系图" class="headerlink" title="相关类关系图"></a>相关类关系图</h3><p><img src="/uploads/deeply-analyse-webkit/09.png" alt="09"></p>
<ul>
<li>Document 和 DocumentParser 相互引用</li>
<li>HTMLDocumentParser 父类是 ScriptableDocumentParser，DecodedDataDocumentParser（字符解码功能） 最后是 DocumentParser。</li>
<li>HTMLInputStream：解码后的字符流的保存，作为缓冲区。</li>
<li>HTMLTokenizer：对字符流进行解析，将解析后的信息比如 tag 名属性列表，注释，Doc 声明，结束 tag，文本都存在 HTMLToken 类中。</li>
<li>HTMLTreeBuilder：生成 DOM Tree，这里会做些语义上的检查，比如 head tag 里不能包含 body tag。</li>
<li>HTMLToken：HTMLTokenizer 生成，HTMLTreeBuilder 来使用</li>
<li>HTMLConstructionSite：创建各种 HTMLElement，再完成 DOM Tree，关键标签比如 body，head 和 html 以外都是通过 HTMLElementFactory 来实现。属性使用生成的 Element 里对应的函数来实现。</li>
<li>HTMLPreloadScanner：专门用来查找类似 src，link 这样的属性，获取外部资源，通过 CachedResourceLoader 这个类进行加载。</li>
</ul>
<h3 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h3><p><img src="/uploads/deeply-analyse-webkit/10.png" alt="10"></p>
<ul>
<li><p>DocumentWriter 调用 DocumentParser::appendBytes 将结果存入 HTMLInputStream 中。</p>
</li>
<li><p>HTMLDocumentParser::pumpTokenizer 函数里的 nextToken 会把字符流解析成 HTMLToken。</p>
</li>
<li><p>把 HTMLToken 对象交给 HTMLTreeBuild，通过 HTMLTreeBuild::processToken 来分析标签是否 OK，再用 HTMLConstructionSite 的 insertHTMLElement，insertHTMLHeadElement 来插入到 HTMLConstructionSite 里，原理是 stack of open elements 栈的方式构造，具体可以看这里：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements。HTMLConstructionSite</a> 通过 HTMLElementFactory 里的 createHTMLElement 来创建 HTMLElement 对象。Element 的 parserSetAttributes 函数用来解析属性。创建完一个 Element 会被加到当前 Node 里，通过 HTMLConstructionSite 的 attachLater 函数异步完成。</p>
</li>
<li><p>然后 HTMLToken 对象还会交给 HTMLPreloadScanner，它会先调用 scan 函数，生成一个 PreloadTask，调用 preload 函数或 CachedResourceLoader 的 preload 进行资源预加载。在 CachedResourceLoader 里的资源是以 url 作为 key，通过 url 来获取资源。具体实现可以看 HTMLPreloadScanner::processToken。</p>
</li>
</ul>
<h3 id="Element-属性设置"><a href="#Element-属性设置" class="headerlink" title="Element 属性设置"></a>Element 属性设置</h3><p>是通过 Element::parserSetAttributes 来设置的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Element::parserSetAttributes(<span class="keyword">const</span> Vector&lt;Attribute&gt;&amp; attributeVector)</div><div class="line">&#123;</div><div class="line">    ASSERT(!isConnected());</div><div class="line">    ASSERT(!parentNode());</div><div class="line">    ASSERT(!m_elementData);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!attributeVector.isEmpty()) &#123;</div><div class="line">        <span class="keyword">if</span> (document().sharedObjectPool())</div><div class="line">            m_elementData = document().sharedObjectPool()-&gt;cachedShareableElementDataWithAttributes(attributeVector);</div><div class="line">        <span class="keyword">else</span></div><div class="line">            m_elementData = ShareableElementData::createWithAttributes(attributeVector);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    parserDidSetAttributes();</div><div class="line"></div><div class="line">    <span class="comment">// Use attributeVector instead of m_elementData because attributeChanged might modify m_elementData.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; attribute : attributeVector)</div><div class="line">        attributeChanged(attribute.name(), nullAtom(), attribute.value(), ModifiedDirectly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>m_attributeData 存储属性的对象，attributeChange 函数会调用 parseAttribute 函数，作用是让 Element 能够处理 src 这样的属性加载图片</p>
<h3 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h3><p>HTMLPreloadScanner 调用 CachedResourceLoader 来加载的。</p>
<h2 id="构建-DOM-Tree"><a href="#构建-DOM-Tree" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h2><p>构建 DOM Tree 需要经过的四个阶段，分别是解码，分词，解析（创建与 Tag 相对应的 Node），创建树（有 DOM Tree，Render Tree，RenderLayer Tree）<br><img src="/uploads/deeply-analyse-webkit/84.png" alt="84"><br>相关类流程图：<br><img src="/uploads/deeply-analyse-webkit/87.png" alt="87"></p>
<p>前三个阶段前面已经介绍，下面主要介绍下创建 DOM 树</p>
<h3 id="DOM-标准规范"><a href="#DOM-标准规范" class="headerlink" title="DOM 标准规范"></a>DOM 标准规范</h3><p>Document Object Model 简称 DOM，全称文档对象模型，可以是 HTML，XML 和 XHTML，DOM 是以面向对象的方式来描述文档的，这样可以通过 JavaScript 或其它面向对象的语言进行访问，创建，删除和修改 DOM 结构。DOM 的接口与平台和语言无关。W3C 定义了一系列的 DOM 接口，目前已经有了四个 level 标准，每个标准都是基于上个标准基础上进行的迭代，如下图是 DOM 规范的演进过程：<br><img src="/uploads/deeply-analyse-webkit/52.png" alt="52"><br>下面对各个 level 进行说明<br>DOM level 1</p>
<ul>
<li>Core：底层接口，接口支持 XML 等任何结构化文档。</li>
<li>HTML：把 HTML 内容定义为 Document 文档，Node 节点，Attribute 属性，Element 元素，Text 文本。</li>
</ul>
<p>DOM level 2</p>
<ul>
<li>Core：对 level 1 的 Core 部分进行扩展，比如 getElementById，还有 namespace 的接口。</li>
<li>HTML：允许动态访问修改文档。</li>
<li>Views：文档的各种视图。</li>
<li>Events：鼠标事件等。</li>
<li>Style：可以修改 HTML 样式的一个属性。</li>
<li>Traveral and range：NodeIterator 和 TreeWalker 遍历树对文档修改，删除等操作。</li>
</ul>
<p>节点DOM level 3</p>
<ul>
<li>Core：加入了新接口 adoptNode 和 textContent。</li>
<li>Load and Save：加载 XML 转成 DOM 表示的文档结构。</li>
<li>Validation：验证文档有效性。</li>
<li>Events：加入键盘支持。</li>
<li>XPath：一种简单直观检索 DOM 节点的方式。</li>
</ul>
<p>DOM 结构构成的基本要素是节点，节点概念比较大，Document 也是一个节点，叫 Document 节点，HTML 里的 Tag 也是一种节点，叫 Element 节点，还有属性节点，Entity 节点，ProcessingIntruction 节点，CDataSection 节点，Comment 节点。下面看看 Document 节点提供的接口，这个接口的描述文件路径是在 WebCore/dom/Document.idl 文件里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div></pre></td><td class="code"><pre><div class="line">interface Document : Node &#123;</div><div class="line">    readonly attribute DOMImplementation implementation; // FIXME: Should be [SameObject].</div><div class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString URL;</div><div class="line">    [ImplementedAs=urlForBindings] readonly attribute USVString documentURI;</div><div class="line">    readonly attribute USVString origin;</div><div class="line">    readonly attribute DOMString compatMode;</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString characterSet;</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString charset; // Historical alias of .characterSet,</div><div class="line">    [ImplementedAs=characterSetWithUTF8Fallback] readonly attribute DOMString inputEncoding; // Historical alias of .characterSet.</div><div class="line">    readonly attribute DOMString contentType;</div><div class="line"></div><div class="line">    readonly attribute DocumentType? doctype;</div><div class="line">    [DOMJIT=Getter] readonly attribute Element? documentElement;</div><div class="line"></div><div class="line">    HTMLCollection getElementsByTagName(DOMString qualifiedName);</div><div class="line">    HTMLCollection getElementsByTagNameNS(DOMString? namespaceURI, DOMString localName);</div><div class="line">    HTMLCollection getElementsByClassName(DOMString classNames);</div><div class="line"></div><div class="line">    [NewObject, MayThrowException, ImplementedAs=createElementForBindings] Element createElement(DOMString localName); // FIXME: missing options parameter.</div><div class="line">    [NewObject, MayThrowException] Element createElementNS(DOMString? namespaceURI, DOMString qualifiedName); // FIXME: missing options parameter.</div><div class="line">    [NewObject] DocumentFragment createDocumentFragment();</div><div class="line">    [NewObject] Text createTextNode(DOMString data);</div><div class="line">    [NewObject, MayThrowException] CDATASection createCDATASection(DOMString data);</div><div class="line">    [NewObject] Comment createComment(DOMString data);</div><div class="line">    [NewObject, MayThrowException] ProcessingInstruction createProcessingInstruction(DOMString target, DOMString data);</div><div class="line"></div><div class="line">    [CEReactions, MayThrowException, NewObject] Node importNode(Node node, optional boolean deep = false);</div><div class="line">    [CEReactions, MayThrowException] Node adoptNode(Node node);</div><div class="line"></div><div class="line">    [NewObject, MayThrowException] Attr createAttribute(DOMString localName);</div><div class="line">    [NewObject, MayThrowException] Attr createAttributeNS(DOMString? namespaceURI, DOMString qualifiedName);</div><div class="line"></div><div class="line">    [MayThrowException, NewObject] Event createEvent(DOMString type);</div><div class="line"></div><div class="line">    [NewObject] Range createRange();</div><div class="line"></div><div class="line">    // NodeFilter.SHOW_ALL = 0xFFFFFFFF.</div><div class="line">    [NewObject] NodeIterator createNodeIterator(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</div><div class="line">    [NewObject] TreeWalker createTreeWalker(Node root, optional unsigned long whatToShow = 0xFFFFFFFF, optional NodeFilter? filter = null);</div><div class="line"></div><div class="line">    // Extensions from HTML specification (https://html.spec.whatwg.org/#the-document-object).</div><div class="line">    [PutForwards=href, Unforgeable] readonly attribute Location? location;</div><div class="line">    [SetterMayThrowException] attribute USVString domain;</div><div class="line">    readonly attribute USVString referrer;</div><div class="line">    [GetterMayThrowException, SetterMayThrowException] attribute USVString cookie;</div><div class="line">    readonly attribute DOMString lastModified;</div><div class="line">    readonly attribute DocumentReadyState readyState;</div><div class="line"></div><div class="line">    // DOM tree accessors.</div><div class="line">    [CEReactions] attribute DOMString title;</div><div class="line">    [CEReactions] attribute DOMString dir;</div><div class="line">    [CEReactions, DOMJIT=Getter, ImplementedAs=bodyOrFrameset, SetterMayThrowException] attribute HTMLElement? body;</div><div class="line">    readonly attribute HTMLHeadElement? head;</div><div class="line">    readonly attribute HTMLCollection images; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection embeds; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection plugins; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection links; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection forms; // Should be [SameObject].</div><div class="line">    readonly attribute HTMLCollection scripts; // Should be [SameObject].</div><div class="line">    NodeList getElementsByName([AtomicString] DOMString elementName);</div><div class="line">    readonly attribute HTMLScriptElement? currentScript; // FIXME: Should return a HTMLOrSVGScriptElement.</div><div class="line"></div><div class="line">    // dynamic markup insertion</div><div class="line">    // FIXME: The HTML spec says this should consult the &quot;responsible document&quot;. We should ensure</div><div class="line">    // that the caller document matches those semantics. It is possible we should replace it with</div><div class="line">    // the existing &apos;incumbent document&apos; concept.</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, ImplementedAs=openForBindings, MayThrowException] Document open(optional DOMString type = &quot;text/html&quot;, optional DOMString replace = &quot;&quot;);</div><div class="line">    [CallWith=ActiveWindow&amp;FirstWindow, ImplementedAs=openForBindings, MayThrowException] DOMWindow open(USVString url, DOMString name, DOMString features);</div><div class="line">    [CEReactions, ImplementedAs=closeForBindings, MayThrowException] void close();</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void write(DOMString... text);</div><div class="line">    [CEReactions, CallWith=ResponsibleDocument, MayThrowException] void writeln(DOMString... text);</div><div class="line"></div><div class="line">    // User interaction.</div><div class="line">    readonly attribute DOMWindow? defaultView;</div><div class="line">    boolean hasFocus();</div><div class="line">    [CEReactions] attribute DOMString designMode;</div><div class="line">    [CEReactions] boolean execCommand(DOMString commandId, optional boolean showUI = false, optional DOMString? value = null); // FIXME: value should not be nullable.</div><div class="line">    boolean queryCommandEnabled(DOMString commandId);</div><div class="line">    boolean queryCommandIndeterm(DOMString commandId);</div><div class="line">    boolean queryCommandState(DOMString commandId);</div><div class="line">    boolean queryCommandSupported(DOMString commandId);</div><div class="line">    DOMString queryCommandValue(DOMString commandId);</div><div class="line"></div><div class="line">    // Special event handler IDL attributes that only apply to Document objects.</div><div class="line">    [LenientThis] attribute EventHandler onreadystatechange;</div><div class="line"></div><div class="line">    // Extensions from the CSSOM specification (https://drafts.csswg.org/cssom/#extensions-to-the-document-interface).</div><div class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</div><div class="line">    readonly attribute StyleSheetList styleSheets; // FIXME: Should be [SameObject].</div><div class="line"></div><div class="line">    // Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-document-interface).</div><div class="line">    readonly attribute Element? scrollingElement;</div><div class="line"></div><div class="line">    // Extensions from Selection API (https://www.w3.org/TR/selection-api/#extensions-to-document-interface).</div><div class="line">    // FIXME: Should likely be moved to DocumentOrShadowRoot.</div><div class="line">    DOMSelection? getSelection();</div><div class="line"></div><div class="line">    // XPath extensions (https://www.w3.org/TR/DOM-Level-3-XPath/xpath.html#XPathEvaluator).</div><div class="line">    [MayThrowException] XPathExpression createExpression(optional DOMString expression = &quot;undefined&quot;, optional XPathNSResolver? resolver); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</div><div class="line">    XPathNSResolver createNSResolver(Node? nodeResolver);</div><div class="line">    [MayThrowException] XPathResult evaluate(optional DOMString expression = &quot;undefined&quot;, optional Node? contextNode, optional XPathNSResolver? resolver, optional unsigned short type = 0, optional XPathResult? inResult); // FIXME: Using &quot;undefined&quot; as default parameter value is wrong.</div><div class="line"></div><div class="line">    // Extensions from FullScreen API (https://fullscreen.spec.whatwg.org/#api).</div><div class="line">    // FIXME: Should probably be unprefixed.</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullscreenEnabled;</div><div class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitFullscreenElementForBindings] readonly attribute Element? webkitFullscreenElement;</div><div class="line">    [Conditional=FULLSCREEN_API] void webkitExitFullscreen();</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitIsFullScreen; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API] readonly attribute boolean webkitFullScreenKeyboardInputAllowed; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API, ImplementedAs=webkitCurrentFullScreenElementForBindings] readonly attribute Element webkitCurrentFullScreenElement; // Mozilla version.</div><div class="line">    [Conditional=FULLSCREEN_API] void webkitCancelFullScreen(); // Mozilla version.</div><div class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenchange;</div><div class="line">    [NotEnumerable, Conditional=FULLSCREEN_API] attribute EventHandler onwebkitfullscreenerror;</div><div class="line"></div><div class="line">    // Extensions from Pointer Lock API (https://www.w3.org/TR/pointerlock/#extensions-to-the-document-interface).</div><div class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockchange; // FIXME: Should be enumerable.</div><div class="line">    [NotEnumerable, Conditional=POINTER_LOCK] attribute EventHandler onpointerlockerror; // FIXME: Should be enumerable.</div><div class="line">    [Conditional=POINTER_LOCK] void exitPointerLock();</div><div class="line"></div><div class="line">    // Extensions from CSS Font Loading API (https://drafts.csswg.org/css-font-loading/#font-face-source).</div><div class="line">    // FIXME: Should be in a separate FontFaceSource interface.</div><div class="line">    readonly attribute FontFaceSet fonts;</div><div class="line"></div><div class="line">    // Extensions from Page visibility API (https://www.w3.org/TR/page-visibility/#sec-document-interface).</div><div class="line">    readonly attribute boolean hidden;</div><div class="line">    readonly attribute VisibilityState visibilityState;</div><div class="line">    attribute EventHandler onvisibilitychange;</div><div class="line"></div><div class="line">    // FIXME: Those were dropped from the CSSOM specification.</div><div class="line">    readonly attribute DOMString? preferredStylesheetSet;</div><div class="line">    attribute DOMString? selectedStylesheetSet;</div><div class="line"></div><div class="line">    // FIXME: Those have been dropped from the DOM specification.</div><div class="line">    readonly attribute DOMString? xmlEncoding;</div><div class="line">    [SetterMayThrowException] attribute DOMString? xmlVersion;</div><div class="line">    attribute boolean xmlStandalone;</div><div class="line"></div><div class="line">    // FIXME: Blink has already dropped this (https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/s3ezjTuC8ig).</div><div class="line">    CSSStyleDeclaration getOverrideStyle(optional Element? element = null, optional DOMString pseudoElement = &quot;undefined&quot;);</div><div class="line"></div><div class="line">    // FIXME: Should be moved to GlobalEventHandlers (http://w3c.github.io/selection-api/#extensions-to-globaleventhandlers).</div><div class="line">    [NotEnumerable] attribute EventHandler onselectstart; // FIXME: Should be enumerable.</div><div class="line">    [NotEnumerable] attribute EventHandler onselectionchange; // FIXME: Should be enumerable.</div><div class="line"></div><div class="line">    // Non standard: It has been superseeded by caretPositionFromPoint which we do not implement yet.</div><div class="line">    Range caretRangeFromPoint(optional long x = 0, optional long y = 0);</div><div class="line"></div><div class="line">    // FIXME: This is not standard and has been dropped from Blink already.</div><div class="line">    RenderingContext? getCSSCanvasContext(DOMString contextId, DOMString name, long width, long height);</div><div class="line"></div><div class="line">    // Non standard (https://developer.apple.com/reference/webkitjs/document/1633863-webkitgetnamedflows).</div><div class="line">    [Conditional=CSS_REGIONS] DOMNamedFlowCollection webkitGetNamedFlows();</div><div class="line"></div><div class="line"></div><div class="line">    // Obsolete features from https://html.spec.whatwg.org/multipage/obsolete.html</div><div class="line"></div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString fgColor;</div><div class="line">    [CEReactions, ImplementedAs=linkColorForBindings] attribute [TreatNullAs=EmptyString] DOMString linkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString vlinkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString alinkColor;</div><div class="line">    [CEReactions] attribute [TreatNullAs=EmptyString] DOMString bgColor;</div><div class="line"></div><div class="line">    readonly attribute HTMLCollection anchors; /* [SameObject] */</div><div class="line">    readonly attribute HTMLCollection applets; /* [SameObject] */</div><div class="line"></div><div class="line">    void clear();</div><div class="line">    void captureEvents();</div><div class="line">    void releaseEvents();</div><div class="line"></div><div class="line">    [Replaceable] readonly attribute HTMLAllCollection all; /* [SameObject] */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="DOM-Tree-Token-的构造算法"><a href="#DOM-Tree-Token-的构造算法" class="headerlink" title="DOM Tree Token 的构造算法"></a>DOM Tree Token 的构造算法</h3><p>这个算法被描述为一个 state machine，state 为插入模式（insertion modes）。完整算法可以参看 w3c 的定义：<a href="https://www.w3.org/TR/html5/syntax.html#html-parser" target="_blank" rel="external">https://www.w3.org/TR/html5/syntax.html#html-parser</a></p>
<p><img src="/uploads/deeply-analyse-webkit/19.png" alt="19"><br>当 parser 创建后也会创建一个 Document 对象。在 tree construction 的阶段，Document 会做为 root 的 element 添加进来。tree constructor 会处理每个 tokenizer 生成的 node。每个 token 会对应一个 DOM element。每个 element 不光会被添加到 DOM tree，还会添加到 stack of open elements里。这个 stack 用于检查嵌套错误和未关闭的 tag。</p>
<p>具体过程是，在 tree construction 阶段的输入是来自 tokenization 的 tokens 排序的阶段。最开始的状态是 initial mode。接收 html token 会变成 before html mode，并且在那个模式里重新处理 token。这会创建一个 HTMLHtmlElement 元素添加到 Document 对象的 root 上。</p>
<p>接下来状态会变成 before head。然后创建 HTMLHeadElement，如果 head 里有 token 就会被添加到这个 tree 里。状态会有 in head 和 after head。</p>
<p>再后面会创建 HTMLBodyElement，添加到树中，状态转成 in body，里面的 html token 会被转成对应的 DOM element 被添加到 body 的 node 中。当收到 body end token 会让状态切换成 after body。接着就是收到 html end tag，转成 after after body 状态，接到 end of file token 会结束 parsing。</p>
<h3 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h3><p>构建 DOM 的几个关键的类<br><img src="/uploads/deeply-analyse-webkit/53.png" alt="53"></p>
<p><img src="/uploads/deeply-analyse-webkit/11.png" alt="11"></p>
<ul>
<li>HTMLDocumentParser：管理类，解析 html 文本使用词法分析器成 HTMLTokenizer 类，最后输出到 HTMLTreeBuilder。</li>
<li>HTMLTreeBuilder：负责 DOM 树的建立，对 tokens 分类处理，创建一个个节点对象，使用 HTMLConstructionSite 类将这些创建好的节点构建为 DOM 树。</li>
<li>HTMLConstructionSite：不同的标签类型在不同位置会有不同的函数来构建 DOM 树。m_document 代表根节点，即 javascript 里的 window.document 对象。</li>
<li>HTMLElementFactory：一个工厂类对不同类型的标签创建不同的 html 元素，同时建立父子兄弟关系。</li>
</ul>
<p>构建 DOM 树的过程如下图：<br><img src="/uploads/deeply-analyse-webkit/54.png" alt="54"></p>
<p>举个例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">			Hello World</div><div class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"example.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>转成 DOM Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/69.png" alt="69"></p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>通过 DocumentLoader 这个类里的 startLoadingMainResource 加载 url<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">FetchRequest <span class="title">fetchRequest</span><span class="params">(m_request, FetchInitiatorTypeNames::document,</span></span></div><div class="line">                            mainResourceLoadOptions);</div><div class="line">  m_mainResource =</div><div class="line">      RawResource::fetchMainResource(fetchRequest, fetcher(), m_substituteData);</div></pre></td></tr></table></figure></p>
<p>DocumentLoader 的 commitData 会去处理 dataReceived 的数据块<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DocumentLoader::commitData(<span class="keyword">const</span> <span class="keyword">char</span>* bytes, <span class="keyword">size_t</span> length) &#123;</div><div class="line">  ensureWriter(m_response.mimeType()); <span class="comment">//会初始化 HTMLDocumentParser 实例化 document 对象</span></div><div class="line">  <span class="keyword">if</span> (length)</div><div class="line">    m_dataReceived = <span class="literal">true</span>;</div><div class="line">  m_writer-&gt;addData(bytes, length); <span class="comment">//给 Parser 解析，这里的bytes就是返回来的 html 文本代码</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//ensureWriter 里有个判断，如果 m_writer 已经初始化就不处理，所以 parser 只会初始化一次</span></div><div class="line"><span class="keyword">void</span> DocumentLoader::ensureWriter(<span class="keyword">const</span> AtomicString&amp; mimeType, <span class="keyword">const</span> KURL&amp; overridingURL) &#123;</div><div class="line">  <span class="keyword">if</span> (m_writer)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="DOM-Tree"><a href="#DOM-Tree" class="headerlink" title="DOM Tree"></a>DOM Tree</h3><p>DOM Tree 已经被 W3 标准化了 <a href="https://www.w3.org/DOM/DOMTR" target="_blank" rel="external">Document Object Model (DOM) Technical Reports</a> 在 DOM Level 3 里 IDL 的定义在 <a href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank" rel="external">IDL Definitions</a></p>
<h4 id="Node-节点"><a href="#Node-节点" class="headerlink" title="Node 节点"></a>Node 节点</h4><p>Node 是 DOM 模型的基础类，根据标签的不同可以分成多个类，详细的定义可以看 NodeType，最主要的是 Document，Element 和 Text 三类。下图列出了 Node 节点相关继承关系图：<br><img src="/uploads/deeply-analyse-webkit/56.png" alt="56"></p>
<p>在构建树时是由 Insertion Mode 来控制，这个规则是完全按照 w3c 指定，可以参看：<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode" target="_blank" rel="external">http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#the-insertion-mode</a> 。构建树级别时是根据堆栈来的，碰到 StartTag 的 token 就会在 m_opnElements 里压栈，碰到 EndTag 的 token 就会出栈。 w3c 对于 Element 的堆栈也有规范：<a href="https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#the-stack-of-open-elements</a> 。通过 ContainerNode::parserAddChild 接口添加 Node 到 DOM Tree 中。</p>
<p>需要注意的是有些标签属于 Format 标签不参与嵌套关系属于平级，是不会被加入到 m_openElements 里。这些标签的定义可以参看：<a href="https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements" target="_blank" rel="external">https://html.spec.whatwg.org/multipage/parsing.html#list-of-active-formatting-elements</a></p>
<p><img src="/uploads/deeply-analyse-webkit/37.png" alt="37"></p>
<p>DOM Node 的数据结构<br><img src="/uploads/deeply-analyse-webkit/12.png" alt="12"></p>
<h4 id="HTMLElement"><a href="#HTMLElement" class="headerlink" title="HTMLElement"></a>HTMLElement</h4><p>由 HTMLElementFactory 类的 createHTMLElement 来创建，然后通过 Hash map 来记录，key 为 tag name，value 为对应的 element。不同 tag 有不同的 HTMLElement 派生类，类继承图如下：<br><img src="/uploads/deeply-analyse-webkit/75.png" alt="75"></p>
<h4 id="构建-DOM-Tree-1"><a href="#构建-DOM-Tree-1" class="headerlink" title="构建 DOM Tree"></a>构建 DOM Tree</h4><p>从 Token 的构建节点。是 HTMLDocumentParser 类调用了 HTMLTreeBuilder 类的 processToken 函数来处理的，该函数在 WebCore/html/parser/HTMLTreeBuilder.cpp 文件里。<br>constructtreefromToken<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLTreeBuilder::processToken(AtomicHTMLToken&amp;&amp; token)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">switch</span> (token.type()) &#123;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Uninitialized:</div><div class="line">        ASSERT_NOT_REACHED();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::DOCTYPE:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processDoctypeToken(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::StartTag:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processStartTag(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::EndTag:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processEndTag(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Comment:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processComment(WTFMove(token));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::Character:</div><div class="line">        processCharacter(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> HTMLToken::EndOfFile:</div><div class="line">        m_shouldSkipLeadingNewline = <span class="literal">false</span>;</div><div class="line">        processEndOfFile(WTFMove(token));</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将节点构建成 DOM Tree，还有给 Tree 的元素节点创建属性节点都是 HTMLConstructionSite 这个类来做的，它会通过 insert 类函数一次将 Token 类型创建的 HTMLElement 对象加入到 DOM Tree。这个类会会先创建一个 html 根节点 HTMLDocument 对象和一个栈 HTMLElementStack 变量，栈里存放没有遇到 EndTag 的 所有 StartTag。根据这个栈来建立父子关系。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> HTMLConstructionSite::insertHTMLHtmlStartTagBeforeHTML(AtomicHTMLToken* token) &#123;</div><div class="line">  HTMLHtmlElement* element = HTMLHtmlElement::create(*m_document);</div><div class="line">  attachLater(m_attachmentRoot, element);</div><div class="line">  m_openElements.pushHTMLHtmlElement(HTMLStackItem::create(element, token)); <span class="comment">//push 到 HTMLStackItem 栈里</span></div><div class="line">  executeQueuedTasks();</div><div class="line">&#125;</div><div class="line"><span class="comment">//通过 attachLater 创建 task</span></div><div class="line"><span class="keyword">void</span> HTMLConstructionSite::attachLater(ContainerNode* parent,</div><div class="line">                                       Node* child,</div><div class="line">                                       <span class="keyword">bool</span> selfClosing) &#123;</div><div class="line">  <span class="function">HTMLConstructionSiteTask <span class="title">task</span><span class="params">(HTMLConstructionSiteTask::Insert)</span></span>;</div><div class="line">  task.parent = parent;</div><div class="line">  task.child = child;</div><div class="line">  task.selfClosing = selfClosing;</div><div class="line">  <span class="comment">//判断是否到达最深，512是最深</span></div><div class="line">  <span class="keyword">if</span> (m_openElements.stackDepth() &gt; maximumHTMLParserDOMTreeDepth &amp;&amp;</div><div class="line">      task.parent-&gt;parentNode())</div><div class="line">    task.parent = task.parent-&gt;parentNode();</div><div class="line">  queueTask(task);</div><div class="line">&#125;</div><div class="line"><span class="comment">//executeQueued 添加子节点</span></div><div class="line"><span class="keyword">void</span> ContainerNode::parserAppendChild(Node* newChild) &#123;</div><div class="line">  <span class="keyword">if</span> (!checkParserAcceptChild(*newChild))</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">    AdoptAndAppendChild()(*<span class="keyword">this</span>, *newChild, <span class="literal">nullptr</span>);</div><div class="line">  &#125;</div><div class="line">  notifyNodeInserted(*newChild, ChildrenChangeSourceParser);</div><div class="line">&#125;</div><div class="line"><span class="comment">//添加前会先检查是否支持子元素</span></div><div class="line"><span class="keyword">void</span> ContainerNode::appendChildCommon(Node&amp; child) &#123;</div><div class="line">  child.setParentOrShadowHostNode(<span class="keyword">this</span>);</div><div class="line">  <span class="keyword">if</span> (m_lastChild) &#123;</div><div class="line">    child.setPreviousSibling(m_lastChild);</div><div class="line">    m_lastChild-&gt;setNextSibling(&amp;child);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    setFirstChild(&amp;child);</div><div class="line">  &#125;</div><div class="line">  setLastChild(&amp;child);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>闭标签会把元素 pop 出来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m_tree.openElements()-&gt;popUntilPopped(token-&gt;name());</div></pre></td></tr></table></figure></p>
<h3 id="对错误的处理"><a href="#对错误的处理" class="headerlink" title="对错误的处理"></a>对错误的处理</h3><p>parser 一个 html 代码的时候如果是符合规范的那么就都好说，不幸的是很多 html 代码都不规范，所以 parser 需要做些容错。下面列出一些 WebKit 容错的例子</p>
<h4 id="问题"><a href="#问题" class="headerlink" title=" 问题"></a><br> 问题</h4><p>一些网站会用 <br> 替代 <br>，处理的代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) &#123;</div><div class="line">     reportError(MalformedBRError);</div><div class="line">     t-&gt;beginTag = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="stray-table"><a href="#stray-table" class="headerlink" title="stray table"></a>stray table</h4><p>stray table 是一个 table 包含了一个不在 table cell 的 table。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">         <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>WebKit 的处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (m_inStrayTableContent &amp;&amp; localName == tableTag)</div><div class="line">        popBlock(tableTag);</div></pre></td></tr></table></figure></p>
<p>这样会处理成两个同级 table<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>outer table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>inner table<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h4 id="嵌套-form"><a href="#嵌套-form" class="headerlink" title="嵌套 form"></a>嵌套 form</h4><p>将一个 form 放到另一个 form 里。那么第二个 form 会被忽略<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!m_currentFormElement) &#123;</div><div class="line">        m_currentFormElement = <span class="keyword">new</span> HTMLFormElement(formTag,    m_document);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="过深的层级"><a href="#过深的层级" class="headerlink" title="过深的层级"></a>过深的层级</h4><p>同一个类型里只允许嵌套 20 个 tag。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> HTMLParser::allowNestedRedundantTag(<span class="keyword">const</span> AtomicString&amp; tagName)</div><div class="line">&#123;</div><div class="line"><span class="keyword">unsigned</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (HTMLStackElem* curr = m_blockStack;</div><div class="line">         i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName;</div><div class="line">     curr = curr-&gt;next, i++) &#123; &#125;</div><div class="line"><span class="keyword">return</span> i != cMaxRedundantTagDepth;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="html-或-body-的-end-tags-缺失"><a href="#html-或-body-的-end-tags-缺失" class="headerlink" title="html 或 body 的 end tags 缺失"></a>html 或 body 的 end tags 缺失</h4><p>这些都会在 end() 是调用<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag )</div><div class="line">        <span class="keyword">return</span>;</div></pre></td></tr></table></figure></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-语法简介"><a href="#CSS-语法简介" class="headerlink" title="CSS 语法简介"></a>CSS 语法简介</h3><p>所有的 CSS 都是由 CSSStyleSheet 集合组成，CSSStyleSheet 是有多个 CSSRule 组成，每个 CSSRule 由 CSSStyleSelector 选择器和 CSSStyleDeclaration 声明组成。CSSStyleDeclaration 是 CSS 属性的键值集合。</p>
<h4 id="CSS-declarations"><a href="#CSS-declarations" class="headerlink" title="CSS declarations"></a>CSS declarations</h4><p><img src="/uploads/deeply-analyse-webkit/40.png" alt="40"><br>在这里可以找到 CSS  的不同的属性。</p>
<h4 id="CSS-declaration-blocks"><a href="#CSS-declaration-blocks" class="headerlink" title="CSS declaration blocks"></a>CSS declaration blocks</h4><p>使用大括号包起来。<br><img src="/uploads/deeply-analyse-webkit/41.png" alt="41"></p>
<h4 id="CSS-selectors-and-rules"><a href="#CSS-selectors-and-rules" class="headerlink" title="CSS selectors and rules"></a>CSS selectors and rules</h4><p>在 CSS declarations block 前加上 selector 来匹配页面上的元素。selector 和 declarations block 在一起被称作 ruleset，简称 rule。<br><img src="/uploads/deeply-analyse-webkit/42.png" alt="42"></p>
<p>selector 可以分为以下类别</p>
<ul>
<li>Simple selectors：简单选择器，通过 class 或 id 类匹配一个或多个元素。</li>
<li>Attribute selectors：属性选择器，通过属性匹配。</li>
<li>Pseudo-classes：伪类，匹配确定状态的比如鼠标悬停元素，当前选中或未选中的复选框， DOM 树中一父节点的第一个子节点的元素。比如 a:visited 表示访问过的链接， a:hover 表示鼠标在上面的链接。</li>
<li>Pseudo-elements：伪元素，匹配处于确定位置的一个或多个元素，比如每个段落的第一个字，某个元素之前生成的内容。比如 [href^=http]::after { content: ‘-&gt;’} 表示属性是 herf 值的开头是 http 的元素内容后面添加 -&gt; 符号。</li>
<li>Combinators：组合器，组合多个选择器用于特定的选择的方法。比如只选择 div 的直系子节点段落。比如 A &gt; B 那么 B 是 A 的直接子节点。</li>
<li>Multiple selectors：多用选择器，将一组声明应用于由多个选择器选择的所有元素。</li>
</ul>
<p>Attribute selectors 属性选择器是针对 data-* 这样的数据属性进行选择的，尝试匹配精确属性值的 Presence and value attribute selector 分为下面几种</p>
<ul>
<li>[attr]：不论值是什么选择所有 attr 属性的元素。</li>
<li>[attr=val]：按照 attr 属性的值为 val 的所有元素。</li>
<li>[attr~=val]：attr 属性的值包含 val 值的所有元素，val 以空格间隔多个值。</li>
</ul>
<p>还有 Substring value attribute selector 这样的伪正则选择器：</p>
<ul>
<li>[attr|=val]：匹配选择以 val 或 val- 开头的元素，-一般用来处理语言编码。</li>
<li>[attr^=val]：匹配选择以 val 开头的元素。</li>
<li>[attr$=val]：匹配选择以 val 结尾的元素。</li>
<li>[attr*=val]：匹配选择包含 val 的元素。</li>
</ul>
<p>Combinators 组合器有以下几种</p>
<ul>
<li>A,B： 匹配 A B 的任意元素。</li>
<li>A B：B 是 A 的后代节点，可以是直接的子节点或者是子节点的子节点。</li>
<li>A &gt; B：B 是 A 的直接子节点。</li>
<li>A + B：B 是 A 的兄弟节点。</li>
<li>A ~ B：B 是 A 兄弟节点中的任意一个。</li>
</ul>
<h4 id="CSS-statements"><a href="#CSS-statements" class="headerlink" title="CSS statements"></a>CSS statements</h4><p>CSS rule 只是 CSS statements 的一种。<br>其它类型是 @-规则，在 CSS 里使用 @-规则来传递元数据，条件信息或其它描述信息。@ 符号后面跟一个描述符来表明用哪种规则，再后面是 CSS declarations block，结束是 ; 符号。</p>
<ul>
<li>@charset：元数据</li>
<li>@import：元数据</li>
<li>@media：嵌套语句，只在运行浏览器的设备匹配条件时才会运用 @-规则里的内容。</li>
<li>@supports：嵌套语句，只有浏览器确实支持采用应用 @-规则里的内容。</li>
<li>@document：嵌套语句，只有当前页面匹配条件采用运用 @-规则的内容。</li>
<li>@font-face：描述性信息</li>
</ul>
<p>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">import</span> <span class="string">'starming.css'</span>;</div></pre></td></tr></table></figure></p>
<p>表示向当前的 CSS 导入了 starming.css 文件。再举个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">media</span> (min-width: <span class="number">801px</span>) &#123;</div><div class="line">    <span class="selector-tag">body</span> &#123;</div><div class="line">        <span class="attribute">margin</span>:<span class="number">0</span> auto;</div><div class="line">        <span class="attribute">width</span>:<span class="number">800px</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个表示页面宽度超过801像素时才会运用 @-规则里的内容。</p>
<h4 id="Shorthand"><a href="#Shorthand" class="headerlink" title="Shorthand"></a>Shorthand</h4><p>有些属性是 Shorthand 属性，比如 font，background，padding，border和 margin。他们允许一行里设置多个属性。<br>比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">maring</span>: 20<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 10<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p>
<p>等效于<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">margin-top</span>: 20<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-right</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-bottom</span>: 10<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">margin-left</span>: 20<span class="selector-tag">px</span>;</div></pre></td></tr></table></figure></p>
<p>再比如 background 属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span>: <span class="selector-tag">black</span> <span class="selector-tag">url</span>(<span class="selector-tag">starming-bg</span><span class="selector-class">.png</span>) 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> <span class="selector-tag">repeat-x</span> <span class="selector-tag">fixed</span>;</div></pre></td></tr></table></figure></p>
<p>和下面的属性设置等效<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">black</span>;</div><div class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>(<span class="selector-tag">starming-bg</span><span class="selector-class">.png</span>);</div><div class="line"><span class="selector-tag">background-position</span>: 20<span class="selector-tag">px</span> 20<span class="selector-tag">px</span>;</div><div class="line"><span class="selector-tag">background-repeat</span>: <span class="selector-tag">repeat-x</span>;</div><div class="line"><span class="selector-tag">background-scroll</span>: <span class="selector-tag">fixed</span>;</div></pre></td></tr></table></figure></p>
<h4 id="Value-and-unit"><a href="#Value-and-unit" class="headerlink" title="Value and unit"></a>Value and unit</h4><ul>
<li>absolute units 绝对单位：px，mm，cm，in：pixel 像素，millimeters 毫米，centimeters 厘米，inches 英寸。pt，pc：Points (1/72 of an inch) 点，picas (12 points.) 十二点活字。</li>
<li>相对单位：em：1em 的计算值默认为 16px。但是要注意 em 单位会继承父元素的字体大小。ex，ch：支持的不是很好。rem：REM(root em)，跟 em 工作方式一样，不同的是总是等于默认基础字体大小。vw，vh：视图宽度的 1/100 和视图高度的 1/100，但是支持没有 rem 那么好。</li>
<li>无单位的值：在某些情况下无单位的值是可以存在的，比如设置 margin: 0; 就是可以的，还有 p { line-height: 1.5 } 这里的值类似一个简单的乘法因子，比如 font-size 为16px的话，行高就为24px。</li>
<li>百分比：相对于父容器所占的百分比，注意如果 font-size 使用百分比是指新的大小相对于父容器的字体大小，和 em 类似，所以 200% 和 2em 类似。</li>
<li>颜色：有165个不同关键字可用，具体见 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Color_keywords</a> ，还可以使用类似 background-color: #0000ff; 这样的十六进制表示颜色，还有 RGB 表示 background-color: rgb(0,0,255); 。还支持background-color: hsl(240,100%,50%); 这种 HSL 的表示，值依次是色调，值范围是0到360，饱和度0表示没有颜色，明度里0表示全黑，100%表示全白。HSL 是采用圆柱体可视化颜色的工作方式，Wikipedia 上有详细说明：<a href="https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle" target="_blank" rel="external">https://en.wikipedia.org/wiki/HSL_and_HSV#Basic_principle</a></li>
<li>透明度：可以通过 rgba 和 hsla 来表示，比如 background-color: hsla(240,100%,50%,0.5); 。还可以通过 CSS 属性 opacity 来指定透明度。</li>
<li>函数：只要是一个名字后面用括号包含一个或多个值之间用逗号分隔就是一个函数，比如 background-color: rgba(255,0,0,0.5); transform: translate(50px, 60px); background-image: url(‘myimage.png’);</li>
</ul>
<h4 id="验证-CSS-语法正确性"><a href="#验证-CSS-语法正确性" class="headerlink" title="验证 CSS 语法正确性"></a>验证 CSS 语法正确性</h4><p>可以通过 w3c 提供的服务 <a href="http://jigsaw.w3.org/css-validator/" target="_blank" rel="external">http://jigsaw.w3.org/css-validator/</a> 来验证，w3c 还提供了 html 的验证服务 <a href="https://validator.w3.org/#validate_by_uri" target="_blank" rel="external">https://validator.w3.org/#validate_by_uri</a></p>
<h3 id="CSS-BNF"><a href="#CSS-BNF" class="headerlink" title="CSS BNF"></a>CSS BNF</h3><p>CSS 语法 BNF<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">ruleset</div><div class="line">  : selector [ &apos;,&apos; S* selector ]*</div><div class="line">    &apos;&#123;&apos; S* declaration [ &apos;;&apos; S* declaration ]* &apos;&#125;&apos; S*</div><div class="line">  ;</div><div class="line">selector</div><div class="line">  : simple_selector [ combinator selector | S+ [ combinator selector ] ]</div><div class="line">  ;</div><div class="line">simple_selector</div><div class="line">  : element_name [ HASH | class | attrib | pseudo ]*</div><div class="line">  | [ HASH | class | attrib | pseudo ]+</div><div class="line">  ;</div><div class="line">class</div><div class="line">  : &apos;.&apos; IDENT</div><div class="line">  ;</div><div class="line">element_name</div><div class="line">  : IDENT | &apos;*&apos;</div><div class="line">  ;</div><div class="line">attrib</div><div class="line">  : &apos;[&apos; S* IDENT S* [ [ &apos;=&apos; | INCLUDES | DASHMATCH ] S*</div><div class="line">    [ IDENT | STRING ] S* ] &apos;]&apos;</div><div class="line">  ;</div><div class="line">pseudo</div><div class="line">  : &apos;:&apos; [ IDENT | FUNCTION S* [IDENT S*] &apos;)&apos; ]</div><div class="line">  ;</div></pre></td></tr></table></figure></p>
<p>WebKit 会使用 Flex 和 Bison 来解析这个 BNF 文件。CSS 文件会被解析成 StyleSheet object，每个 object 包含 CSS rules object，这些 object 包含 selector 和 declaration 还要其它对应于 CSS 语法的 object。接下来进行会进行 CSSRule 的匹配过程，去找能够和 CSSRule Selector 部分匹配的 HTML 元素。<br><img src="/uploads/deeply-analyse-webkit/68.png" alt="68"></p>
<h3 id="CSS-主要类与关系"><a href="#CSS-主要类与关系" class="headerlink" title="CSS 主要类与关系"></a>CSS 主要类与关系</h3><p><img src="/uploads/deeply-analyse-webkit/57.png" alt="57"><br>上图看出 Document 里包含了一个 DocumentStyleSheetCollection 类和一个 StyleSheetResolver 类，DocumentStyleSheetCollection 包含了所有的 StyleSheet，StyleSheet 里包含了 CSS 的 href，类型，内容等信息，这些内容就是 StyleSheetContents，包含了 StyleRuleBase。</p>
<p>StyleSheetResolver 负责组织用来为 DOM 里的元素匹配的规则，里面包含了一个 DocumentRuleSets 的类，这个类是用来表示多个 RuleSet 的。</p>
<p>CSS 文档结构的类图如下：<br><img src="/uploads/deeply-analyse-webkit/90.png" alt="90"></p>
<h4 id="StyleRuleBase-类的继承关系"><a href="#StyleRuleBase-类的继承关系" class="headerlink" title="StyleRuleBase 类的继承关系"></a>StyleRuleBase 类的继承关系</h4><p>RuleSet 有很多类型，下图是 StyleRuleBase 相关继承关系<br><img src="/uploads/deeply-analyse-webkit/58.png" alt="58"><br>我们来看看这些子类类型都是对应 CSS 里的什么</p>
<ul>
<li>StyleRule：常用的都是这个类型</li>
<li>StyleRuleImport：对应的是 @import</li>
<li>StyleRuleMedia：对应的是 @media</li>
<li>StyleRuleFontFace：对应的 @font-face</li>
<li>StyleRulePage：对应的 @page</li>
<li>StyleRuleKeyFrames：对应的 @-webkit-key-frames</li>
<li>StyleRuleRegion：分区域排版</li>
</ul>
<h4 id="StyleRule-类的结构"><a href="#StyleRule-类的结构" class="headerlink" title="StyleRule 类的结构"></a>StyleRule 类的结构</h4><p><img src="/uploads/deeply-analyse-webkit/59.png" alt="59"></p>
<h3 id="解析-CSS"><a href="#解析-CSS" class="headerlink" title="解析 CSS"></a>解析 CSS</h3><p>WebKit 解析的入口函数是 CSSParser::parseSheet。解析过程如下图：<br><img src="/uploads/deeply-analyse-webkit/91.png" alt="91"></p>
<p>字符串转 tokens<br><img src="/uploads/deeply-analyse-webkit/13.png" alt="13"></p>
<p>将 tokens 转成 styleRule。每个 styleRule 包含 selectors 和 properties。<br>定义 matchType<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> MatchType &#123;</div><div class="line">    Unknown,</div><div class="line">    Tag,               <span class="comment">//比如 div</span></div><div class="line">    Id,                <span class="comment">// #id</span></div><div class="line">    Class,             <span class="comment">// .class</span></div><div class="line">    PseudoClass,       <span class="comment">// :nth-child(2)</span></div><div class="line">    PseudoElement,     <span class="comment">// ::first-line</span></div><div class="line">    PagePseudoClass,   <span class="comment">//</span></div><div class="line">    AttributeExact,    <span class="comment">// E[attr="value"]</span></div><div class="line">    AttributeSet,      <span class="comment">// E[attr]</span></div><div class="line">    AttributeHyphen,   <span class="comment">// E[attr|="value"]</span></div><div class="line">    AttributeList,     <span class="comment">// E[attr~="value"]</span></div><div class="line">    AttributeContain,  <span class="comment">// E[attr*="value"]</span></div><div class="line">    AttributeBegin,    <span class="comment">// E[attr^="value"]</span></div><div class="line">    AttributeEnd,      <span class="comment">// E[attr$="value"]</span></div><div class="line">    FirstAttributeSelectorMatch = AttributeExact,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>定义 selectors 的 Relation 类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> RelationType &#123;</div><div class="line">    SubSelector,       <span class="comment">// No combinator</span></div><div class="line">    Descendant,        <span class="comment">// "Space" combinator</span></div><div class="line">    Child,             <span class="comment">// &gt; combinator</span></div><div class="line">    DirectAdjacent,    <span class="comment">// + combinator</span></div><div class="line">    IndirectAdjacent,  <span class="comment">// ~ combinator</span></div><div class="line">    <span class="comment">// Special cases for shadow DOM related selectors.</span></div><div class="line">    ShadowPiercingDescendant,  <span class="comment">// &gt;&gt;&gt; combinator</span></div><div class="line">    ShadowDeep,                <span class="comment">// /deep/ combinator</span></div><div class="line">    ShadowPseudo,              <span class="comment">// ::shadow pseudo element</span></div><div class="line">    ShadowSlot                 <span class="comment">// ::slotted() pseudo element</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CSS 的属性是 id 来标识的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> CSSPropertyID &#123;</div><div class="line">    CSSPropertyColor = <span class="number">15</span>,</div><div class="line">    CSSPropertyWidth = <span class="number">316</span>,</div><div class="line">    CSSPropertyMarginLeft = <span class="number">145</span>,</div><div class="line">    CSSPropertyMarginRight = <span class="number">146</span>,</div><div class="line">    CSSPropertyMarginTop = <span class="number">147</span>,</div><div class="line">    CSSPropertyMarkerEnd = <span class="number">148</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认样式，Blink ua全部 CSS 样式：<a href="http://yincheng.site/html/chrome-ua-css.html" target="_blank" rel="external">http://yincheng.site/html/chrome-ua-css.html</a> 。w3c 的默认样式是：<a href="https://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">https://www.w3.org/TR/CSS2/sample.html</a></p>
<p>接着会生成 hash map，分成四个类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CompactRuleMap m_idRules;                    <span class="comment">//id</span></div><div class="line">CompactRuleMap m_classRules;                 <span class="comment">//class</span></div><div class="line">CompactRuleMap m_tagRules;                   <span class="comment">//标签</span></div><div class="line">CompactRuleMap m_shadowPseudoElementRules;   <span class="comment">//伪类选择器</span></div></pre></td></tr></table></figure></p>
<p>CSS 解析完会触发  layout tree ，会给每个可视 Node 创建一个 layout 节点，创建时需要计算 style，这个过程包括找到 selector 和 设置 style。</p>
<p>layout 会更新递归所有 DOM 元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> ContainerNode::attachLayoutTree(<span class="keyword">const</span> AttachContext&amp; context) &#123;</div><div class="line">  <span class="keyword">for</span> (Node* child = firstChild(); child; child = child-&gt;nextSibling()) &#123;</div><div class="line">    <span class="keyword">if</span> (child-&gt;needsAttach())</div><div class="line">      child-&gt;attachLayoutTree(childrenContext);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后对每个 node 都会按照 id，class，伪元素和标签顺序取出所有对应的 selector<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//id</span></div><div class="line"><span class="keyword">if</span> (element.hasID()) </div><div class="line">  collectMatchingRulesForList(</div><div class="line">      matchRequest.ruleSet-&gt;idRules(element.idForStyleResolution()),</div><div class="line">      cascadeOrder, matchRequest);</div><div class="line"><span class="comment">//class</span></div><div class="line"><span class="keyword">if</span> (element.isStyledElement() &amp;&amp; element.hasClass()) &#123; </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; element.classNames().size(); ++i)</div><div class="line">    collectMatchingRulesForList(</div><div class="line">        matchRequest.ruleSet-&gt;classRules(element.classNames()[i]),</div><div class="line">        cascadeOrder, matchRequest);</div><div class="line">&#125;</div><div class="line"><span class="comment">//伪类</span></div><div class="line">...</div><div class="line"><span class="comment">//tag 和 selector</span></div><div class="line">collectMatchingRulesForList(</div><div class="line">    matchRequest.ruleSet-&gt;tagRules(element.localNameForSelectorMatching()),</div><div class="line">    cascadeOrder, matchRequest);</div><div class="line"><span class="comment">//通配符</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到 id 是唯一的，容易直接取到，class 就需要遍历数组来设置 style。</p>
<p>在 classRules 里会进行检验<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!checkOne(context, subResult))</div><div class="line">  <span class="keyword">return</span> SelectorFailsLocally;</div><div class="line"><span class="keyword">if</span> (context.selector-&gt;isLastInTagHistory()) &#123; </div><div class="line">    <span class="keyword">return</span> SelectorMatches;</div><div class="line">&#125;</div><div class="line"><span class="comment">//checkOne 的实现</span></div><div class="line"><span class="keyword">switch</span> (selector.match()) &#123; </div><div class="line">  <span class="keyword">case</span> CSSSelector::Tag:</div><div class="line">    <span class="keyword">return</span> matchesTagName(element, selector.tagQName());</div><div class="line">  <span class="keyword">case</span> CSSSelector::Class:</div><div class="line">    <span class="keyword">return</span> element.hasClass() &amp;&amp;</div><div class="line">           element.classNames().contains(selector.value());</div><div class="line">  <span class="keyword">case</span> CSSSelector::Id:</div><div class="line">    <span class="keyword">return</span> element.hasID() &amp;&amp;</div><div class="line">           element.idForStyleResolution() == selector.value();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 Relation 类型是 Descendant 表示是后代，就需要在 checkOne 后处理 relation。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (relation) &#123; </div><div class="line">  <span class="keyword">case</span> CSSSelector::Descendant:</div><div class="line">    <span class="keyword">for</span> (nextContext.element = parentElement(context); nextContext.element;</div><div class="line">         nextContext.element = parentElement(nextContext)) &#123; </div><div class="line">      MatchStatus match = matchSelector(nextContext, result);</div><div class="line">      <span class="keyword">if</span> (match == SelectorMatches || match == SelectorFailsCompletely)</div><div class="line">        <span class="keyword">return</span> match;</div><div class="line">      <span class="keyword">if</span> (nextSelectorExceedsScope(nextContext))</div><div class="line">        <span class="keyword">return</span> SelectorFailsCompletely;</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> SelectorFailsCompletely;</div><div class="line">      <span class="keyword">case</span> CSSSelector::Child:</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这个就是 selector 从右到左解释的实现，它会递归所有父节点，再次执行 checkOne ，这样直到找到需要的父节点以及如果需要的父节点的父节点才会停止递归。所以选择器不要写太长，会影响效率。</p>
<h3 id="CSS-规则匹配"><a href="#CSS-规则匹配" class="headerlink" title="CSS 规则匹配"></a>CSS 规则匹配</h3><p>CSS 解析完，节点会调用 CSSStyleSelector 的 styleForElement 来给节点创建 RenderStyle 实例。RenderObject 需要 RenderStyle 的排版信息。</p>
<p>CSSStyleSelector 会从 CSSRuleList 里将匹配的样式属性取出进行规则匹配，相关类图如下：<br><img src="/uploads/deeply-analyse-webkit/92.png" alt="92"><br>匹配的流程图如下：<br><img src="/uploads/deeply-analyse-webkit/93.png" alt="93"></p>
<h3 id="设置-style"><a href="#设置-style" class="headerlink" title="设置 style"></a>设置 style</h3><p>设置的顺序是先设置父节点，在使用默认的 UA 的 style，最后再使用 Author 的 style。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">style-&gt;inheritFrom(*state.parentStyle())</div><div class="line">matchUARules(collector);</div><div class="line">matchAuthorRules(*state.element(), collector);</div></pre></td></tr></table></figure>
<p>在执行每一步时如有一个 styleRule 匹配的话都会放到当前元素的 m_matchedRule 里，然后计算优先级，优先级算法就是从右到左取每个 selector 优先级之和，实现如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> CSSSelector* selector = <span class="keyword">this</span>; selector;</div><div class="line">     selector = selector-&gt;tagHistory()) &#123; </div><div class="line">  temp = total + selector-&gt;specificityForOneSelector();</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> total;</div></pre></td></tr></table></figure></p>
<p>每个不同类型的 selector 的优先级如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (m_match) &#123;</div><div class="line">    <span class="keyword">case</span> Id: </div><div class="line">      <span class="keyword">return</span> <span class="number">0x010000</span>;</div><div class="line">    <span class="keyword">case</span> PseudoClass:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000100</span>;</div><div class="line">    <span class="keyword">case</span> Class:</div><div class="line">    <span class="keyword">case</span> PseudoElement:</div><div class="line">    <span class="keyword">case</span> AttributeExact:</div><div class="line">    <span class="keyword">case</span> AttributeSet:</div><div class="line">    <span class="keyword">case</span> AttributeList:</div><div class="line">    <span class="keyword">case</span> AttributeHyphen:</div><div class="line">    <span class="keyword">case</span> AttributeContain:</div><div class="line">    <span class="keyword">case</span> AttributeBegin:</div><div class="line">    <span class="keyword">case</span> AttributeEnd:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000100</span>;</div><div class="line">    <span class="keyword">case</span> Tag:</div><div class="line">      <span class="keyword">return</span> <span class="number">0x000001</span>;</div><div class="line">    <span class="keyword">case</span> Unknown:</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 id 的优先级最大是 0x010000 = 65536，类，属性，伪类优先级是 0x000100 = 256，标签是 0x000001 = 1</p>
<p>举个优先级计算的例子<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*优先级为257 = 265 + 1*/</span></div><div class="line"><span class="selector-class">.text</span> <span class="selector-tag">h1</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">8em</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*优先级为65537 = 65536 + 1*/</span></div><div class="line"><span class="selector-id">#my-text</span> <span class="selector-tag">h1</span>&#123;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">16em</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将所有 CSS 规则放到 collector 的 m_matchedRules 里，再根据优先级从小到大排序，这样，越执行到后面优先级越高，可以覆盖前面的。</p>
<p>目前优先级是 ID 选择器大于类型选择器，大于标签选择器，大于相邻选择器，大于子选择器，大于后代选择器。</p>
<p>排序规则<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">compareRules</span><span class="params">(<span class="keyword">const</span> MatchedRule&amp; matchedRule1,</span></span></div><div class="line">                                <span class="keyword">const</span> MatchedRule&amp; matchedRule2) &#123;</div><div class="line">  <span class="keyword">unsigned</span> specificity1 = matchedRule1.specificity();</div><div class="line">  <span class="keyword">unsigned</span> specificity2 = matchedRule2.specificity();</div><div class="line">  <span class="keyword">if</span> (specificity1 != specificity2)</div><div class="line">    <span class="keyword">return</span> specificity1 &lt; specificity2;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> matchedRule1.position() &lt; matchedRule2.position();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>规则和优先级完后就开始设置元素的 style 了：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">applyMatchedPropertiesAndCustomPropertyAnimations(</div><div class="line">        state, collector.matchedResult(), element);</div><div class="line"></div><div class="line">applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</div><div class="line">      state, matchResult.allRules(), <span class="literal">false</span>, applyInheritedOnly, needsApplyPass);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> range : ImportantAuthorRanges(matchResult)) &#123;</div><div class="line">    applyMatchedProperties&lt;HighPropertyPriority, CheckNeedsApplyPass&gt;(</div><div class="line">        state, range, <span class="literal">true</span>, applyInheritedOnly, needsApplyPass);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>最后的 style 是什么样的，style 会生成一个 ComputedStyle 对象。对象结构如下：<br><img src="/uploads/deeply-analyse-webkit/14.png" alt="14"></p>
<p><img src="/uploads/deeply-analyse-webkit/15.png" alt="15"></p>
<h3 id="CSS-Object-Model-CSSOM"><a href="#CSS-Object-Model-CSSOM" class="headerlink" title="CSS Object Model (CSSOM)"></a>CSS Object Model (CSSOM)</h3><p>CSS 对象模型 CSSOM 提供了便于 JavaScript 操作 CSS 的接口 CSSStyleSheet。通过这个接口我们可以很容易获取 CSS 的 href，cssRule 这样的信息。</p>
<p>W3C 还定义了 CSSOM View，增加了 Window，Document，Element，HTMLElement 和 MouseEvent 的接口。比如 Window 对 CSSOM View 的支持就可以在 WebCore/page/DOMWindow.idl 里查看到，我摘出和 CSSOM View 相关的规范定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">// Extensions from the CSSOM-View specification (https://drafts.csswg.org/cssom-view/#extensions-to-the-window-interface).</div><div class="line">[NewObject] MediaQueryList matchMedia(CSSOMString query);</div><div class="line">[Replaceable] readonly attribute Screen screen; // FIXME: Should be [SameObject].</div><div class="line"></div><div class="line">// Browsing context (CSSOM-View).</div><div class="line">void moveTo(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line">void moveBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line">void resizeTo(optional unrestricted float width = NaN, optional unrestricted float height = NaN); // Parameters should be mandatory and of type long.</div><div class="line">void resizeBy(optional unrestricted float x = NaN, optional unrestricted float y = NaN); // FIXME: Parameters should be mandatory and of type long.</div><div class="line"></div><div class="line">// Viewport (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute long innerHeight;</div><div class="line">[Replaceable] readonly attribute long innerWidth;</div><div class="line"></div><div class="line">// Viewport scrolling (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute double scrollX;</div><div class="line">[Replaceable, ImplementedAs=scrollX] readonly attribute double pageXOffset;</div><div class="line">[Replaceable] readonly attribute double scrollY;</div><div class="line">[Replaceable, ImplementedAs=scrollY] readonly attribute double pageYOffset;</div><div class="line">[ImplementedAs=scrollTo] void scroll(optional ScrollToOptions options);</div><div class="line">[ImplementedAs=scrollTo] void scroll(unrestricted double x, unrestricted double y);</div><div class="line">void scrollTo(optional ScrollToOptions options);</div><div class="line">void scrollTo(unrestricted double x, unrestricted double y);</div><div class="line">void scrollBy(optional ScrollToOptions option);</div><div class="line">void scrollBy(unrestricted double x, unrestricted double y);</div><div class="line"></div><div class="line">// Client (CSSOM-View).</div><div class="line">[Replaceable] readonly attribute long screenX;</div><div class="line">[Replaceable] readonly attribute long screenY;</div><div class="line">[Replaceable] readonly attribute long outerWidth;</div><div class="line">[Replaceable] readonly attribute long outerHeight;</div><div class="line">[Replaceable] readonly attribute double devicePixelRatio;</div></pre></td></tr></table></figure></p>
<p>可以看出 CSSOM View 定义了 Window 的大小，滚动，位置等各种信息。</p>
<h2 id="RenderObject-Tree"><a href="#RenderObject-Tree" class="headerlink" title="RenderObject Tree"></a>RenderObject Tree</h2><p>当 DOM tree 构建过程中，在 HTMLConstruction 的 attachToCurrent 方法里会通过 createRendererIfNeeded 方法构建的另外一个 tree，叫 Render tree。构成这个 tree 的元素都是 RenderObject。RenderObject 会记录各个 node 的 render 信息，比如 RenderStyle，Node 和 RenderLayer 等。当 WebKit 创建 DOM Tree 的同时也会创建 RenderObject 对象，DOM Tree 动态加入一个新节点时也会创建相应的 RenderObject 对象。</p>
<p>整个 tree 的创建过程都是由 NodeRenderingContext 类来完成。下图是如何创建 RenderObject 对象和构建 RenderObject Tree 的。<br><img src="/uploads/deeply-analyse-webkit/64.png" alt="64"><br>上图所示，WebKit 会先检查 DOM 节点是否需要新的  RenderObject 对象，需要的话会创建或者获取一个 NodeRenderingContext 对象来创建 RenderObject 对象。NodeRenderingContext 的作用是分析设置 RenderObject 对象父结点，兄弟节点等信息然后完成插入 RenderObject 树。</p>
<h3 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject"></a>RenderObject</h3><p>RenderObject 需要知道 CSS 相关属性，会引用在 CSS 解析过程中生成的 CSSStyleSelector 提供的 RenderStyle。RenderObject 的创建过程如下：<br><img src="/uploads/deeply-analyse-webkit/88.png" alt="88"></p>
<p>RenderObject 被创建时创建时相关的类如下图所示：<br><img src="/uploads/deeply-analyse-webkit/62.png" alt="62"><br>Element 对象会递归调用 attach 函数，会检查是否需要创建一个新的 RenderObject。需要创建的话会使用 NodeRenderingContext 类来创建不同 DOM 节点类型的 RenderObject。attach 的具体过程是在当前的 Render 节点的父节点会将当前的 Render 节点插入到合适位置，父节点再设置当前节点的兄弟节点。attach 过程见下图：<br><img src="/uploads/deeply-analyse-webkit/89.png" alt="89"></p>
<p>RenderObject 树和 DOM 树一样也有很多类型，下面是 RenderObject 基类和子类示意图：<br><img src="/uploads/deeply-analyse-webkit/63.png" alt="63"></p>
<p>RenderObject 核心对象关系图如下：<br><img src="/uploads/deeply-analyse-webkit/94.png" alt="94"></p>
<p>RenderBox 类是 Box 模型的类，包含了外边距，内边距，边框等信息。</p>
<p>RenderObject 的继承关系图如下：<br><img src="/uploads/deeply-analyse-webkit/76.png" alt="76"></p>
<p>RenderObject 的一些主要虚函数</p>
<ul>
<li>parent()，firstChild()，nextSibling()，previousSibling()，addChild()，removeChild() 这些遍历和修改 RenderObject 树的函数。</li>
<li>layout()，style()，enclosingBox() 这些计算和获取布局的函数。</li>
<li>isASubClass 类似这样判断那种子类类型的函数。</li>
<li>paint()，repaint() 这样讲内容绘制传入绘制结果对象的坐标和绘图函数。</li>
</ul>
<p>RenderObject 用来构建 Render Tree 的相关方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">RenderElement* <span class="title">parent</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_parent; &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDescendantOf</span><span class="params">(<span class="keyword">const</span> RenderObject*)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">previousSibling</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_previous; &#125;</div><div class="line"><span class="function">RenderObject* <span class="title">nextSibling</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_next; &#125;</div><div class="line"></div><div class="line"><span class="comment">// Use RenderElement versions instead.</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> RenderObject* <span class="title">firstChildSlow</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">virtual</span> RenderObject* <span class="title">lastChildSlow</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrder</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrder</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrderAfterChildren</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">nextInPreOrderAfterChildren</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">previousInPreOrder</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">previousInPreOrder</span><span class="params">(<span class="keyword">const</span> RenderObject* stayWithin)</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">WEBCORE_EXPORT RenderObject* <span class="title">childAt</span><span class="params">(<span class="keyword">unsigned</span>)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="function">RenderObject* <span class="title">firstLeafChild</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"><span class="function">RenderObject* <span class="title">lastLeafChild</span><span class="params">()</span> <span class="keyword">const</span></span>;</div></pre></td></tr></table></figure></p>
<p>RenderObject 用来布局相关的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsLayout</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()</div><div class="line">        || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">selfNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsPositionedMovementLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsPositionedMovementLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsPositionedMovementLayoutOnly</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()</div><div class="line">        &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">posChildNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.posChildNeedsLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">needsSimplifiedNormalFlowLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.needsSimplifiedNormalFlowLayout(); &#125;</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">normalChildNeedsLayout</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_bitfields.normalChildNeedsLayout(); &#125;</div></pre></td></tr></table></figure></p>
<p>RenderBoxModelObject 是 RenderObject 的子类，是对 CSS Box 的封装，里面定义了 CSS Box 的各个接口。</p>
<p>RenderBox 是 RenderBoxModelObject 的子类，会重载 RenderObject 和 RenderBoxModelObject 的一些方法。</p>
<p>RenderBlock 是 RenderBox 的子类，封装 CSS 里 Block 的元素，里面有布局 Inline，block，和定位相关的方法，有删除，插入 Float 浮动节点还有计算浮动节点位置等方法，绘制相关的比如绘制 Float 节点，绘制 outline，绘制选择区等方法。</p>
<p>RenderView 继承自 RenderBlock，Render Tree 的根节点，是 Tree 布局和渲染的入口。</p>
<p>RenderInlineBox 是 RenderBoxModelObject 的子类，会封装 CSS 里的 Inline 元素。里面的方法主要处理 Inline 的自动换多行情况。对多行的处理 RenderInlineBox 会有个 RenderInlineBoxList 类的 m_lineBoxes 持有有多个 InlineBox 的行元素。RenderBox 和 InlineBox 的关系类图如下：<br><img src="/uploads/deeply-analyse-webkit/95.png" alt="95"><br>RenderStyle 会保存 CSS 解析结果，这些 CSS 属性会保存在 InheritedFlags 和 NonInheritedFlags 里，InheritedFlags 保存的都是文本方向和文本对齐等属性，NonInheritedFlags 里保存了浮动，定位，overflow 等属性，还有大量的访问和设置 CSS 属性的方法。</p>
<p>RenderText 继承 RenderObject，提供处理文字相关功能。相关的类图如下：<br><img src="/uploads/deeply-analyse-webkit/96.png" alt="96"></p>
<h3 id="StyleResolver"><a href="#StyleResolver" class="headerlink" title="StyleResolver"></a>StyleResolver</h3><p>RenderStyle 来自 CSS，保存了 Render Tree 绘制需要的所有内容，StyleResolver 就是负责将 CSS 转成 RenderStyle。StyleResolver 类根据元素的信息，例如标签名和类别等，保存到新建的 RenderStyle 对象中，它们最后被 RenderObject 类所管理和使用。<br><img src="/uploads/deeply-analyse-webkit/61.png" alt="61"></p>
<p>规则的匹配是由 ElementRuleCollector 类计算获得，根据元素属性信息，从 DocumentRuleSets 类里获得规则集合按照 ID，Class，Tag 等信息获得元素的样式，具体的过程如下：<br><img src="/uploads/deeply-analyse-webkit/60.png" alt="60"><br>创建 RenderObject 类时 StyleResolver 会收集样式信息给 RenderStyle 对象，这样 RenderStyle 对象包含了完整的样式信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForElement(Element*, RenderStyle* parentStyle = <span class="number">0</span>, StyleSharingBehavior = AllowStyleSharing,  </div><div class="line">    RuleMatchingBehavior = MatchAllRules, RenderRegion* regionForStyling = <span class="number">0</span>);   </div><div class="line"> ......  </div><div class="line">  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; pseudoStyleForElement(PseudoId, Element*, RenderStyle* parentStyle);  </div><div class="line">  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForPage(<span class="keyword">int</span> pageIndex);  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; defaultStyleForElement();  </div><div class="line">PassRefPtr&lt;RenderStyle&gt; styleForText(Text*);  </div><div class="line">  </div><div class="line"><span class="keyword">static</span> PassRefPtr&lt;RenderStyle&gt; styleForDocument(Document*, CSSFontSelector* = <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>StyleResolver 是 Document 的子对象。当 CSS 发生变化（style 发生变化）就会调用 recalcStyle，recalcStyle 调用 Element::StyleForRender，Element::StyleForRender 调用 styleForElement。</p>
<h3 id="styleForElement-进行-CSS-选择和匹配"><a href="#styleForElement-进行-CSS-选择和匹配" class="headerlink" title="styleForElement 进行 CSS 选择和匹配"></a>styleForElement 进行 CSS 选择和匹配</h3><p>具体代码实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//保存 element</span></div><div class="line">initElement(element);</div><div class="line">initForStyleResolve(element, defaultParent);  </div><div class="line">....  </div><div class="line"></div><div class="line"><span class="comment">//规则匹配  </span></div><div class="line">MatchResult matchResult;  </div><div class="line"><span class="keyword">if</span> (matchingBehavior == MatchOnlyUserAgentRules)  </div><div class="line">    matchUARules(matchResult);  </div><div class="line"><span class="keyword">else</span>  </div><div class="line">    matchAllRules(matchResult, matchingBehavior != MatchAllRulesExcludingSMIL);  </div><div class="line"></div><div class="line"><span class="comment">//将规则和 element 做映射</span></div><div class="line">applyMatchedProperties(matchResult, element);</div><div class="line"></div><div class="line"><span class="comment">//matchUARules</span></div><div class="line"><span class="keyword">void</span> StyleResolver::matchUARules(MatchResult&amp; result, RuleSet* rules)  </div><div class="line">&#123;</div><div class="line">    m_matchedRules.clear();</div><div class="line">    result.ranges.lastUARule = result.matchedProperties.size() - <span class="number">1</span>;</div><div class="line">    <span class="comment">//收集匹配规则</span></div><div class="line">    collectMatchingRules(rules, result.ranges.firstUARule, result.ranges.lastUARule, <span class="literal">false</span>);  </div><div class="line">	<span class="comment">//规则排序</span></div><div class="line">    sortAndTransferMatchedRules(result);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RuleSet"><a href="#RuleSet" class="headerlink" title="RuleSet"></a>RuleSet</h3><p>matchUARules 的 RuleSet 代表 CSS 规则，比如<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">background </span>: red; &#125;</div></pre></td></tr></table></figure></p>
<p>RuleSet 的成员变量<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RuleSet</span> ... &#123;</span></div><div class="line">.....</div><div class="line">AtomRuleMap m_idRules;</div><div class="line">AtomRuleMap m_classRules;</div><div class="line">AtomRuleMap m_tagRules;</div><div class="line">AtomRuleMap m_shadowPseudoElementRules;</div><div class="line">...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>sortAndTransferMatchedRules 是为了保证正确的匹配顺序。</p>
<p>RuleSet 来自浏览器定义的默认 RuleSet，也可来自写页面定义的 Author RuleSet，对于 Element 还有自身的规则。只有继承 StyledElement 的内联 CSS 的 Element 才能够有 RuleSet。实现是在 StyledElement::rebuildPresentationAttributeStyle 里实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> StyledElement::rebuildPresentationAttributeStyle()  </div><div class="line">&#123;  </div><div class="line">.....  </div><div class="line">  </div><div class="line">    RefPtr&lt;StylePropertySet&gt; style;</div><div class="line">    <span class="keyword">if</span> (cacheHash &amp;&amp; cacheIterator-&gt;value) &#123;  </div><div class="line">        style = cacheIterator-&gt;value-&gt;value;  </div><div class="line">        presentationAttributeCacheCleaner().didHitPresentationAttributeCache();  </div><div class="line">    &#125; <span class="keyword">else</span> &#123;  </div><div class="line">        style = StylePropertySet::create(isSVGElement() ? SVGAttributeMode : CSSQuirksMode);  </div><div class="line">        <span class="keyword">unsigned</span> size = attributeCount();  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;  </div><div class="line">            <span class="keyword">const</span> Attribute* attribute = attributeItem(i);  </div><div class="line">            collectStyleForPresentationAttribute(*attribute, style.get());  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// ImmutableElementAttributeData doesn't store presentation attribute style, so make sure we have a MutableElementAttributeData.  </span></div><div class="line">    ElementAttributeData* attributeData = mutableAttributeData();  </div><div class="line">  </div><div class="line">    attributeData-&gt;m_presentationAttributeStyleIsDirty = <span class="literal">false</span>;  </div><div class="line">    attributeData-&gt;setPresentationAttributeStyle(style-&gt;isEmpty() ? <span class="number">0</span> : style);  </div><div class="line">....</div></pre></td></tr></table></figure></p>
<p>关于 AuthorStyle 用 StyleResolver::m_authorStyle 来保存 html 里所有 style tag 和 link 的外部 css。当 CSS 被改变或者页面大小变化时会调用 Document::styleResolverChanged 函数，接着调用 DocumentStyleCollection::updateActiveStyleSheets，最后调用 StyleResolver::appendAuthorStyleSheets。</p>
<h3 id="Render-tree-和-DOM-tree-做对应"><a href="#Render-tree-和-DOM-tree-做对应" class="headerlink" title="Render tree 和 DOM tree 做对应"></a>Render tree 和 DOM tree 做对应</h3><p>其实并不是一一对应的，比如说 head 标签或者 display 属性为 none 的就不会在 Render tree 中。</p>
<p>有些 render object 有对应的 DOM node，但是不在 tree 的相同位置，比如 floats 和 absolutely position 的元素，他们会放在 tree 的其它地方，会映根据设置的 frame 直接射到对应的位置。如下图，虚线表示他们能够对应的：<br><img src="/uploads/deeply-analyse-webkit/65.png" alt="65"><br><img src="/uploads/deeply-analyse-webkit/73.png" alt="73"></p>
<p>上图可以看到一般的 Element 比如 HTMLBodyElement 和 HTMLDivElement 对应的都是 RenderBlock。</p>
<h3 id="构建-Render-Tree-的流程"><a href="#构建-Render-Tree-的流程" class="headerlink" title="构建 Render Tree 的流程"></a>构建 Render Tree 的流程</h3><p>解决样式和创建一个 renderer 称作 attachment，每个 Element 有一个 attach 方法，Render Tree 的创建就是从这里开始，attachment 是同步的，Element 节点插入 DOM tree 会调用新 node 的 attach 方法。在处理 html 和 body 标签时会创建 Render Tree 的 root。root Render Object 对应了 CSS 里的 containing block，top block 会包含所有的其它 block。Render Object 通过 RenderObject::CreateObject 静态方法创建，创建时会计算出 Element 的 CSSStyle。 浏览器 window 显示区域 viewport，在 WebKit 里叫做 RenderView。</p>
<h3 id="RenderLayer-Tree"><a href="#RenderLayer-Tree" class="headerlink" title="RenderLayer Tree"></a>RenderLayer Tree</h3><p>RenderLayer Tree 是基于 RenderObject Tree 建立的，它们是多个 RenderObject 对应一个 RenderLayer 的关系。在创建完 RenderObject Tree WebKit 还会创建 RenderLayer Tree，根节点是 RenderView 实例，根据一些条件来判断是否需要创建一个新的 RenderLayer 对象，再设置 RenderLayer 对象的父对象和兄弟对象。RenderLayer 需要满足一定条件才会创建，下面是那些需要创建新 RenderLayer 对象的条件：</p>
<ul>
<li>HTMLElement 节点对应的 RenderBlock 节点。</li>
<li>有设置 relative，absolute，transform 的 CSS position 属性的。</li>
<li>透明效果的 RenderObject 节点。</li>
<li>节点有 overflow， apha mask 或反射效果的 RenderObject 节点。</li>
<li>设置了 CSS filter 属性的节点。</li>
<li>使用 Canvas 或 WebGL 的 RenderObject 节点。</li>
<li>Video 节点对应的 RenderObject 节点。</li>
</ul>
<p>RenderObject Tree 和 RenderLayer Tree 的关系如下图：<br><img src="/uploads/deeply-analyse-webkit/66.png" alt="66"><br>接下来看看 RenderObject Tree 和 RenderLayer Tree 的布局信息如下图所示：<br><img src="/uploads/deeply-analyse-webkit/67.png" alt="67"></p>
<h3 id="style-计算"><a href="#style-计算" class="headerlink" title="style 计算"></a>style 计算</h3><p>构建 render tree 需要计算每个 render object 的视觉特性。是通过计算每个 element 的 style 属性来做到的。</p>
<p>这个样式包含了各种来源的 style sheets，有 inline style element 和 html 里视觉属性设置比如 bgcolor 这样的属性，后面这些都会转为 CSS style 的属性。来源还有浏览器默认的 style sheets，这个 style sheets 可以是用户自定义的。</p>
<p>我们先看看 style 计算可能会有一些什么样问题</p>
<ul>
<li>Style 的数据是个非常大的结构，因为里面有大量的 style 属性这样会有内存问题。</li>
<li>如果没有优化为每个 element 查找合适的规则会导致性能问题。为每个 element 到整个规则列表查找合适的规则是个巨大消耗。Selectors 可能会有个很复杂的结构，比如 div div div div {…} 这样的话匹配时会有很多遍历来匹配。</li>
<li>应用规则涉及到比较复杂的层级规则。</li>
</ul>
<p>下面来说下如何解决这些问题</p>
<h4 id="共享-style-数据"><a href="#共享-style-数据" class="headerlink" title="共享 style 数据"></a>共享 style 数据</h4><p>WebKit 的 nodes 是 style objects（RenderStyle），这些 objects 可以被 nodes 在某些情况下共享，这些 nodes 可以是兄弟节点或表兄弟节点。有下面这些情况是可以 style 共享的</p>
<ul>
<li>element 必须有相同的鼠标状态</li>
<li>都没有 id</li>
<li>tag 名能匹配上</li>
<li>class 属性能匹配上</li>
<li>一组映射的属性是相同的</li>
<li>链接状态能匹配上</li>
<li>focus 状态能匹配上</li>
<li>任何 element 都不会被属性 selectors 影响</li>
<li>elements 不能有 inline style 属性</li>
<li>不要使用兄弟 selectors</li>
</ul>
<h4 id="Rule-tree"><a href="#Rule-tree" class="headerlink" title="Rule tree"></a>Rule tree</h4><p>WebKit 会把 style objects 和 DOM 的 node 相关联。通过正确的顺序将所有逻辑规则值转成计算值，比如百分比会被转换成绝对单位，rule tree 可以使节点之间共享这些值，避免多次计算，同时节省内存。所有匹配的规则都会存在一个 tree 里。tree 的最下面的 node 有着最高的优先级。Rule tree 是当 node style 需要的时候才会去根据规则计算的。<br><img src="/uploads/deeply-analyse-webkit/70.png" alt="70"></p>
<p>通过上图看看设置 rule tree 的好处吧，如果我们要找到 B - E - I 的规则我们能够省掉很多工作，因为我们已经计算了 A - B - E - I。</p>
<h4 id="可确定样式分到各个-structs-里"><a href="#可确定样式分到各个-structs-里" class="headerlink" title="可确定样式分到各个 structs 里"></a>可确定样式分到各个 structs 里</h4><p>一些样式的信息是可以一开始就确定的，比如 border 和 color。所有属性分为可继承和不可继承两种，如果是需要继承需要特别指定，默认都是不可继承的。</p>
<p>rule tree 帮着我们缓存全部的 structs，这样的好处是如果下面的 node 没有可用的 struct，那么可以使用上一级 node 的缓存里的来用。</p>
<h4 id="使用-rule-tree-计算-style-contexts"><a href="#使用-rule-tree-计算-style-contexts" class="headerlink" title="使用 rule tree 计算 style contexts"></a>使用 rule tree 计算 style contexts</h4><p>当确定要为某个 element 计算 style context 时，我们首先计算 rule tree 的路径或者使用一个已经存在的。接着我们开始在我们新的 style context 里应用路径里的规则去填充 structs。</p>
<p>从路径下面的 node 开始，然后往上直到 struct 完成。如果 struct 没有符合的 rule node，那么往 rule tree  上面 node 找，知道找到就可以直接使用，这样就是被优化了，整个 struct 都是共享的。</p>
<p>如果没有找到一个为这个 struct 的 rule node 定义，那么先检查是否是可继承的，如果是就使用父 struct 的 context。如果这个条件也没满足那么就使用默认的值。</p>
<p>如果一个 element 有兄弟节点指向相同的 tree node，那么全部 style context 可以被共享。</p>
<p>看个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">                          this is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> big error <span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">                          this is also a</div><div class="line">                          <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"big"</span>&gt;</span> very  big  error<span class="tag">&lt;/<span class="name">span</span>&gt;</span> error</div><div class="line">                <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"err"</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>another error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>下面是 CSS 的定义<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</div><div class="line"><span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line"><span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</div><div class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</div><div class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</div><div class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</div></pre></td></tr></table></figure></p>
<p>这里有两个 structs 需要填充， color struct 和 margin struct。color struct 只包含一个值， margin struct 有四个。下面是 rule tree<br><img src="/uploads/deeply-analyse-webkit/71.png" alt="71"></p>
<p>context tree：<br><img src="/uploads/deeply-analyse-webkit/72.png" alt="72"></p>
<p>假设到第二个 div 标签时，我们会创建一个 style context 给这个 node 并且填充 style struct。我们找到 1，2和6这个 rule 是满足的，而且在 rule tree 里已经存在了一个这样的路径，我们只需要把 F 添加到这个 node 里。这样形成一个 context tree 来保存这些对应关系。</p>
<p>现在需要填充 style struct，先从 margin struct 开始，比如 rule tree 里最后 node F 没有添加到 margin struct 里，我们可以往 rule tree 的上面找，找到并且使用之，最后我们找到 node B 这个是最近的一个有 margin struct 的 node。</p>
<p>已经定义了 color struct，那么就不能使用缓存的 struct，这样就不用往 rule tree 上级 node 去找，接着就把值转成 RGB 什么的并且缓存到这个 node 里。</p>
<p>对于第二个 span element，它会指向 rule G，就像前一个 span 一样。如果兄弟 node 都是指向同一个 rule node，那么它们是可以共享整个 style context 的。</p>
<p>如果是继承的 struct 会在 context tree 上进行缓存，color 属性是可继承的。</p>
<h4 id="比较容易匹配的-rules"><a href="#比较容易匹配的-rules" class="headerlink" title="比较容易匹配的 rules"></a>比较容易匹配的 rules</h4><p>下面是不同的 style rules 的来源：</p>
<ul>
<li><p>CSS rules，来自于 style sheets 或者在 style elements 里</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Inline style 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:blue"</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>HTML 视觉属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">bgcolor</span>=<span class="string">"blue"</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>后面两个属于容易匹配 element，可以使用 element 作为 map 的 key。解析 style sheet 后，通过 selector rules 会添加一些 has maps。有 id 的 map，有 class name 的 map，还有 tag name 的 map。如果 selector 是 id 那么 rule 会添加到 id map 里。</p>
<p>如果是 class name 那么会添加到 class map 里。</p>
<p>这个操作更容易匹配 rule。完全没必要去查找每个声明，我们可以从对应的 element 的 map 里提取相关的 rule。</p>
<p>下面举个例子</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span><span class="selector-class">.error</span> &#123;<span class="attribute">color</span>:red&#125;</div><div class="line"><span class="selector-id">#messageDiv</span> &#123;<span class="attribute">height</span>:<span class="number">50px</span>&#125;</div><div class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>&#125;</div></pre></td></tr></table></figure>
<p>第一个 rule 会被加到 class map 里。第二个会加入到 id map 里，第三个会被添加到 tag map 里。</p>
<p>对于下面的 HTML<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"error"</span>&gt;</span>an error occurred <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">" messageDiv"</span>&gt;</span>this is a message<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们会先试着找 p 这个 element 的 rules，在 class map 里能找到 error 这个 key 里有 rule p.error。div 这个 element 可以在 id map 和 tag map 里找到。下面看看 div 的这个 rule<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">table div &#123;margin:5px&#125;</div></pre></td></tr></table></figure></p>
<p>selector 都是从右到左来查找的，先在 tag map 里找 div，然后再看看左边是 table tag，所以不吻合。</p>
<h4 id="Style-sheet-的-cascade-排序"><a href="#Style-sheet-的-cascade-排序" class="headerlink" title="Style sheet 的 cascade 排序"></a>Style sheet 的 cascade 排序</h4><p>一个 style 属性可以被定义在多个 style sheets 里，那么应用 rules 的顺序就显得非常的重要，在 CSS 的定义里把这个顺序叫做 cascade 排序，意思是从低到高。</p>
<ul>
<li>浏览器的设置</li>
<li>用户的设置</li>
<li>网页里普通的设置</li>
<li>网页里重要的设置</li>
<li>用户重要的设置</li>
</ul>
<h4 id="CSS-specification"><a href="#CSS-specification" class="headerlink" title="CSS specification"></a>CSS specification</h4><p>selector 的 specifity 在 w3c 里有定义 <a href="https://www.w3.org/TR/CSS2/cascade.html#specificity" target="_blank" rel="external">https://www.w3.org/TR/CSS2/cascade.html#specificity</a></p>
<p>计算方法如下</p>
<ul>
<li>style attribute 数量 =a</li>
<li>ID attribute 数量 =b</li>
<li>其它的 attribute 和 pseudo-classes 数量 =c</li>
<li>element names 和 pseudo-element 数量 =d</li>
</ul>
<p>举个例子<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> *             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</div><div class="line"> li            &#123;&#125;  /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</div><div class="line"> li:first-line &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line"> ul li         &#123;&#125;  /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</div><div class="line"> ul ol+li      &#123;&#125;  /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</div><div class="line"> h1 + *[rel=up]&#123;&#125;  /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</div><div class="line"> ul ol li.red  &#123;&#125;  /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</div><div class="line"> li.red.level  &#123;&#125;  /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</div><div class="line"> #x34y         &#123;&#125;  /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</div><div class="line"> style=""          /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-id">#x97z</span> &#123; <span class="attribute">color</span>: red &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">BODY</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">P</span> <span class="attr">ID</span>=<span class="string">x97z</span> <span class="attr">style</span>=<span class="string">"color: green"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">BODY</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>从例子可以看出 p element 的 color 会是 green，因为 style attribute 会覆盖 Style element 里的设置，因为它有更高的 specificity。</p>
<h4 id="Rules-排序"><a href="#Rules-排序" class="headerlink" title="Rules 排序"></a>Rules 排序</h4><p>这些 rules 匹配后就需要对其排序了，WebKit 使用的是冒泡排序，通过重写 &gt; 操作符<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(CSSRuleData&amp; r1, CSSRuleData&amp; r2)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> spec1 = r1.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">int</span> spec2 = r2.selector()-&gt;specificity();</div><div class="line">    <span class="keyword">return</span> (spec1 == spec2) : r1.position() &gt; r2.position() : spec1 &gt; spec2; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Layout-布局"><a href="#Layout-布局" class="headerlink" title="Layout 布局"></a>Layout 布局</h2><p>当 renderer 创建完并添加到 tree 里时是没有位置和高这些信息的，需要计算，WebKit 计算位置大小等信息的过程称为布局计算。</p>
<p>HTML 使用的是流式布局模型，那么就表示大多数情况一次就可以按照从左到右从顶到底算出布局需要的值。需要注意的是 HTML tables 需要的次数可能不仅一次。</p>
<p>Layout 是个递归的过程，以 FrameView::layout 为起始，调用 Render Tree 根节点的 layout，对应 HTML 里的 element，Layout 持续递归 frame hierarchy 计算每个 renderer 的几何信息。root 的 position 是0,0，把浏览器里可见的部分尺寸叫做 viewport。每个 renderer 都有 layout 或 reflow 方法，每个 renderer 都会去调用子视图的 layout 方法。FrameView::layout 可以被布局 WebViewCore::layout 方法触发。</p>
<h3 id="Layout-处理过程"><a href="#Layout-处理过程" class="headerlink" title="Layout 处理过程"></a>Layout 处理过程</h3><p>完成上面那些过程后就会开始布局，上面的过程达到开始布局 FrameView::layout 的方法堆栈如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">FrameView:: layout( <span class="keyword">bool</span> allowSubtree) <span class="comment">// 栈 顶 </span></div><div class="line">Document:: implicitClose() </div><div class="line">FrameLoader:: checkCallImplicitClose() </div><div class="line">FrameLoader:: checkCompleted() </div><div class="line">FrameLoader:: finishedParsing() </div><div class="line">Document:: finishedParsing() </div><div class="line">HTMLParser:: finished() </div><div class="line">HTMLTokenizer:: end() </div><div class="line">HTMLTokenizer:: finish() </div><div class="line">Document:: finishParsing() </div><div class="line">FrameLoader:: endIfNotLoadingMainResource() </div><div class="line">FrameLoader:: end() </div><div class="line">DocumentLoader:: finishedLoading() </div><div class="line">FrameLoader:: finishedLoading() </div><div class="line">MainResourceLoader:: didFinishLoading() </div><div class="line">ResourceLoader:: didFinishLoading( WebCore:: ResourceHandle * h)</div></pre></td></tr></table></figure></p>
<p>layout 会先暂停 layout 定时器的实现，然后更新样式，获取到 RenderView 然后调用它的 layout 方法开始布局，具体相关的代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div></pre></td><td class="code"><pre><div class="line">void FrameView::layout(bool allowSubtree)</div><div class="line">&#123;</div><div class="line">    ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());</div><div class="line"></div><div class="line">    LOG(Layout, "FrameView %p (%dx%d) layout, main frameview %d, allowSubtree=%d", this, size().width(), size().height(), frame().isMainFrame(), allowSubtree);</div><div class="line">    //判断是否已在 layout 过程中，避免多次 layout</div><div class="line">    if (isInRenderTreeLayout()) &#123;</div><div class="line">        LOG(Layout, "  in layout, bailing");</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (layoutDisallowed()) &#123;</div><div class="line">        LOG(Layout, "  layout is disallowed, bailing");</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Protect the view from being deleted during layout (in recalcStyle).</div><div class="line">    Ref&lt;FrameView&gt; protectedThis(*this);</div><div class="line"></div><div class="line">    // Many of the tasks performed during layout can cause this function to be re-entered,</div><div class="line">    // so save the layout phase now and restore it on exit.</div><div class="line">    SetForScope&lt;LayoutPhase&gt; layoutPhaseRestorer(m_layoutPhase, InPreLayout);</div><div class="line"></div><div class="line">    // Every scroll that happens during layout is programmatic.</div><div class="line">    SetForScope&lt;bool&gt; changeInProgrammaticScroll(m_inProgrammaticScroll, true);</div><div class="line"></div><div class="line">    bool inChildFrameLayoutWithFrameFlattening = isInChildFrameWithFrameFlattening();</div><div class="line"></div><div class="line">    if (inChildFrameLayoutWithFrameFlattening) &#123;</div><div class="line">        if (!m_frameFlatteningViewSizeForMediaQuery) &#123;</div><div class="line">            LOG_WITH_STREAM(MediaQueries, stream &lt;&lt; "FrameView " &lt;&lt; this &lt;&lt; " snapshotting size " &lt;&lt;  ScrollView::layoutSize() &lt;&lt; " for media queries");</div><div class="line">            m_frameFlatteningViewSizeForMediaQuery = ScrollView::layoutSize();</div><div class="line">        &#125;</div><div class="line">        startLayoutAtMainFrameViewIfNeeded(allowSubtree);</div><div class="line">        //获取 root。这个 root 就是 RenderView 对象</div><div class="line">        RenderElement* root = m_layoutRoot ? m_layoutRoot : frame().document()-&gt;renderView();</div><div class="line">        if (!root || !root-&gt;needsLayout())</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    TraceScope tracingScope(LayoutStart, LayoutEnd);</div><div class="line"></div><div class="line">#if PLATFORM(IOS)</div><div class="line">    if (updateFixedPositionLayoutRect())</div><div class="line">        allowSubtree = false;</div><div class="line">#endif</div><div class="line">    //也是避免多次触发，会把 layoutTimer 先停止</div><div class="line">    m_layoutTimer.stop();</div><div class="line">    m_delayedLayout = false;</div><div class="line">    m_setNeedsLayoutWasDeferred = false;</div><div class="line">    </div><div class="line">    //我们不应该在 painting 时进入 layout</div><div class="line">    ASSERT(!isPainting());</div><div class="line">    if (isPainting())</div><div class="line">        return;</div><div class="line"></div><div class="line">    InspectorInstrumentationCookie cookie = InspectorInstrumentation::willLayout(frame());</div><div class="line">    AnimationUpdateBlock animationUpdateBlock(&amp;frame().animation());</div><div class="line">    </div><div class="line">    if (!allowSubtree &amp;&amp; m_layoutRoot)</div><div class="line">        convertSubtreeLayoutToFullLayout();</div><div class="line"></div><div class="line">    ASSERT(frame().view() == this);</div><div class="line">    ASSERT(frame().document());</div><div class="line"></div><div class="line">    Document&amp; document = *frame().document();</div><div class="line">    ASSERT(document.pageCacheState() == Document::NotInPageCache);</div><div class="line">    //对样式先进行更新</div><div class="line">    &#123;</div><div class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</div><div class="line"></div><div class="line">        if (!m_nestedLayoutCount &amp;&amp; !m_inSynchronousPostLayout &amp;&amp; m_postLayoutTasksTimer.isActive() &amp;&amp; !inChildFrameLayoutWithFrameFlattening) &#123;</div><div class="line">            // This is a new top-level layout. If there are any remaining tasks from the previous</div><div class="line">            // layout, finish them now.</div><div class="line">            SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</div><div class="line">            performPostLayoutTasks();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m_layoutPhase = InPreLayoutStyleUpdate;</div><div class="line"></div><div class="line">        // Viewport-dependent media queries may cause us to need completely different style information.</div><div class="line">        auto* styleResolver = document.styleScope().resolverIfExists();</div><div class="line">        if (!styleResolver || styleResolver-&gt;hasMediaQueriesAffectedByViewportChange()) &#123;</div><div class="line">            LOG(Layout, "  hasMediaQueriesAffectedByViewportChange, enqueueing style recalc");</div><div class="line">            document.styleScope().didChangeStyleSheetEnvironment();</div><div class="line">            // FIXME: This instrumentation event is not strictly accurate since cached media query results do not persist across StyleResolver rebuilds.</div><div class="line">            InspectorInstrumentation::mediaQueryResultChanged(document);</div><div class="line">        &#125;</div><div class="line">        document.evaluateMediaQueryList();</div><div class="line">        // If there is any pagination to apply, it will affect the RenderView's style, so we should</div><div class="line">        // take care of that now.</div><div class="line">        applyPaginationToViewport();</div><div class="line">        // Always ensure our style info is up-to-date. This can happen in situations where</div><div class="line">        // the layout beats any sort of style recalc update that needs to occur.</div><div class="line">        document.updateStyleIfNeeded();</div><div class="line">        // If there is only one ref to this view left, then its going to be destroyed as soon as we exit,</div><div class="line">        // so there's no point to continuing to layout</div><div class="line">        if (hasOneRef())</div><div class="line">            return;</div><div class="line"></div><div class="line">        // Close block here so we can set up the font cache purge preventer, which we will still</div><div class="line">        // want in scope even after we want m_layoutSchedulingEnabled to be restored again.</div><div class="line">        // The next block sets m_layoutSchedulingEnabled back to false once again.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InPreLayout;</div><div class="line"></div><div class="line">    RenderLayer* layer = nullptr;</div><div class="line">    bool subtree = false;</div><div class="line">    RenderElement* root = nullptr;</div><div class="line"></div><div class="line">    ++m_nestedLayoutCount;</div><div class="line"></div><div class="line">    &#123;</div><div class="line">        SetForScope&lt;bool&gt; changeSchedulingEnabled(m_layoutSchedulingEnabled, false);</div><div class="line"></div><div class="line">        autoSizeIfEnabled();</div><div class="line">        //重新设置 RenderView 对象，准备开始 layout</div><div class="line">        root = m_layoutRoot ? m_layoutRoot : document.renderView();</div><div class="line">        if (!root)</div><div class="line">            return;</div><div class="line">        subtree = m_layoutRoot;</div><div class="line"></div><div class="line">        if (!m_layoutRoot) &#123;</div><div class="line">            auto* body = document.bodyOrFrameset();</div><div class="line">            if (body &amp;&amp; body-&gt;renderer()) &#123;</div><div class="line">                if (is&lt;HTMLFrameSetElement&gt;(*body) &amp;&amp; !frameFlatteningEnabled()) &#123;</div><div class="line">                    body-&gt;renderer()-&gt;setChildNeedsLayout();</div><div class="line">                &#125; else if (is&lt;HTMLBodyElement&gt;(*body)) &#123;</div><div class="line">                    if (!m_firstLayout &amp;&amp; m_size.height() != layoutHeight() &amp;&amp; body-&gt;renderer()-&gt;enclosingBox().stretchesToViewport())</div><div class="line">                        body-&gt;renderer()-&gt;setChildNeedsLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">#if !LOG_DISABLED</div><div class="line">            if (m_firstLayout &amp;&amp; !frame().ownerElement())</div><div class="line">                LOG(Layout, "FrameView %p elapsed time before first layout: %.3fs\n", this, document.timeSinceDocumentCreation().value());</div><div class="line">#endif</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        m_needsFullRepaint = !subtree &amp;&amp; (m_firstLayout || downcast&lt;RenderView&gt;(*root).printing());</div><div class="line"></div><div class="line">        if (!subtree) &#123;</div><div class="line">            ScrollbarMode hMode;</div><div class="line">            ScrollbarMode vMode;    </div><div class="line">            calculateScrollbarModesForLayout(hMode, vMode);</div><div class="line"></div><div class="line">            if (m_firstLayout || (hMode != horizontalScrollbarMode() || vMode != verticalScrollbarMode())) &#123;</div><div class="line">                if (m_firstLayout) &#123;</div><div class="line">                    setScrollbarsSuppressed(true);</div><div class="line"></div><div class="line">                    m_firstLayout = false;</div><div class="line">                    m_firstLayoutCallbackPending = true;</div><div class="line">                    m_lastViewportSize = sizeForResizeEvent();</div><div class="line">                    m_lastZoomFactor = root-&gt;style().zoom();</div><div class="line"></div><div class="line">                    // Set the initial vMode to AlwaysOn if we're auto.</div><div class="line">                    if (vMode == ScrollbarAuto)</div><div class="line">                        setVerticalScrollbarMode(ScrollbarAlwaysOn); // This causes a vertical scrollbar to appear.</div><div class="line">                    // Set the initial hMode to AlwaysOff if we're auto.</div><div class="line">                    if (hMode == ScrollbarAuto)</div><div class="line">                        setHorizontalScrollbarMode(ScrollbarAlwaysOff); // This causes a horizontal scrollbar to disappear.</div><div class="line">                    Page* page = frame().page();</div><div class="line">                    if (page &amp;&amp; page-&gt;expectsWheelEventTriggers())</div><div class="line">                        scrollAnimator().setWheelEventTestTrigger(page-&gt;testTrigger());</div><div class="line">                    setScrollbarModes(hMode, vMode);</div><div class="line">                    setScrollbarsSuppressed(false, true);</div><div class="line">                &#125; else</div><div class="line">                    setScrollbarModes(hMode, vMode);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            LayoutSize oldSize = m_size;</div><div class="line">            m_size = layoutSize();</div><div class="line"></div><div class="line">            if (oldSize != m_size) &#123;</div><div class="line">                LOG(Layout, "  layout size changed from %.3fx%.3f to %.3fx%.3f", oldSize.width().toFloat(), oldSize.height().toFloat(), m_size.width().toFloat(), m_size.height().toFloat());</div><div class="line">                m_needsFullRepaint = true;</div><div class="line">                if (!m_firstLayout) &#123;</div><div class="line">                    RenderBox* rootRenderer = document.documentElement() ? document.documentElement()-&gt;renderBox() : nullptr;</div><div class="line">                    auto* body = document.bodyOrFrameset();</div><div class="line">                    RenderBox* bodyRenderer = rootRenderer &amp;&amp; body ? body-&gt;renderBox() : nullptr;</div><div class="line">                    if (bodyRenderer &amp;&amp; bodyRenderer-&gt;stretchesToViewport())</div><div class="line">                        bodyRenderer-&gt;setChildNeedsLayout();</div><div class="line">                    else if (rootRenderer &amp;&amp; rootRenderer-&gt;stretchesToViewport())</div><div class="line">                        rootRenderer-&gt;setChildNeedsLayout();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            m_layoutPhase = InPreLayout;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        layer = root-&gt;enclosingLayer();</div><div class="line">        SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(m_layoutRoot);</div><div class="line"></div><div class="line">        RenderView::RepaintRegionAccumulator repaintRegionAccumulator(&amp;root-&gt;view());</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InPreLayout);</div><div class="line">        m_layoutPhase = InRenderTreeLayout;</div><div class="line"></div><div class="line">        forceLayoutParentViewIfNeeded();</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</div><div class="line">#ifndef NDEBUG</div><div class="line">        RenderTreeNeedsLayoutChecker checker(*root);</div><div class="line">#endif</div><div class="line">        //从 RenderView 这个根级开始进行 layout。</div><div class="line">        root-&gt;layout();</div><div class="line">        ASSERT(!root-&gt;view().renderTreeIsBeingMutatedInternally());</div><div class="line"></div><div class="line">#if ENABLE(TEXT_AUTOSIZING)</div><div class="line">        if (frame().settings().textAutosizingEnabled() &amp;&amp; !root-&gt;view().printing()) &#123;</div><div class="line">            float minimumZoomFontSize = frame().settings().minimumZoomFontSize();</div><div class="line">            float textAutosizingWidth = frame().page() ? frame().page()-&gt;textAutosizingWidth() : 0;</div><div class="line">            if (int overrideWidth = frame().settings().textAutosizingWindowSizeOverride().width())</div><div class="line">                textAutosizingWidth = overrideWidth;</div><div class="line"></div><div class="line">            LOG(TextAutosizing, "Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f", minimumZoomFontSize, textAutosizingWidth);</div><div class="line">            </div><div class="line">            if (minimumZoomFontSize &amp;&amp; textAutosizingWidth) &#123;</div><div class="line">                root-&gt;adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);</div><div class="line">                if (root-&gt;needsLayout())</div><div class="line">                    root-&gt;layout();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">        ASSERT(m_layoutPhase == InRenderTreeLayout);</div><div class="line">        m_layoutRoot = nullptr;</div><div class="line">        // Close block here to end the scope of changeSchedulingEnabled and SubtreeLayoutStateMaintainer.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InViewSizeAdjust;</div><div class="line"></div><div class="line">    bool neededFullRepaint = m_needsFullRepaint;</div><div class="line"></div><div class="line">    if (!subtree &amp;&amp; !downcast&lt;RenderView&gt;(*root).printing()) &#123;</div><div class="line">        adjustViewSize();</div><div class="line">        // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by</div><div class="line">        // navigating away from the current document (see webkit.org/b/173329).</div><div class="line">        if (hasOneRef())</div><div class="line">            return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_layoutPhase = InPostLayout;</div><div class="line"></div><div class="line">    m_needsFullRepaint = neededFullRepaint;</div><div class="line"></div><div class="line">    // Now update the positions of all layers.</div><div class="line">    if (m_needsFullRepaint)</div><div class="line">        root-&gt;view().repaintRootContents();</div><div class="line"></div><div class="line">    root-&gt;view().releaseProtectedRenderWidgets();</div><div class="line"></div><div class="line">    ASSERT(!root-&gt;needsLayout());</div><div class="line"></div><div class="line">    layer-&gt;updateLayerPositionsAfterLayout(renderView()-&gt;layer(), updateLayerPositionFlags(layer, subtree, m_needsFullRepaint));</div><div class="line"></div><div class="line">    updateCompositingLayersAfterLayout();</div><div class="line"></div><div class="line">    m_layoutPhase = InPostLayerPositionsUpdatedAfterLayout;</div><div class="line"></div><div class="line">    m_layoutCount++;</div><div class="line"></div><div class="line">#if PLATFORM(COCOA) || PLATFORM(WIN) || PLATFORM(GTK)</div><div class="line">    if (AXObjectCache* cache = root-&gt;document().existingAXObjectCache())</div><div class="line">        cache-&gt;postNotification(root, AXObjectCache::AXLayoutComplete);</div><div class="line">#endif</div><div class="line"></div><div class="line">#if ENABLE(DASHBOARD_SUPPORT)</div><div class="line">    updateAnnotatedRegions();</div><div class="line">#endif</div><div class="line"></div><div class="line">#if ENABLE(IOS_TOUCH_EVENTS)</div><div class="line">    document.setTouchEventRegionsNeedUpdate();</div><div class="line">#endif</div><div class="line"></div><div class="line">    updateCanBlitOnScrollRecursively();</div><div class="line"></div><div class="line">    handleDeferredScrollUpdateAfterContentSizeChange();</div><div class="line"></div><div class="line">    handleDeferredScrollbarsUpdateAfterDirectionChange();</div><div class="line"></div><div class="line">    if (document.hasListenerType(Document::OVERFLOWCHANGED_LISTENER))</div><div class="line">        updateOverflowStatus(layoutWidth() &lt; contentsWidth(), layoutHeight() &lt; contentsHeight());</div><div class="line"></div><div class="line">    frame().document()-&gt;markers().invalidateRectsForAllMarkers();</div><div class="line"></div><div class="line">    if (!m_postLayoutTasksTimer.isActive()) &#123;</div><div class="line">        if (!m_inSynchronousPostLayout) &#123;</div><div class="line">            if (inChildFrameLayoutWithFrameFlattening)</div><div class="line">                updateWidgetPositions();</div><div class="line">            else &#123;</div><div class="line">                SetForScope&lt;bool&gt; inSynchronousPostLayoutChange(m_inSynchronousPostLayout, true);</div><div class="line">                performPostLayoutTasks(); // Calls resumeScheduledEvents().</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (!m_postLayoutTasksTimer.isActive() &amp;&amp; (needsLayout() || m_inSynchronousPostLayout || inChildFrameLayoutWithFrameFlattening)) &#123;</div><div class="line">            // If we need layout or are already in a synchronous call to postLayoutTasks(), </div><div class="line">            // defer widget updates and event dispatch until after we return. postLayoutTasks()</div><div class="line">            // can make us need to update again, and we can get stuck in a nasty cycle unless</div><div class="line">            // we call it through the timer here.</div><div class="line">            m_postLayoutTasksTimer.startOneShot(0_s);</div><div class="line">        &#125;</div><div class="line">        if (needsLayout())</div><div class="line">            layout();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    InspectorInstrumentation::didLayout(cookie, *root);</div><div class="line">    DebugPageOverlays::didLayout(frame());</div><div class="line"></div><div class="line">    --m_nestedLayoutCount;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RenderView 的 layout 里会调用 layoutContent 方法。这个方法的实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RenderView::layoutContent(<span class="keyword">const</span> LayoutState&amp; state)</div><div class="line">&#123;</div><div class="line">    UNUSED_PARAM(state);</div><div class="line">    ASSERT(needsLayout());</div><div class="line"></div><div class="line">    RenderBlockFlow::layout();</div><div class="line">    <span class="keyword">if</span> (hasRenderNamedFlowThreads())</div><div class="line">        flowThreadController().layoutRenderNamedFlowThreads();</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></div><div class="line">    checkLayoutState(state);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现这个方法实现很简单，里面主要是通过 RenderBlockFlow 来进行 layout 的。RenderBlockFlow 是 RenderBlock 的子类，layout 方法是在 RenderBlock 里实现，里面直接调了 layoutBlock 方法，这个方法是在 RenderBlockFlow 里重载实现的。下面看看 RenderBlockFlow 的实现吧：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div></pre></td><td class="code"><pre><div class="line">void RenderBlockFlow::layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight)</div><div class="line">&#123;</div><div class="line">    ASSERT(needsLayout());</div><div class="line">    //当不需要布局子节点同时能 simplifiedLayout 重新布局成功</div><div class="line">    if (!relayoutChildren &amp;&amp; simplifiedLayout())</div><div class="line">        return;</div><div class="line"></div><div class="line">    LayoutRepainter repainter(*this, checkForRepaintDuringLayout());</div><div class="line">    //重新计算逻辑宽度</div><div class="line">    if (recomputeLogicalWidthAndColumnWidth())</div><div class="line">        relayoutChildren = true;</div><div class="line"></div><div class="line">    rebuildFloatingObjectSetFromIntrudingFloats();</div><div class="line"></div><div class="line">    //先保留一份以前的高度为后面做对比用</div><div class="line">    LayoutUnit previousHeight = logicalHeight();</div><div class="line">    // FIXME: should this start out as borderAndPaddingLogicalHeight() + scrollbarLogicalHeight(),</div><div class="line">    // for consistency with other render classes?</div><div class="line">    //然后将 logicalHeight 设置为 0，避免累加以前的。</div><div class="line">    setLogicalHeight(0);</div><div class="line"></div><div class="line">    bool pageLogicalHeightChanged = false;</div><div class="line">    checkForPaginationLogicalHeightChange(relayoutChildren, pageLogicalHeight, pageLogicalHeightChanged);</div><div class="line"></div><div class="line">    const RenderStyle&amp; styleToUse = style();</div><div class="line">    LayoutStateMaintainer statePusher(view(), *this, locationOffset(), hasTransform() || hasReflection() || styleToUse.isFlippedBlocksWritingMode(), pageLogicalHeight, pageLogicalHeightChanged);</div><div class="line"></div><div class="line">    preparePaginationBeforeBlockLayout(relayoutChildren);</div><div class="line">    if (!relayoutChildren)</div><div class="line">        relayoutChildren = namedFlowFragmentNeedsUpdate();</div><div class="line"></div><div class="line">    // We use four values, maxTopPos, maxTopNeg, maxBottomPos, and maxBottomNeg, to track</div><div class="line">    // our current maximal positive and negative margins. These values are used when we</div><div class="line">    // are collapsed with adjacent blocks, so for example, if you have block A and B</div><div class="line">    // collapsing together, then you'd take the maximal positive margin from both A and B</div><div class="line">    // and subtract it from the maximal negative margin from both A and B to get the</div><div class="line">    // true collapsed margin. This algorithm is recursive, so when we finish layout()</div><div class="line">    // our block knows its current maximal positive/negative values.</div><div class="line">    //</div><div class="line">    // Start out by setting our margin values to our current margins. Table cells have</div><div class="line">    // no margins, so we don't fill in the values for table cells.</div><div class="line">    bool isCell = isTableCell();</div><div class="line">    if (!isCell) &#123;</div><div class="line">        initMaxMarginValues();</div><div class="line">        </div><div class="line">        setHasMarginBeforeQuirk(styleToUse.hasMarginBeforeQuirk());</div><div class="line">        setHasMarginAfterQuirk(styleToUse.hasMarginAfterQuirk());</div><div class="line">        setPaginationStrut(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    LayoutUnit repaintLogicalTop = 0;</div><div class="line">    LayoutUnit repaintLogicalBottom = 0;</div><div class="line">    LayoutUnit maxFloatLogicalBottom = 0;</div><div class="line">    if (!firstChild() &amp;&amp; !isAnonymousBlock())</div><div class="line">        setChildrenInline(true);</div><div class="line">    //Inline 和 Block 的不同布局处理</div><div class="line">    if (childrenInline())</div><div class="line">        layoutInlineChildren(relayoutChildren, repaintLogicalTop, repaintLogicalBottom);</div><div class="line">    else</div><div class="line">        layoutBlockChildren(relayoutChildren, maxFloatLogicalBottom);</div><div class="line"></div><div class="line">    // Expand our intrinsic height to encompass floats.</div><div class="line">    LayoutUnit toAdd = borderAndPaddingAfter() + scrollbarLogicalHeight();</div><div class="line">    if (lowestFloatLogicalBottom() &gt; (logicalHeight() - toAdd) &amp;&amp; createsNewFormattingContext())</div><div class="line">        setLogicalHeight(lowestFloatLogicalBottom() + toAdd);</div><div class="line">    </div><div class="line">    if (relayoutForPagination(statePusher) || relayoutToAvoidWidows(statePusher)) &#123;</div><div class="line">        ASSERT(!shouldBreakAtLineToAvoidWidow());</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Calculate our new height. 计算新高</div><div class="line">    LayoutUnit oldHeight = logicalHeight();</div><div class="line">    LayoutUnit oldClientAfterEdge = clientLogicalBottom();</div><div class="line"></div><div class="line">    // Before updating the final size of the flow thread make sure a forced break is applied after the content.</div><div class="line">    // This ensures the size information is correctly computed for the last auto-height region receiving content.</div><div class="line">    if (is&lt;RenderFlowThread&gt;(*this))</div><div class="line">        downcast&lt;RenderFlowThread&gt;(*this).applyBreakAfterContent(oldClientAfterEdge);</div><div class="line"></div><div class="line">    updateLogicalHeight();</div><div class="line">    LayoutUnit newHeight = logicalHeight();</div><div class="line">    if (oldHeight != newHeight) &#123;</div><div class="line">        if (oldHeight &gt; newHeight &amp;&amp; maxFloatLogicalBottom &gt; newHeight &amp;&amp; !childrenInline()) &#123;</div><div class="line">            // One of our children's floats may have become an overhanging float for us. We need to look for it.</div><div class="line">            for (auto&amp; blockFlow : childrenOfType&lt;RenderBlockFlow&gt;(*this)) &#123;</div><div class="line">                if (blockFlow.isFloatingOrOutOfFlowPositioned())</div><div class="line">                    continue;</div><div class="line">                if (blockFlow.lowestFloatLogicalBottom() + blockFlow.logicalTop() &gt; newHeight)</div><div class="line">                    addOverhangingFloats(blockFlow, false);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //前面保留的先前高度和重新计算后的高度比较有变化就重新布局子结点</div><div class="line">    bool heightChanged = (previousHeight != newHeight);</div><div class="line">    if (heightChanged)</div><div class="line">        relayoutChildren = true;</div><div class="line"></div><div class="line">    layoutPositionedObjects(relayoutChildren || isDocumentElementRenderer());</div><div class="line"></div><div class="line">    //Add overflow from children (unless we're multi-column, since in that case all our child overflow is clipped anyway).</div><div class="line">    computeOverflow(oldClientAfterEdge);</div><div class="line">    </div><div class="line">    statePusher.pop();</div><div class="line"></div><div class="line">    fitBorderToLinesIfNeeded();</div><div class="line"></div><div class="line">    if (view().layoutState()-&gt;m_pageLogicalHeight)</div><div class="line">        setPageLogicalOffset(view().layoutState()-&gt;pageLogicalOffset(this, logicalTop()));</div><div class="line"></div><div class="line">    updateLayerTransform();</div><div class="line"></div><div class="line">    // Update our scroll information if we're overflow:auto/scroll/hidden now that we know if</div><div class="line">    // we overflow or not.</div><div class="line">    updateScrollInfoAfterLayout();</div><div class="line"></div><div class="line">    // FIXME: This repaint logic should be moved into a separate helper function!</div><div class="line">    // Repaint with our new bounds if they are different from our old bounds.</div><div class="line">    bool didFullRepaint = repainter.repaintAfterLayout();</div><div class="line">    if (!didFullRepaint &amp;&amp; repaintLogicalTop != repaintLogicalBottom &amp;&amp; (styleToUse.visibility() == VISIBLE || enclosingLayer()-&gt;hasVisibleContent())) &#123;</div><div class="line">        // FIXME: We could tighten up the left and right invalidation points if we let layoutInlineChildren fill them in based off the particular lines</div><div class="line">        // it had to lay out. We wouldn't need the hasOverflowClip() hack in that case either.</div><div class="line">        LayoutUnit repaintLogicalLeft = logicalLeftVisualOverflow();</div><div class="line">        LayoutUnit repaintLogicalRight = logicalRightVisualOverflow();</div><div class="line">        if (hasOverflowClip()) &#123;</div><div class="line">            // If we have clipped overflow, we should use layout overflow as well, since visual overflow from lines didn't propagate to our block's overflow.</div><div class="line">            // Note the old code did this as well but even for overflow:visible. The addition of hasOverflowClip() at least tightens up the hack a bit.</div><div class="line">            // layoutInlineChildren should be patched to compute the entire repaint rect.</div><div class="line">            repaintLogicalLeft = std::min(repaintLogicalLeft, logicalLeftLayoutOverflow());</div><div class="line">            repaintLogicalRight = std::max(repaintLogicalRight, logicalRightLayoutOverflow());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        LayoutRect repaintRect;</div><div class="line">        if (isHorizontalWritingMode())</div><div class="line">            repaintRect = LayoutRect(repaintLogicalLeft, repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop);</div><div class="line">        else</div><div class="line">            repaintRect = LayoutRect(repaintLogicalTop, repaintLogicalLeft, repaintLogicalBottom - repaintLogicalTop, repaintLogicalRight - repaintLogicalLeft);</div><div class="line"></div><div class="line">        if (hasOverflowClip()) &#123;</div><div class="line">            // Adjust repaint rect for scroll offset</div><div class="line">            repaintRect.moveBy(-scrollPosition());</div><div class="line"></div><div class="line">            // Don't allow this rect to spill out of our overflow box.</div><div class="line">            repaintRect.intersect(LayoutRect(LayoutPoint(), size()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Make sure the rect is still non-empty after intersecting for overflow above</div><div class="line">        if (!repaintRect.isEmpty()) &#123;</div><div class="line">            repaintRectangle(repaintRect); // We need to do a partial repaint of our content.</div><div class="line">            if (hasReflection())</div><div class="line">                repaintRectangle(reflectedRect(repaintRect));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clearNeedsLayout();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上方法里有两个分支，一个是 layoutInlineChildren 一个是 layoutBlockChildren。由于 Inline 属于动态调整高度所以比 Block 的实现要负责很多，layoutInlineChildren 方式是 Inline 布局的入口。</p>
<h3 id="Layout-Tree-创建"><a href="#Layout-Tree-创建" class="headerlink" title="Layout Tree 创建"></a>Layout Tree 创建</h3><p>Parsing 完成会触发 Layout Tree。Layout Tree 的目的就是存储需要绘制的数据，Layout 就是处理 Nodes 在页面上的大小和位置。Chrome，firefox和 android 使用的是<a href="https://skia.org/" target="_blank" rel="external">Skia</a> 开源 2D 图形库做底层 Paint 引擎。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Document::finishedParsing() &#123;</div><div class="line">      updateStyleAndLayoutTree();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个 Node 都会创建一个 LayoutObject，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LayoutObject* newLayoutObject = m_node-&gt;createLayoutObject(style);</div><div class="line">parentLayoutObject-&gt;addChild(newLayoutObject, nextLayoutObject);</div></pre></td></tr></table></figure></p>
<h3 id="Layout-值的计算"><a href="#Layout-值的计算" class="headerlink" title="Layout 值的计算"></a>Layout 值的计算</h3><p>Layout Tree 创建完成就开始计算 layout 的值，比如宽，margin 等。Block 类型节点的位置计算实现是在 RenderBlock 里的 layoutBlockChild 方法里实现的，该方法主要是先确定节点的 top 坐标，然后计算布局变化后 margin，float 和 分页等对 top 值的影响确定影响后的 top 坐标，最后使用 determineLogicalLeftPositionForChild 得到 left 坐标。具体实现如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> RenderBlockFlow::layoutBlockChild(RenderBox&amp; child, MarginInfo&amp; marginInfo, LayoutUnit&amp; previousFloatLogicalBottom, LayoutUnit&amp; maxFloatLogicalBottom)</div><div class="line">&#123;</div><div class="line">    LayoutUnit oldPosMarginBefore = maxPositiveMarginBefore();</div><div class="line">    LayoutUnit oldNegMarginBefore = maxNegativeMarginBefore();</div><div class="line"></div><div class="line">    <span class="comment">// The child is a normal flow object. Compute the margins we will use for collapsing now.</span></div><div class="line">    child.computeAndSetBlockDirectionMargins(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Try to guess our correct logical top position. In most cases this guess will</span></div><div class="line">    <span class="comment">// be correct. Only if we're wrong (when we compute the real logical top position)</span></div><div class="line">    <span class="comment">// will we have to potentially relayout.</span></div><div class="line">    LayoutUnit estimateWithoutPagination;</div><div class="line">    <span class="comment">//估算 top 坐标，estimateLogicalTopPosition 会先获取 RenderBlock 的高来作为初始的 top，再根据 margin 分页和 float 来调整 top 坐标</span></div><div class="line">    LayoutUnit logicalTopEstimate = estimateLogicalTopPosition(child, marginInfo, estimateWithoutPagination);</div><div class="line"></div><div class="line">    <span class="comment">// Cache our old rect so that we can dirty the proper repaint rects if the child moves.</span></div><div class="line">    LayoutRect oldRect = child.frameRect();</div><div class="line">    LayoutUnit oldLogicalTop = logicalTopForChild(child);</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> !ASSERT_DISABLED</span></div><div class="line">    LayoutSize oldLayoutDelta = view().layoutDelta();</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// Position the child as though it didn't collapse with the top.</span></div><div class="line">    <span class="comment">//先设置布局前 top 坐标</span></div><div class="line">    setLogicalTopForChild(child, logicalTopEstimate, ApplyLayoutDelta);</div><div class="line">    estimateRegionRangeForBoxChild(child);</div><div class="line"></div><div class="line">    RenderBlockFlow* childBlockFlow = is&lt;RenderBlockFlow&gt;(child) ? &amp;downcast&lt;RenderBlockFlow&gt;(child) : <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">bool</span> markDescendantsWithFloats = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (logicalTopEstimate != oldLogicalTop &amp;&amp; !child.avoidsFloats() &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">        markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (UNLIKELY(logicalTopEstimate.mightBeSaturated()))</div><div class="line">        <span class="comment">// logicalTopEstimate, returned by estimateLogicalTopPosition, might be saturated for</span></div><div class="line">        <span class="comment">// very large elements. If it does the comparison with oldLogicalTop might yield a</span></div><div class="line">        <span class="comment">// false negative as adding and removing margins, borders etc from a saturated number</span></div><div class="line">        <span class="comment">// might yield incorrect results. If this is the case always mark for layout.</span></div><div class="line">        markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!child.avoidsFloats() || child.shrinkToAvoidFloats()) &#123;</div><div class="line">        <span class="comment">// If an element might be affected by the presence of floats, then always mark it for</span></div><div class="line">        <span class="comment">// layout.</span></div><div class="line">        LayoutUnit fb = <span class="built_in">std</span>::max(previousFloatLogicalBottom, lowestFloatLogicalBottom());</div><div class="line">        <span class="keyword">if</span> (fb &gt; logicalTopEstimate)</div><div class="line">            markDescendantsWithFloats = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (childBlockFlow) &#123;</div><div class="line">        <span class="keyword">if</span> (markDescendantsWithFloats)</div><div class="line">            childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</div><div class="line">        <span class="keyword">if</span> (!child.isWritingModeRoot())</div><div class="line">            previousFloatLogicalBottom = <span class="built_in">std</span>::max(previousFloatLogicalBottom, oldLogicalTop + childBlockFlow-&gt;lowestFloatLogicalBottom());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    child.markForPaginationRelayoutIfNeeded();</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> childHadLayout = child.everHadLayout();</div><div class="line">    <span class="comment">//对子节点进行布局</span></div><div class="line">    <span class="keyword">bool</span> childNeededLayout = child.needsLayout();</div><div class="line">    <span class="keyword">if</span> (childNeededLayout)</div><div class="line">        child.layout();</div><div class="line"></div><div class="line">    <span class="comment">// Cache if we are at the top of the block right now.</span></div><div class="line">    <span class="keyword">bool</span> atBeforeSideOfBlock = marginInfo.atBeforeSideOfBlock();</div><div class="line"></div><div class="line">    <span class="comment">//保证 top 坐标和子节点布局后能够同步</span></div><div class="line">    <span class="comment">// Now determine the correct ypos based off examination of collapsing margin</span></div><div class="line">    <span class="comment">// values.</span></div><div class="line">    LayoutUnit logicalTopBeforeClear = collapseMargins(child, marginInfo);</div><div class="line"></div><div class="line">    <span class="comment">// Now check for clear.</span></div><div class="line">    LayoutUnit logicalTopAfterClear = clearFloatsIfNeeded(child, marginInfo, oldPosMarginBefore, oldNegMarginBefore, logicalTopBeforeClear);</div><div class="line">    </div><div class="line">    <span class="keyword">bool</span> paginated = view().layoutState()-&gt;isPaginated();</div><div class="line">    <span class="keyword">if</span> (paginated)</div><div class="line">        logicalTopAfterClear = adjustBlockChildForPagination(logicalTopAfterClear, estimateWithoutPagination, child, atBeforeSideOfBlock &amp;&amp; logicalTopBeforeClear == logicalTopAfterClear);</div><div class="line"></div><div class="line">    <span class="comment">//经过上面的子节点布局完后重新计算得到新高</span></div><div class="line">    setLogicalTopForChild(child, logicalTopAfterClear, ApplyLayoutDelta);</div><div class="line"></div><div class="line">    <span class="comment">// Now we have a final top position. See if it really does end up being different from our estimate.</span></div><div class="line">    <span class="comment">// clearFloatsIfNeeded can also mark the child as needing a layout even though we didn't move. This happens</span></div><div class="line">    <span class="comment">// when collapseMargins dynamically adds overhanging floats because of a child with negative margins.</span></div><div class="line">    <span class="keyword">if</span> (logicalTopAfterClear != logicalTopEstimate || child.needsLayout() || (paginated &amp;&amp; childBlockFlow &amp;&amp; childBlockFlow-&gt;shouldBreakAtLineToAvoidWidow())) &#123;</div><div class="line">        <span class="keyword">if</span> (child.shrinkToAvoidFloats()) &#123;</div><div class="line">            <span class="comment">// The child's width depends on the line width. When the child shifts to clear an item, its width can</span></div><div class="line">            <span class="comment">// change (because it has more available line width). So mark the item as dirty.</span></div><div class="line">            child.setChildNeedsLayout(MarkOnlyThis);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (childBlockFlow) &#123;</div><div class="line">            <span class="keyword">if</span> (!child.avoidsFloats() &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">                childBlockFlow-&gt;markAllDescendantsWithFloatsForLayout();</div><div class="line">            child.markForPaginationRelayoutIfNeeded();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (updateRegionRangeForBoxChild(child))</div><div class="line">        child.setNeedsLayout(MarkOnlyThis);</div><div class="line"></div><div class="line">    <span class="comment">// In case our guess was wrong, relayout the child.</span></div><div class="line">    child.layoutIfNeeded();</div><div class="line"></div><div class="line">    <span class="comment">// We are no longer at the top of the block if we encounter a non-empty child.  </span></div><div class="line">    <span class="comment">// This has to be done after checking for clear, so that margins can be reset if a clear occurred.</span></div><div class="line">    <span class="keyword">if</span> (marginInfo.atBeforeSideOfBlock() &amp;&amp; !child.isSelfCollapsingBlock())</div><div class="line">        marginInfo.setAtBeforeSideOfBlock(<span class="literal">false</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Now place the child in the correct left position</span></div><div class="line">    <span class="comment">//计算获得 left 坐标。determineLogicalLeftPositionForChild 会先去计算 border-left 和 padding-left 然后计算 margin-left 来确定 left 坐标。最后通过 setLogicalLeftForChild 将确认的 left 坐标记录下。</span></div><div class="line">    determineLogicalLeftPositionForChild(child, ApplyLayoutDelta);</div><div class="line"></div><div class="line">    <span class="comment">// Update our height now that the child has been placed in the correct position.</span></div><div class="line">    setLogicalHeight(logicalHeight() + logicalHeightForChildForFragmentation(child));</div><div class="line">    <span class="keyword">if</span> (mustSeparateMarginAfterForChild(child)) &#123;</div><div class="line">        setLogicalHeight(logicalHeight() + marginAfterForChild(child));</div><div class="line">        marginInfo.clearMargin();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// If the child has overhanging floats that intrude into following siblings (or possibly out</span></div><div class="line">    <span class="comment">// of this block), then the parent gets notified of the floats now.</span></div><div class="line">    <span class="keyword">if</span> (childBlockFlow &amp;&amp; childBlockFlow-&gt;containsFloats())</div><div class="line">        maxFloatLogicalBottom = <span class="built_in">std</span>::max(maxFloatLogicalBottom, addOverhangingFloats(*childBlockFlow, !childNeededLayout));</div><div class="line"></div><div class="line">    LayoutSize childOffset = child.location() - oldRect.location();</div><div class="line">    <span class="keyword">if</span> (childOffset.width() || childOffset.height()) &#123;</div><div class="line">        view().addLayoutDelta(childOffset);</div><div class="line"></div><div class="line">        <span class="comment">// If the child moved, we have to repaint it as well as any floating/positioned</span></div><div class="line">        <span class="comment">// descendants. An exception is if we need a layout. In this case, we know we're going to</span></div><div class="line">        <span class="comment">// repaint ourselves (and the child) anyway.</span></div><div class="line">        <span class="keyword">if</span> (childHadLayout &amp;&amp; !selfNeedsLayout() &amp;&amp; child.checkForRepaintDuringLayout())</div><div class="line">            child.repaintDuringLayoutIfMoved(oldRect);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//渲染</span></div><div class="line">    <span class="keyword">if</span> (!childHadLayout &amp;&amp; child.checkForRepaintDuringLayout()) &#123;</div><div class="line">        child.repaint();</div><div class="line">        child.repaintOverhangingFloats(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (paginated) &#123;</div><div class="line">        <span class="keyword">if</span> (RenderFlowThread* flowThread = flowThreadContainingBlock())</div><div class="line">            flowThread-&gt;flowThreadDescendantBoxLaidOut(&amp;child);</div><div class="line">        <span class="comment">// Check for an after page/column break.</span></div><div class="line">        LayoutUnit newHeight = applyAfterBreak(child, logicalHeight(), marginInfo);</div><div class="line">        <span class="keyword">if</span> (newHeight != height())</div><div class="line">            setLogicalHeight(newHeight);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ASSERT(view().layoutDeltaMatches(oldLayoutDelta));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>判断值的类型是固定值还是百分比的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (length.type()) &#123;</div><div class="line">  <span class="keyword">case</span> Fixed:</div><div class="line">    <span class="keyword">return</span> LayoutUnit(length.value()); <span class="comment">//返回 LayoutUnit 封装的数据 1px = 1 &lt;&lt; 6 = 64 unit</span></div><div class="line">  <span class="keyword">case</span> Percent:</div><div class="line">    <span class="comment">//maximumValue 是传进来的最大值</span></div><div class="line">    <span class="keyword">return</span> LayoutUnit(</div><div class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(maximumValue * length.percent() / <span class="number">100.0f</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>计算 margin 的值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CSS 2.1: "If both 'margin-left' and 'margin-right' are 'auto', their used</span></div><div class="line"><span class="comment">// values are equal. This horizontally centers the element with respect to</span></div><div class="line"><span class="comment">// the edges of the containing block."</span></div><div class="line"><span class="keyword">const</span> ComputedStyle&amp; containingBlockStyle = containingBlock-&gt;styleRef();</div><div class="line"><span class="keyword">if</span> (marginStartLength.isAuto() &amp;&amp; marginEndLength.isAuto()) &#123;</div><div class="line">  LayoutUnit centeredMarginBoxStart = <span class="built_in">std</span>::max(</div><div class="line">      LayoutUnit(),</div><div class="line">      (availableWidth - childWidth) / <span class="number">2</span>); </div><div class="line">  marginStart = centeredMarginBoxStart;</div><div class="line">  marginEnd = availableWidth - childWidth - marginStart;</div><div class="line">  <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Box Model 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m_frameRect.setWidth(width);</div><div class="line">m_marginBox.setStart(marginLeft);</div></pre></td></tr></table></figure></p>
<p>经过计算后的 Render Tree 具有布局信息，比如下面的 html 代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First line.<span class="tag">&lt;<span class="name">br</span>&gt;</span>Second one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>布局计算后带布局信息的 Render Tree 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RenderBlock &#123;HTML&#125; at (0, 0) size 640x480 </div><div class="line">|—— RenderBody &#123;BODY&#125; at (0, 80) size 640x480 [bgcolor=# FFFFFF] </div><div class="line">| |—— RenderBlock &#123;P&#125; at (0, 0) size 640x80 </div><div class="line">| | |—— RenderText &#123;#text&#125; at (0, 0) size 48x24 &quot;First line.&quot; </div><div class="line">| | |—— RenderBR &#123;BR&#125; at (20, 20) size 0x0 </div><div class="line">| | |—— RenderText &#123;#text&#125; at (0, 24) size 48x24 &quot;Second one.&quot;</div></pre></td></tr></table></figure></p>
<h3 id="Box-Model-数据结构"><a href="#Box-Model-数据结构" class="headerlink" title="Box Model 数据结构"></a>Box Model 数据结构</h3><p><img src="/uploads/deeply-analyse-webkit/16.png" alt="16"><br>所有的 elements 都有 display 属性用来确定显示类型。属性值有</p>
<ul>
<li>block：生成一个 block box</li>
<li>inline：生成一个或多个 inline boxes</li>
<li>none：不生成 box</li>
</ul>
<p>默认是 inline 的，但是浏览器会设置其它默认值，比如说 div 就是 block 的，完整的定义可以参看 w3c 定义的：<a href="http://www.w3.org/TR/CSS2/sample.html" target="_blank" rel="external">http://www.w3.org/TR/CSS2/sample.html</a></p>
<h4 id="定位的方案"><a href="#定位的方案" class="headerlink" title="定位的方案"></a>定位的方案</h4><p>有三种方案</p>
<ul>
<li>Normal：由 render tree 来决定的位置。</li>
<li>Float：会先按照正常流程来排列，然后再尽可能的往左或往右移动。</li>
<li>Absolute：让其在 render tree 的位置和 DOM tree 不一样</li>
</ul>
<p>定位方案是根据 position 属性和 float 属性来决定的，static 和 relative 就是正常的排列， absolute 和 fixed 就是 absolute 定位。</p>
<p>对于 float 的处理，首先需要判断宽度是否需要 fit content<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> LayoutBox::sizesLogicalWidthToFitContent(</div><div class="line">    <span class="keyword">const</span> Length&amp; logicalWidth) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">if</span> (isFloating() || isInlineBlockOrInlineTable())</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是 float 或者 inline-block ，宽度靠内容来撑，行内的内容会将间隔控制成一个空格，前后空格和多余空格都会忽略。</p>
<p>对于 float:left 的计算<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//logicalRightOffsetForPositioningFloat 剩余空间如果不小于 floatLogicalLeft 时循环结束</span></div><div class="line"><span class="keyword">while</span> (logicalRightOffsetForPositioningFloat(</div><div class="line">           logicalTopOffset, logicalRightOffset, &amp;heightRemainingRight) -</div><div class="line">           floatLogicalLeft &lt;</div><div class="line">       floatLogicalWidth) &#123;</div><div class="line">  <span class="comment">//下移</span></div><div class="line">  logicalTopOffset +=</div><div class="line">      <span class="built_in">std</span>::min&lt;LayoutUnit&gt;(heightRemainingLeft, heightRemainingRight);</div><div class="line">  <span class="comment">//新的 floatLogicalLeft</span></div><div class="line">  floatLogicalLeft = logicalLeftOffsetForPositioningFloat(</div><div class="line">      logicalTopOffset, logicalLeftOffset, &amp;heightRemainingLeft);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//看看 floatLogicalLeft 是否大于 left 的 offset 和 padding left 的差值</span></div><div class="line">floatLogicalLeft = <span class="built_in">std</span>::max(</div><div class="line">    logicalLeftOffset - borderAndPaddingLogicalLeft(), floatLogicalLeft);</div></pre></td></tr></table></figure></p>
<h4 id="Box-类型"><a href="#Box-类型" class="headerlink" title="Box 类型"></a>Box 类型</h4><p>Block box：在浏览器的 window 里有自己的矩形<br><img src="/uploads/deeply-analyse-webkit/20.png" alt="20"></p>
<p>Inline box：没有自己的 block，但是会在一个 block 里<br><img src="/uploads/deeply-analyse-webkit/21.png" alt="21"></p>
<p>Block 是按照垂直排列，Inline 是按照水平来排列<br><img src="/uploads/deeply-analyse-webkit/22.png" alt="22"></p>
<p>Inline boxes 会被包含在 line boxes 里，lines 的高度至少和最高的 box 一样，甚至更高，当 boxes 用的是 baseline，这意味着多个元素底部对齐。如果容器宽度不够，inline 会变成多 lines。<br><img src="/uploads/deeply-analyse-webkit/23.png" alt="23"></p>
<p>下面举个例子看看 Inline  类型的例子，比如有如下的 html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>First line.<span class="tag">&lt;<span class="name">br</span>&gt;</span>Second one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这段 html 的 Render Tree 如下：<br><img src="/uploads/deeply-analyse-webkit/97.png" alt="97"></p>
<h4 id="Position-类型"><a href="#Position-类型" class="headerlink" title="Position 类型"></a>Position 类型</h4><p>Relative：相对定位，先按照正常的定位然后根据设置的值再移动。<br><img src="/uploads/deeply-analyse-webkit/24.png" alt="24"></p>
<p>Float：会被移动到左边或右边侧<br><img src="/uploads/deeply-analyse-webkit/25.png" alt="25"></p>
<p>Absolute 和 fixed：不会参与 normal flow，只按照精确定位，尺寸值相对于容器，对于 fixed 来说，是相对于 view port 的。fixed box 不会随着 document 的滚动而移动。<br><img src="/uploads/deeply-analyse-webkit/26.png" alt="26"></p>
<h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><p>分层可以通过指定 CSS 的 z-index 属性。它表示了 box 的第三个维度，位置按照 z 轴来。这些 box 会被分成 stacks，叫做 stacking contexts，每个栈顶的 box 更靠近用户。stack 根据 z-index 的属性排序。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">STYLE</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-tag">div</span> &#123; </div><div class="line">        <span class="attribute">position</span>: absolute; </div><div class="line">        <span class="attribute">left</span>: <span class="number">2in</span>; </div><div class="line">        <span class="attribute">top</span>: <span class="number">2in</span>; </div><div class="line">    &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">STYLE</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">style</span>=<span class="string">"z-index: 3;background-color:red; width: 1in; height: 1in; "</span>&gt;</span><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">DIV</span> <span class="attr">style</span>=<span class="string">"z-index: 1;background-color:green;width: 2in; height: 2in;"</span>&gt;</span><span class="tag">&lt;/<span class="name">DIV</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
<p>效果如下：<br><img src="/uploads/deeply-analyse-webkit/27.png" alt="27"></p>
<p>可以看到层级是按照 z-index 来排的。</p>
<h4 id="大小的计算"><a href="#大小的计算" class="headerlink" title="大小的计算"></a>大小的计算</h4><p>border 及以内区域使用 m_frameRect 对象表示。不同方法通过不同的计算能够获取到不同的值比如 clientWidth 的计算方法是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// More IE extensions.  clientWidth and clientHeight represent the interior of</span></div><div class="line"><span class="comment">// an object excluding border and scrollbar.</span></div><div class="line">LayoutUnit LayoutBox::clientWidth() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> m_frameRect.width() - borderLeft() - borderRight() -</div><div class="line">         verticalScrollbarWidth();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>offsetWidth  是 frameRect 的宽度<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IE extensions. Used to calculate offsetWidth/Height.</span></div><div class="line"><span class="function">LayoutUnit <span class="title">offsetWidth</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> m_frameRect.width(); &#125;</div><div class="line"><span class="function">LayoutUnit <span class="title">offsetHeight</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> m_frameRect.height(); &#125;</div></pre></td></tr></table></figure></p>
<p>Margin 区域是用 LayoutRectOutsets<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LayoutUnit m_top;</div><div class="line">LayoutUnit m_right;</div><div class="line">LayoutUnit m_bottom;</div><div class="line">LayoutUnit m_left;</div></pre></td></tr></table></figure></p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>位置的计算，即 x 和 y 是通过下面两个函数计算得到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据 margin 得到 y 值</span></div><div class="line">LayoutUnit logicalTopBeforeClear =</div><div class="line">    collapseMargins(child, layoutInfo, childIsSelfCollapsing,</div><div class="line">                    childDiscardMarginBefore, childDiscardMarginAfter);</div><div class="line"><span class="comment">// 得到 x 值</span></div><div class="line">determineLogicalLeftPositionForChild(child);</div></pre></td></tr></table></figure></p>
<p>计算是个递归过程，由子元素到父元素。这样做的原因是有的父元素的高是由子元素撑起的，需要先知道子元素才能够推出父元素。</p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="戴铭 wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一扫Starming星光社微信公众号starming-weixin，关注最新文章</div>
</div>


      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      戴铭
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/" title="深入剖析 WebKit">http://ming1016.github.io/2017/10/11/deeply-analyse-webkit/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Web/" rel="tag"># Web</a>
          
            <a href="/tags/WebKit/" rel="tag"># WebKit</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/20/deeply-ios-performance-optimization/" rel="next" title="深入剖析 iOS 性能优化">
                <i class="fa fa-chevron-left"></i> 深入剖析 iOS 性能优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/16/html-to-native-htn-development-record/" rel="prev" title="HTML 转原生 HTN 项目开发记录">
                HTML 转原生 HTN 项目开发记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/251980?v=3&s=460"
               alt="戴铭" />
          <p class="site-author-name" itemprop="name">戴铭</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里；不积小流，无以成江海</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">41</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">32</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/ming1016" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/allstarming" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/ming1016" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-标准"><span class="nav-number">1.</span> <span class="nav-text">HTML 标准</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML"><span class="nav-number">1.1.</span> <span class="nav-text">HTML</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器"><span class="nav-number">2.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#历史"><span class="nav-number">2.1.</span> <span class="nav-text">历史</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebKit-全貌"><span class="nav-number">3.</span> <span class="nav-text">WebKit 全貌</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#架构"><span class="nav-number">3.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit-源代码结构说明"><span class="nav-number">3.2.</span> <span class="nav-text">WebKit 源代码结构说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit-代码风格"><span class="nav-number">3.3.</span> <span class="nav-text">WebKit 代码风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit-的设计模式"><span class="nav-number">3.4.</span> <span class="nav-text">WebKit 的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主要类"><span class="nav-number">3.5.</span> <span class="nav-text">主要类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整体"><span class="nav-number">3.5.1.</span> <span class="nav-text">整体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebCore-Frame"><span class="nav-number">3.5.2.</span> <span class="nav-text">WebCore::Frame</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#渲染引擎"><span class="nav-number">3.6.</span> <span class="nav-text">渲染引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Frame-的主要接口"><span class="nav-number">3.7.</span> <span class="nav-text">Frame 的主要接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Create"><span class="nav-number">3.7.1.</span> <span class="nav-text">Create</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#createView"><span class="nav-number">3.7.2.</span> <span class="nav-text">createView</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setDocument"><span class="nav-number">3.7.3.</span> <span class="nav-text">setDocument</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WTF"><span class="nav-number">4.</span> <span class="nav-text">WTF</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Smart-ptr-智能指针"><span class="nav-number">4.1.</span> <span class="nav-text">Smart ptr 智能指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RefPtr"><span class="nav-number">4.2.</span> <span class="nav-text">RefPtr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assert-断言的实现和应用"><span class="nav-number">4.3.</span> <span class="nav-text">Assert 断言的实现和应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理"><span class="nav-number">4.4.</span> <span class="nav-text">内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器类"><span class="nav-number">4.5.</span> <span class="nav-text">容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector-动态数组"><span class="nav-number">4.5.1.</span> <span class="nav-text">Vector 动态数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashTable-哈希表"><span class="nav-number">4.5.2.</span> <span class="nav-text">HashTable 哈希表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-number">4.6.</span> <span class="nav-text">线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Loader"><span class="nav-number">5.</span> <span class="nav-text">Loader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Loader-的资源"><span class="nav-number">5.1.</span> <span class="nav-text">Loader 的资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FrameLoader"><span class="nav-number">5.2.</span> <span class="nav-text">FrameLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载过程"><span class="nav-number">5.2.1.</span> <span class="nav-text">加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类关系"><span class="nav-number">5.2.2.</span> <span class="nav-text">类关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FrameLoader-的主要接口"><span class="nav-number">5.3.</span> <span class="nav-text">FrameLoader 的主要接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Frame-init"><span class="nav-number">5.3.1.</span> <span class="nav-text">Frame::init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FrameLoader-commitProvisionalLoad"><span class="nav-number">5.3.2.</span> <span class="nav-text">FrameLoader::commitProvisionalLoad</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Frame-finishedLoading"><span class="nav-number">5.3.3.</span> <span class="nav-text">Frame::finishedLoading</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FrameLoader-finishedParsing"><span class="nav-number">5.3.4.</span> <span class="nav-text">FrameLoader::finishedParsing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FrameLoader-load-FrameLoadRequest-amp-amp-request"><span class="nav-number">5.3.5.</span> <span class="nav-text">FrameLoader::load(FrameLoadRequest&& request)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit-网络处理"><span class="nav-number">5.4.</span> <span class="nav-text">WebKit 网络处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceHandle-的相关类"><span class="nav-number">5.5.</span> <span class="nav-text">ResourceHandle 的相关类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceHandleClient"><span class="nav-number">5.6.</span> <span class="nav-text">ResourceHandleClient</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载流程"><span class="nav-number">5.7.</span> <span class="nav-text">加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MainResourceLoader-的加载顺序"><span class="nav-number">5.7.1.</span> <span class="nav-text">MainResourceLoader 的加载顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SubResourceLoader-的加载顺序"><span class="nav-number">5.7.2.</span> <span class="nav-text">SubResourceLoader 的加载顺序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源的生命周期"><span class="nav-number">5.8.</span> <span class="nav-text">资源的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebKit-的-Cache"><span class="nav-number">5.9.</span> <span class="nav-text">WebKit 的 Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Page-Cache"><span class="nav-number">5.9.1.</span> <span class="nav-text">Page Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Memory-Cache"><span class="nav-number">5.9.2.</span> <span class="nav-text">Memory Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Disk-Cache"><span class="nav-number">5.9.3.</span> <span class="nav-text">Disk Cache</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-词法解析，字符串解析成-Tag-为单位的-HTML-Token"><span class="nav-number">6.</span> <span class="nav-text">HTML 词法解析，字符串解析成 Tag 为单位的 HTML Token</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解析成-HTML-Token-的算法"><span class="nav-number">6.1.</span> <span class="nav-text">解析成 HTML Token 的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML-语法解析"><span class="nav-number">7.</span> <span class="nav-text">HTML 语法解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML-的语法定义"><span class="nav-number">7.1.</span> <span class="nav-text">HTML 的语法定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关类关系图"><span class="nav-number">7.2.</span> <span class="nav-text">相关类关系图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析过程"><span class="nav-number">7.3.</span> <span class="nav-text">解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Element-属性设置"><span class="nav-number">7.4.</span> <span class="nav-text">Element 属性设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源加载"><span class="nav-number">7.5.</span> <span class="nav-text">资源加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构建-DOM-Tree"><span class="nav-number">8.</span> <span class="nav-text">构建 DOM Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-标准规范"><span class="nav-number">8.1.</span> <span class="nav-text">DOM 标准规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-Tree-Token-的构造算法"><span class="nav-number">8.2.</span> <span class="nav-text">DOM Tree Token 的构造算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键类"><span class="nav-number">8.3.</span> <span class="nav-text">关键类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载"><span class="nav-number">8.4.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM-Tree"><span class="nav-number">8.5.</span> <span class="nav-text">DOM Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-节点"><span class="nav-number">8.5.1.</span> <span class="nav-text">Node 节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTMLElement"><span class="nav-number">8.5.2.</span> <span class="nav-text">HTMLElement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构建-DOM-Tree-1"><span class="nav-number">8.5.3.</span> <span class="nav-text">构建 DOM Tree</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对错误的处理"><span class="nav-number">8.6.</span> <span class="nav-text">对错误的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题"><span class="nav-number">8.6.1.</span> <span class="nav-text"> 问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stray-table"><span class="nav-number">8.6.2.</span> <span class="nav-text">stray table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套-form"><span class="nav-number">8.6.3.</span> <span class="nav-text">嵌套 form</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过深的层级"><span class="nav-number">8.6.4.</span> <span class="nav-text">过深的层级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#html-或-body-的-end-tags-缺失"><span class="nav-number">8.6.5.</span> <span class="nav-text">html 或 body 的 end tags 缺失</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS"><span class="nav-number">9.</span> <span class="nav-text">CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-语法简介"><span class="nav-number">9.1.</span> <span class="nav-text">CSS 语法简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-declarations"><span class="nav-number">9.1.1.</span> <span class="nav-text">CSS declarations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-declaration-blocks"><span class="nav-number">9.1.2.</span> <span class="nav-text">CSS declaration blocks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-selectors-and-rules"><span class="nav-number">9.1.3.</span> <span class="nav-text">CSS selectors and rules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-statements"><span class="nav-number">9.1.4.</span> <span class="nav-text">CSS statements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shorthand"><span class="nav-number">9.1.5.</span> <span class="nav-text">Shorthand</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Value-and-unit"><span class="nav-number">9.1.6.</span> <span class="nav-text">Value and unit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证-CSS-语法正确性"><span class="nav-number">9.1.7.</span> <span class="nav-text">验证 CSS 语法正确性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-BNF"><span class="nav-number">9.2.</span> <span class="nav-text">CSS BNF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-主要类与关系"><span class="nav-number">9.3.</span> <span class="nav-text">CSS 主要类与关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StyleRuleBase-类的继承关系"><span class="nav-number">9.3.1.</span> <span class="nav-text">StyleRuleBase 类的继承关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StyleRule-类的结构"><span class="nav-number">9.3.2.</span> <span class="nav-text">StyleRule 类的结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解析-CSS"><span class="nav-number">9.4.</span> <span class="nav-text">解析 CSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-规则匹配"><span class="nav-number">9.5.</span> <span class="nav-text">CSS 规则匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置-style"><span class="nav-number">9.6.</span> <span class="nav-text">设置 style</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSS-Object-Model-CSSOM"><span class="nav-number">9.7.</span> <span class="nav-text">CSS Object Model (CSSOM)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RenderObject-Tree"><span class="nav-number">10.</span> <span class="nav-text">RenderObject Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RenderObject"><span class="nav-number">10.1.</span> <span class="nav-text">RenderObject</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StyleResolver"><span class="nav-number">10.2.</span> <span class="nav-text">StyleResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#styleForElement-进行-CSS-选择和匹配"><span class="nav-number">10.3.</span> <span class="nav-text">styleForElement 进行 CSS 选择和匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RuleSet"><span class="nav-number">10.4.</span> <span class="nav-text">RuleSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Render-tree-和-DOM-tree-做对应"><span class="nav-number">10.5.</span> <span class="nav-text">Render tree 和 DOM tree 做对应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建-Render-Tree-的流程"><span class="nav-number">10.6.</span> <span class="nav-text">构建 Render Tree 的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RenderLayer-Tree"><span class="nav-number">10.7.</span> <span class="nav-text">RenderLayer Tree</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#style-计算"><span class="nav-number">10.8.</span> <span class="nav-text">style 计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享-style-数据"><span class="nav-number">10.8.1.</span> <span class="nav-text">共享 style 数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rule-tree"><span class="nav-number">10.8.2.</span> <span class="nav-text">Rule tree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可确定样式分到各个-structs-里"><span class="nav-number">10.8.3.</span> <span class="nav-text">可确定样式分到各个 structs 里</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-rule-tree-计算-style-contexts"><span class="nav-number">10.8.4.</span> <span class="nav-text">使用 rule tree 计算 style contexts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较容易匹配的-rules"><span class="nav-number">10.8.5.</span> <span class="nav-text">比较容易匹配的 rules</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Style-sheet-的-cascade-排序"><span class="nav-number">10.8.6.</span> <span class="nav-text">Style sheet 的 cascade 排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSS-specification"><span class="nav-number">10.8.7.</span> <span class="nav-text">CSS specification</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rules-排序"><span class="nav-number">10.8.8.</span> <span class="nav-text">Rules 排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Layout-布局"><span class="nav-number">11.</span> <span class="nav-text">Layout 布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Layout-处理过程"><span class="nav-number">11.1.</span> <span class="nav-text">Layout 处理过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layout-Tree-创建"><span class="nav-number">11.2.</span> <span class="nav-text">Layout Tree 创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Layout-值的计算"><span class="nav-number">11.3.</span> <span class="nav-text">Layout 值的计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Box-Model-数据结构"><span class="nav-number">11.4.</span> <span class="nav-text">Box Model 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定位的方案"><span class="nav-number">11.4.1.</span> <span class="nav-text">定位的方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Box-类型"><span class="nav-number">11.4.2.</span> <span class="nav-text">Box 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Position-类型"><span class="nav-number">11.4.3.</span> <span class="nav-text">Position 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分层"><span class="nav-number">11.4.4.</span> <span class="nav-text">分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大小的计算"><span class="nav-number">11.4.5.</span> <span class="nav-text">大小的计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位置"><span class="nav-number">11.4.6.</span> <span class="nav-text">位置</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">戴铭</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
