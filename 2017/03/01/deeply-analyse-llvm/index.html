<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="戴铭">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="戴铭">
    
    <meta name="keywords" content="戴铭,戴铭的博客,iOS,移动开发">
    
    <meta name="description" content="前滴滴出行技术专家。极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者。个人博客：戴铭的博客。微信公共号：starming-weixin。微博：@戴铭">
    <meta name="description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">
<meta name="keywords" content="iOS,LLVM,Clang">
<meta property="og:type" content="article">
<meta property="og:title" content="深入剖析 iOS 编译 Clang &#x2F; LLVM">
<meta property="og:url" content="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/index.html">
<meta property="og:site_name" content="戴铭的博客 - 星光社">
<meta property="og:description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/08.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/04.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/05.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/06.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/07.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/09.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/10.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/11.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/12.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/01.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/02.png">
<meta property="og:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/03.png">
<meta property="og:updated_time" content="2017-10-11T03:08:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入剖析 iOS 编译 Clang &#x2F; LLVM">
<meta name="twitter:description" content="前言2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器">
<meta name="twitter:image" content="http://ming1016.github.io/uploads/deeply-analyse-llvm/08.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <link rel="alternate" href="/atom.xml" title="戴铭的博客 - 星光社" type="application/atom+xml">
    
    <title>深入剖析 iOS 编译 Clang / LLVM · 戴铭的博客 - 星光社</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/logo.png" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >戴铭的博客 - 星光社</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">深入剖析 iOS 编译 Clang / LLVM</a>
            </div>
    </div>
    
    <a class="home-link" href=/>戴铭的博客 - 星光社</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/postbg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            深入剖析 iOS 编译 Clang / LLVM
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "iOS">iOS</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "LLVM">LLVM</a>
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "Clang">Clang</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">22.9k</span>Reading time: <span class="post-count reading-time">100 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2017/03/01</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter <a href="https://twitter.com/clattner_llvm" target="_blank" rel="external">@clattner_llvm</a> ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。</p>
<p>Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。</p>
<p>iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。</p>
<p>swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成的中间代码 .sil 属于 High-Level IR， 因为 swift 在编译时就完成了方法绑定直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。</p>
<p>LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是  Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。</p>
<p>LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。</p>
<p>LLVM 还用在 Gallium3D 中进行 JIT 优化，Xorg 中的 pixman 也有考虑使用 LLVM 优化执行速度， LLVM-Lua 用LLVM 来编译 lua 代码， gpuocelot 使用 LLVM 可以让 CUDA 程序无需重新编译就能够在多种 CPU 机器上跑。</p>
<p>这里是 Clang 官方详细文档： <a href="http://clang.llvm.org/docs/" target="_blank" rel="external">Welcome to Clang’s documentation! — Clang 4.0 documentation</a></p>
<p>这篇是对 LLVM 架构的一个概述： <a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Applications</a></p>
<p>将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 <a href="https://book.douban.com/subject/1436811/" target="_blank" rel="external">《linkers and loaders》</a> 这本书就知道了。</p>
<h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>在列出完整步骤之前可以先看个简单例子。看看是如何完成一次编译的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#define DEFINEEight 8</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = DEFINEEight;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在命令行输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -ccc-print-phases main.m</div></pre></td></tr></table></figure></p>
<p>可以看到编译源文件需要的几个不同的阶段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">0: input, “main.m”, objective-c</div><div class="line">1: preprocessor, &#123;0&#125;, objective-c-cpp-output</div><div class="line">2: compiler, &#123;1&#125;, ir</div><div class="line">3: backend, &#123;2&#125;, assembler</div><div class="line">4: assembler, &#123;3&#125;, object</div><div class="line">5: linker, &#123;4&#125;, image</div><div class="line">6: bind-arch, “x86_64”, &#123;5&#125;, image</div></pre></td></tr></table></figure></p>
<p>这样能够了解到过程和重要的信息。<br>查看oc的c实现可以使用如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -rewrite-objc main.m</div></pre></td></tr></table></figure></p>
<p>查看操作内部命令，可以使用 -### 命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -### main.m -o main</div></pre></td></tr></table></figure></p>
<p>想看清clang的全部过程，可以先通过-E查看clang在预编译处理这步做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -E main.m</div></pre></td></tr></table></figure></p>
<p>执行完后可以看到文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># 1 “/System/Library/Frameworks/Foundation.framework/Headers/FoundationLegacySwiftCompatibility.h” 1 3</div><div class="line"># 185 “/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h” 2 3</div><div class="line"># 2 “main.m” 2</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int eight = 8;</div><div class="line">        int six = 6;</div><div class="line">        NSString* site = [[NSString alloc] initWithUTF8String:”starming”];</div><div class="line">        int rank = eight + six;</div><div class="line">        NSLog(@“%@ rank %d”, site, rank);</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个过程的处理包括宏的替换，头文件的导入。下面这些代码也会在这步处理。</p>
<ul>
<li>“#define”</li>
<li>“#include”</li>
<li>“#indef”</li>
<li>注释</li>
<li>“#pragma”</li>
</ul>
<p>预处理完成后就会进行词法分析，这里会把代码切成一个个 Token，比如大小括号，等于号还有字符串等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>然后是语法分析，验证语法是否正确，然后将所有节点组成抽象语法树 AST 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>完成这些步骤后就可以开始IR中间代码的生成了，CodeGen 会负责将语法树自顶向下遍历逐步翻译成 LLVM IR，IR 是编译过程的前端的输出后端的输入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>这里 LLVM 会去做些优化工作，在 Xcode 的编译设置里也可以设置优化级别-01，-03，-0s，还可以写些自己的 Pass，官方有比较完整的 Pass 教程： <a href="http://llvm.org/docs/WritingAnLLVMPass.html" target="_blank" rel="external">Writing an LLVM Pass — LLVM 5 documentation</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -O3 -S -fobjc-arc -emit-llvm main.m -o main.ll</div></pre></td></tr></table></figure></p>
<p>Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。</p>
<p>如果开启了 bitcode 苹果会做进一步的优化，有新的后端架构还是可以用这份优化过的 bitcode 去生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -emit-llvm -c main.m -o main.bc</div></pre></td></tr></table></figure></p>
<p>生成汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -S -fobjc-arc main.m -o main.s</div></pre></td></tr></table></figure></p>
<p>生成目标文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -c main.m -o main.o</div></pre></td></tr></table></figure></p>
<p>生成可执行文件，这样就能够执行看到输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">clang main.o -o main</div><div class="line">执行</div><div class="line">./main</div><div class="line">输出</div><div class="line">starming rank 14</div></pre></td></tr></table></figure></p>
<p>下面是完整步骤：</p>
<ul>
<li>编译信息写入辅助文件，创建文件架构 .app 文件</li>
<li>处理文件打包信息</li>
<li>执行 CocoaPod 编译前脚本，checkPods Manifest.lock</li>
<li>编译.m文件，使用 CompileC 和 clang 命令</li>
<li>链接需要的 Framework</li>
<li>编译 xib</li>
<li>拷贝 xib ，资源文件</li>
<li>编译 ImageAssets</li>
<li>处理 info.plist</li>
<li>执行 CocoaPod 脚本</li>
<li>拷贝标准库</li>
<li>创建 .app 文件和签名</li>
</ul>
<h1 id="Clang-编译-m-文件"><a href="#Clang-编译-m-文件" class="headerlink" title="Clang 编译 .m 文件"></a>Clang 编译 .m 文件</h1><p>在 Xcode 编译过后，可以通过 Show the report navigator 里对应 target 的 build 中查看每个 .m 文件的 clang 参数信息，这些参数都是通过Build Setting。</p>
<p>具体拿编译 AFSecurityPolicy.m 的信息来看看。首先对任务进行描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CompileC DerivedData path/AFSecurityPolicy.o AFNetworking/AFNetworking/AFSecurityPolicy.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</div></pre></td></tr></table></figure></p>
<p>接下来对会更新工作路径，同时设置 PATH<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /Users/didi/Documents/Demo/GitHub/GCDFetchFeed/GCDFetchFeed/Pods</div><div class="line">    export LANG=en_US.US-ASCII</div><div class="line">    export PATH=“/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/usr/bin:/Applications/Xcode.app/Contents/Developer/usr/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin”</div></pre></td></tr></table></figure></p>
<p>接下来就是实际的编译命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc… -Wno-missing-field-initializers … -DDEBUG=1 … -isysroot iPhoneSimulator10.1.sdk -fasm-blocks … -I -F -c AFSecurityPolicy.m -o AFSecurityPolicy.o</div></pre></td></tr></table></figure></p>
<p>clang 命令参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-x 编译语言比如objective-c</div><div class="line">-arch 编译的架构，比如arm7</div><div class="line">-f 以-f开头的。</div><div class="line">-W 以-W开头的，可以通过这些定制编译警告</div><div class="line">-D 以-D开头的，指的是预编译宏，通过这些宏可以实现条件编译</div><div class="line">-iPhoneSimulator10.1.sdk 编译采用的iOS SDK版本</div><div class="line">-I 把编译信息写入指定的辅助文件</div><div class="line">-F 需要的Framework</div><div class="line">-c 标识符指明需要运行预处理器，语法分析，类型检查，LLVM生成优化以及汇编代码生成.o文件</div><div class="line">-o 编译结果</div></pre></td></tr></table></figure></p>
<h2 id="构建-Target"><a href="#构建-Target" class="headerlink" title="构建 Target"></a>构建 Target</h2><p>编译工程中的第三方依赖库后会构建我们程序的 target，会按顺序输出如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Create product structure</div><div class="line">Process product packaging</div><div class="line">Run custom shell script ‘Check Pods Manifest.lock’</div><div class="line">Compile … 各个项目中的.m文件</div><div class="line">Link /Users/… 路径</div><div class="line">Copy … 静态文件</div><div class="line">Compile asset catalogs</div><div class="line">Compile Storyboard file …</div><div class="line">Process info.plist</div><div class="line">Link Storyboards</div><div class="line">Run custom shell script ‘Embed Pods Frameworks’</div><div class="line">Run custom shell script ‘Copy Pods Resources’</div><div class="line">…</div><div class="line">Touch GCDFetchFeed.app</div><div class="line">Sign GCDFetchFeed.app</div></pre></td></tr></table></figure></p>
<p>从这些信息可以看出在这些步骤中会分别调用不同的命令行工具来执行。</p>
<h2 id="Target-在-Build-过程的控制"><a href="#Target-在-Build-过程的控制" class="headerlink" title="Target 在 Build 过程的控制"></a>Target 在 Build 过程的控制</h2><p>在 Xcode 的 Project editor 中的 Build Setting，Build Phases 和 Build Rules 能够控制编译的过程。</p>
<h3 id="Build-Phases"><a href="#Build-Phases" class="headerlink" title="Build Phases"></a>Build Phases</h3><p>构建可执行文件的规则。指定 target 的依赖项目，在 target build 之前需要先 build 的依赖。在 Compile Source 中指定所有必须编译的文件，这些文件会根据 Build Setting 和 Build Rules 里的设置来处理。</p>
<p>在 Link Binary With Libraries 里会列出所有的静态库和动态库，它们会和编译生成的目标文件进行链接。</p>
<p>build phase 还会把静态资源拷贝到 bundle 里。</p>
<p>可以通过在 build phases 里添加自定义脚本来做些事情，比如像 CocoaPods 所做的那样。</p>
<h3 id="Build-Rules"><a href="#Build-Rules" class="headerlink" title="Build Rules"></a>Build Rules</h3><p>指定不同文件类型如何编译。每条 build rule 指定了该类型如何处理以及输出在哪。可以增加一条新规则对特定文件类型添加处理方法。</p>
<h3 id="Build-Settings"><a href="#Build-Settings" class="headerlink" title="Build Settings"></a>Build Settings</h3><p>在 build 的过程中各个阶段的选项的设置。</p>
<h3 id="pbxproj工程文件"><a href="#pbxproj工程文件" class="headerlink" title="pbxproj工程文件"></a>pbxproj工程文件</h3><p>build 过程控制的这些设置都会被保存在工程文件 .pbxproj 里。在这个文件中可以找 rootObject 的 ID 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rootObject = 3EE311301C4E1F0800103FA3 /* Project object */;</div></pre></td></tr></table></figure></p>
<p>然后根据这个 ID 找到 main 工程的定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* Begin PBXProject section */</div><div class="line">		3EE311301C4E1F0800103FA3 /* Project object */ = &#123;</div><div class="line">			isa = PBXProject;</div><div class="line">			…</div><div class="line">/* End PBXProject section */</div></pre></td></tr></table></figure></p>
<p>在 targets 里会指向各个 taget 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">targets = (</div><div class="line">	3EE311371C4E1F0800103FA3 /* GCDFetchFeed */,</div><div class="line">	3EE311501C4E1F0800103FA3 /* GCDFetchFeedTests */,</div><div class="line">	3EE3115B1C4E1F0800103FA3 /* GCDFetchFeedUITests */,</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>顺着这些 ID 就能够找到更详细的定义地方。比如我们通过 GCDFetchFeed 这个 target 的 ID 找到定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">3EE311371C4E1F0800103FA3 /* GCDFetchFeed */ = &#123;</div><div class="line">	isa = PBXNativeTarget;</div><div class="line">	buildConfigurationList = 3EE311651C4E1F0800103FA3 /* configuration list for PBXNativeTarget “GCDFetchFeed” </div><div class="line">	buildPhases = (</div><div class="line">		9527AA01F4AAE11E18397E0C /* Check Pods st.lock */,</div><div class="line">		3EE311341C4E1F0800103FA3 /* Sources */,</div><div class="line">		3EE311351C4E1F0800103FA3 /* Frameworks */,</div><div class="line">		3EE311361C4E1F0800103FA3 /* Resources */,</div><div class="line">		C3DDA7C46C0308459A18B7D9 /* Embed Pods Frameworks </div><div class="line">		DD33A716222617FAB49F1472 /* Copy Pods Resources </div><div class="line">	);</div><div class="line">	buildRules = (</div><div class="line">	);</div><div class="line">	dependencies = (</div><div class="line">	);</div><div class="line">	name = GCDFetchFeed;</div><div class="line">	productName = GCDFetchFeed;</div><div class="line">	productReference = 3EE311381C4E1F0800103FA3 /* chFeed.app */;</div><div class="line">	productType = “com.apple.product-type.application”;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个里面又有更多的 ID 可以得到更多的定义，其中 buildConfigurationList 指向了可用的配置项，包含 Debug 和 Release。可以看到还有 buildPhases，buildRules 和 dependencies 都能够通过这里索引找到更详细的定义。</p>
<p>接下来详细的看看 Clang 所做的事情吧。</p>
<h1 id="Clang-Static-Analyzer静态代码分析"><a href="#Clang-Static-Analyzer静态代码分析" class="headerlink" title="Clang Static Analyzer静态代码分析"></a>Clang Static Analyzer静态代码分析</h1><p>可以在 <a href="https://code.woboq.org/llvm/clang/" target="_blank" rel="external">llvm/clang/ Source Tree - Woboq Code Browser</a> 上查看 Clang 的代码。</p>
<p>Youtube上一个教程：<a href="https://www.youtube.com/watch?time_continue=280&amp;v=VqCkCDFLSsc" target="_blank" rel="external">The Clang AST - a Tutorial - YouTube</a><br>CMU关于llvm的教案 <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/" target="_blank" rel="external">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15745-s14/public/lectures/</a></p>
<p>静态分析前会对源代码分词成 Token，这个过程称为词法分析（Lexical Analysis），在 <a href="https://opensource.apple.com//source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">TokensKind.def</a> 里有 Clang 定义的所有 Token。Token 可以分为以下几类</p>
<ul>
<li>关键字：语法中的关键字，if else while for 等。</li>
<li>标识符：变量名</li>
<li>字面量：值，数字，字符串</li>
<li>特殊符号：加减乘除等符号</li>
</ul>
<p>通过下面的命令可以输出所有 token 和所在文件具体位置，命令如下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -E -Xclang -dump-tokens main.m</div></pre></td></tr></table></figure></p>
<p>可以获得每个 token 的类型，值还有类似 StartOfLine 的位置类型和 Loc=<main.m:11:1> 这个样的具体位置。</main.m:11:1></p>
<p>接着进行语法分析（Semantic Analysis）将 token 先按照语法组合成语义生成 VarDecl 节点，然后将这些节点按照层级关系构成抽象语法树 Abstract Syntax Tree (AST)。</p>
<p>打个比方，如果遇到 token 是 = 符号进行赋值的处理，遇到加减乘除就先处理乘除，然后处理加减，这些组合经过嵌套后会生成一个语法数的结构。这个过程完成后会进行赋值操作时类型是不是匹配的处理。</p>
<p>打印语法树的命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -fmodules -fsyntax-only -Xclang -ast-dump main.m</div></pre></td></tr></table></figure></p>
<p>TranslationUnitDecl 是根节点，表示一个源文件。Decl 表示一个声明，Expr 表示表达式，Literal 表示字面量是特殊的 Expr，Stmt 表示语句。</p>
<p>clang 静态分析是通过建立分析引擎和 checkers 所组成的架构，这部分功能可以通过 clang —analyze 命令方式调用。clang static analyzer 分为 analyzer core 分析引擎和 checkers 两部分，所有 checker 都是基于底层分析引擎之上，通过分析引擎提供的功能能够编写新的 checker。</p>
<p>可以通过 clang —analyze -Xclang -analyzer-checker-help 来列出当前 clang 版本下所有 checker。如果想编写自己的 checker，可以在 clang 项目的 lib / StaticAnalyzer / Checkers 目录下找到实例参考，比如 ObjCUnusedIVarsChecker.cpp 用来检查未使用定义过的变量。这种方式能够方便用户扩展对代码检查规则或者对 bug 类型进行扩展，但是这种架构也有不足，每执行完一条语句后，分析引擎会遍历所有 checker 中的回调函数，所以 checker 越多，速度越慢。通过 clang -cc1 -analyzer-checker-help 可以列出能调用的 checker，下面是常用 checker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">debug.ConfigDumper              Dump config table</div><div class="line">debug.DumpCFG                   Display Control-Flow Graphs</div><div class="line">debug.DumpCallGraph             Display Call Graph</div><div class="line">debug.DumpCalls                 Print calls as they are traversed by the engine</div><div class="line">debug.DumpDominators            Print the dominance tree for a given CFG</div><div class="line">debug.DumpLiveVars              Print results of live variable analysis</div><div class="line">debug.DumpTraversal             Print branch conditions as they are traversed by the engine</div><div class="line">debug.ExprInspection            Check the analyzer&apos;s understanding of expressions</div><div class="line">debug.Stats                     Emit warnings with analyzer statistics</div><div class="line">debug.TaintTest                 Mark tainted symbols as such.</div><div class="line">debug.ViewCFG                   View Control-Flow Graphs using GraphViz</div><div class="line">debug.ViewCallGraph             View Call Graph using GraphViz</div><div class="line">debug.ViewExplodedGraph         View Exploded Graphs using GraphViz</div></pre></td></tr></table></figure>
<p>这些 checker 里最常用的是 DumpCFG，DumpCallGraph，DumpLiveVars 和 DumpViewExplodedGraph。</p>
<p>clang static analyzer 引擎大致分为 CFG，MemRegion，SValBuilder，ConstraintManager 和 ExplodedGraph 几个模块。clang static analyzer 本质上就是 path-sensitive analysis，要很好的理解 clang static analyzer 引擎就需要对 Data Flow Analysis 有所了解，包括迭代数据流分析，path-sensitive，path-insensitive ，flow-sensitive等。</p>
<p>编译的概念（词法-&gt;语法-&gt;语义-&gt;IR-&gt;优化-&gt;CodeGen）在 clang static analyzer 里到处可见，例如 Relaxed Live Variables Analysis 可以减少分析中的内存消耗，使用 mark-sweep 实现 Dead Symbols 的删除。</p>
<p>clang static analyzer 提供了很多辅助方法，比如 SVal.dump()，MemRegion.getString 以及 Stmt 和 Dcel 提供的 dump 方法。Clang 抽象语法树 Clang AST 常见的 API 有 Stmt，Decl，Expr 和 QualType。在编写 checker 时会遇到 AST 的层级检查，这时有个很好的接口 StmtVisitor，这个接口类似 RecursiveASTVisitor。</p>
<p>整个 clang static analyzer 的入口是 AnalysisConsumer，接着会调 HandleTranslationUnit() 方法进行 AST 层级进行分析或者进行 path-sensitive 分析。默认会按照 inline 的 path-sensitive 分析，构建 CallGraph，从顶层 caller 按照调用的关系来分析，具体是使用的 WorkList 算法，从 EntryBlock 开始一步步的模拟，这个过程叫做 intra-procedural analysis（IPA）。这个模拟过程还需要对内存进行模拟，clang static analyzer 的内存模型是基于《A Memory Model for Static Analysis of C Programs》这篇论文而来，pdf地址：<a href="http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf" target="_blank" rel="external">http://lcs.ios.ac.cn/~xuzb/canalyze/memmodel.pdf</a> 在clang里的具体实现代码可以查看这两个文件 <a href="https://code.woboq.org/llvm/clang/include/clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h.html" target="_blank" rel="external">MemRegion.h</a>和 <a href="https://code.woboq.org/llvm/clang/lib/StaticAnalyzer/Core/RegionStore.cpp.html" target="_blank" rel="external">RegionStore.cpp</a> 。</p>
<p>下面举个简单例子看看 clang static  analyzer 是如何对源码进行模拟的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line">	a = b;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 AST 以及 CFG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#————————AST—————————</div><div class="line"># clang -cc1 -ast-dump</div><div class="line">TranslationUnitDecl 0xc75b450 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;</div><div class="line">|-TypedefDecl 0xc75b740 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list ‘char *’</div><div class="line">`-FunctionDecl 0xc75b7b0 &lt;test.cpp:1:1, line:7:1&gt; line:1:5 main ‘int (void)’</div><div class="line">  `-CompoundStmt 0xc75b978 &lt;line:2:1, line:7:1&gt;</div><div class="line">    |-DeclStmt 0xc75b870 &lt;line:3:2, col:7&gt;</div><div class="line">    | `-VarDecl 0xc75b840 &lt;col:2, col:6&gt; col:6 used a ‘int’</div><div class="line">    |-DeclStmt 0xc75b8d8 &lt;line:4:2, col:12&gt;</div><div class="line">    | `-VarDecl 0xc75b890 &lt;col:2, col:10&gt; col:6 used b ‘int’ cinit</div><div class="line">    |   `-IntegerLiteral 0xc75b8c0 &lt;col:10&gt; ‘int’ 10</div><div class="line"></div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; a = b &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line">    |-BinaryOperator 0xc75b928 &lt;line:5:2, col:6&gt; ‘int’ lvalue ‘=‘</div><div class="line">    | |-DeclRefExpr 0xc75b8e8 &lt;col:2&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">    | `-ImplicitCastExpr 0xc75b918 &lt;col:6&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">    |   `-DeclRefExpr 0xc75b900 &lt;col:6&gt; ‘int’ lvalue Var 0xc75b890 ‘b’ ‘int’</div><div class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</div><div class="line"></div><div class="line">    `-ReturnStmt 0xc75b968 &lt;line:6:2, col:9&gt;</div><div class="line">      `-ImplicitCastExpr 0xc75b958 &lt;col:9&gt; ‘int’ &lt;LValueToRValue&gt;</div><div class="line">        `-DeclRefExpr 0xc75b940 &lt;col:9&gt; ‘int’ lvalue Var 0xc75b840 ‘a’ ‘int’</div><div class="line">#————————CFG—————————</div><div class="line"># clang -cc1 -analyze -analyzer-checker=debug.DumpCFG</div><div class="line">int main()</div><div class="line"> [B2 (ENTRY)]</div><div class="line">   Succs (1): B1</div><div class="line"></div><div class="line"> [B1]</div><div class="line">   1: int a;</div><div class="line">   2: 10</div><div class="line">   3: int b = 10;</div><div class="line">   4: b</div><div class="line">   5: [B1.4] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">   6: a</div><div class="line">   7: [B1.6] = [B1.5]</div><div class="line">   8: a</div><div class="line">   9: [B1.8] (ImplicitCastExpr, LValueToRValue, int)</div><div class="line">  10: return [B1.9];</div><div class="line">   Preds (1): B2</div><div class="line">   Succs (1): B0</div><div class="line"></div><div class="line"> [B0 (EXIT)]</div><div class="line">   Preds (1): B1</div></pre></td></tr></table></figure>
<p>CFG 将程序拆得更细，能够将执行的过程表现的更直观些，为了避免路径爆炸，函数 inline 的条件会设置的比较严格，函数 CFG 块多时不会进行 inline 分析，模拟栈深度超过一定值不会进行 inline 分析，这个默认是5。</p>
<p>在MRC使用的是CFG这样的执行路径模拟，ARC就没有了，举个例子，没有全部条件都返回，CFG就会报错，而AST就不会。</p>
<p>官方 AST 相关文档</p>
<ul>
<li><a href="http://clang.llvm.org/docs/Tooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/Tooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="external">http://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="external">http://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibTooling.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibTooling.html</a></li>
<li><a href="http://clang.llvm.org/docs/LibASTMatchers.html" target="_blank" rel="external">http://clang.llvm.org/docs/LibASTMatchers.html</a></li>
</ul>
<p>静态检查的一些库以及使用方法</p>
<ul>
<li><a href="https://github.com/DeveloperLx/FauxPas_document_translation/blob/master/README.md?from=timeline&amp;isappinstalled=0" target="_blank" rel="external">FauxPas_document_translation/README.md at master · DeveloperLx/FauxPas_document_translation · GitHub</a></li>
</ul>
<h1 id="CodeGen-生成-IR-代码"><a href="#CodeGen-生成-IR-代码" class="headerlink" title="CodeGen 生成 IR 代码"></a>CodeGen 生成 IR 代码</h1><p>将语法树翻译成 LLVM IR 中间代码，做为 LLVM Backend 输入的桥接语言。这样做的好处在前言里也提到了，方便 LLVM Backend 给多语言做相同的优化，做到语言无关。</p>
<p>这个过程中还会跟 runtime 桥接。</p>
<ul>
<li>各种类，方法，成员变量等的结构体的生成，并将其放到对应的Mach-O的section中。</li>
<li>Non-Fragile ABI 合成 OBJC<em>IVAR</em>$_ 偏移值常量。</li>
<li>ObjCMessageExpr 翻译成相应版本的 objc_msgSend，super 翻译成 objc_msgSendSuper。</li>
<li>strong，weak，copy，atomic 合成 @property 自动实现 setter 和 getter。</li>
<li>@synthesize 的处理。</li>
<li>生成 block_layout 数据结构</li>
<li><strong>block 和 </strong>weak</li>
<li>_block_invoke</li>
<li>ARC 处理，插入 objc_storeStrong 和 objc_storeWeak 等 ARC 代码。ObjCAutoreleasePoolStmt 转 objc_autorealeasePoolPush / Pop。自动添加 [super dealloc]。给每个 ivar 的类合成 .cxx_destructor 方法自动释放类的成员变量。</li>
</ul>
<p>不管编译的语言时 Objective-C 还是 Swift 也不管对应机器是什么，亦或是即时编译，LLVM 里唯一不变的是中间语言 LLVM IR。那么我们就来看看如何玩 LLVM IR。</p>
<h2 id="IR-结构"><a href="#IR-结构" class="headerlink" title="IR 结构"></a>IR 结构</h2><p>下面是刚才生成的 main.ll 中间代码文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">; ModuleID = ‘main.c’</div><div class="line">source_filename = “main.c”</div><div class="line">target datalayout = “e-m:o-i64:64-f80:128-n8:16:32:64-S128”</div><div class="line">target triple = “x86_64-apple-macosx10.12.0”</div><div class="line"></div><div class="line">@.str = private unnamed_addr constant [16 x i8] c”Please input a:\00”, align 1</div><div class="line">@.str.1 = private unnamed_addr constant [3 x i8] c”%d\00”, align 1</div><div class="line">@.str.2 = private unnamed_addr constant [16 x i8] c”Please input b:\00”, align 1</div><div class="line">@.str.3 = private unnamed_addr constant [32 x i8] c”a is:%d,b is :%d,count equal:%d\00”, align 1</div><div class="line"></div><div class="line">; Function Attrs: nounwind ssp uwtable</div><div class="line">define i32 @main() #0 &#123;</div><div class="line">  %1 = alloca i32, align 4</div><div class="line">  %2 = alloca i32, align 4</div><div class="line">  %3 = bitcast i32* %1 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %3) #3</div><div class="line">  %4 = bitcast i32* %2 to i8*</div><div class="line">  call void @llvm.lifetime.start(i64 4, i8* %4) #3</div><div class="line">  %5 = tail call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str, i64 0, i64 0))</div><div class="line">  %6 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %1)</div><div class="line">  %7 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.2, i64 0, i64 0))</div><div class="line">  %8 = call i32 (i8*, …) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32* nonnull %2)</div><div class="line">  %9 = load i32, i32* %1, align 4, !tbaa !2</div><div class="line">  %10 = load i32, i32* %2, align 4, !tbaa !2</div><div class="line">  %11 = add nsw i32 %10, %9</div><div class="line">  %12 = call i32 (i8*, …) @printf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.3, i64 0, i64 0), i32 %9, i32 %10, i32 %11)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %4) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* %3) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.start(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @printf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: nounwind</div><div class="line">declare i32 @scanf(i8* nocapture readonly, …) #2</div><div class="line"></div><div class="line">; Function Attrs: argmemonly nounwind</div><div class="line">declare void @llvm.lifetime.end(i64, i8* nocapture) #1</div><div class="line"></div><div class="line">attributes #0 = &#123; nounwind ssp uwtable “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #1 = &#123; argmemonly nounwind &#125;</div><div class="line">attributes #2 = &#123; nounwind “disable-tail-calls”=“false” “less-precise-fpmad”=“false” “no-frame-pointer-elim”=“true” “no-frame-pointer-elim-non-leaf” “no-infs-fp-math”=“false” “no-nans-fp-math”=“false” “stack-protector-buffer-size”=“8” “target-cpu”=“penryn” “target-features”=“+cx16,+fxsr,+mmx,+sse,+sse2,+sse3,+sse4.1,+ssse3” “unsafe-fp-math”=“false” “use-soft-float”=“false” &#125;</div><div class="line">attributes #3 = &#123; nounwind &#125;</div><div class="line"></div><div class="line">!llvm.module.flags = !&#123;!0&#125;</div><div class="line">!llvm.ident = !&#123;!1&#125;</div><div class="line"></div><div class="line">!0 = !&#123;i32 1, !”PIC Level”, i32 2&#125;</div><div class="line">!1 = !&#123;!”Apple LLVM version 8.0.0 (clang-800.0.42.1)”&#125;</div><div class="line">!2 = !&#123;!3, !3, i64 0&#125;</div><div class="line">!3 = !&#123;!”int”, !4, i64 0&#125;</div><div class="line">!4 = !&#123;!”omnipotent char”, !5, i64 0&#125;</div><div class="line">!5 = !&#123;!”Simple C/C++ TBAA”&#125;</div></pre></td></tr></table></figure></p>
<p>LLVM IR 有三种表示格式，第一种是 bitcode 这样的存储格式，以 .bc 做后缀，第二种是可读的以 .ll，第三种是用于开发时操作 LLVM IR 的内存格式。</p>
<p>一个编译的单元即一个文件在 IR 里就是一个 Module，Module 里有 Global Variable 和 Function，在 Function里有 Basic Block，Basic Block 里有 指令 Instructions。<br>‘</p>
<p>通过下面的 IR 结构图能够更好的理解 IR 的整体结构。</p>
<p><img src="/uploads/deeply-analyse-llvm/08.png" alt=""></p>
<p>图中可以看出最大的是 Module，里面包含多个 Function，每个 Function 包含多个 BasicBlock，BasicBlock 里含有 Instruction，代码非常清晰，这样如果想开发一个新语言只需要完成语法解析后通过 LLVM 提供的丰富接口在内存中生成 IR 就可以直接运行在各个不同的平台。</p>
<p>IR 语言满足静态单赋值，可以很好的降低数据流分析和控制流分析的复杂度。及只能在定义时赋值，后面不能更改。但是这样就没法写程序了，输入输出都没法弄，所以函数式编程才会有类似 Monad 这样机制的原因。</p>
<h2 id="LLVM-IR-优化"><a href="#LLVM-IR-优化" class="headerlink" title="LLVM IR 优化"></a>LLVM IR 优化</h2><p>使用 O2，O3 这样的优化会调用对应的 Pass 来进行处理，有比如类似死代码清理，内联化，表达式重组，循环变量移动这样的 Pass。可以通过 llvm-opt 调用 LLVM 优化相关的库。</p>
<p>可能直接这么说不太直观，我们可以更改下原 c 代码举个小例子看看这些 Pass 会做哪些优化。当我们加上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</div><div class="line">    i++;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的 IR 代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">%call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 1)</div><div class="line">%call4.1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 2)</div><div class="line">%call4.2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 3)</div><div class="line">%call4.3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 4)</div><div class="line">%call4.4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 5)</div><div class="line">%call4.5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 6)</div><div class="line">%call4.6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 7)</div><div class="line">%call4.7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 8)</div><div class="line">%call4.8 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 9)</div><div class="line">%call4.9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 10)</div></pre></td></tr></table></figure></p>
<p>可以看出来这个 while 在 IR 中就是重复的打印了10次，那要是我把10改成100是不是会变成打印100次呢？</p>
<p>我们改成100后，再次生成 IR 可以看到 IR 变成了这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  br label %while.body</div><div class="line"></div><div class="line">while.body:                                       ; preds = %while.body, %entry</div><div class="line">  %i.010 = phi i32 [ 0, %entry ], [ %inc, %while.body ]</div><div class="line">  %inc = add nuw nsw i32 %i.010, 1</div><div class="line">  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.1, i64 0, i64 0), i32 %inc)</div><div class="line">  %exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div><div class="line"></div><div class="line">while.end:                                        ; preds = %while.body</div><div class="line">  %2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">  %3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">  %add = add nsw i32 %3, %2</div><div class="line">  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.3, i64 0, i64 0), i32 %add)</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %1) #3</div><div class="line">  call void @llvm.lifetime.end(i64 4, i8* nonnull %0) #3</div><div class="line">  ret i32 0</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里对不同条件生成的不同都是 Pass 优化器做的事情。解读上面这段 IR 需要先了解下 IR 语法关键字，如下：</p>
<ul>
<li>@ - 代表全局变量</li>
<li>% - 代表局部变量</li>
<li>alloca - 指令在当前执行的函数的堆栈帧中分配内存，当该函数返回到其调用者时，将自动释放内存。</li>
<li>i32：- i 是几这个整数就会占几位，i32就是32位4字节</li>
<li>align - 对齐，比如一个 int,一个 char 和一个 int。单个 int 占4个字节，为了对齐只占一个字节的 char需要向4对齐占用4字节空间。</li>
<li>Load - 读出，store 写入</li>
<li>icmp - 两个整数值比较，返回布尔值</li>
<li>br - 选择分支，根据 cond 来转向 label，不根据条件跳转的话类似 goto</li>
<li>indirectbr - 根据条件间接跳转到一个 label，而这个 label 一般是在一个数组里，所以跳转目标是可变的，由运行时决定的</li>
<li>label - 代码标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">br label %while.body</div></pre></td></tr></table></figure>
<p>如上面表述，br  会选择跳向 while.body 定义的这个标签。这个标签里可以看到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">%exitcond = icmp eq i32 %inc, 100</div><div class="line">  br i1 %exitcond, label %while.end, label %while.body</div></pre></td></tr></table></figure></p>
<p>这段，icmp 会比较当前的 %inc 和定义的临界值 100，根据返回的布尔值来决定 br 跳转到那个代码标签，真就跳转到 while.end 标签，否就在进入 while.body 标签。这就是 while 的逻辑。通过br 跳转和 label 这种标签的概念使得 IR 语言能够成为更低级兼容性更高更方便转向更低级语言的语言。</p>
<h2 id="SSA"><a href="#SSA" class="headerlink" title="SSA"></a>SSA</h2><p>LLVM IR 是 SSA 形式的，维护双向 def-use 信息，use-def 是通过普通指针实现信息维护，def-use 是通过内存跳表和链表来实现的，便于 forward dataflow analysis 和 backward dataflow analysis。可以通过 ADCE 这个 Pass 来了解下 backward dataflow，这个pass 的源文件在 lib/Transforms/Scalar/ADCE.cpp 中，ADCE 实现了 Aggressive Dead Code Elimination Pass。这个 Pass 乐观地假设所有 instructions 都是 Dead 直到证明是否定的，允许它消除其他 DCE Pass 的 Dead 计算 catch，特别是涉及循环计算。其它 DCE 相关的 Pass 可以查看同级目录下的 BDCE.cpp 和 DCE.cpp，目录下其它的 Pass 都是和数据流相关的分析包含了各种分析算法和思路。</p>
<p>那么看看加法这个操作的相关的 IR 代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">%2 = load i32, i32* %a, align 4, !tbaa !2</div><div class="line">%3 = load i32, i32* %b, align 4, !tbaa !2</div><div class="line">%add = add nsw i32 %3, %2</div></pre></td></tr></table></figure></p>
<p>加法对应的指令是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BinaryOperator::CreateAdd(Value *V1, Value *V2, <span class="keyword">const</span> Twine &amp;Name)</div></pre></td></tr></table></figure></p>
<p>两个输入 V1 和 V2 的 def-use 是如何的呢，看看如下代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">class Value &#123;</div><div class="line">  void addUse(Use &amp;U) &#123; U.addToList(&amp;UseList); &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Use &#123;</div><div class="line">  Value *Val;</div><div class="line">  Use *Next;</div><div class="line">  PointerIntPair&lt;Use **, 2, PrevPtrTag&gt; Prev;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void Use::set(Value *V) &#123;</div><div class="line">  if (Val) removeFromList();</div><div class="line">  Val = V;</div><div class="line">  if (V) V-&gt;addUse(*this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Value *Use::operator=(Value *RHS) &#123;</div><div class="line">  set(RHS);</div><div class="line">  return RHS;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class User : public Value &#123;</div><div class="line">  template &lt;int Idx, typename U&gt; static Use &amp;OpFrom(const U *that) &#123;</div><div class="line">    return Idx &lt; 0</div><div class="line">      ? OperandTraits&lt;U&gt;::op_end(const_cast&lt;U*&gt;(that))[Idx]</div><div class="line">      : OperandTraits&lt;U&gt;::op_begin(const_cast&lt;U*&gt;(that))[Idx];</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; Use &amp;Op() &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line">  template &lt;int Idx&gt; const Use &amp;Op() const &#123;</div><div class="line">    return OpFrom&lt;Idx&gt;(this);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class Instruction : public User,</div><div class="line">                    public ilist_node_with_parent&lt;Instruction, BasicBlock&gt; &#123;</div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class BinaryOperator : public Instruction &#123;</div><div class="line">  /// Construct a binary instruction, given the opcode and the two</div><div class="line">  /// operands.  Optionally (if InstBefore is specified) insert the instruction</div><div class="line">  /// into a BasicBlock right before the specified instruction.  The specified</div><div class="line">  /// Instruction is allowed to be a dereferenced end iterator.</div><div class="line">  ///</div><div class="line">  static BinaryOperator *Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                const Twine &amp;Name = Twine(),</div><div class="line">                                Instruction *InsertBefore = nullptr);</div><div class="line"></div><div class="line">  // ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">BinaryOperator::BinaryOperator(BinaryOps iType, Value *S1, Value *S2,</div><div class="line">                               Type *Ty, const Twine &amp;Name,</div><div class="line">                               Instruction *InsertBefore)</div><div class="line">  : Instruction(Ty, iType,</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::op_begin(this),</div><div class="line">                OperandTraits&lt;BinaryOperator&gt;::operands(this),</div><div class="line">                InsertBefore) &#123;</div><div class="line">  Op&lt;0&gt;() = S1;</div><div class="line">  Op&lt;1&gt;() = S2;</div><div class="line">  init(iType);</div><div class="line">  setName(Name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">BinaryOperator *BinaryOperator::Create(BinaryOps Op, Value *S1, Value *S2,</div><div class="line">                                       const Twine &amp;Name,</div><div class="line">                                       Instruction *InsertBefore) &#123;</div><div class="line">  assert(S1-&gt;getType() == S2-&gt;getType() &amp;&amp;</div><div class="line">         "Cannot create binary operator with two operands of differing type!");</div><div class="line">  return new BinaryOperator(Op, S1, S2, S1-&gt;getType(), Name, InsertBefore);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码里可以看出是使用了 Use 对象来把 use 和 def 联系起来的。</p>
<p>LLVM IR 通过 mem2reg 这个 Pass 来把局部变量成 SSA 形式。这个 Pass 的代码在 lib/Transforms/Utils/Mem2Reg.cpp 里。LLVM通过 mem2reg Pass 能够识别 alloca 模式，将其设置 SSA value。这时就不在需要 alloca，load和store了。mem2reg 是对 PromoteMemToReg 函数调用的一个简单包装，真正的算法实现是在 PromoteMemToReg 函数里，这个函数在 lib/Transforms/Utils/PromoteMemoryToRegister.cpp 这个文件里。</p>
<p>这个算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。这种算法叫做 iterated dominance frontier算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。</p>
<p>当然把多个字节码 .bc 合成一个文件，链接时还会优化，IR 结构在优化后会有变化，这样还能够在变化后的 IR 的结构上再进行更多的优化。</p>
<p>这里可以进行 lli 解释执行 LLVM IR。</p>
<p>llc 编译器是专门编译 LLVM IR 的编译器用来生成汇编文件。</p>
<p>调用系统汇编器比如 GNU 的 as 来编译生成 .o Object 文件，接下来就是用链接器链接相关库和 .o 文件一起生成可执行的 .out 或者 exe 文件了。</p>
<p>llvm-mc 还可以直接生成 object 文件。</p>
<h1 id="Clang-CFE"><a href="#Clang-CFE" class="headerlink" title="Clang CFE"></a>Clang CFE</h1><p>动手玩肯定不能少了 Clang 的前端组件及库，熟悉这些库以后就能够自己动手用这些库编写自己的程序了。下面我就对这些库做些介绍，然后再着重说说 libclang 库，以及如何用它来写工具。</p>
<ul>
<li>LLVM Support Library - LLVM libSupport 库提供了许多底层库和数据结构，包括命令行 option 处理，各种容器和系统抽象层，用于文件系统访问。</li>
<li>The Clang “Basic” Library - 提供了跟踪和操纵 source buffers，source buffers 的位置，diagnostics，tokens,抽象目标以及编译语言子集信息的 low-level 实用程序。还有部分可以用在其他的非 c 语言比如 SourceLocation，SourceManager，Diagnositics，FileManager 等。其中 Diagnositics 这个子系统是编译器和普通写代码人交流的主要组成部分，它会诊断当前代码哪些不正确，按照严重程度而产生 WARNING 或 ERROR，每个诊断会有唯一 ID ， SourceLocation 会负责管理。</li>
<li>The Driver Library - 和 Driver 相关的库，上面已经对其做了详细的介绍。</li>
<li>Precompiled Headers - Clang 支持预编译 headers 的两个实现。</li>
<li>The Frontend Library - 这个库里包含了在 Clang 库之上构建的功能，比如输出 diagnositics 的几种方法。</li>
<li>The Lexer and Preprocessor Library - 词法分析和预处理的库，包含了 Token，Annotation Tokens，TokenLexer，Lexer 等词法类，还有 Parser Library 和 AST 语法树相关的比如 Type，ASTContext，QualType，DeclarationName，DeclContext 以及 CFG 类。</li>
<li>The Sema Library - 解析器调用此库时，会对输入进行语义分析。 对于有效的程序，Sema 为解析构造一个 AST。</li>
<li>The CodeGen Library - CodeGen 用 AST 作为输入，并从中生成 LLVM IR 代码。</li>
</ul>
<h2 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h2><p>libclang 会让你觉得 clang 不仅仅只是一个伟大的编译器。下面从解析源码来说下</p>
<p>先写个 libclang 的程序来解析源码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</div><div class="line">    CXIndex Index = clang_createIndex(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    CXTranslationUnit TU = clang_parseTranslationUnit(Index, <span class="number">0</span>,</div><div class="line">                                                      argv, argc, <span class="number">0</span>, <span class="number">0</span>, CXTranslationUnit_None); <span class="keyword">for</span> (<span class="keyword">unsigned</span> I = <span class="number">0</span>, N = clang_getNumDiagnostics(TU); I != N; ++I) &#123;</div><div class="line">        CXDiagnostic Diag = clang_getDiagnostic(TU, I);</div><div class="line">        CXString String = clang_formatDiagnostic(Diag,clang_defaultDiagnosticDisplayOptions());</div><div class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, clang_getCString(String));</div><div class="line">        clang_disposeString(String);</div><div class="line">    &#125;</div><div class="line">    clang_disposeTranslationUnit(TU);</div><div class="line">    clang_disposeIndex(Index);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再写个有问题的 c 程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span> <span class="comment">/**/</span> &#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">union</span> List *L)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</div></pre></td></tr></table></figure></p>
<p>运行了语法检查后会出现提示信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">list.c:2:9: error: use of <span class="string">'List'</span> with tag <span class="built_in">type</span> that does not match</div><div class="line">      previous declaration</div><div class="line">int sum(union List *Node) &#123;</div><div class="line">^~~~~</div><div class="line">struct</div><div class="line">list.c:1:8: note: previous use is here</div><div class="line">struct List &#123;</div><div class="line">^</div></pre></td></tr></table></figure></p>
<p>下面我们看看诊断过程，显示几个核心诊断方法诊断出问题</p>
<ul>
<li>enum CXDiagnosticSeverity clang_getDiagnosticSeverity(CXDiagnostic Diag);</li>
<li>CXSourceLocation clang_getDiagnosticLocation(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticSpelling(CXDiagnostic Diag);</li>
</ul>
<p>接着进行高亮显示，最后提供两个提示修复的方法</p>
<ul>
<li>unsigned clang_getDiagnosticNumFixIts(CXDiagnostic Diag);</li>
<li>CXString clang_getDiagnosticFixIt(CXDiagnostic Diag, unsigned FixIt,<br>CXSourceRange *ReplacementRange);</li>
</ul>
<p>我们先遍历语法树的节点。源 c 程序如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(struct List *Node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (; Node; Node = Node-&gt;Next)</div><div class="line">        result = result + Node-&gt;Data;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先找出所有的声明，比如 List，Data，Next，sum，Node 以及 result 等。再找出引用，比如 struct List *Next 里的 List。还有声明和表达式，比如 int result = 0; 还有 for 语句等。还有宏定义和实例化等。</p>
<p>CXCursor 会统一 AST 的节点，规范包含的信息</p>
<ul>
<li>代码所在位置和长度</li>
<li>名字和符号解析</li>
<li>类型</li>
<li>子节点</li>
</ul>
<p>举个 CXCursor 分析例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> Data;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">Next</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>CXCursor 的处理过程如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Top-level cursor C</span></div><div class="line">clang_getCursorKind(C) == CXCursor_StructDecl</div><div class="line">clang_getCursorSpelling(C) == <span class="string">"List"</span> <span class="comment">//获取名字字符串</span></div><div class="line">clang_getCursorLocation(C) <span class="comment">//位置</span></div><div class="line">clang_getCursorExtent(C) <span class="comment">//长度</span></div><div class="line">clang_visitChildren(C, ...); <span class="comment">//访问子节点</span></div><div class="line"></div><div class="line"><span class="comment">//Reference cursor R</span></div><div class="line">clang_getCursorKind(R) == CXCursor_TypeRef </div><div class="line">clang_getCursorSpelling(R) == <span class="string">"List"</span></div><div class="line">clang_getCursorLocation(R)</div><div class="line">clang_getCursorExtent(R)</div><div class="line">clang_getCursorReferenced(R) == C <span class="comment">//指向C</span></div></pre></td></tr></table></figure></p>
<h1 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h1><p>动手玩的话，特别是想要使用这些工具链之前最好先了解我们和 LLVM 交互的实现。那么这部分就介绍下 LLVM 里的 Driver。</p>
<p>Driver 是 Clang 面对用户的接口，用来解析 Option 设置，判断决定调用的工具链，最终完成整个编译过程。</p>
<p>相关源代码在这里：clang/tools/driver/driver.cpp</p>
<p>整个 Driver 源码的入口函数就是 driver.cpp 里的 main() 函数。从这里可以作为入口看看整个  driver 是如何工作的，这样更利于我们以后轻松动手驾驭 LLVM。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc_, <span class="keyword">const</span> <span class="keyword">char</span> **argv_)</span> </span>&#123;</div><div class="line">  llvm::sys::PrintStackTraceOnErrorSignal(argv_[<span class="number">0</span>]);</div><div class="line">  llvm::<span class="function">PrettyStackTraceProgram <span class="title">X</span><span class="params">(argc_, argv_)</span></span>;</div><div class="line">  llvm::llvm_shutdown_obj Y; <span class="comment">// Call llvm_shutdown() on exit.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (llvm::sys::Process::FixupStandardFileDescriptors())</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line"></div><div class="line">  SmallVector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="number">256</span>&gt; argv;</div><div class="line">  llvm::SpecificBumpPtrAllocator&lt;<span class="keyword">char</span>&gt; ArgAllocator;</div><div class="line">  <span class="built_in">std</span>::error_code EC = llvm::sys::Process::GetArgumentVector(</div><div class="line">      argv, llvm::makeArrayRef(argv_, argc_), ArgAllocator);</div><div class="line">  <span class="keyword">if</span> (EC) &#123;</div><div class="line">    llvm::errs() &lt;&lt; <span class="string">"error: couldn't get arguments: "</span> &lt;&lt; EC.message() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  llvm::InitializeAllTargets();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> ProgName = argv[<span class="number">0</span>];</div><div class="line">  <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; TargetAndMode =</div><div class="line">      ToolChain::getTargetAndModeFromProgramName(ProgName);</div><div class="line"></div><div class="line">  llvm::BumpPtrAllocator A;</div><div class="line">  llvm::<span class="function">StringSaver <span class="title">Saver</span><span class="params">(A)</span></span>;</div><div class="line">	</div><div class="line">	<span class="comment">//省略</span></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="comment">// If we have multiple failing commands, we return the result of the first</span></div><div class="line">  <span class="comment">// failing command.</span></div><div class="line">  <span class="keyword">return</span> Res;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Driver-的工作流程图"><a href="#Driver-的工作流程图" class="headerlink" title="Driver 的工作流程图"></a>Driver 的工作流程图</h2><p>在 driver.cpp 的 main 函数里有 Driver 的初始化。我们来看看和 driver 相关的代码<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">  Driver TheDriver(Path, llvm::sys::getDefaultTargetTriple(), Diags);</div><div class="line">  SetInstallDir(argv, TheDriver, CanonicalPrefixes);</div><div class="line"></div><div class="line">  insertTargetAndModeArgs(TargetAndMode.first, TargetAndMode.second, argv,</div><div class="line">                          SavedStrings);</div><div class="line"></div><div class="line">  SetBackdoorDriverOutputsFromEnvVars(TheDriver);</div><div class="line"></div><div class="line">  std::unique_ptr&lt;Compilation&gt; C(TheDriver.BuildCompilation(argv));</div><div class="line">  int Res = 0;</div><div class="line">  SmallVector&lt;std::pair&lt;int, const Command *&gt;, 4&gt; FailingCommands;</div><div class="line">  if (C.get())</div><div class="line">    Res = TheDriver.ExecuteCompilation(*C, FailingCommands);</div><div class="line"></div><div class="line">  // Force a crash to test the diagnostics.</div><div class="line">  if (::getenv("FORCE_CLANG_DIAGNOSTICS_CRASH")) &#123;</div><div class="line">    Diags.Report(diag::err_drv_force_crash) &lt;&lt; "FORCE_CLANG_DIAGNOSTICS_CRASH";</div><div class="line"></div><div class="line">    // Pretend that every command failed.</div><div class="line">    FailingCommands.clear();</div><div class="line">    for (const auto &amp;J : C-&gt;getJobs())</div><div class="line">      if (const Command *C = dyn_cast&lt;Command&gt;(&amp;J))</div><div class="line">        FailingCommands.push_back(std::make_pair(-1, C));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  for (const auto &amp;P : FailingCommands) &#123;</div><div class="line">    int CommandRes = P.first;</div><div class="line">    const Command *FailingCommand = P.second;</div><div class="line">    if (!Res)</div><div class="line">      Res = CommandRes;</div><div class="line"></div><div class="line">    // If result status is &lt; 0, then the driver command signalled an error.</div><div class="line">    // If result status is 70, then the driver command reported a fatal error.</div><div class="line">    // On Windows, abort will return an exit code of 3.  In these cases,</div><div class="line">    // generate additional diagnostic information if possible.</div><div class="line">    bool DiagnoseCrash = CommandRes &lt; 0 || CommandRes == 70;</div><div class="line">#ifdef LLVM_ON_WIN32</div><div class="line">    DiagnoseCrash |= CommandRes == 3;</div><div class="line">#endif</div><div class="line">    if (DiagnoseCrash) &#123;</div><div class="line">      TheDriver.generateCompilationDiagnostics(*C, *FailingCommand);</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>可以看到初始化 Driver 后 driver 会调用 BuildCompilation 生成 Compilation。Compilation 字面意思是合集的意思，通过 driver.cpp 的 include 可以看到<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Driver/Compilation.h"</span></span></div></pre></td></tr></table></figure></p>
<p>根据此路径可以细看下 Compilation 这个为了 driver 设置的一组任务的类。通过这个类我们提取里面这个阶段比较关键的几个信息出来<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> &#123;</span></div><div class="line">	<span class="comment">/// The original (untranslated) input argument list.</span></div><div class="line">  llvm::opt::InputArgList *Args;</div><div class="line"></div><div class="line">  <span class="comment">/// The driver translated arguments. Note that toolchains may perform their</span></div><div class="line">  <span class="comment">/// own argument translation.</span></div><div class="line">  llvm::opt::DerivedArgList *TranslatedArgs;</div><div class="line">  <span class="comment">/// The driver we were created by.</span></div><div class="line">  <span class="keyword">const</span> Driver &amp;TheDriver;</div><div class="line"></div><div class="line">  <span class="comment">/// The default tool chain.</span></div><div class="line">  <span class="keyword">const</span> ToolChain &amp;DefaultToolChain;</div><div class="line"> ...</div><div class="line">  <span class="comment">/// The list of actions.  This is maintained and modified by consumers, via</span></div><div class="line">  <span class="comment">/// getActions().</span></div><div class="line">  ActionList Actions;</div><div class="line"></div><div class="line">  <span class="comment">/// The root list of jobs.</span></div><div class="line">  JobList Jobs;</div><div class="line">	...</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	...</div><div class="line">  <span class="function"><span class="keyword">const</span> Driver &amp;<span class="title">getDriver</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> TheDriver; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">const</span> ToolChain &amp;<span class="title">getDefaultToolChain</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DefaultToolChain; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">ActionList &amp;<span class="title">getActions</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> ActionList &amp;<span class="title">getActions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Actions; &#125;</div><div class="line">	...</div><div class="line">  <span class="function">JobList &amp;<span class="title">getJobs</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line">  <span class="function"><span class="keyword">const</span> JobList &amp;<span class="title">getJobs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Jobs; &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Command&gt; C)</span> </span>&#123; Jobs.addJob(<span class="built_in">std</span>::move(C)); &#125;</div><div class="line">	...</div><div class="line">  <span class="comment">/// ExecuteCommand - Execute an actual command.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommand - For non-zero results, this will be set to the</span></div><div class="line">  <span class="comment">/// Command which failed, if any.</span></div><div class="line">  <span class="comment">/// \return The result code of the subprocess.</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">ExecuteCommand</span><span class="params">(<span class="keyword">const</span> Command &amp;C, <span class="keyword">const</span> Command *&amp;FailingCommand)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/// ExecuteJob - Execute a single job.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param FailingCommands - For non-zero results, this will be a vector of</span></div><div class="line">  <span class="comment">/// failing commands and their associated result code.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ExecuteJobs</span><span class="params">(</span></span></div><div class="line">      <span class="keyword">const</span> JobList &amp;Jobs,</div><div class="line">      SmallVectorImpl&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">const</span> Command *&gt;&gt; &amp;FailingCommands) <span class="keyword">const</span>;</div><div class="line">	...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>通过这些关键定义再结合 BuildCompilation 函数的实现可以看出这个 Driver 的流程是按照 ArgList - Actions - Jobs 来的，完整的图如下：</p>
<p><img src="/uploads/deeply-analyse-llvm/04.png" alt=""></p>
<h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>看完完整的 Driver 流程后，我们就先从 Parse 开始说起。</p>
<p>Parse 是解析选项，对应的代码在 ParseArgStrings 这个函数里。</p>
<p>下面通过执行一个试试，比如 clang -### main.c -ITheOptionWeAdd</p>
<p><img src="/uploads/deeply-analyse-llvm/05.png" alt=""></p>
<p>这里的 -I 是 Clang 支持的，在 Clang 里是 Option 类，Clang 会对这些 Option 专门的进行解析，使用一种 DSL 语言将其转成 .tb 文件后使用 table-gen 转成 C++ 语言和其它代码一起进行编译。</p>
<p>Driver 层会解析我们传入的 -I Option 参数。</p>
<p>-x 后加个 c 表示是对 c 语言进行编译，Clang Driver 通过文件的后缀 .c 来自动加上这个 参数的。如果是 c++ 语言，仅仅通过在 -x 后添加 cpp 编译还是会出错的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ main.cpp</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-llvm/06.png" alt=""></p>
<p>通过报错信息可以看出一些链接错误</p>
<p>因为需要链接 C++ 标准库，所以加上参数 -lc++ 就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -x c++ -lc++ main.cpp</div></pre></td></tr></table></figure></p>
<p>那么 clang++ 和 clang 命令的区别就在于会加载 C++ 库，其实 clang++ 最终还是会调用 Clang，那么手动指定加载库就好了何必还要多个 clang++ 命令呢，这主要是为了能够在这个命令里去加载更多的库，除了标准库以外，还有些非 C++ 标准库，辅助库等等。这样只要是 C++ 的程序用 clang++ 够了。</p>
<p>只有加上 -cc1 这个 option 才能进入到 Clang driver 比如 emit-obj 这个 option 就需要先加上 -cc1。</p>
<p>这点可以通过  driver.cpp 源码来看，在 main()  函数里可以看到在做了些多平台的兼容处理后就开始进行对入参判断第一个是不是 -cc1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (MarkEOLs &amp;&amp; argv.size() &gt; <span class="number">1</span> &amp;&amp; StringRef(argv[<span class="number">1</span>]).startswith(<span class="string">"-cc1"</span>))</div><div class="line">    MarkEOLs = <span class="literal">false</span>;</div><div class="line">  llvm::cl::ExpandResponseFiles(Saver, Tokenizer, argv, MarkEOLs);</div><div class="line"></div><div class="line">  <span class="comment">// 处理 -cc1 集成工具</span></div><div class="line">  <span class="keyword">auto</span> FirstArg = <span class="built_in">std</span>::find_if(argv.begin() + <span class="number">1</span>, argv.end(),</div><div class="line">                               [](<span class="keyword">const</span> <span class="keyword">char</span> *A) &#123; <span class="keyword">return</span> A != <span class="literal">nullptr</span>; &#125;);</div><div class="line">  <span class="keyword">if</span> (FirstArg != argv.end() &amp;&amp; StringRef(*FirstArg).startswith(<span class="string">"-cc1"</span>)) &#123;</div><div class="line">    <span class="comment">// 如果 -cc1 来自 response file, 移除 EOL sentinels</span></div><div class="line">    <span class="keyword">if</span> (MarkEOLs) &#123;</div><div class="line">      <span class="keyword">auto</span> newEnd = <span class="built_in">std</span>::remove(argv.begin(), argv.end(), <span class="literal">nullptr</span>);</div><div class="line">      argv.resize(newEnd - argv.begin());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ExecuteCC1Tool(argv, argv[<span class="number">1</span>] + <span class="number">4</span>);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>如果是 -cc1 的话会调用 ExecuteCC1Tool 这个函数，先看看这个函数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ExecuteCC1Tool</span><span class="params">(ArrayRef&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; argv, StringRef Tool)</span> </span>&#123;</div><div class="line">  <span class="keyword">void</span> *GetExecutablePathVP = (<span class="keyword">void</span> *)(<span class="keyword">intptr_t</span>) GetExecutablePath;</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">""</span>)</div><div class="line">    <span class="keyword">return</span> cc1_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line">  <span class="keyword">if</span> (Tool == <span class="string">"as"</span>)</div><div class="line">    <span class="keyword">return</span> cc1as_main(argv.slice(<span class="number">2</span>), argv[<span class="number">0</span>], GetExecutablePathVP);</div><div class="line"></div><div class="line">  <span class="comment">// 拒绝未知工具</span></div><div class="line">  llvm::errs() &lt;&lt; <span class="string">"error: unknown integrated tool '"</span> &lt;&lt; Tool &lt;&lt; <span class="string">"'\n"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终的执行会执行 cc1-main 或者 cc1as_main 。这两个函数分别在 driver.cpp 同级目录里的 cc1_main.cpp 和 cc1as_main.cpp 中。</p>
<p>下面看看有哪些解析 Args 的方法</p>
<ul>
<li>ParseAnalyzerArgs - 解析出静态分析器 option</li>
<li>ParseMigratorArgs - 解析 Migrator option</li>
<li>ParseDependencyOutputArgs - 解析依赖输出 option</li>
<li>ParseCommentArgs - 解析注释 option</li>
<li>ParseFileSystemArgs - 解析文件系统 option</li>
<li>ParseFrontendArgs - 解析前端 option</li>
<li>ParseTargetArgs - 解析目标  option</li>
<li>ParseCodeGenArgs - 解析 CodeGen 相关的 option</li>
<li>ParseHeaderSearchArgs - 解析 HeaderSearch 对象相关初始化相关的 option</li>
<li>parseSanitizerKinds - 解析 Sanitizer Kinds</li>
<li>ParsePreprocessorArgs - 解析预处理的 option</li>
<li>ParsePreprocessorOutputArgs - 解析预处理输出的 option</li>
</ul>
<h2 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h2><p>Pipeline 这里可以添加 -ccc-print-phases 看到进入 Pipeline 以后的事情。</p>
<p>这些如 -ccc-print-phases 这样的 option 在编译时会生成.inc 这样的 C++ TableGen 文件。在 Options.td 可以看到全部的 option 定义。</p>
<p>在 Clang 的 Pipeline 中很多实际行为都有对应的 Action，比如 preprocessor 时提供文件的 InputAction 和用于绑定机器架构的 BindArchAction。</p>
<p>使用 clang main.c -arch i386 -arch x86_64 -o main 然后 file main 能够看到这时 BindArchAction 这个 Action 起到了作用，编译链接了两次同时创建了一个库既能够支持32位也能够支持64位用 lipo 打包。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildActions - Construct the list of actions to perform for the</span></div><div class="line">  <span class="comment">/// given arguments, which are only done for a single architecture.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param Args - The input arguments.</span></div><div class="line">  <span class="comment">/// \param Actions - The list to store the resulting actions onto.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildActions</span><span class="params">(Compilation &amp;C, llvm::opt::DerivedArgList &amp;Args,</span></span></div><div class="line">                    <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">/// BuildUniversalActions - Construct the list of actions to perform</span></div><div class="line">  <span class="comment">/// for the given arguments, which may require a universal build.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// \param C - The compilation that is being built.</span></div><div class="line">  <span class="comment">/// \param TC - The default host tool chain.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">BuildUniversalActions</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> ToolChain &amp;TC,</span></span></div><div class="line">                             <span class="keyword">const</span> InputList &amp;BAInputs) <span class="keyword">const</span>;</div></pre></td></tr></table></figure>
<p>上面两个方法中 BuildUniversalActions 最后也会走 BuildActions。BuildActions 了，进入这个方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Driver::BuildActions(Compilation &amp;C, DerivedArgList &amp;Args,</div><div class="line">                          <span class="keyword">const</span> InputList &amp;Inputs, ActionList &amp;Actions) <span class="keyword">const</span> &#123;</div><div class="line">  llvm::<span class="function">PrettyStackTraceString <span class="title">CrashInfo</span><span class="params">(<span class="string">"Building compilation actions"</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!SuppressMissingInputWarning &amp;&amp; Inputs.empty()) &#123;</div><div class="line">    Diag(clang::diag::err_drv_no_input_files);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Arg *FinalPhaseArg;</div><div class="line">  phases::ID FinalPhase = getFinalPhase(Args, &amp;FinalPhaseArg);</div></pre></td></tr></table></figure></p>
<p>接着跟 getFinalPhase 这个方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// -&#123;E,EP,P,M,MM&#125; only run the preprocessor.</span></div><div class="line">  <span class="keyword">if</span> (CCCIsCPP() || (PhaseArg = DAL.getLastArg(options::OPT_E)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_EP)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT_M, options::OPT_MM)) ||</div><div class="line">      (PhaseArg = DAL.getLastArg(options::OPT__SLASH_P))) &#123;</div><div class="line">    FinalPhase = phases::Preprocess;</div><div class="line"></div><div class="line">    <span class="comment">// -&#123;fsyntax-only,-analyze,emit-ast&#125; only run up to the compiler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_fsyntax_only)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_module_file_info)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_verify_pch)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_rewrite_legacy_objc)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__migrate)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT__analyze,</div><div class="line">                                        options::OPT__analyze_auto)) ||</div><div class="line">             (PhaseArg = DAL.getLastArg(options::OPT_emit_ast))) &#123;</div><div class="line">    FinalPhase = phases::Compile;</div><div class="line"></div><div class="line">    <span class="comment">// -S only runs up to the backend.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_S))) &#123;</div><div class="line">    FinalPhase = phases::Backend;</div><div class="line"></div><div class="line">    <span class="comment">// -c compilation only runs up to the assembler.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((PhaseArg = DAL.getLastArg(options::OPT_c))) &#123;</div><div class="line">    FinalPhase = phases::Assemble;</div><div class="line"></div><div class="line">    <span class="comment">// Otherwise do everything.</span></div><div class="line">  &#125; <span class="keyword">else</span></div><div class="line">    FinalPhase = phases::Link;</div></pre></td></tr></table></figure></p>
<p>看完这段代码就会发现其实每次的 option 都会完整的走一遍从预处理，静态分析，backend 再到汇编的过程。</p>
<p>下面列下一些编译器的前端 Action，大家可以一个个用着玩。</p>
<ul>
<li>InitOnlyAction - 只做前端初始化，编译器 option 是 -init-only</li>
<li>PreprocessOnlyAction - 只做预处理，不输出，编译器的 option 是 -Eonly</li>
<li>PrintPreprocessedAction - 做预处理，子选项还包括-P、-C、-dM、-dD 具体可以查看PreprocessorOutputOptions 这个类，编译器 option 是 -E</li>
<li>RewriteIncludesAction - 预处理</li>
<li>DumpTokensAction - 打印token，option 是 -dump-tokens</li>
<li>DumpRawTokensAction - 输出原始tokens，包括空格符，option 是 -dump-raw-tokens</li>
<li>RewriteMacrosAction - 处理并扩展宏定义，对应的 option 是 -rewrite-macros</li>
<li>HTMLPrintAction - 生成高亮的代码网页，对应的 option 是 -emit-html</li>
<li>DeclContextPrintAction - 打印声明，option 对应的是 -print-decl-contexts</li>
<li>ASTDeclListAction - 打印 AST 节点，option 是 -ast-list</li>
<li>ASTDumpAction - 打印 AST 详细信息，对应 option 是 -ast-dump</li>
<li>ASTViewAction - 生成 AST dot 文件，能够通过 Graphviz 来查看图形语法树。 option 是 -ast-view</li>
<li>AnalysisAction - 运行静态分析引擎，option 是 -analyze</li>
<li>EmitLLVMAction - 生成可读的 IR 中间语言文件，对应的 option 是 -emit-llvm</li>
<li>EmitBCAction - 生成 IR Bitcode 文件，option 是 -emit-llvm-bc</li>
<li>MigrateSourceAction - 代码迁移，option 是 -migrate</li>
</ul>
<h2 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h2><p>Bind 主要是与工具链 ToolChain 交互<br>根据创建的那些 Action，在 Action 执行时 Bind 来提供使用哪些工具，比如生成汇编时是使用内嵌的还是 GNU 的，还是其它的呢，这个就是由 Bind 来决定的，具体使用的工具有各个架构，平台，系统的 ToolChain 来决定。</p>
<p>通过 clang -ccc-print-bindings main.c -o main 来看看 Bind 的结果</p>
<p>可以看到编译选择的是 clang，链接选择的是 darwin::Linker，但是在链接时前没有汇编器的过程，这个就是 Bind 起了作用，它会根据不同的平台来决定选择什么工具，因为是在 Mac 系统里 Bind 就会决定使用 integrated-as 这个内置汇编器。那么如何在不用内置汇编器呢。可以使用 -fno-integrated-as 这个 option。</p>
<h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><p>Translate 就是把相关的参数对应到不同平台上不同的工具。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>从创建 Jobs 的方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// BuildJobsForAction - Construct the jobs to perform for the action \p A and</span></div><div class="line">  <span class="comment">/// return an InputInfo for the result of running \p A.  Will only construct</span></div><div class="line">  <span class="comment">/// jobs for a given (Action, ToolChain, BoundArch, DeviceKind) tuple once.</span></div><div class="line">  <span class="function">InputInfo</span></div><div class="line">  <span class="title">BuildJobsForAction</span><span class="params">(Compilation &amp;C, <span class="keyword">const</span> Action *A, <span class="keyword">const</span> ToolChain *TC,</span></div><div class="line">                     StringRef BoundArch, <span class="keyword">bool</span> AtTopLevel, <span class="keyword">bool</span> MultipleArchs,</div><div class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *LinkingOutput,</div><div class="line">                     <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">const</span> Action *, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;, InputInfo&gt;</div><div class="line">                         &amp;CachedResults,</div><div class="line">                     Action::OffloadKind TargetDeviceOffloadKind) <span class="keyword">const</span>;</div></pre></td></tr></table></figure></p>
<p>可以看出 Jobs 需要前面的 Compilation，Action，ToolChain 等，那么 Jobs 就是将前面获取的信息进行组合分组给后面的 Execute 做万全准备。</p>
<h2 id="Execute"><a href="#Execute" class="headerlink" title="Execute"></a>Execute</h2><p>在 driver.cpp 的 main 函数里的 ExecuteCompilation 方法里可以看到如下代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set up response file names for each command, if necessary</span></div><div class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Job : C.getJobs())</div><div class="line">   setUpResponseFiles(C, Job);</div><div class="line"></div><div class="line"> C.ExecuteJobs(C.getJobs(), FailingCommands);</div></pre></td></tr></table></figure></p>
<p>能够看到 Jobs 准备好了后就要开始 Excute 他们。</p>
<p>Execute 就是执行整个的编译过程的 Jobs。过程执行的内容和耗时可以通过添加 -ftime-report 这个 option 来看到。</p>
<p><img src="/uploads/deeply-analyse-llvm/07.png" alt=""></p>
<h1 id="Clang-Attributes"><a href="#Clang-Attributes" class="headerlink" title="Clang Attributes"></a>Clang Attributes</h1><p>以 <strong>attribute</strong>(xx) 的语法格式出现，是 Clang 提供的一些能够让开发者在编译过程中参与一些源码控制的方法。下面列一些会用到的用法：</p>
<h2 id="attribute-format-NSString-F-A-格式化字符串"><a href="#attribute-format-NSString-F-A-格式化字符串" class="headerlink" title="attribute((format(NSString, F, A))) 格式化字符串"></a><strong>attribute</strong>((format(<strong>NSString</strong>, F, A))) 格式化字符串</h2><p>可以查看 NSLog 的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">FOUNDATION_EXPORT void NSLog(NSString *format, …) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;</div><div class="line"></div><div class="line">// Marks APIs which format strings by taking a format string and optional varargs as arguments</div><div class="line">#if !defined(NS_FORMAT_FUNCTION)</div><div class="line">    #if (__GNUC__*10+__GNUC_MINOR__ &gt;= 42) &amp;&amp; (TARGET_OS_MAC || TARGET_OS_EMBEDDED)</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</div><div class="line">    #else</div><div class="line">	#define NS_FORMAT_FUNCTION(F,A)</div><div class="line">    #endif</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<h2 id="attribute-deprecated-s-版本弃用提示"><a href="#attribute-deprecated-s-版本弃用提示" class="headerlink" title="attribute((deprecated(s))) 版本弃用提示"></a><strong>attribute</strong>((deprecated(s))) 版本弃用提示</h2><p>在编译过程中能够提示开发者该方法或者属性已经被弃用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)preMethod:( NSString *)string __attribute__((deprecated(“preMethod已经被弃用，请使用newMethod”)));</div><div class="line">- (void)deprecatedMethod DEPRECATED_ATTRIBUTE; //也可以直接使用DEPRECATED_ATTRIBUTE这个系统定义的宏</div></pre></td></tr></table></figure></p>
<h2 id="attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><a href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围" class="headerlink" title="attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围"></a><strong>attribute</strong>((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” <strong>VA_ARGS</strong>))) 指明使用版本范围</h2><p>os 指系统的版本，m 指明引入的版本，n 指明过时的版本，o 指完全不用的版本，message 可以写入些描述信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)method __attribute__((availability(ios,introduced=3_0,deprecated=6_0,obsoleted=7_0,message=“iOS3到iOS7版本可用，iOS7不能用”)));</div></pre></td></tr></table></figure></p>
<h2 id="attribute-unavailable-…-方法不可用提示"><a href="#attribute-unavailable-…-方法不可用提示" class="headerlink" title="attribute((unavailable(…))) 方法不可用提示"></a><strong>attribute</strong>((unavailable(…))) 方法不可用提示</h2><p>这个会在编译过程中告知方法不可用，如果使用了还会让编译失败。</p>
<h2 id="attribute-unused"><a href="#attribute-unused" class="headerlink" title="attribute((unused))"></a><strong>attribute</strong>((unused))</h2><p>没有被使用也不报警告</p>
<h2 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="attribute((warn_unused_result))"></a><strong>attribute</strong>((<strong>warn_unused_result</strong>))</h2><p>不使用方法的返回值就会警告，目前 swift3 已经支持该特性了。oc中也可以通过定义这个attribute来支持。</p>
<h2 id="attribute-availability-swift-unavailable-message-msg"><a href="#attribute-availability-swift-unavailable-message-msg" class="headerlink" title="attribute((availability(swift, unavailable, message=_msg)))"></a><strong>attribute</strong>((<strong>availability</strong>(swift, unavailable, message=_msg)))</h2><p>OC 的方法不能在 Swift 中使用。</p>
<h2 id="attribute-cleanup-…-作用域结束时自动执行一个指定方法"><a href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法" class="headerlink" title="attribute((cleanup(…))) 作用域结束时自动执行一个指定方法"></a><strong>attribute</strong>((cleanup(…))) 作用域结束时自动执行一个指定方法</h2><p>作用域结束包括大括号结束，return，goto，break，exception 等情况。这个动作是先于这个对象的 dealloc 调用的。</p>
<p>Reactive Cocoa 中有个比较好的使用范例，@onExit 这个宏，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define onExit \</div><div class="line">    rac_keywordify \</div><div class="line">    __strong rac_cleanupBlock_t metamacro_concat(rac_exitBlock_, __LINE__) __attribute__((cleanup(rac_executeCleanupBlock), unused)) = ^</div><div class="line"></div><div class="line">static inline void rac_executeCleanupBlock (__strong rac_cleanupBlock_t *block) &#123;</div><div class="line">    (*block)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样可以在就可以很方便的把需要成对出现的代码写在一起了。同样可以在 Reactive Cocoa 看到其使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">if (property != NULL) &#123;</div><div class="line">		rac_propertyAttributes *attributes = rac_copyPropertyAttributes(property);</div><div class="line">		if (attributes != NULL) &#123;</div><div class="line">			@onExit &#123;</div><div class="line">				free(attributes);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			BOOL isObject = attributes-&gt;objectClass != nil || strstr(attributes-&gt;type, @encode(id)) == attributes-&gt;type;</div><div class="line">			BOOL isProtocol = attributes-&gt;objectClass == NSClassFromString(@“Protocol”);</div><div class="line">			BOOL isBlock = strcmp(attributes-&gt;type, @encode(void(^)())) == 0;</div><div class="line">			BOOL isWeak = attributes-&gt;weak;</div><div class="line"></div><div class="line">			shouldAddDeallocObserver = isObject &amp;&amp; isWeak &amp;&amp; !isBlock &amp;&amp; !isProtocol;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出 attributes 的设置和释放都在一起使得代码的可读性得到了提高。</p>
<h2 id="attribute-overloadable-方法重载"><a href="#attribute-overloadable-方法重载" class="headerlink" title="attribute((overloadable)) 方法重载"></a><strong>attribute</strong>((overloadable)) 方法重载</h2><p>能够在 c 的函数上实现方法重载。即同样的函数名函数能够对不同参数在编译时能够自动根据参数来选择定义的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">__attribute__((overloadable)) void printArgument(int number)&#123;</div><div class="line">    NSLog(@“Add Int %i”, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSString *number)&#123;</div><div class="line">    NSLog(@“Add NSString %@“, number);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((overloadable)) void printArgument(NSNumber *number)&#123;</div><div class="line">    NSLog(@“Add NSNumber %@“, number);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="attribute-objc-designated-initializer-指定内部实现的初始化方法"><a href="#attribute-objc-designated-initializer-指定内部实现的初始化方法" class="headerlink" title="attribute((objc_designated_initializer)) 指定内部实现的初始化方法"></a><strong>attribute</strong>((objc_designated_initializer)) 指定内部实现的初始化方法</h2><ul>
<li>如果是 objc_designated_initializer 初始化的方法必须调用覆盖实现 super 的 objc_designated_initializer 方法。</li>
<li>如果不是 objc_designated_initializer 的初始化方法，但是该类有 objc_designated_initializer 的初始化方法，那么必须调用该类的 objc_designated_initializer 方法或者非 objc_designated_initializer 方法，而不能够调用 super 的任何初始化方法。</li>
</ul>
<h2 id="attribute-objc-subclassing-restricted-指定不能有子类"><a href="#attribute-objc-subclassing-restricted-指定不能有子类" class="headerlink" title="attribute((objc_subclassing_restricted)) 指定不能有子类"></a><strong>attribute</strong>((objc_subclassing_restricted)) 指定不能有子类</h2><p>相当于 Java 里的 final 关键字，如果有子类继承就会出错。</p>
<h2 id="attribute-objc-requires-super-子类继承必须调用-super"><a href="#attribute-objc-requires-super-子类继承必须调用-super" class="headerlink" title="attribute((objc_requires_super)) 子类继承必须调用 super"></a><strong>attribute</strong>((objc_requires_super)) 子类继承必须调用 super</h2><p>声明后子类在继承这个方法时必须要调用 super，否则会出现编译警告，这个可以定义一些必要执行的方法在 super 里提醒使用者这个方法的内容时必要的。</p>
<h2 id="attribute-const-重复调用相同数值参数优化返回"><a href="#attribute-const-重复调用相同数值参数优化返回" class="headerlink" title="attribute((const)) 重复调用相同数值参数优化返回"></a><strong>attribute</strong>((const)) 重复调用相同数值参数优化返回</h2><p>用于数值类型参数的函数，多次调用相同的数值型参数，返回是相同的，只在第一次是需要进行运算，后面只返回第一次的结果，这时编译器的一种优化处理方式。</p>
<h2 id="attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><a href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY" class="headerlink" title="attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))"></a><strong>attribute</strong>((constructor(PRIORITY))) 和 <strong>attribute</strong>((destructor(PRIORITY)))</h2><p>PRIORITY 是指执行的优先级，main 函数执行之前会执行 constructor，main 函数执行后会执行 destructor，+load 会比 constructor 执行的更早点，因为动态链接器加载 Mach-O 文件时会先加载每个类，需要 +load 调用，然后才会调用所有的 constructor 方法。</p>
<p>通过这个特性，可以做些比较好玩的事情，比如说类已经 load 完了，是不是可以在 constructor 中对想替换的类进行替换，而不用加在特定类的 +load 方法里。</p>
<h1 id="Clang-警告处理"><a href="#Clang-警告处理" class="headerlink" title="Clang 警告处理"></a>Clang 警告处理</h1><p>先看看这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored “-Wdeprecated-declarations”</div><div class="line">        sizeLabel = [self sizeWithFont:font constrainedToSize:size lineBreakMode:NSLineBreakByWordWrapping];</div><div class="line">#pragma clang diagnostic pop</div></pre></td></tr></table></figure></p>
<p>如果没有#pragma clang 这些定义，会报出 sizeWithFont 的方法会被废弃的警告，这个加上这个方法当然是为了兼容老系统，加上 ignored “-Wdeprecated-declarations” 的作用是忽略这个警告。通过 clang diagnostic push/pop 可以灵活的控制代码块的编译选项。</p>
<h1 id="使用-libclang-来进行语法分析"><a href="#使用-libclang-来进行语法分析" class="headerlink" title="使用 libclang 来进行语法分析"></a>使用 libclang 来进行语法分析</h1><p>使用 libclang 里面提供的方法对源文件进行语法分析，分析语法树，遍历语法树上每个节点。</p>
<p>使用这个库可以直接使用 C 的 API，官方也提供了 python binding。还有开源的 node-js / ruby binding，还有 Objective-C的开源库 <a href="https://github.com/macmade/ClangKit" target="_blank" rel="external">GitHub - macmade/ClangKit: ClangKit provides an Objective-C frontend to LibClang. Source tokenization, diagnostics and fix-its are actually implemented.</a> 。</p>
<p>写个 python 脚本来调用 clang<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">pip install clang</div><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># vim: set fileencoding=utf-8</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> clang.cindex</div><div class="line"><span class="keyword">import</span> asciitree</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_children</span><span class="params">(node)</span>:</span></div><div class="line">    <span class="keyword">return</span> (c <span class="keyword">for</span> c <span class="keyword">in</span> node.get_children() <span class="keyword">if</span> c.location.file == sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_node</span><span class="params">(node)</span>:</span></div><div class="line">    text = node.spelling <span class="keyword">or</span> node.displayname</div><div class="line">    kind = str(node.kind)[str(node.kind).index(‘.’)+<span class="number">1</span>:]</div><div class="line">    <span class="keyword">return</span> ‘&#123;&#125; &#123;&#125;’.format(kind, text)</div><div class="line"></div><div class="line"><span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</div><div class="line">    print(“Usage: dump_ast.py [header file name]”)</div><div class="line">    sys.exit()</div><div class="line"></div><div class="line">clang.cindex.Config.set_library_file(‘/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/libclang.dylib’)</div><div class="line">index = clang.cindex.Index.create()</div><div class="line">translation_unit = index.parse(sys.argv[<span class="number">1</span>], [‘-x’, ‘objective-c’])</div><div class="line"></div><div class="line"><span class="keyword">print</span> asciitree.draw_tree(translation_unit.cursor,</div><div class="line">                          <span class="keyword">lambda</span> n: list(n.get_children()),</div><div class="line">                          <span class="keyword">lambda</span> n: “%s (%s)” % (n.spelling <span class="keyword">or</span> n.displayname, str(n.kind).split(“.”)[<span class="number">1</span>]))</div></pre></td></tr></table></figure></p>
<p>基于语法树的分析还可以针对字符串做加密。</p>
<h1 id="LibTooling-对语法树完全的控制"><a href="#LibTooling-对语法树完全的控制" class="headerlink" title="LibTooling 对语法树完全的控制"></a>LibTooling 对语法树完全的控制</h1><p>因为 LibTooling 能够完全控制语法树，那么可以做的事情就非常多了。</p>
<ul>
<li>可以改变 clang 生成代码的方式。</li>
<li>增加更强的类型检查。</li>
<li>按照自己的定义进行代码的检查分析。</li>
<li>对源码做任意类型分析，甚至重写程序。</li>
<li>给 clang 添加一些自定义的分析，创建自己的重构器。</li>
<li>基于现有代码做出大量的修改。</li>
<li>基于工程生成相关图形或文档。</li>
<li>检查命名是否规范，还能够进行语言的转换，比如把 OC 语言转成JS或者  Swift 。</li>
</ul>
<p>官方有个文档开发者可以按照这个里面的说明去构造 LLVM，clang 和其工具： <a href="http://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="external">Tutorial for building tools using LibTooling and LibASTMatchers — Clang 4.0 documentation</a></p>
<p>按照说明编译完成后进入 LLVM 的目录 ~/llvm/tools/clang/tools/ 在这了可以创建自己的 clang 工具。这里有个范例： <a href="https://github.com/objcio/issue-6-compiler-tool" target="_blank" rel="external">GitHub - objcio/issue-6-compiler-tool: Example code for a standalone clang/llvm tool.</a> 可以直接 make 成一个二进制文件。</p>
<p>下面是检查 target 对象中是否有对应的 action 方法存在检查的一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface Observer</div><div class="line">+ (instancetype)observerWithTarget:(id)target action:(SEL)selector;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//查找消息表达式，observer 作为接受者，observerWithTarget:action: 作为 selector，检查 target 中是否存在相应的方法。</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *E)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (E-&gt;getReceiverKind() == ObjCMessageExpr::Class) &#123;</div><div class="line">    QualType ReceiverType = E-&gt;getClassReceiver();</div><div class="line">    Selector Sel = E-&gt;getSelector();</div><div class="line">    <span class="built_in">string</span> TypeName = ReceiverType.getAsString();</div><div class="line">    <span class="built_in">string</span> SelName = Sel.getAsString();</div><div class="line">    <span class="keyword">if</span> (TypeName == “Observer” &amp;&amp; SelName == “observerWithTarget:action:”) &#123;</div><div class="line">      Expr *Receiver = E-&gt;getArg(<span class="number">0</span>)-&gt;IgnoreParenCasts();</div><div class="line">      ObjCSelectorExpr* SelExpr = cast&lt;ObjCSelectorExpr&gt;(E-&gt;getArg(<span class="number">1</span>)-&gt;IgnoreParenCasts());</div><div class="line">      Selector Sel = SelExpr-&gt;getSelector();</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> ObjCObjectPointerType *OT = Receiver-&gt;getType()-&gt;getAs&lt;ObjCObjectPointerType&gt;()) &#123;</div><div class="line">        ObjCInterfaceDecl *decl = OT-&gt;getInterfaceDecl();</div><div class="line">        <span class="keyword">if</span> (! decl-&gt;lookupInstanceMethod(Sel)) &#123;</div><div class="line">          errs() &lt;&lt; “Warning: <span class="class"><span class="keyword">class</span> “ &lt;&lt; TypeName &lt;&lt; “ does not implement selector “ &lt;&lt; Sel.getAsString() &lt;&lt; “\n”;</span></div><div class="line">          SourceLocation Loc = E-&gt;getExprLoc();</div><div class="line">          PresumedLoc PLoc = astContext-&gt;getSourceManager().getPresumedLoc(Loc);</div><div class="line">          errs() &lt;&lt; “in “ &lt;&lt; PLoc.getFilename() &lt;&lt; “ &lt;“ &lt;&lt; PLoc.getLine() &lt;&lt; “:” &lt;&lt; PLoc.getColumn() &lt;&lt; “&gt;\n”;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Clang-Plugin"><a href="#Clang-Plugin" class="headerlink" title="Clang Plugin"></a>Clang Plugin</h1><p>通过自己写个插件，比如上面写的 LibTooling 的 clang 工具，可以将这个插件动态的加载到编译器中，对编译进行控制，可以在 LLVM 的这个目录下查看一些范例 llvm/tools/clang/tools</p>
<p>动态化方案 DynamicCocoa 中就是使用了一个将 OC 源码转 JS 的插件来进行代码的转换，这里整理了些利用 clang 转 js 的库  <a href="https://lmsgsendnilself.github.io/blog/2017/02/28/clangtojszi-yuan/" target="_blank" rel="external">clangtojs资源 - Lmsgsendnilself</a> ，JSPatch 是直接手写 JS 而没有转换的过程，所以也就没有多出这一步，而鹅厂的OCS更猛，直接在端内写了个编译器。在 C 函数的调用上孙源有个 slides 可以看看： <a href="http://slides.com/sunnyxx/calling-conventions-in-cocoa#/" target="_blank" rel="external">Calling Conventions in Cocoa by sunnyxx</a> bang 也有篇文章： <a href="http://blog.cnbang.net/tech/3219/" target="_blank" rel="external">如何动态调用 C 函数 «  bang’s blog</a>  。</p>
<p>这三个方案作者都分别写了文章详细说明其实现方案。</p>
<ul>
<li><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解 «  bang’s blog</a></li>
<li><a href="http://mp.weixin.qq.com/s/qRW_akbU3TSd0SxpF3iQmQ" target="_blank" rel="external">DynamicCocoa：滴滴 iOS 动态化方案的诞生与起航</a></li>
<li><a href="http://www.jianshu.com/p/6c756ce76758" target="_blank" rel="external">OCS——史上最疯狂的iOS动态化方案 - 简书</a></li>
</ul>
<p>滴滴的王康在做瘦身时也实现了一个自定义的 clang 插件，具体自定义插件的实现可以查看他的这文章 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=2651112856&amp;idx=1&amp;sn=b2c74c62a10b4c9a4e7538d1ad7eb739" target="_blank" rel="external">《基于clang插件的一种iOS包大小瘦身方案》</a></p>
<p>那么我们要自己动手做应该怎么入门呢，除了本身带的范例外还有些教程可以看看。</p>
<ul>
<li>官方 clang 的插件： <a href="http://clang.llvm.org/docs/ExternalClangExamples.html" target="_blank" rel="external">External Clang Examples</a></li>
<li>收集一些如何使用 clang 库的例子：<a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li>在 Xcode 中添加 clang 静态分析自定义 checks： <a href="http://clang-analyzer.llvm.org/xcode.html" target="_blank" rel="external">Running the analyzer within Xcode</a></li>
<li>将 LLVM C 的 API 用 swift 来包装： <a href="https://github.com/harlanhaskins/LLVMSwift" target="_blank" rel="external">GitHub - harlanhaskins/LLVMSwift: A Swifty wrapper for the LLVM C API version 3.9.1</a></li>
</ul>
<h1 id="LLVM-Backend"><a href="#LLVM-Backend" class="headerlink" title="LLVM Backend"></a>LLVM Backend</h1><p>首先通过下图看看 LLVM Backend 在整个 LLVM 里所处的位置：<br><img src="/uploads/deeply-analyse-llvm/09.png" alt=""></p>
<p>接下来是整个 LLVM Backend 的流程图，后面会对每个过程详细说明</p>
<p><img src="/uploads/deeply-analyse-llvm/10.png" alt=""></p>
<h2 id="CodeGen-阶段"><a href="#CodeGen-阶段" class="headerlink" title="CodeGen 阶段"></a>CodeGen 阶段</h2><ul>
<li>Instruction Selection 指令选择：将IR转化成目标平台指令组成的定向非循环图 DAG（Directed Acyclic Graph）。选择既能完成指定操作，又能执行时间最短的指令。</li>
<li>Scheduling and Formation 调度与排序：读取 DAG，将 DAG 的指令排成 MachineInstr 的队列。根据指令间的依赖进行指令重排使得能够更好的利用 CPU 的功能单元。</li>
<li>SSA 优化：多个基于 SSA（Static Single Assignment） 的 Pass 组成。比如 modulo-scheduling 和 peephole optimization 都是在这个阶段完成的</li>
<li>Register allocation 寄存器分配：将 Virtual Register 映射到 Physical Register 或内存上<br>Prolog / Epilog 生成</li>
<li>确定所需堆栈大小：Machine Code </li>
<li>晚期优化：最后一次优化机会</li>
<li>Code Emission：输出代码，可以选择汇编或者二进制机器码。</li>
</ul>
<h2 id="SelectionDAG"><a href="#SelectionDAG" class="headerlink" title="SelectionDAG"></a>SelectionDAG</h2><ul>
<li>构建最初的 DAG：把 IR 里的 add 指令转成 SelectionDAG 的 add 节点</li>
<li>优化构建好的 DAG：把一些平台支持的 meta instructions 比如 Rotates，div / rem 指令识别出</li>
<li>Legalization SelectionDAG 类型：比如某些平台只有64位浮点和32位整数运算指令，那么就需要把所有 f32 都提升到 f64，i1/i8/i16 都提升到 i32，同时还要把 i64 拆分成两个 i32 来存储，操作符的合法化，比如 SDIV 在 x86 上回转成 SDIVREM。这个过程结果可以通过 llc -view-dag-combine2-dags sum.ll 看到</li>
<li>指令选择 instruction selector（ISel）：将平台无关的 DAG 通过 TableGen 读入 .tb 文件并且生成对应的模式匹配代码从而转成平台相关的 DAG</li>
<li>SelectionDAG Scheduling and Formation：因为 CPU 是没法执行 DAG，所以需要将指令从 DAG 中提取依据一定规则比如 minimal register pressure 或隐藏指令延迟重排成指令队列。（DAG -&gt; linear list（SSA form） -&gt; MachineInstr -&gt; MC Layer API MCInst MCStreamr -&gt; MCCodeEmitter -&gt; Binary Instr）</li>
</ul>
<p>下图是 llc -view-isel-dags 状态下的 DAG 图：</p>
<p><img src="/uploads/deeply-analyse-llvm/11.png" alt=""></p>
<p>查看 DAG 不同状态的说明如下：</p>
<ul>
<li>-view-dag-combine1-dags：可以显示没有被优化的 DAG</li>
<li>-view-legalize-dags：合法化之前的 DAG</li>
<li>-view-dag-cmobine2-dags：第二次优化前</li>
<li>-view-isel-dags：显示指令选择前的 DAG</li>
<li>-view-sched-dags：在 Scheduler 之前 ISel 之后</li>
<li>-view-sunit-dags：可以显示 Scheduler 的依赖图</li>
</ul>
<h3 id="SDNode"><a href="#SDNode" class="headerlink" title="SDNode"></a>SDNode</h3><p>DAG 的节点都是有 SDNode 所构成，它的主要是作为 dag 值的操作符，描述这个 dag 所代表的操作，操作数。在 LLVM 里 SDNode 的定义出现在 SelectDAGNodes.h 还有就是 TargetSelectionDAG.td 里，每个 SelectionDAG 节点类型都有一个对应的 SDNode 定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDNode</span>&lt;string opcode, SDTypeProfile typeprof, list&lt;SDNodeProperty&gt; props = [], string sdclass ="SDNode"&gt; :</span>SDPatternOperator &#123;</div><div class="line">	stringOpcode  = opcode;</div><div class="line">	<span class="built_in">string</span> SDClass= sdclass;</div><div class="line">	<span class="built_in">list</span>&lt;SDNodeProperty&gt; Properties = props;</div><div class="line">	SDTypeProfileTypeProfile = typeprof; <span class="comment">//类型</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//类型要求</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDTypeProfile</span>&lt;intnumresults, int numoperands, list&lt;SDTypeConstraint&gt;constraints&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> NumResults= numresults;   <span class="comment">//多少个结果</span></div><div class="line">	<span class="keyword">int</span> NumOperands= numoperands; <span class="comment">//多少个操作数</span></div><div class="line">	<span class="built_in">list</span>&lt;SDTypeConstraint&gt; Constraints = constraints; <span class="comment">//类型的约束</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//描述对操作数类型的约束</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SDTypeConstraint</span>&lt;intopnum&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> OperandNum= opnum; <span class="comment">//指明该约束适用第几个操作数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>目标机器可以根据自己的需求定制约束来描述自己特有的指令。</p>
<p>SDNodeProperty 是 SDNode 的属性，用来描述 SDNode 操作的特征。</p>
<h3 id="PatFrag-可复用的结构"><a href="#PatFrag-可复用的结构" class="headerlink" title="PatFrag 可复用的结构"></a>PatFrag 可复用的结构</h3><p>为了支持高级语言的特性，TD 也通过 PatFrag 来支持，在SelectionTargetDAG.td 里定义的，这样就可以支持数据与结构的复用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PatFrag</span>&lt;dag ops, dag frag, code pred = [&#123;&#125;], SDNodeXForm xform =NOOP_SDNodeXForm&gt; :</span> SDPatternOperator &#123;</div><div class="line">	dag Operands= ops;  <span class="comment">//操作数</span></div><div class="line">	dag Fragment= frag; <span class="comment">//所指定的</span></div><div class="line">	code PredicateCode = pred; <span class="comment">//表示嵌入生成的指令选择器的代码，满足条件采用用这个 PatFrag</span></div><div class="line">	code ImmediateCode = [&#123;&#125;]; </div><div class="line">	SDNodeXForm OperandTransform = xform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Pattern-匹配指令"><a href="#Pattern-匹配指令" class="headerlink" title="Pattern 匹配指令"></a>Pattern 匹配指令</h3><p>Pattern 主要是解决复杂操作的 DAG 模式，LLVM 会使用贪婪匹配自动完成这个指令选择。定义在 Target.td 里。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pattern</span>&lt;dag patternToMatch, list&lt;dag&gt;resultInstrs&gt; &#123;</span></div><div class="line">	dagPatternToMatch = patternToMatch;</div><div class="line">	<span class="built_in">list</span>&lt;dag&gt;ResultInstrs  = resultInstrs;</div><div class="line">	<span class="built_in">list</span>&lt;Predicate&gt; Predicates = [];</div><div class="line">	<span class="keyword">int</span> AddedComplexity = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>在 Pattern 和 Instruction 的定义里都有 Predicates。满足 Predicates 的条件才能够继续，定义也在 Target.td 里<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Predicate</span>&lt;string cond&gt; &#123;</span></div><div class="line">	<span class="built_in">string</span> CondString = cond;</div><div class="line">	<span class="comment">//汇编匹配器的 predicate</span></div><div class="line">	bit AssemblerMatcherPredicate = <span class="number">0</span>;</div><div class="line">  	<span class="comment">//被测试的子 target 的名称用作汇编匹配器的替代条件字符串</span></div><div class="line">	<span class="built_in">string</span> AssemblerCondString = <span class="string">""</span>;</div><div class="line">	<span class="comment">//用户级别的 name 给 predicate 用，主要用在诊断时在汇编匹配器里缺少功能。</span></div><div class="line">	<span class="built_in">string</span> PredicateName = <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 Predicate 实际上就是一个容器，转么装嵌入代码的，然后把这个代码插入到合适的地方来对某些局限的指令进行筛选过滤。</p>
<h3 id="Itinerary-和-SchedRW-调度信息"><a href="#Itinerary-和-SchedRW-调度信息" class="headerlink" title="Itinerary 和 SchedRW 调度信息"></a>Itinerary 和 SchedRW 调度信息</h3><p>Itinerary 和 SchedRW 在 Instruction 里定义，用来描述指令调度的信息。目标机器平台会从 InstrltinClass 来派生对应指令的定义，比如 X86，它的指令很多而且复杂所以定义的 InstrltinClass 派生定义数量也很多，都在 X86Schedule.td 里。每条指令都对应一个 InstrltinClass 定义。比如除法的 InstrltinClass 的定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def IIC_DIV8_MEM   : InstrItinClass;</div><div class="line">def IIC_DIV8_REG   : InstrItinClass;</div><div class="line">def IIC_DIV16      : InstrItinClass;</div><div class="line">def IIC_DIV32      : InstrItinClass;</div><div class="line">defIIC_DIV64       : InstrItinClass;</div></pre></td></tr></table></figure></p>
<p>执行步骤是由 InstrStage 来描述：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstrStage</span>&lt;int cycles, list&lt;FuncUnit&gt; units, int timeinc = -1, ReservationKind kind =Required&gt; &#123;</span></div><div class="line">	<span class="keyword">int</span> Cycles          = cycles;       <span class="comment">//完成这个步骤需要的周期数</span></div><div class="line">	<span class="built_in">list</span>&lt;FuncUnit&gt; Units = units;       <span class="comment">//用于完成该步骤功能单元的选择</span></div><div class="line">	<span class="keyword">int</span> TimeInc         = timeinc;      <span class="comment">//从步骤开始到下个步骤需要多少周期</span></div><div class="line">	<span class="keyword">int</span> Kind            = kind.Value;   </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过 InstrltinData 将 InstrltinClass 和 stages 绑在一起使得指令能顺序执行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstrItinData</span>&lt;InstrItinClass Class,list&lt;InstrStage&gt; stages, list&lt;int&gt;operandcycles = [], list&lt;Bypass&gt; bypasses= [], int uops = 1&gt; &#123;</span></div><div class="line">	InstrItinClass TheClass = Class;</div><div class="line">	<span class="keyword">int</span> NumMicroOps = uops; <span class="comment">//指令解码后的 mirco operation 的数量，0表示数量不定</span></div><div class="line">	<span class="built_in">list</span>&lt;InstrStage&gt; Stages = stages;</div><div class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; OperandCycles =operandcycles; <span class="comment">//可选周期数</span></div><div class="line">	<span class="built_in">list</span>&lt;Bypass&gt; Bypasses = bypasses;       <span class="comment">//绕过寄存器，将写操作指令的结果直接交给后面读操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="TableGen"><a href="#TableGen" class="headerlink" title="TableGen"></a>TableGen</h3><p>在 llvm/lib/Target 目录下有各个 CPU 架构的目录。以 X86 举例</p>
<ul>
<li>X86.td：架构描述。</li>
<li>X86CallingConv.td：架构调用规范。</li>
<li>X86InstrInfo.td：基本指令集。</li>
<li>X86InstrMMX.td：MMX 指令集。</li>
<li>X86InstrMPX.td：MPX（MemoryProtection Extensions）指令集。</li>
<li>X86InstrSGX.td：SGX（Software GardExtensions）指令集。</li>
<li>X86InstrSSE.td：SSE指令集。</li>
<li>X86InstrSVM.td：AMD SVM（Secure VirutalMachine）指令集。</li>
<li>X86InstrTSX.td：TSX（TransactionalSynchronziation Extensions）指令集。</li>
<li>X86InstrVMX.td：VMX（Virtual MachineExtensions）指令集。</li>
<li>X86InstrSystem.td：特权指令集。</li>
<li>X86InstrXOP.td：对扩展操作的描述。</li>
<li>X86InstrFMA.td：对融合乘加指令的描述。</li>
<li>X86InstrFormat.td：格式定义的描述。</li>
<li>X86InstrFPStack.td：浮点单元指令集的描述。</li>
<li>X86InstrExtension.td：对零及符号扩展的描述。</li>
<li>X86InstrFragmentsSIMD.td：描述 SIMD 所使用的模式片段。</li>
<li>X86InstrShiftRotate.td：对 shift 和 rotate 指令的描述。</li>
<li>X86Instr3DNow.td：3DNow! 指令集的描述。</li>
<li>X86InstrArithmetic.td：算术指令的描述。</li>
<li>X86InstrAVX512.td：AVX512 指令集的描述。</li>
<li>X86InstrCMovSetCC.td：条件 move 及设置条件指令的描述。</li>
<li>X86InstrCompiler.td：各种伪指令和指令选择中的 Pat 模式。</li>
<li>X86InstrControl.td：jump，return，call 指令。</li>
<li>X86RegisterInfo.td：寄存器的描述。</li>
<li>X86SchedHaswell.td：对 Haswell 机器模型的描述。</li>
<li>X86SchedSandyBridge.td：对 Sandy Bridge 机器模型的描述。</li>
<li>X86Schedule.td：指令调度的一般描述。</li>
<li>X86ScheduleAtom.td：用于 Intel Atom 处理器指令调度。</li>
<li>X86SchedSandyBridge.td：用于 Sandy Bridge 机器模型的指令调度。</li>
<li>X86SchedHaswell.td：用于 Haswell 机器模型的指令调度。</li>
<li>X86ScheduleSLM.td：用于 Intel Silvermont 机器模型的指令调度。</li>
<li>X86ScheduleBtVer2.td：用于 AMD btver2 (Jaguar) 机器模型的指令调度。</li>
</ul>
<p>与平台无关的公用的描述在 llvm/include/llvm/target/ 下</p>
<ul>
<li>Target.td：每个机器都要实现的平台无关的接口。</li>
<li>TargetItinerary.td：平台无关的 instruction itineraries 调度接口。</li>
<li>TargetSchedule.td：平台无关的基于 Tablegen 调度接口。</li>
<li>TargetSelectionDAG.td：平台无关的 SelectionDAG 调度接口。</li>
<li>TargetCallingConv.td：平台无关 CallingConv 接口。</li>
</ul>
<p>llvm/include/llvm/CodeGen 目录包含 ValueTypes.td 是用来描述具有通用性的寄存器和操作数的类型。在 llvm/include/llvm/IR 包含描述平台无关的固有函数 Intrinsics.td 文件，还有平台相关的比如 IntrinsicsX86.td 这样的文件。</p>
<h4 id="TabelGen-类型"><a href="#TabelGen-类型" class="headerlink" title="TabelGen 类型"></a>TabelGen 类型</h4><ul>
<li>Dag：表示程序中间表达树中的 DAG 结构，是一个递归构造。有“(“DagArg DagArgList”)”，DagArgList ::= DagArg (“,” DagArg)*，DagArg ::= Value [“:” TokVarName] | TokVarName 这几种语法。比如 (set VR128:$dst, (v2i64 (scalar_to_vector (i64 (bitconvert (x86mmx VR64:$src)))))) 这个 dag 值有多层嵌套，表达的意思是将64位标量的源操作数保存在 MMX 寄存器中，先转成 64 位有符号整数，再转成 2Xi64向量，保存到 128 位寄存器。dag 操作都是比如 def 比如 out，in, set 等，再就是 SDNode 比如 scalar_to_vector 和 bitconvert，或者是 ValueType 的派生定义描述值类型比如 VR128，i64，x86mmx 等。</li>
<li>List：代表队列，有 “[“ ValueList ”]” [“&lt;” Type ”&gt;”]，ValueList ::= [ValueListNE]，ValueListNE ::= Value (“,” Value)* 这样的语法，比如 [llvm_ptr_ty, llvm_ptr_ty]</li>
<li>String：C++ 字符串常量</li>
<li>Bit，int：Bit 代表字节，int 是64位整数</li>
<li>Bits：代表若干字节，比如“bits<64>”</64></li>
</ul>
<h2 id="Register-Allocation-寄存器分配"><a href="#Register-Allocation-寄存器分配" class="headerlink" title="Register Allocation 寄存器分配"></a>Register Allocation 寄存器分配</h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>寄存器定义在 TargetRegisterInfo.td 里，它们的基类是这样定义的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Register</span>&lt;string n, list&lt;string&gt; altNames =[]&gt; &#123;</span></div><div class="line">	<span class="built_in">string</span> Namespace = <span class="string">""</span>;</div><div class="line">	<span class="built_in">string</span> AsmName = n;</div><div class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; AltNames = altNames;</div><div class="line">	<span class="comment">//别名寄存器</span></div><div class="line">	<span class="built_in">list</span>&lt;Register&gt; Aliases = [];</div><div class="line">	<span class="comment">//属于寄存器的子寄存器</span></div><div class="line">	<span class="built_in">list</span>&lt;Register&gt; SubRegs = [];</div><div class="line">	<span class="comment">//子寄存器的索引编号</span></div><div class="line">	<span class="built_in">list</span>&lt;SubRegIndex&gt; SubRegIndices = [];</div><div class="line">	<span class="comment">//可选名寄存器的索引</span></div><div class="line">	<span class="built_in">list</span>&lt;RegAltNameIndex&gt; RegAltNameIndices= [];</div><div class="line">    <span class="comment">//gcc/gdb 定义的号码</span></div><div class="line">	<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; DwarfNumbers = [];</div><div class="line">	<span class="comment">//寄存器分配器会通过这个值尽量减少一个寄存器的指令数量</span></div><div class="line">	<span class="keyword">int</span> CostPerUse = <span class="number">0</span>;</div><div class="line">	<span class="comment">//决定寄存器的值是否由子寄存器的值来决定</span></div><div class="line">	bit CoveredBySubRegs = <span class="number">0</span>;</div><div class="line">	<span class="comment">//特定硬件的编码</span></div><div class="line">	bits&lt;<span class="number">16</span>&gt; HWEncoding = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据目标机器可以派生，比如 X86 可以派生出 X86RegisterInfo.td<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">X86Reg</span>&lt;string n, bits&lt;16&gt; Enc, list&lt;Register&gt;subregs = []&gt; :</span> Register&lt;n&gt; &#123;</div><div class="line">  let Namespace= <span class="string">"X86"</span>;</div><div class="line">  letHWEncoding = Enc;</div><div class="line">  let SubRegs =subregs;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="RegisterClass"><a href="#RegisterClass" class="headerlink" title="RegisterClass"></a>RegisterClass</h3><p>为了描述寄存器用途，将相同用途的寄存器归入同一个 RegisterClass。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterClass</span>&lt;string namespace, list&lt;ValueType&gt;regTypes, int alignment, dagregList, RegAltNameIndex idx = NoRegAltName&gt; :</span> DAGOperand &#123;</div><div class="line">	<span class="built_in">string</span> Namespace = <span class="keyword">namespace</span>;</div><div class="line"></div><div class="line">  	<span class="comment">//寄存器的值类型，寄存器里的寄存器们必须有相同的值类型</span></div><div class="line">	<span class="built_in">list</span>&lt;ValueType&gt; RegTypes = regTypes;</div><div class="line"></div><div class="line">	<span class="comment">//指定寄存器溢出大小</span></div><div class="line">	<span class="keyword">int</span> Size = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">//当寄存器进行存储或者读取时指定排序</span></div><div class="line">	<span class="keyword">int</span> Alignment = alignment;</div><div class="line"></div><div class="line">	<span class="comment">//指定在两个寄存器之间拷贝时的消耗，默认值是1，意味着使用一个指令执行拷贝，如果是负数意味着拷贝消耗昂贵或者不可能</span></div><div class="line">	<span class="keyword">int</span> CopyCost = <span class="number">1</span>;</div><div class="line"></div><div class="line">  	<span class="comment">//说明这个 class 里有哪些寄存器。如果 allocation_order_* 方法没有指定，这个同时定义在寄存器分配器的分配顺序</span></div><div class="line">	dagMemberList = regList;</div><div class="line"></div><div class="line">	<span class="comment">//寄存器备用名用在打印操作这个寄存器 class 时。每个寄存器都需要在一个给定的索引里有一个有效的备用名。</span></div><div class="line">	RegAltNameIndex altNameIndex = idx;</div><div class="line"></div><div class="line">	<span class="comment">//指定寄存器 class 是否能用在虚拟寄存器和寄存器分配里。有些寄存器 class 只限制在模型指令操作，这样就需要设置为0</span></div><div class="line">	bit isAllocatable = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="comment">//列出可选的分配的命令。默认的命令是 memberlist 自己。当寄存器分配者自动移除保留的寄存器并且移动被调用保存的寄存器到最后是足够好的。</span></div><div class="line">	<span class="built_in">list</span>&lt;dag&gt;AltOrders = [];</div><div class="line"></div><div class="line">	<span class="comment">//这个函数里作用是选择分配给定机器函数顺序，</span></div><div class="line">	code AltOrderSelect = [&#123;&#125;];</div><div class="line"></div><div class="line">	<span class="comment">//寄存器分配器使用贪婪启发式指定分配优先级。如果值高表示优先。这个值的范围在[0,63]</span></div><div class="line">	<span class="keyword">int</span> AllocationPriority = <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="寄存器在-LLVM-中的表达"><a href="#寄存器在-LLVM-中的表达" class="headerlink" title="寄存器在 LLVM 中的表达"></a>寄存器在 LLVM 中的表达</h3><p>物理寄存器在 LLVM 里均有 1 - 1023 范围内的编号。在 GenRegisterNames.inc 里找到，比如 lib/Target/X86/X86GenRegisterInfo.inc</p>
<h3 id="虚拟寄存器到物理寄存器的映射"><a href="#虚拟寄存器到物理寄存器的映射" class="headerlink" title="虚拟寄存器到物理寄存器的映射"></a>虚拟寄存器到物理寄存器的映射</h3><p>直接映射使用 TargetRegisterInfo 和 MachineOperand 中的 API。间接映射的API用 VirtRegMap 以正确插入读写指令实现内存调度</p>
<h3 id="LLVM-自带的寄存器分配算法"><a href="#LLVM-自带的寄存器分配算法" class="headerlink" title="LLVM 自带的寄存器分配算法"></a>LLVM 自带的寄存器分配算法</h3><p>llc -regalloc=Greedy add.bc -o ln.s</p>
<ul>
<li>Fast - debug 默认，尽可能保存寄存器。</li>
<li>Basic - 增量分配</li>
<li>Greedy - LLVM 默认寄存器分配算法，对 Basic 算法变量生存期进行分裂进行高度优化</li>
<li>PBQP - 将寄存器分配描述成分区布尔二次规划</li>
</ul>
<h2 id="Code-Emission"><a href="#Code-Emission" class="headerlink" title="Code Emission"></a>Code Emission</h2><p>下图详细表达了整个 Code Emission 的过程<br><img src="/uploads/deeply-analyse-llvm/12.png" alt=""></p>
<h1 id="Swift-编译流"><a href="#Swift-编译流" class="headerlink" title="Swift 编译流"></a>Swift 编译流</h1><p>Swift 编译流和 Clang 一样都是编译前端，和 Clang 一样代码会被解析成语法数 AST，接下来会比 Clang 多一步，通过 SILGen 生成 SIL 这一次方便做些 Swift 特定的优化，SIL 会被传递给 IR 生成阶段生成 LLVM IR，最后由 LLVM 解决余下事情。看到这里大家肯定会好奇 swift 是如何与 C 和 OC 交互的比如系统底层的模块，这里就要提提 swift 的模块映射了（Module map），它调用 Clang 的模块，将其传入 Clang importer 中生成 AST 来分析是的 swift 能够和 C/OC 进行交互。</p>
<p>下面通过一个例子看详细了解下 Swift 编译流吧。先创建一个 toy.swift<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">print</span>(“hi!”)</div></pre></td></tr></table></figure></p>
<p>生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc toy.swift</div><div class="line">./toy</div></pre></td></tr></table></figure></p>
<p>生成检查 AST<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -dump-ast toy.swift</div></pre></td></tr></table></figure></p>
<p>可以还原之前函数名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-silgen toy.swift | xcrun swift-demangle</div></pre></td></tr></table></figure></p>
<p>llvm ir 和汇编的生成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">swiftc -emit-ir toy.swift</div><div class="line">swiftc -emit-assembly toy.swift</div></pre></td></tr></table></figure></p>
<p>生成可执行的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk macosx swiftc toy.swift -o toy</div></pre></td></tr></table></figure></p>
<h1 id="编译后生成的二进制内容-Link-Map-File"><a href="#编译后生成的二进制内容-Link-Map-File" class="headerlink" title="编译后生成的二进制内容 Link Map File"></a>编译后生成的二进制内容 Link Map File</h1><p>在 Build Settings 里设置 Write Link Map File 为 Yes 后每次编译都会在指定目录生成这样一个文件。文件内容包含 Object files，Sections，Symbols。下面分别说说这些内容</p>
<h2 id="Object-files"><a href="#Object-files" class="headerlink" title="Object files"></a>Object files</h2><p>这个部分的内容都是 .m 文件编译后的 .o 和需要 link 的 .a 文件。前面是文件编号，后面是文件路径。</p>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>这里描述的是每个 Section 在可执行文件中的位置和大小。每个 Section 的 Segment 的类型分为 <strong>TEXT 代码段和 </strong>DATA 数据段两种。</p>
<h2 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h2><p>Symbols 是对 Sections 进行了再划分。这里会描述所有的 methods，ivar 和字符串，及它们对应的地址，大小，文件编号信息。</p>
<h1 id="每次编译后生成的-dSYM-文件"><a href="#每次编译后生成的-dSYM-文件" class="headerlink" title="每次编译后生成的 dSYM 文件"></a>每次编译后生成的 dSYM 文件</h1><p>在每次编译后都会生成一个 dSYM 文件，程序在执行中通过地址来调用方法函数，而 dSYM 文件里存储了函数地址映射，这样调用栈里的地址可以通过 dSYM 这个映射表能够获得具体函数的位置。一般都会用来处理 crash 时获取到的调用栈 .crash 文件将其符号化。</p>
<p>可以通过 Xcode 进行符号化，将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，打开 Xcode 的 Window 菜单下的 organizer，再点击 Device tab，最后选中左边的 Device Logs。选择 import 将 .crash 文件导入就可以看到 crash 的详细 log 了。</p>
<p>还可以通过命令行工具 symbolicatecrash 来手动符号化 crash log。同样先将 .crash 文件，.dSYM 和 .app 文件放到同一个目录下，然后输入下面的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</div><div class="line">symbolicatecrash appName.crash appName.app &gt; appName.log</div></pre></td></tr></table></figure></p>
<h1 id="Mach-O-文件"><a href="#Mach-O-文件" class="headerlink" title="Mach-O 文件"></a>Mach-O 文件</h1><p>记录编译后的可执行文件，对象代码，共享库，动态加载代码和内存转储的文件格式。不同于 xml 这样的文件，它只是二进制字节流，里面有不同的包含元信息的数据块，比如字节顺序，cpu 类型，块大小等。文件内容是不可以修改的，因为在 .app 目录中有个 _CodeSignature 的目录，里面包含了程序代码的签名，这个签名的作用就是保证签名后 .app 里的文件，包括资源文件，Mach-O 文件都不能够更改。</p>
<p>Mach-O 文件包含三个区域</p>
<ul>
<li>Mach-O Header：包含字节顺序，magic，cpu 类型，加载指令的数量等</li>
<li>Load Commands：包含很多内容的表，包括区域的位置，符号表，动态符号表等。每个加载指令包含一个元信息，比如指令类型，名称，在二进制中的位置等。</li>
<li>Data：最大的部分，包含了代码，数据，比如符号表，动态符号表等。</li>
</ul>
<h2 id="Mach-O-文件的解析"><a href="#Mach-O-文件的解析" class="headerlink" title="Mach-O 文件的解析"></a>Mach-O 文件的解析</h2><p>再通过一个例子来分析下：<br>这次用 xcrun 来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -v</div></pre></td></tr></table></figure></p>
<p>先创建一个test.c的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch test.c</div></pre></td></tr></table></figure></p>
<p>编辑里面的内容<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi test.c</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"hi there!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行，没有起名默认为 a.out<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang test.c</div><div class="line">./a.out</div></pre></td></tr></table></figure></p>
<p>a.out 就是编译生成的二进制文件，下面看看这个二进制文件时如何生成的把。先看看输出的汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - test.c | open -f</div></pre></td></tr></table></figure></p>
<p>输出的结果里 . 开头的行是汇编指令不是汇编代码，其它的都是汇编代码。先看看前几行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.section	__TEXT,__text,regular,pure_instructions</div><div class="line">.macosx_version_min 10, 12</div><div class="line">.globl	_main</div><div class="line">.align	4, 0x90</div></pre></td></tr></table></figure></p>
<p>.section 指令指定接下来执行哪一个段。</p>
<p>.globl 指令说明 _main 是一个外部符号，因为 main() 函数对于系统来说是需要调用它来运行执行文件的。</p>
<p>.align 指出后面代码的对齐方式，16(2^4) 字节对齐， 0x90 补齐。</p>
<p>看看接下来的 main 函数头部部分<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">_main:                                  ## @main</div><div class="line">	.cfi_startproc</div><div class="line">## BB#0:</div><div class="line">	pushq	%rbp</div><div class="line">Ltmp0:</div><div class="line">	.cfi_def_cfa_offset 16</div><div class="line">Ltmp1:</div><div class="line">	.cfi_offset %rbp, -16</div><div class="line">	movq	%rsp, %rbp</div><div class="line">Ltmp2:</div><div class="line">	.cfi_def_cfa_register %rbp</div><div class="line">	subq	$32, %rsp</div></pre></td></tr></table></figure></p>
<p>_main 是函数开始的地址，二进制文件会有这个位置的引用。</p>
<p>.cfi_startproc 这个指令用于函数的开始，CFI 是 Call Frame Infomation 的缩写是调用帧信息的意思，在用 debugger 时实际上就是 stepping in / out 的一个调用帧。当出现 .cfi_endproc 时表示匹对结束标记出 main() 函数结束。</p>
<p>pushq %rbp 是汇编代码，## BB#0: 这个 label 里的。ABI 会让 rbp 这个寄存器的被保护起来，当函数调用返回时让 rbp 寄存器的值跟以前一样。 ABI 是 application binary interface 的缩写表示应用二进制接口，它指定了函数调用是如何在汇编代码层面上工作的。pushq %rbp 将 rbp 的值 push 到栈中。</p>
<p>.cfi_def_cfa_offset 16 和 .cfi_offset %rbp, -16 会输出一些堆栈和调试信息，确保调试器要使用这些信息时能够找到。</p>
<p>movq %rsp, %rbp 把局部变量放到栈上。</p>
<p>subq $32, %rsp 会将栈指针移动 32 个字节，就是函数调用的位置。旧的栈指针存在 rbp 里作为局部变量的基址，再更新堆栈指针到会使用的位置。</p>
<p>再看看 printf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">leaq	L_.str(%rip), %rax</div><div class="line">movl	$0, -4(%rbp)</div><div class="line">movl	%edi, -8(%rbp)</div><div class="line">movq	%rsi, -16(%rbp)</div><div class="line">movq	%rax, %rdi</div><div class="line">movb	$0, %al</div><div class="line">callq	_printf</div></pre></td></tr></table></figure></p>
<p>leap 会将 L<em>.str 这个指针加载到 rax 寄存器里。可以看看 L</em>.str 的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div></pre></td></tr></table></figure></p>
<p>这个就是我们代码文件里定义的那个字符串。</p>
<p>这里可以看到函数的两个参数分别保存在 edi 和 rsi 寄存器里，根据函数地址做了不同的偏移。</p>
<p>当然也可以看出在这个汇编代码还有能够优化的地方，因为这两个值并没有用，却还是被寄存器存储了。</p>
<p>printf() 是个可变参数的函数，按照 ABI 调用约定存储参数的寄存器数量存储在寄存器 al 中，可变所以数量设置为0，callq 会调用 printf() 函数。</p>
<p>接下来看看返回和函数的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xorl	%ecx, %ecx</div><div class="line">movl	%eax, -20(%rbp)         ## 4-byte Spill</div><div class="line">movl	%ecx, %eax</div><div class="line">addq	$32, %rsp</div><div class="line">popq	%rbp</div><div class="line">retq</div><div class="line">.cfi_endproc</div></pre></td></tr></table></figure></p>
<p>xorl    %ecx, %ecx 相当于将 ecx 寄存器设置为0。ABI 约定 eax 寄存器用来保存函数返回值，拷贝 ecx 到 eax 中，这样 main() 返回值就是0。</p>
<p>函数执行完会恢复堆栈指针，前面是 subq 32 是把 rsp 下移32字节，addq 就是上移归位。然后把 rbp 的值从栈里 pop 出来。ret 会读取出栈返回的地址，.cfi_endproc 和 .cfi_startproc 配对标记结束。</p>
<p>接下来是字符串输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	.section	__TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">	.asciz	&quot;hi there\n&quot;</div><div class="line"></div><div class="line">.subsections_via_symbols</div></pre></td></tr></table></figure></p>
<p>同样 .section 指出进入一个新的段。最后 .subsections_via_symbols 是静态链接器用的。</p>
<p>接下来通过 size 工具来看看 a.out 里的 section。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: 0x100000000 (vmaddr 0x0 fileoff 0)</div><div class="line">Segment __TEXT: 0x1000 (vmaddr 0x100000000 fileoff 0)</div><div class="line">	Section __text: 0x34 (addr 0x100000f50 offset 3920)</div><div class="line">	Section __stubs: 0x6 (addr 0x100000f84 offset 3972)</div><div class="line">	Section __stub_helper: 0x1a (addr 0x100000f8c offset 3980)</div><div class="line">	Section __cstring: 0xa (addr 0x100000fa6 offset 4006)</div><div class="line">	Section __unwind_info: 0x48 (addr 0x100000fb0 offset 4016)</div><div class="line">	total 0xa6</div><div class="line">Segment __DATA: 0x1000 (vmaddr 0x100001000 fileoff 4096)</div><div class="line">	Section __nl_symbol_ptr: 0x10 (addr 0x100001000 offset 4096)</div><div class="line">	Section __la_symbol_ptr: 0x8 (addr 0x100001010 offset 4112)</div><div class="line">	total 0x18</div><div class="line">Segment __LINKEDIT: 0x1000 (vmaddr 0x100002000 fileoff 8192)</div><div class="line">total 0x100003000</div></pre></td></tr></table></figure>
<p>可以看出有四个 segment 和多个section。</p>
<p>在运行时，虚拟内存会把 segment 映射到进程的地址空间，虚拟内存会避免将全部执行文件全部加载到内存。</p>
<p>__PAGEZERO segment 的大小是 4GB，不是文件真实大小，是规定进程地址空间前 4GB 被映射为不可执行，不可写和不可读。</p>
<p>__TEXT segment 包含被执行的代码以只读和可执行的方式映射。</p>
<ul>
<li>__text section 包含编译后的机器码。</li>
<li><strong>stubs 和 </strong>stub_helper 是给动态链接器 dyld 使用，可以允许延迟链接。</li>
<li>__cstring 可执行文件中的字符串。</li>
<li>__const 不可变的常量。</li>
</ul>
<p>__DATA segment 以可读写和不可执行的方式映射，里面是会被更改的数据。</p>
<ul>
<li>__nl_symbol_ptr 非延迟指针。可执行文件加载同时加载。 </li>
<li>__la_symbol_ptr 延迟符号指针。延迟用于可执行文件中调用未定义的函数，可执行文件里没有包含的函数会延迟加载。</li>
<li>__const 需要重定向的常量，例如 char * const c = “foo”; c指针指向可变的数据。</li>
<li>__bss 不用初始化的静态变量，例如 static int i; ANSI C 标准规定静态变量必须设置为0。运行时静态变量的值是可修改的。</li>
<li>__common 包含外部全局变量。例如在函数外定义 int i;</li>
<li>__dyld 是section占位符，用于动态链接器。</li>
</ul>
<p>更多 section 类型介绍可以查看苹果文档： <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Reference/Assembler/000-Introduction/introduction.html" target="_blank" rel="external">OS X Assembler Reference</a></p>
<p>接下来用 otool 查看下 section 里的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">Contents of (__TEXT,__text) section</div><div class="line">0000000100000f50	55 48 89 e5 48 83 ec 20 48 8d 05 47 00 00 00 c7 </div><div class="line">0000000100000f60	45 fc 00 00 00 00 89 7d f8 48 89 75 f0 48 89 c7 </div><div class="line">0000000100000f70	b0 00 e8 0d 00 00 00 31 c9 89 45 ec 89 c8 48 83 </div><div class="line">0000000100000f80	c4 20 5d c3</div></pre></td></tr></table></figure>
<p>这个返回的内容很难读，加个 - v  就可以查看反汇编代码了， -s <strong>TEXT </strong>text 有个缩写 -t<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line">0000000100000f50	pushq	%rbp</div><div class="line">0000000100000f51	movq	%rsp, %rbp</div><div class="line">0000000100000f54	subq	$0x20, %rsp</div><div class="line">0000000100000f58	leaq	0x47(%rip), %rax</div><div class="line">0000000100000f5f	movl	$0x0, -0x4(%rbp)</div><div class="line">0000000100000f66	movl	%edi, -0x8(%rbp)</div><div class="line">0000000100000f69	movq	%rsi, -0x10(%rbp)</div><div class="line">0000000100000f6d	movq	%rax, %rdi</div><div class="line">0000000100000f70	movb	$0x0, %al</div><div class="line">0000000100000f72	callq	0x100000f84</div><div class="line">0000000100000f77	xorl	%ecx, %ecx</div><div class="line">0000000100000f79	movl	%eax, -0x14(%rbp)</div><div class="line">0000000100000f7c	movl	%ecx, %eax</div><div class="line">0000000100000f7e	addq	$0x20, %rsp</div><div class="line">0000000100000f82	popq	%rbp</div><div class="line">0000000100000f83	retq</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉，和前面的编译时差不多，不同的就是没有汇编指令。</p>
<p>现在来看看可执行文件。</p>
<p>通过 otool 来看看可执行文件头部， 通过 -h 可以打印出头部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL LIB64     EXECUTE    15       1200   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>mach_header 结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>      magic;</div><div class="line">  <span class="keyword">cpu_type_t</span>    cputype;</div><div class="line">  <span class="keyword">cpu_subtype_t</span> cpusubtype;</div><div class="line">  <span class="keyword">uint32_t</span>      filetype;</div><div class="line">  <span class="keyword">uint32_t</span>      ncmds;</div><div class="line">  <span class="keyword">uint32_t</span>      sizeofcmds;</div><div class="line">  <span class="keyword">uint32_t</span>      flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>cputype 和 cpusubtype 规定可执行文件可以在哪些目标架构运行。ncmds 和 sizeofcmds 是加载命令。通过 -l 可以查看加载命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out | open -f</div></pre></td></tr></table></figure></p>
<p>加载命令结构体<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span></div><div class="line">  <span class="keyword">uint32_t</span>  cmd;</div><div class="line">  <span class="keyword">uint32_t</span>  cmdsize;</div><div class="line">  <span class="keyword">char</span>      segname[<span class="number">16</span>];</div><div class="line">  <span class="keyword">uint32_t</span>  vmaddr;</div><div class="line">  <span class="keyword">uint32_t</span>  vmsize;</div><div class="line">  <span class="keyword">uint32_t</span>  fileoff;</div><div class="line">  <span class="keyword">uint32_t</span>  filesize;</div><div class="line">  <span class="keyword">vm_prot_t</span> maxprot;</div><div class="line">  <span class="keyword">vm_prot_t</span> initprot;</div><div class="line">  <span class="keyword">uint32_t</span>  nsects;</div><div class="line">  <span class="keyword">uint32_t</span>  flags;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>查看 Load command 1 这个部分可以找到 initprot r-x ，表示只读和可执行。</p>
<p>在加载命令里还是看看 <strong>TEXT </strong>text 的section的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Section</div><div class="line">  sectname __text</div><div class="line">   segname __TEXT</div><div class="line">      addr 0x0000000100000f50</div><div class="line">      size 0x0000000000000034</div><div class="line">    offset 3920</div><div class="line">     align 2^4 (16)</div><div class="line">    reloff 0</div><div class="line">    nreloc 0</div><div class="line">      type S_REGULAR</div><div class="line">attributes PURE_INSTRUCTIONS SOME_INSTRUCTIONS</div><div class="line"> reserved1 0</div><div class="line"> reserved2 0</div></pre></td></tr></table></figure></p>
<p>addr 的值表示代码的位置地址，在上面反汇编的代码里可以看到地址是一样的，offset 表示在文件中的偏移量。</p>
<p>单个文件的就这样了，但是工程都是多个源文件的，那么多个文件是怎么合成一个可执行文件的呢？那么建多个文件来看看先。<br>Foo.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Foo : NSObject</div><div class="line"></div><div class="line">- (void)say;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>Foo.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">@implementation Foo</div><div class="line"></div><div class="line">- (void)say</div><div class="line">&#123;</div><div class="line">    NSLog(@“hi there again!\n”);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>SayHi.m<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import “Foo.h”</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        Foo *foo = [[Foo alloc] init];</div><div class="line">        [foo say];</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先编译多个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcrun clang -c Foo.m</div><div class="line">xcrun clang -c SayHi.m</div></pre></td></tr></table></figure></p>
<p>再将编译后的文件链接起来，这样就可以生成 a.out 可执行文件了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang SayHi.o Foo.o -Wl,`xcrun —show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</div></pre></td></tr></table></figure></p>
<h2 id="逆向-Mach-O-文件"><a href="#逆向-Mach-O-文件" class="headerlink" title="逆向 Mach-O 文件"></a>逆向 Mach-O 文件</h2><p>需要先安装 tweak，安装越狱可以通过 cydia，不越狱直接打包成 ipa 安装包。越狱的话会安装一个 mobilesubstrate 的动态库，使用 theos 开发工具，非越狱的直接把这个库打包进 ipa 中或者直接修改汇编代码。</p>
<p>Mobilesubstrate 提供了三个模块来方便开发。</p>
<ul>
<li>MobileHooker：利用 method swizzling 技术定义一些宏和函数来替换系统或者目标函数。</li>
<li>MobileLoader：在程序启动时将我们写的破解程序用的第三方库注入进去。怎么注入的呢，还记得先前说的 clang attribute 里的一个 attribute((constructor)) 么，它会在 main 执行之前执行，所以把我们的 hook  放在这里就可以了。</li>
<li>Safe mode：类似安全模式，会禁用的改动。</li>
</ul>
<p>先前提到 Mach-O 的结构有 Header，Load commands 和 Data，Mobileloader 会通过修改二进制的 loadCommands 来先把自己注入然后再把我们写的第三方库注入进去，这样破解程序就会放在 Load commands 段里面了。</p>
<p>当然如果是我们自己的程序我们是知道要替换哪些方法的，既然是逆向肯定是别人的程序了，这个时候就需要去先分析下我们想替换方法是哪个，网络相关的分析可以用常用那些抓包工具，比如 Charles，WireShark 等，静态的可以通过砸壳，反汇编，classdump 头文件来分析 app 的架构，对应的常用工具dumpdecrypted，hopper disassembler 和 class_dump。运行时的分析可用工具有运行时控制台cycript，远程断点调试lldb+debugserver，logify。</p>
<ul>
<li>这里有个实例，讲解如何通过逆向实现微信抢红包的插件： <a href="http://dev.qq.com/topic/5791da152168f2690e72daa4" target="_blank" rel="external">【Dev Club 分享第三期】iOS 黑客技术大揭秘 - DEV CLUB</a></li>
<li>入门文章可以看看这篇： <a href="https://github.com/zhengmin1989/MyArticles/tree/master/iOS%E5%86%B0%E4%B8%8E%E7%81%AB%E4%B9%8B%E6%AD%8C" target="_blank" rel="external">MyArticles/iOS冰与火之歌 at master · zhengmin1989/MyArticles · GitHub</a></li>
<li>玩出新花样： <a href="http://blog.imjun.net/2016/10/08/%E9%BB%91%E7%A7%91%E6%8A%80%EF%BC%9A%E6%8A%8A%E7%AC%AC%E4%B8%89%E6%96%B9-iOS-%E5%BA%94%E7%94%A8%E8%BD%AC%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93/" target="_blank" rel="external">黑科技：把第三方 iOS 应用转成动态库 - Jun’s Blog</a>，作者另一篇文章： <a href="http://blog.imjun.net/2016/08/25/iOS%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%81%A2%E5%A4%8D-%E9%80%86%E5%90%91%E6%94%AF%E4%BB%98%E5%AE%9D/" target="_blank" rel="external">iOS符号表恢复&amp;逆向支付宝 - Jun’s Blog</a></li>
</ul>
<h1 id="dyld动态链接"><a href="#dyld动态链接" class="headerlink" title="dyld动态链接"></a>dyld动态链接</h1><p>生成可执行文件后就是在启动时进行动态链接了，进行符号和地址的绑定。首先会加载所依赖的 dylibs，修正地址偏移，因为 iOS 会用 ASLR 来做地址偏移避免攻击，确定 Non-Lazy Pointer 地址进行符号地址绑定，加载所有类，最后执行 load 方法和 clang attribute 的 constructor 修饰函数。</p>
<p>用先前 Mach-O 章节的例子继续分析，每个函数，全局变量和类都是通过符号的形式来定义和使用的，当把目标文件链接成一个执行文件时，链接器在目标文件和动态库之间对符号做解析处理。</p>
<p>符号表会规定它们的符号，使用 nm 工具看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm SayHi.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _OBJC_CLASS_$_Foo</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush</div><div class="line">                 (undefined) external _objc_msgSend</div><div class="line">0000000000000000 (__TEXT,__text) external _main</div></pre></td></tr></table></figure>
<ul>
<li>_OBJC<em>CLASS</em>$_Foo 表示 Foo 的 OC 符号。</li>
<li>(undefined) external 表示未实现非私有，如果是私有就是 non-external。</li>
<li>external _main 表示 main() 函数，处理 0 地址，将要到 <strong>TEXT,</strong>text section </li>
</ul>
<p>再看看 Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm Foo.o</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject</div><div class="line">                 (undefined) external ___CFConstantStringClassReference</div><div class="line">                 (undefined) external __objc_empty_cache</div><div class="line">0000000000000000 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000000000060 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Foo</div><div class="line">00000000000000a8 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Foo</div><div class="line">00000000000000c8 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Foo</div><div class="line">0000000000000110 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000000000138 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>因为 undefined 符号表示该文件类未实现的，所以在目标文件和  Fundation framework 动态库做链接处理时，链接器会尝试解析所有的 undefined 符号。</p>
<p>链接器通过动态库解析成符号会记录是通过哪个动态库解析的，路径也会一起记录。对比下 a.out 符号表看看是怎么解析符号的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun nm -nm a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">                 (undefined) external _NSLog (from Foundation)</div><div class="line">                 (undefined) external _OBJC_CLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external _OBJC_METACLASS_$_NSObject (from CoreFoundation)</div><div class="line">                 (undefined) external ___CFConstantStringClassReference (from CoreFoundation)</div><div class="line">                 (undefined) external __objc_empty_cache (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPop (from libobjc)</div><div class="line">                 (undefined) external _objc_autoreleasePoolPush (from libobjc)</div><div class="line">                 (undefined) external _objc_msgSend (from libobjc)</div><div class="line">                 (undefined) external dyld_stub_binder (from libSystem)</div><div class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</div><div class="line">0000000100000e90 (__TEXT,__text) external _main</div><div class="line">0000000100000f10 (__TEXT,__text) non-external -[Foo say]</div><div class="line">0000000100001130 (__DATA,__objc_data) external _OBJC_METACLASS_$_Foo</div><div class="line">0000000100001158 (__DATA,__objc_data) external _OBJC_CLASS_$_Foo</div></pre></td></tr></table></figure>
<p>看看哪些 undefined 的符号，有了更多信息，可以知道在哪个动态库能够找到。</p>
<p>通过 otool 可以找到所需库在哪<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -L a.out</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">	/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1349.25.0)</div><div class="line">	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)</div><div class="line">	/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1348.28.0)</div><div class="line">	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</div></pre></td></tr></table></figure>
<p>libSystem 里有很多我们熟悉的lib</p>
<ul>
<li>libdispatch：GCD</li>
<li>libsystem_c：C语言库</li>
<li>libsystem_blocks：Block</li>
<li>libcommonCrypto：加密，比如md5</li>
</ul>
<p>dylib 这种格式的表示是动态链接的，编译的时候不会被编译到执行文件中，在程序执行的时候才 link，这样就不用算到包的大小里，而且也能够不更新执行程序就能够更新库。</p>
<p>打印什么库被加载了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(export DYLD_PRINT_LIBRARIES=; ./a.out )</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dyld: loaded: /Users/didi/Downloads/./a.out</div><div class="line">dyld: loaded: /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</div><div class="line">dyld: loaded: /usr/lib/libSystem.B.dylib</div><div class="line">dyld: loaded: /System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation</div><div class="line">…</div></pre></td></tr></table></figure>
<p>数数还挺多的，因为 Fundation 还会依赖一些其它的动态库，其它的库还会再依赖更多的库，这样相互依赖的符号会很多，需要处理的时间也会比较长，这里系统上的动态链接器会使用共享缓存，共享缓存在 /var/db/dyld/。当加载 Mach-O 文件时动态链接器会先检查共享内存是否有。每个进程都会在自己地址空间映射这些共享缓存，这样可以优化启动速度。</p>
<p>动态链接器的作用顺序是怎么样的呢，可以先看看 Mike Ash 写的这篇关于 dyld 的博客： <a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="external">Dynamic Linking On OS X</a></p>
<p>dyld 做了些什么事</p>
<ul>
<li>kernel 做启动程序初始准备，开始由dyld负责。</li>
<li>基于非常简单的原始栈为 kernel 设置进程来启动自身。</li>
<li>使用共享缓存来处理递归依赖带来的性能问题，ImageLoader 会读取二进制文件，其中包含了我们的类，方法等各种符号。</li>
<li>立即绑定 non-lazy 的符号并设置用于 lazy bind 的必要表，将这些库 link 到执行文件里。</li>
<li>为可执行文件运行静态初始化。</li>
<li>设置参数到可执行文件的 main 函数并调用它。</li>
<li>在执行期间，通过绑定符号处理对 lazily-bound 符号存根的调用提供 runtime 动态加载服务（通过 dl*() 这个 API ），并为gdb和其它调试器提供钩子以获得关键信息。runtime  会调用 map_images 做解析和处理，load_images 来调用 call_load_methods 方法遍历所有加载了的 Class，按照继承层级依次调用  +load 方法。</li>
<li>在 mian 函数返回后运行 static terminator。</li>
<li>在某些情况下，一旦 main 函数返回，就需要调用 libSystem 的 _exit。</li>
</ul>
<p>查看运行时的调用 map_images 和 调用 +load 方法的相关 runtime 处理可以通过 RetVal 的可debug 的 objc/runtime <a href="https://github.com/RetVal/objc-runtime" target="_blank" rel="external">RetVal/objc-runtime: objc runtime 706</a> 来进行断点查看调用的 runtime 方法具体实现。在 debug-objc 下创建一个类，在 +load 方法里断点查看走到这里调用的堆栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">0  +[someclass load]</div><div class="line">1  call_class_loads()</div><div class="line">2  ::call_load_methods</div><div class="line">3  ::load_images(const char *path __unused, const struct mach_header *mh)</div><div class="line">4  dyld::notifySingle(dyld_image_states, ImageLoader const*, ImageLoader::InitializerTimingList*)</div><div class="line">11 _dyld_start</div></pre></td></tr></table></figure>
<p>在  load_images 方法里断点 p path 可以打印出所有加载的动态链接库，这个方法的 hasLoadMethods 用于快速判断是否有 +load 方法。</p>
<p>prepare_load_methods 这个方法会获取所有类的列表然后收集其中的 +load 方法，在代码里可以发现 Class 的 +load 是先执行的，然后执行 Category 的。为什么这样做，原因可以通过 prepare_load_methods 这个方法看出，在遍历 Class 的 +load 方法时会执行 schedule_class_load 这个方法，这个方法会递归到根节点来满足 Class 收集完整关系树的需求。</p>
<p>最后 call_load_methods 会创建一个 autoreleasePool 使用函数指针来动态调用类和 Category 的 +load 方法。</p>
<p>如果想了解 Cocoa 的 Fundation 库可以通过 <a href="https://github.com/AaronYi/gnustep-base" target="_blank" rel="external">GNUStep</a> 源码来学习。比如 NSNotificationCenter 发送通知是按什么顺序发送的可以查看 NSNotificationCenter.m 里的 addObserver 方法和 postNotification 方法，看看观察者是怎么添加的和怎么被遍历通知到的。</p>
<p>dyld 是开源的： <a href="https://github.com/opensource-apple/dyld" target="_blank" rel="external">GitHub - opensource-apple/dyld</a></p>
<p>还可以看看苹果的 WWDC 视频 <a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">WWDC 2016 Session 406</a> 里讲解对启动进行优化。</p>
<p>这篇文章也不错： <a href="https://www.codeproject.com/articles/187181/dynamic-linking-of-imported-functions-in-mach-o" target="_blank" rel="external">Dynamic Linking of Imported Functions in Mach-O - CodeProject</a></p>
<h1 id="LLVM-工具链"><a href="#LLVM-工具链" class="headerlink" title="LLVM 工具链"></a>LLVM 工具链</h1><h2 id="获取-LLVM"><a href="#获取-LLVM" class="headerlink" title="获取 LLVM"></a>获取 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#先下载 LLVM</span></div><div class="line">svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 tools 目录下下载 Clang</span></div><div class="line"><span class="built_in">cd</span> llvm/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/cfe/trunk clang</div><div class="line"></div><div class="line"><span class="comment">#在 LLVM 的 projects 目录下下载 compiler-rt，libcxx，libcxxabi</span></div><div class="line"><span class="built_in">cd</span> ../projects</div><div class="line">svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx</div><div class="line">svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk libcxxabi</div><div class="line"></div><div class="line"><span class="comment">#在 Clang 的 tools 下安装 extra 工具</span></div><div class="line"><span class="built_in">cd</span> ../tools/clang/tools</div><div class="line">svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra</div></pre></td></tr></table></figure>
<h2 id="编译-LLVM"><a href="#编译-LLVM" class="headerlink" title="编译 LLVM"></a>编译 LLVM</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">brew install gcc</div><div class="line">brew install cmake</div><div class="line">mkdir build</div><div class="line"><span class="built_in">cd</span> build</div><div class="line">cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON -DLLVM_TARGETS_TO_BUILD=<span class="string">"AArch64;X86"</span> -G <span class="string">"Unix Makefiles"</span> ..</div><div class="line">make j8</div><div class="line"><span class="comment">#安装</span></div><div class="line">make install</div><div class="line"><span class="comment">#如果找不到标准库，Xcode 需要安装 xcode-select --install</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/01.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#如果希望是 xcodeproject 方式 build 可以使用 -GXcode</span></div><div class="line">mkdir xcodeBuild</div><div class="line"><span class="built_in">cd</span> xcodeBuild</div><div class="line">cmake -GXcode /path/to/llvm/<span class="built_in">source</span></div></pre></td></tr></table></figure>
<p><img src="/uploads/deeply-analyse-llvm/02.png" alt=""></p>
<p>在 bin 下存放着工具链，有了这些工具链就能够完成源码编译了。</p>
<p><img src="/uploads/deeply-analyse-llvm/03.png" alt=""></p>
<h2 id="LLVM-源码工程目录介绍"><a href="#LLVM-源码工程目录介绍" class="headerlink" title="LLVM 源码工程目录介绍"></a>LLVM 源码工程目录介绍</h2><ul>
<li>llvm/examples/ - 使用 LLVM IR 和 JIT 的例子。</li>
<li>llvm/include/ - 导出的头文件。</li>
<li>llvm/lib/ - 主要源文件都在这里。</li>
<li>llvm/project/ - 创建自己基于 LLVM 的项目的目录。</li>
<li>llvm/test/ - 基于 LLVM 的回归测试，健全检察。</li>
<li>llvm/suite/ - 正确性，性能和基准测试套件。</li>
<li>llvm/tools/ - 基于 lib 构建的可以执行文件，用户通过这些程序进行交互，-help 可以查看各个工具详细使用。</li>
<li>llvm/utils/ - LLVM 源代码的实用工具，比如，查找 LLC 和 LLI 生成代码差异工具， Vim 或 Emacs 的语法高亮工具等。</li>
</ul>
<h2 id="lib-目录介绍"><a href="#lib-目录介绍" class="headerlink" title="lib 目录介绍"></a>lib 目录介绍</h2><ul>
<li>llvm/lib/IR/ - 核心类比如 Instruction 和 BasicBlock。</li>
<li>llvm/lib/AsmParser/ - 汇编语言解析器。</li>
<li>llvm/lib/Bitcode/ - 读取和写入字节码</li>
<li>llvm/lib/Analysis/ - 各种对程序的分析，比如 Call Graphs，Induction Variables，Natural Loop Identification 等等。</li>
<li>llvm/lib/Transforms/ - IR-to-IR 程序的变换。</li>
<li>llvm/lib/Target/ - 对像 X86 这样机器的描述。</li>
<li>llvm/lib/CodeGen/ - 主要是代码生成，指令选择器，指令调度和寄存器分配。</li>
<li>llvm/lib/ExecutionEngine/ - 在解释执行和JIT编译场景能够直接在运行时执行字节码的库。</li>
</ul>
<h2 id="工具链命令介绍"><a href="#工具链命令介绍" class="headerlink" title="工具链命令介绍"></a>工具链命令介绍</h2><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>llvm-as - 汇编器，将 .ll 汇编成字节码。</li>
<li>llvm-dis - 反汇编器，将字节码编成可读的 .ll 文件。</li>
<li>opt - 字节码优化器。</li>
<li>llc - 静态编译器，将字节码编译成汇编代码。</li>
<li>lli - 直接执行 LLVM 字节码。</li>
<li>llvm-link - 字节码链接器，可以把多个字节码文件链接成一个。</li>
<li>llvm-ar - 字节码文件打包器。</li>
<li>llvm-lib - LLVM lib.exe 兼容库工具。</li>
<li>llvm-nm - 列出字节码和符号表。</li>
<li>llvm-config - 打印 LLVM 编译选项。</li>
<li>llvm-diff - 对两个进行比较。</li>
<li>llvm-cov - 输出 coverage infomation。</li>
<li>llvm-profdata - Profile 数据工具。</li>
<li>llvm-stress - 生成随机 .ll 文件。</li>
<li>llvm-symbolizer - 地址对应源码位置，定位错误。</li>
<li>llvm-dwarfdump - 打印 DWARF。</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li>bugpoint - 自动测试案例工具</li>
<li>llvm-extract - 从一个 LLVM 的模块里提取一个函数。</li>
<li>llvm-bcanalyzer - LLVM 字节码分析器。</li>
</ul>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul>
<li>FileCheck - 灵活的模式匹配文件验证器。</li>
<li>tblgen - C++ 代码生成器。</li>
<li>lit - LLVM 集成测试器。</li>
<li>llvm-build - LLVM 构建工程时需要的工具。</li>
<li>llvm-readobj - LLVM Object 结构查看器。</li>
</ul>
<h1 id="Swift-编译"><a href="#Swift-编译" class="headerlink" title="Swift 编译"></a>Swift 编译</h1><p>官网： <a href="https://github.com/apple/swift" target="_blank" rel="external">GitHub - apple/swift: The Swift Programming Language</a><br>swift 现在是开源的，如果希望能够为它做贡献可以先了解下官方的介绍说明： <a href="https://swift.org/contributing/#contributing-code" target="_blank" rel="external">Swift.org - Contributing</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#首先和 LLVM 一样先安装 cmake 和 ninja ，再创建目录</div><div class="line">brew install cmake ninja</div><div class="line">mkdir swiftsource</div><div class="line">cd swiftsource</div><div class="line"></div><div class="line">#clone 下 swift 源码</div><div class="line">git clone https://github.com/apple/swift.git</div><div class="line"></div><div class="line">#checkout 相关编译的依赖，比如 llvm，clang，llbuild，lldb，ninja，cmark 等等，目前差不多有13个</div><div class="line">./swift/utils/update-checkout —clone</div><div class="line"></div><div class="line">#查看文件夹</div><div class="line">du -h -d 1</div><div class="line"></div><div class="line">#build swift，这里的 -x 参数会生成 xcode 的工程文件方便在xcode里阅读。-R 会使用 release 模式，比 debug 快。</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#更新</div><div class="line">./swift/utils/update-checkout</div><div class="line">./swift/utils/build-script -x -R</div><div class="line"></div><div class="line">#切到指定tag和分支</div><div class="line">#tag</div><div class="line">./swift/utils/update-checkout —tag swift-3.0-RELEASE</div><div class="line">#特定分支</div><div class="line">./swift/utils/update-checkout —scheme swift-3.0-branch</div></pre></td></tr></table></figure>
<p>swift 编译是由多个代码仓库组合而成的，各个代码仓库的介绍说明可以查看官方说明： <a href="https://swift.org/source-code/" target="_blank" rel="external">Swift.org - Source Code</a></p>
<h1 id="其它编译工具"><a href="#其它编译工具" class="headerlink" title="其它编译工具"></a>其它编译工具</h1><h2 id="js写的C-解释器JSCPP"><a href="#js写的C-解释器JSCPP" class="headerlink" title="js写的C++解释器JSCPP"></a>js写的C++解释器JSCPP</h2><p>适合学生学习时能够方便的在浏览器里直接编c++程序。项目地址：<a href="https://github.com/felixhao28/JSCPP" target="_blank" rel="external">GitHub - felixhao28/JSCPP: A simple C++ interpreter written in JavaScript</a></p>
<h2 id="C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><a href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language" class="headerlink" title="C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language"></a>C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</h2><p>在 web 中有个 WebAssembly 是个标准，可以使得 web 运行 C/C++ 成为可能。当然还有其它的比如：<a href="http://c-smile.sourceforge.net/" target="_blank" rel="external">http://c-smile.sourceforge.net/</a></p>
<h1 id="资料网址"><a href="#资料网址" class="headerlink" title="资料网址"></a>资料网址</h1><ul>
<li><a href="http://llvm.org" target="_blank" rel="external">http://llvm.org</a></li>
<li><a href="http://clang.llvm.org/" target="_blank" rel="external">http://clang.llvm.org/</a></li>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">http://www.aosabook.org/en/llvm.html</a></li>
<li><a href="https://github.com/loarabia/Clang-tutorial" target="_blank" rel="external">GitHub - loarabia/Clang-tutorial: A collection of code samples showing usage of clang and llvm as a library</a></li>
<li><a href="http://stackoverflow.com/questions/3297986/using-an-external-xcode-clang-static-analyzer-binary-with-additional-checks" target="_blank" rel="external">Using an external Xcode Clang Static Analyzer binary, with additional checks - Stack Overflow</a></li>
<li><a href="http://llvm.org/devmtg/" target="_blank" rel="external">LLVM Developers’ Metting</a></li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://ming1016.github.io">戴铭</a>
            <p>原文链接：<a href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/</a>
            <p>发表日期：<a href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">March 1st 2017, 9:58:09 pm</a>
            <p>更新日期：<a href="http://ming1016.github.io/2017/03/01/deeply-analyse-llvm/">October 11th 2017, 11:08:40 am</a>
            <p>版权声明：本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2017/04/01/slides-of-deeply-analyse-llvm/" title= "深入剖析 iOS 编译 Clang / LLVM 直播的 Slides">
                    <div class="nextTitle">深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2016/11/22/how-to-preload-web-in-ios/" title= "iOS预加载Web页面方案">
                    <div class="prevTitle">iOS预加载Web页面方案</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:ming1016@foxmail.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/ming1016" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/assets/wechat-qcode.jpg" />
                </span>
            
        
    
        
    
        
    
        
            
                <a href="//weibo.com/allstarming" class="iconfont-archer weibo" target="_blank" title=weibo></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
    <div class="copyright">
    <a href="http://www.beian.miit.gov.cn">鄂ICP备17011999号</a>
    </div>
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编译流程"><span class="toc-number">2.</span> <span class="toc-text">编译流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-编译-m-文件"><span class="toc-number">3.</span> <span class="toc-text">Clang 编译 .m 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构建-Target"><span class="toc-number">3.1.</span> <span class="toc-text">构建 Target</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Target-在-Build-过程的控制"><span class="toc-number">3.2.</span> <span class="toc-text">Target 在 Build 过程的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-Phases"><span class="toc-number">3.2.1.</span> <span class="toc-text">Build Phases</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-Rules"><span class="toc-number">3.2.2.</span> <span class="toc-text">Build Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Build-Settings"><span class="toc-number">3.2.3.</span> <span class="toc-text">Build Settings</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pbxproj工程文件"><span class="toc-number">3.2.4.</span> <span class="toc-text">pbxproj工程文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-Static-Analyzer静态代码分析"><span class="toc-number">4.</span> <span class="toc-text">Clang Static Analyzer静态代码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CodeGen-生成-IR-代码"><span class="toc-number">5.</span> <span class="toc-text">CodeGen 生成 IR 代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IR-结构"><span class="toc-number">5.1.</span> <span class="toc-text">IR 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLVM-IR-优化"><span class="toc-number">5.2.</span> <span class="toc-text">LLVM IR 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSA"><span class="toc-number">5.3.</span> <span class="toc-text">SSA</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-CFE"><span class="toc-number">6.</span> <span class="toc-text">Clang CFE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#libclang"><span class="toc-number">6.1.</span> <span class="toc-text">libclang</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Driver"><span class="toc-number">7.</span> <span class="toc-text">Driver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Driver-的工作流程图"><span class="toc-number">7.1.</span> <span class="toc-text">Driver 的工作流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parse"><span class="toc-number">7.2.</span> <span class="toc-text">Parse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline"><span class="toc-number">7.3.</span> <span class="toc-text">Pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Action"><span class="toc-number">7.4.</span> <span class="toc-text">Action</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bind"><span class="toc-number">7.5.</span> <span class="toc-text">Bind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Translate"><span class="toc-number">7.6.</span> <span class="toc-text">Translate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jobs"><span class="toc-number">7.7.</span> <span class="toc-text">Jobs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Execute"><span class="toc-number">7.8.</span> <span class="toc-text">Execute</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-Attributes"><span class="toc-number">8.</span> <span class="toc-text">Clang Attributes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-format-NSString-F-A-格式化字符串"><span class="toc-number">8.1.</span> <span class="toc-text">attribute((format(NSString, F, A))) 格式化字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-deprecated-s-版本弃用提示"><span class="toc-number">8.2.</span> <span class="toc-text">attribute((deprecated(s))) 版本弃用提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-availability-os-introduced-m-deprecated-n-obsoleted-o-message-“”-VA-ARGS-指明使用版本范围"><span class="toc-number">8.3.</span> <span class="toc-text">attribute((availability(os,introduced=m,deprecated=n, obsoleted=o,message=“” VA_ARGS))) 指明使用版本范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-unavailable-…-方法不可用提示"><span class="toc-number">8.4.</span> <span class="toc-text">attribute((unavailable(…))) 方法不可用提示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-unused"><span class="toc-number">8.5.</span> <span class="toc-text">attribute((unused))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-warn-unused-result"><span class="toc-number">8.6.</span> <span class="toc-text">attribute((warn_unused_result))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-availability-swift-unavailable-message-msg"><span class="toc-number">8.7.</span> <span class="toc-text">attribute((availability(swift, unavailable, message=_msg)))</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-cleanup-…-作用域结束时自动执行一个指定方法"><span class="toc-number">8.8.</span> <span class="toc-text">attribute((cleanup(…))) 作用域结束时自动执行一个指定方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-overloadable-方法重载"><span class="toc-number">8.9.</span> <span class="toc-text">attribute((overloadable)) 方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-objc-designated-initializer-指定内部实现的初始化方法"><span class="toc-number">8.10.</span> <span class="toc-text">attribute((objc_designated_initializer)) 指定内部实现的初始化方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-objc-subclassing-restricted-指定不能有子类"><span class="toc-number">8.11.</span> <span class="toc-text">attribute((objc_subclassing_restricted)) 指定不能有子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-objc-requires-super-子类继承必须调用-super"><span class="toc-number">8.12.</span> <span class="toc-text">attribute((objc_requires_super)) 子类继承必须调用 super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-const-重复调用相同数值参数优化返回"><span class="toc-number">8.13.</span> <span class="toc-text">attribute((const)) 重复调用相同数值参数优化返回</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#attribute-constructor-PRIORITY-和-attribute-destructor-PRIORITY"><span class="toc-number">8.14.</span> <span class="toc-text">attribute((constructor(PRIORITY))) 和 attribute((destructor(PRIORITY)))</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-警告处理"><span class="toc-number">9.</span> <span class="toc-text">Clang 警告处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-libclang-来进行语法分析"><span class="toc-number">10.</span> <span class="toc-text">使用 libclang 来进行语法分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LibTooling-对语法树完全的控制"><span class="toc-number">11.</span> <span class="toc-text">LibTooling 对语法树完全的控制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Clang-Plugin"><span class="toc-number">12.</span> <span class="toc-text">Clang Plugin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LLVM-Backend"><span class="toc-number">13.</span> <span class="toc-text">LLVM Backend</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CodeGen-阶段"><span class="toc-number">13.1.</span> <span class="toc-text">CodeGen 阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SelectionDAG"><span class="toc-number">13.2.</span> <span class="toc-text">SelectionDAG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDNode"><span class="toc-number">13.2.1.</span> <span class="toc-text">SDNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PatFrag-可复用的结构"><span class="toc-number">13.2.2.</span> <span class="toc-text">PatFrag 可复用的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern-匹配指令"><span class="toc-number">13.2.3.</span> <span class="toc-text">Pattern 匹配指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicate"><span class="toc-number">13.2.4.</span> <span class="toc-text">Predicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Itinerary-和-SchedRW-调度信息"><span class="toc-number">13.2.5.</span> <span class="toc-text">Itinerary 和 SchedRW 调度信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TableGen"><span class="toc-number">13.2.6.</span> <span class="toc-text">TableGen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TabelGen-类型"><span class="toc-number">13.2.6.1.</span> <span class="toc-text">TabelGen 类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Register-Allocation-寄存器分配"><span class="toc-number">13.3.</span> <span class="toc-text">Register Allocation 寄存器分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器"><span class="toc-number">13.3.1.</span> <span class="toc-text">寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RegisterClass"><span class="toc-number">13.3.2.</span> <span class="toc-text">RegisterClass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄存器在-LLVM-中的表达"><span class="toc-number">13.3.3.</span> <span class="toc-text">寄存器在 LLVM 中的表达</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟寄存器到物理寄存器的映射"><span class="toc-number">13.3.4.</span> <span class="toc-text">虚拟寄存器到物理寄存器的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLVM-自带的寄存器分配算法"><span class="toc-number">13.3.5.</span> <span class="toc-text">LLVM 自带的寄存器分配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Code-Emission"><span class="toc-number">13.4.</span> <span class="toc-text">Code Emission</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-编译流"><span class="toc-number">14.</span> <span class="toc-text">Swift 编译流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编译后生成的二进制内容-Link-Map-File"><span class="toc-number">15.</span> <span class="toc-text">编译后生成的二进制内容 Link Map File</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-files"><span class="toc-number">15.1.</span> <span class="toc-text">Object files</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sections"><span class="toc-number">15.2.</span> <span class="toc-text">Sections</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbols"><span class="toc-number">15.3.</span> <span class="toc-text">Symbols</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#每次编译后生成的-dSYM-文件"><span class="toc-number">16.</span> <span class="toc-text">每次编译后生成的 dSYM 文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mach-O-文件"><span class="toc-number">17.</span> <span class="toc-text">Mach-O 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mach-O-文件的解析"><span class="toc-number">17.1.</span> <span class="toc-text">Mach-O 文件的解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逆向-Mach-O-文件"><span class="toc-number">17.2.</span> <span class="toc-text">逆向 Mach-O 文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dyld动态链接"><span class="toc-number">18.</span> <span class="toc-text">dyld动态链接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LLVM-工具链"><span class="toc-number">19.</span> <span class="toc-text">LLVM 工具链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#获取-LLVM"><span class="toc-number">19.1.</span> <span class="toc-text">获取 LLVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译-LLVM"><span class="toc-number">19.2.</span> <span class="toc-text">编译 LLVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LLVM-源码工程目录介绍"><span class="toc-number">19.3.</span> <span class="toc-text">LLVM 源码工程目录介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lib-目录介绍"><span class="toc-number">19.4.</span> <span class="toc-text">lib 目录介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工具链命令介绍"><span class="toc-number">19.5.</span> <span class="toc-text">工具链命令介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本命令"><span class="toc-number">19.5.1.</span> <span class="toc-text">基本命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试工具"><span class="toc-number">19.5.2.</span> <span class="toc-text">调试工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开发工具"><span class="toc-number">19.5.3.</span> <span class="toc-text">开发工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Swift-编译"><span class="toc-number">20.</span> <span class="toc-text">Swift 编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其它编译工具"><span class="toc-number">21.</span> <span class="toc-text">其它编译工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#js写的C-解释器JSCPP"><span class="toc-number">21.1.</span> <span class="toc-text">js写的C++解释器JSCPP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-SMILE-一套支持C-C-JS-JAVA四种语言的scripting-language"><span class="toc-number">21.2.</span> <span class="toc-text">C-SMILE 一套支持C/C++ JS JAVA四种语言的scripting language</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#资料网址"><span class="toc-number">22.</span> <span class="toc-text">资料网址</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 45
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/18</span><a class="archive-post-title" href= "/2020/12/18/thinking-in-how-to-speed-up-app/" >App 启动提速实践和一些想法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/04</span><a class="archive-post-title" href= "/2020/05/04/draw-in-2020/" >2020年涂图</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span><a class="archive-post-title" href= "/2020/04/12/why_write_study_ios_programming_with_daiming_book_and_draw_recently/" >我为什么写了《跟戴铭学iOS编程》这本书</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/29</span><a class="archive-post-title" href= "/2020/03/29/apple-system-executable-file-macho/" >Apple 操作系统可执行文件 Mach-O</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span><a class="archive-post-title" href= "/2020/01/05/kuaishou-unused-class-swiftui-note-binary-tree-interview/" >在快手做分享、无用类检查、在广州做 SwiftUI 学习笔记分享、InfoQ二叉树视频</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/2019/12/28/japan-travel/" >日本游玩</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/07</span><a class="archive-post-title" href= "/2019/12/07/how-to-analyze-startup-time-cost-in-ios/" >如何对 iOS 启动阶段耗时进行分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span><a class="archive-post-title" href= "/2019/12/06/draw-in-2019/" >2019年涂图</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2019/07/29/ios-map/" >iOS 开发舆图</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/19</span><a class="archive-post-title" href= "/2019/06/19/white-dragon-class/" >白龙班</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/17</span><a class="archive-post-title" href= "/2018/09/17/produce-slides-of-third-at-swift-conference/" >这次swift大会分享准备的幻灯片和 demo</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/2018/09/14/draw-with-procreate-in-ipad-during-pre-half-in-20182/" >18年上半年procreate的练习图图</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/21</span><a class="archive-post-title" href= "/2018/04/21/deeply-analyse-javascriptcore/" >深入剖析 JavaScriptCore</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/07</span><a class="archive-post-title" href= "/2018/04/07/read-snapkit-and-masonry-source-code/" >读 SnapKit 和 Masonry 自动布局框架源码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/" >Swift 项目中涉及到 JSONDecoder，网络请求，泛型协议式编程的一些记录和想法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/24</span><a class="archive-post-title" href= "/2018/01/24/why-swift/" >Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/10</span><a class="archive-post-title" href= "/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/" >GIAC 大会上分享的《Swift 将 Web 代码转成60帧满帧原生应用的方案及实践》的幻灯片</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href= "/2018/01/04/baimi/" >白芈</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href= "/2018/01/04/huaye/" >花野</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2017/10/24/how-do-i-improve-the-development/" >在滴滴，我是如何指数级提升开发技术的？</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/16</span><a class="archive-post-title" href= "/2017/10/16/html-to-native-htn-development-record/" >HTML 转原生 HTN 项目开发记录</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2017/10/11/deeply-analyse-webkit/" >深入剖析 WebKit</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2017/06/20/deeply-ios-performance-optimization/" >深入剖析 iOS 性能优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/12</span><a class="archive-post-title" href= "/2017/06/12/gmtc-ios-slimming-practice/" >GMTC 上分享滴滴出行 iOS 端瘦身实践的 Slides</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2017/05/27/slides-of-learn-what-interesting-things-you-can-do-with-iOS-compilation/" >atSwift大会上分享《学习iOS编译原理能做哪些有意思的事情》的 Slides</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2017/04/01/build-static-analysis-program-smck-use-swift/" >用 Swift 编写的工程代码静态分析命令行工具 smck</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2017/04/01/slides-of-deeply-analyse-llvm/" >深入剖析 iOS 编译 Clang / LLVM 直播的 Slides</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href= "/2017/03/01/deeply-analyse-llvm/" >深入剖析 iOS 编译 Clang / LLVM</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2016 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2016/11/22/how-to-preload-web-in-ios/" >iOS预加载Web页面方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span><a class="archive-post-title" href= "/2016/11/17/use-swift3-build-macos-program-to-clear-unuse-method/" >使用Swift3开发了个macOS的程序可以检测出objc项目中无用方法，然后一键全部清理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2016/09/20/draw-with-procreate-in-ipad-during-15-to-16/" >15，16年iPad上使用Procreate画的</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2016/09/02/develop-rss-reader/" >使用ReactiveCocoa开发RSS阅读器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/09</span><a class="archive-post-title" href= "/2016/08/09/how-to-use-reactivecocoa/" >iOS函数响应式编程以及ReactiveCocoa的使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/21</span><a class="archive-post-title" href= "/2016/07/21/assembleview/" >制作一个类似苹果VFL(Visual Format Language)的格式化语言来描述类似UIStackView那种布局思路，并解析生成页面</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/30</span><a class="archive-post-title" href= "/2016/05/30/what-learn-from-reactivecocoa/" >从 ReactiveCocoa 中能学到什么？不用此库也能学以致用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span><a class="archive-post-title" href= "/2016/05/23/try-to-decouple-with-demo/" >竭尽全力的去解耦的一次实践，封装一个TableView和一些功能组合的控件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/04</span><a class="archive-post-title" href= "/2016/04/04/tenth-middle-school/" >十中</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/13</span><a class="archive-post-title" href= "/2016/01/13/how-to-use-gcd/" >细说 GCD（Grand Central Dispatch）如何用</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2015 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span><a class="archive-post-title" href= "/2015/11/03/deeply-analyse-autolayout/" >深入剖析Auto Layout，分析iOS各版本新增特性</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/02</span><a class="archive-post-title" href= "/2015/11/02/draw-with-note-in-ipad-during-15/" >15年用iPad上的备忘录画的</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span><a class="archive-post-title" href= "/2015/05/28/macos-app-i-used/" >我用过的 macOS 应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2015/04/02/draw-game-of-thrones-with-pencil-during-14/" >整理了画的权利的游戏里的角色，有龙女，小恶魔等等</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2015/04/01/objc-runtime/" >Objc Runtime 总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/12</span><a class="archive-post-title" href= "/2015/03/12/draw-practice-with-pencil-during-14-to-15/" >14和15年间的铅笔画练习</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2014 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/01</span><a class="archive-post-title" href= "/2014/03/01/black-star-blue-map/" >黑星蓝图</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="Novel"><span class="iconfont-archer">&#xe606;</span>Novel</span>
    
        <span class="sidebar-tag-name" data-tags="smck"><span class="iconfont-archer">&#xe606;</span>smck</span>
    
        <span class="sidebar-tag-name" data-tags="Swift"><span class="iconfont-archer">&#xe606;</span>Swift</span>
    
        <span class="sidebar-tag-name" data-tags="iOS"><span class="iconfont-archer">&#xe606;</span>iOS</span>
    
        <span class="sidebar-tag-name" data-tags="Autolayout"><span class="iconfont-archer">&#xe606;</span>Autolayout</span>
    
        <span class="sidebar-tag-name" data-tags="Painting"><span class="iconfont-archer">&#xe606;</span>Painting</span>
    
        <span class="sidebar-tag-name" data-tags="iPad"><span class="iconfont-archer">&#xe606;</span>iPad</span>
    
        <span class="sidebar-tag-name" data-tags="Procreate"><span class="iconfont-archer">&#xe606;</span>Procreate</span>
    
        <span class="sidebar-tag-name" data-tags="AssembleView"><span class="iconfont-archer">&#xe606;</span>AssembleView</span>
    
        <span class="sidebar-tag-name" data-tags="RSSReader"><span class="iconfont-archer">&#xe606;</span>RSSReader</span>
    
        <span class="sidebar-tag-name" data-tags="Pencil"><span class="iconfont-archer">&#xe606;</span>Pencil</span>
    
        <span class="sidebar-tag-name" data-tags="JavaScript"><span class="iconfont-archer">&#xe606;</span>JavaScript</span>
    
        <span class="sidebar-tag-name" data-tags="Web"><span class="iconfont-archer">&#xe606;</span>Web</span>
    
        <span class="sidebar-tag-name" data-tags="编译"><span class="iconfont-archer">&#xe606;</span>编译</span>
    
        <span class="sidebar-tag-name" data-tags="GOT"><span class="iconfont-archer">&#xe606;</span>GOT</span>
    
        <span class="sidebar-tag-name" data-tags="Performance optimization"><span class="iconfont-archer">&#xe606;</span>Performance optimization</span>
    
        <span class="sidebar-tag-name" data-tags="Slides"><span class="iconfont-archer">&#xe606;</span>Slides</span>
    
        <span class="sidebar-tag-name" data-tags="Study"><span class="iconfont-archer">&#xe606;</span>Study</span>
    
        <span class="sidebar-tag-name" data-tags="UIWebView"><span class="iconfont-archer">&#xe606;</span>UIWebView</span>
    
        <span class="sidebar-tag-name" data-tags="NSURLProtocol"><span class="iconfont-archer">&#xe606;</span>NSURLProtocol</span>
    
        <span class="sidebar-tag-name" data-tags="macOS"><span class="iconfont-archer">&#xe606;</span>macOS</span>
    
        <span class="sidebar-tag-name" data-tags="APP"><span class="iconfont-archer">&#xe606;</span>APP</span>
    
        <span class="sidebar-tag-name" data-tags="ReactiveCocoa"><span class="iconfont-archer">&#xe606;</span>ReactiveCocoa</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="Japan"><span class="iconfont-archer">&#xe606;</span>Japan</span>
    
        <span class="sidebar-tag-name" data-tags="swift"><span class="iconfont-archer">&#xe606;</span>swift</span>
    
        <span class="sidebar-tag-name" data-tags="LLVM"><span class="iconfont-archer">&#xe606;</span>LLVM</span>
    
        <span class="sidebar-tag-name" data-tags="runtime"><span class="iconfont-archer">&#xe606;</span>runtime</span>
    
        <span class="sidebar-tag-name" data-tags="Pattern"><span class="iconfont-archer">&#xe606;</span>Pattern</span>
    
        <span class="sidebar-tag-name" data-tags="Clang"><span class="iconfont-archer">&#xe606;</span>Clang</span>
    
        <span class="sidebar-tag-name" data-tags="WebKit"><span class="iconfont-archer">&#xe606;</span>WebKit</span>
    
        <span class="sidebar-tag-name" data-tags="Apple"><span class="iconfont-archer">&#xe606;</span>Apple</span>
    
        <span class="sidebar-tag-name" data-tags="Mach-O"><span class="iconfont-archer">&#xe606;</span>Mach-O</span>
    
        <span class="sidebar-tag-name" data-tags="book"><span class="iconfont-archer">&#xe606;</span>book</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="My-novel"><span class="iconfont-archer">&#xe60a;</span>My-novel</span>
    
        <span class="sidebar-category-name" data-categories="Programming"><span class="iconfont-archer">&#xe60a;</span>Programming</span>
    
        <span class="sidebar-category-name" data-categories="My-painting"><span class="iconfont-archer">&#xe60a;</span>My-painting</span>
    
        <span class="sidebar-category-name" data-categories="APP"><span class="iconfont-archer">&#xe60a;</span>APP</span>
    
        <span class="sidebar-category-name" data-categories="travel"><span class="iconfont-archer">&#xe60a;</span>travel</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "戴铭"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


