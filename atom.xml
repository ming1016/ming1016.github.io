<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>戴铭的博客 - 星光社</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ming1016.github.io/"/>
  <updated>2020-12-21T02:49:49.025Z</updated>
  <id>http://ming1016.github.io/</id>
  
  <author>
    <name>戴铭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>App 启动提速实践和一些想法</title>
    <link href="http://ming1016.github.io/2020/12/18/thinking-in-how-to-speed-up-app/"/>
    <id>http://ming1016.github.io/2020/12/18/thinking-in-how-to-speed-up-app/</id>
    <published>2020-12-18T08:14:09.000Z</published>
    <updated>2020-12-21T02:49:49.025Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/thinking-in-how-to-speed-up-app/1.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动是门面，好的印象也助于留存率提高。苹果也在系统启动上不断努力，提升用户体验，最新的 M1 宣传中还特别强调了翻盖秒开 macOS，可以看出其对极致启动速度的追求。<a href="https://farfetchtechblog.com/en/blog/post/mobile-app-launch-performance-ii/" target="_blank" rel="external">这篇文章</a>提到，据 <a href="https://wemakewebsites.com/blog/improve-page-load-speed-increase-conversion/" target="_blank" rel="external">Akamai</a> 调查，每多1秒等待，转化率会下降7%，KissMetrics 的一份报告说启动超5秒，会使19%的用户放弃等待卸载 App。<br><img src="/uploads/thinking-in-how-to-speed-up-app/2.png" alt=""></p>
<p>高德 App 启动优化专项完成后已经有一段时间了，一直保持实属不易，我一年前在这篇<a href="https://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/">文章</a>里也做了些总结。我这里再补充些启动优化用到一些手段和一些想法，希望这些能够对你有帮助。</p>
<h2 id="通过-Universal-Links-和-App-Links-优化唤端启动体验"><a href="#通过-Universal-Links-和-App-Links-优化唤端启动体验" class="headerlink" title="通过 Universal Links 和 App Links 优化唤端启动体验"></a>通过 Universal Links 和 App Links 优化唤端启动体验</h2><p>App 都会存在拉新和导流的诉求，如何提高这样场景的用户体验呢？这里会用到唤端技术。包含选择什么样的换端协议，我们先看看唤端路径，如下：<br><img src="/uploads/thinking-in-how-to-speed-up-app/3.png" alt=""></p>
<p>唤端的协议分为自定义协议和平台标准协议，自定义协议在 iOS 端会有系统提示弹框，在 Android 端 chrome 25 后自定义协议失效，需用 Intent 协议包装才能打开 App。如果希望提高体验最好使用平台标准协议。平台标准协议在 iOS 平台叫 Universal Links，在 iOS 9 开始引入的，所以 iOS 9 及以上系统都支持，如果用户安装了要跳的 App 就会直接跳到 App，不会有系统弹框提示。相对应的 Android 平台标准协议叫 App Links，Android 6 以上都支持。</p>
<p>这里需要注意的是 iOS 的 Universal Links 不支持自动唤端，也就是页面加载后自动执行唤端是不行的，需要用户主动点击进行唤端。对于自定义协议和平台标准协议在有些 App 里是遇到屏蔽或者那些 App 自定义弹窗提示，这就只能通过沟通加白来解决了。</p>
<p>另外对于启动时展示 H5 启动页，或唤端跳转特定功能页，可以将拦截判断置前，判断出启动去往功能页，优先加载功能页的任务，主图相关任务项延后再加载，以提升启动到特定页面的速度。</p>
<h2 id="H5启动页"><a href="#H5启动页" class="headerlink" title="H5启动页"></a>H5启动页</h2><p>现在 App 启动会在有活动时先弹出活动运营 H5 页面提高活动曝光率。但如果 H5 加载慢势必非常影响启动的体验。</p>
<p>iOS 的话可以使用 ODR(On-Demand Resources) 在安装后先下载下来，点击启动前实际上就可以直接加载本地的了。ODR 安装后立刻下载的模式，下载资源会被清除，所以需要将下载内容移动到自定义的地方，同时还需要做自己兜底的下载来保证在 On-Demand Resources 下载失败时，还能够再从自己兜底服务器上拉下资源。</p>
<p>On-Demand Resources 还能够放很多资源，甚至包括脚本代码的预加载，可以减少包体积。由于使用的是苹果服务器，还能够减少 CDN 产生的峰值成本。</p>
<p>如果不使用 On-Demand Resources 也可以对 WKWebView 进行预加载，虽然安装后第一次还是需要从服务器上加载一次，不过后面就可以从本地快速读取了。</p>
<p>iOS 有三套方案，一套是通过 WKBrowsingContextController 注册 scheme，使用 URLProtocol 进行网络拦截。第二套是基于 WKURLSchemeHandler 自定义 scheme 拦截请求。第三套是在本地搭建 local server，拦截网络请求重定向到本地 server。第三套搭建本地 server 成本高，启动 server 比较耗时。第二套 WKURLSchemeHandler 使用自定义 scheme，对于 H5 适配成本很高，而且需要 iOS 11 以上系统支持。</p>
<p>第一套方案是使用了 WKBrowsingContextController 的 registerSchemeForCustomProtocol: 这个方法，这个方法的参数设置为 http 或 https 然后执行，后面这类 scheme 就能够被 NSURLProtocol 处理了，具体实现可以在<a href="https://github.com/Yeatse/NSURLProtocol-WebKitSupport" target="_blank" rel="external">这里</a>看到。</p>
<p>Android 通过系统提供的资源拦截Api即可实现加载拦截，拦截后根据请求的url识别资源类型，命中后设置对应的mimeType、encoding、fileStream即可。</p>
<h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><img src="/uploads/thinking-in-how-to-speed-up-app/4.png" alt=""><br>App 安装前的下载速度也直接影响到了用户从选择你的 App 到使用的体验，如果下载大小过大，用户没有耐心等待，可能就放弃了你的 App，4G5G 环境下超 200MB 会弹窗提示是否继续下载，严重影响转化率。</p>
<p>因此还对下载大小做了优化，将 __TEXT 字段迁移到自定义段，使得 iPhone X 以前机器的下载大小减少了1/3的大小，这招之所以对 iPhone X 以前机器管用的原因是因为先前机器是按照先加密再压缩，压缩率低，而之后机器改变了策略因此下载大小就会大幅减少。Michael Eisel 这篇博客<a href="https://eisel.me/app-size" target="_blank" rel="external">《One Quick Way to Drastically Reduce your iOS App’s Download Size》</a> 提出了这套方案，你可以立刻应用到自己应用中，提高老机器下载速度，效果立竿见影。</p>
<p>Michael Eisel 还用 Swift 包装了 <a href="https://github.com/simdjson/simdjson" target="_blank" rel="external">simdjson</a> 写了个库 <a href="https://github.com/michaeleisel/ZippyJSON" target="_blank" rel="external">ZippyJSONDecoder</a> 比系统自带 JSONDecoder 快三倍，很符合本篇“要更快”的主题对吧，人类对速度的追求是没有止境的，最近 YY 大神 ibireme 也在写 JSON 库 <a href="https://github.com/ibireme/yyjson" target="_blank" rel="external">YYJSON</a> 速度比 simdjson 还快。Michael 还写个了提速构建的自制链接器 <a href="https://github.com/michaeleisel/zld" target="_blank" rel="external">zld</a>，项目说明还描述了如何开发定制自己的链接器。还有主线程阻塞（ANR）检测的 swift 类 <a href="https://gist.github.com/michaeleisel/77b8efc9bedab1444dbb71a5915dbd15" target="_blank" rel="external">ANRChecker</a>，还有通过hook 方式记录系统错误日志的<a href="https://gist.github.com/michaeleisel/8eddd0082b4fd7f2bd118d97e79bf12e" target="_blank" rel="external">例子</a>展示如何通过截获自动布局错误，函数是 UIViewAlertForUnsatisfiableConstraints ，malloc 问题替换函数为 malloc_error_break 即可。Michael 的这些性能问题处理手段非常实用，真是个宝藏男孩。</p>
<p>通过每月新增激活量、浏览到新增激活转换率、下载到激活转换率、转换率受体积因素影响占比、每个用户获取成本，使用公式计算能够得到每月成本收益，把你们公司对应具体参数数值套到公式中，算出来后你会发现如果降低了50多MB，每月就会有非常大的收益。</p>
<p>对于 Android 来说，很多功能是可以放在云端按需下载使用，后面的方向是重云轻端，云端一体，打通云端链路。</p>
<p>下载和安装完成后，就要分析 App 开始启动时如何做优化了，我接下来跟你说说 Android 启动 so 库加载如何做监控和优化。</p>
<h2 id="Android-so-库加载优化"><a href="#Android-so-库加载优化" class="headerlink" title="Android so 库加载优化"></a>Android so 库加载优化</h2><h3 id="编译阶段-静态分析优化"><a href="#编译阶段-静态分析优化" class="headerlink" title="编译阶段-静态分析优化"></a>编译阶段-静态分析优化</h3><p>依托自动化构建平台，通过构建配置实现对源码模块的灵活配置，进行定制化编译。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-ffunction-sections -fdata-sections <span class="comment">// 实现按需加载</span></div><div class="line">-fvisibility=hidden -fvisibility-inlines-hidden <span class="comment">// 实现符号隐藏</span></div></pre></td></tr></table></figure>
<p>这样可以避免无用模块的引入，效果如下图：<br><img src="/uploads/thinking-in-how-to-speed-up-app/7.png" alt=""></p>
<h3 id="运行阶段-hook分析优化"><a href="#运行阶段-hook分析优化" class="headerlink" title="运行阶段-hook分析优化"></a>运行阶段-hook分析优化</h3><p>Android Linker 调用流程如下：<br><img src="/uploads/thinking-in-how-to-speed-up-app/5.png" alt=""><br>注意，find_library 加载成功后返回 soinfo 对象指针，然后调用其 call_constructors 来调用 so 的 init_array。call_constructors 调用 call_array，其内部循环调用 call_funtion 来访问 init_array 数组的调用。</p>
<p>高德Android小伙伴们基于 <a href="https://github.com/frida/frida-gum" target="_blank" rel="external">frida-gum</a> 的 hook 引擎开发了线下性能监控工具，可以 hook c++ 库，支持 macos、android、ios，针对 so 的全局构造时间和链接时间进行 hook，对关键 so 加载的关键节点耗时进行分析。dlopen 相关 hook 监控点如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">target_func_t</span> android_funcs_22[] = &#123;</div><div class="line">    &#123;<span class="string">"__dl_dlopen"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_dlopen&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZL12find_libraryPKciPK12android_dlextinfo"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_find_library&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZN6soinfo16CallConstructorsEv"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_soinfo_CallConstructors&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZN6soinfo9CallArrayEPKcPPFvvEjb"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_soinfo_CallArray&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">target_func_t</span> android_funcs_28[] = &#123;</div><div class="line">    &#123;<span class="string">"__dl_Z9do_dlopenPKciPK17android_dlextinfoPKv"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_do_dlopen_28&#125;,</div><div class="line">    &#123;<span class="string">"__dl_Z14find_librariesP19android_namespace"</span>&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZN6soinfo17call_constructorsEv"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_soinfo_CallConstructors&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZL10call_arrayIPFviPPcS1_EEvPKcPT_jbS5_"</span>, <span class="number">0</span>, (<span class="keyword">void</span> *)my_call_array_28&lt;constructor_func&gt;&#125;,</div><div class="line">    &#123;<span class="string">"__dl_ZN6soinfo10link_imageERK10LinkListIS"</span>&#125;,</div><div class="line">    &#123;<span class="string">"__dl_g_argc"</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</div><div class="line">    &#123;<span class="string">"__dl_g_argv"</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</div><div class="line">    &#123;<span class="string">"__dl_g_envp"</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>android 版本不同对应 hook 方法有所不同，要注意当 so 有其他外部链接依赖时，针对 dlopen 的监控数据，不只包括自身部分，也包括依赖的 so 部分。在这种情况下，so 加载顺序也会产生很大的影响。</p>
<p>JNI_OnLoad 的 hook 监控代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ABTOR_ANDROID</span></div><div class="line"><span class="function">jint <span class="title">my_JNI_ONLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> </span>&#123;</div><div class="line">    asl::HookEngine::HoolContext *ctx = asl::HookEngine::getHookContext();</div><div class="line"></div><div class="line">    <span class="keyword">uint64_t</span> start = PerfUtils::getTickTime();</div><div class="line">    jint res = asl::CastFuncPtr(my_JNI_OnLoad, ctx-&gt;org_func)(vm, reserved);</div><div class="line">    <span class="keyword">int</span> duration = (<span class="keyword">int</span>)(PerfUtils::getTickTime() - start);</div><div class="line"></div><div class="line">    LibLoaderMonitorImpl *monitor = (LibLoaderMonitorImpl*)LibLoaderMonitor::getInstance();</div><div class="line">    monitor-&gt;addOnloadInfo(ctx-&gt;user_data, duration);</div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
<p>如上代码所示，linker 的 dlopen 完成加载，然后调用 dlsym 来调用目标 so 的 JNI_OnLoad，完成 JNI 涉及的初始化操作。</p>
<p>加载 so 需要注意并行出现 loadLibrary0 锁的问题，这样会让多线程发生等锁现象。可以减少并发加载，但不能简单把整个加载过程放到串行任务里，这样耗时可能会更长，并且没法充分利用资源。比较好的做法是，将耗时少的串行起来同时并行耗时长的 so 加载。</p>
<p>至此完成了 so 的初始化和链接的监控。</p>
<p>说完 Android，那么 iOS 的加载是怎样的，如何优化呢？我接着跟你说。</p>
<h2 id="App-加载"><a href="#App-加载" class="headerlink" title="App 加载"></a>App 加载</h2><p>_dyld_start 之前做了什么，dyld_start 是谁调用的，通过查看<a href="https://opensource.apple.com/tarballs/xnu/" target="_blank" rel="external">xnu的源码</a>可以理出，当 App 点击后会通过__mac_execve 函数 fork 进程，加载解析 Mach-O 文件，调用 exec_activate_image() 开始激活 image 的过程。先根据 image 类型来选择 imgact，开始 load_machfile，这个过程会先解析 Mach-O，解析后依据其中的 LoadCommand 启动 dyld。最后使用 activate_exec_state() 处理结构信息，thread_setentrypoint() 设置 entry_point App的入口点。</p>
<p>_dyld_start 之后要少些动态库，因为链接耗时；少些 +load、C 的 constructor 函数和 C++ 静态对象，因为这些会在启动阶段执行，多了就会影响启动时间。因此，没有用的代码就需要定期清理和线上监控。通过元类中flag的方式进行监控然后定期清理。</p>
<h2 id="iOS-主线程方法调用时长检测"><a href="#iOS-主线程方法调用时长检测" class="headerlink" title="iOS 主线程方法调用时长检测"></a>iOS 主线程方法调用时长检测</h2><p>+load 方法时间统计，使用运行时 swizzling 的方式，将统计代码放到链接顺序的最前面即可。静态初始化函数在 DATA 的 mod_init_func 区，先把里面原始函数地址保存，前后加上自定义函数记录时间。</p>
<p>在 Linux上 有 strace 工具，还有库跟踪工具 ltrace，OSX 有包装了 dtrace 的 instruments 和 dtruss 工具，不过在某些场景需求下不好用。objc_msgSend 实际上会通过在类对象中查找选择器到函数的映射来重定向执行到实现函数。一旦它找到了目标函数，它就会简单地跳转到那里，而不必重新调整参数寄存器。这就是为什么我把它称为路由机制，而不是消息传递。Objective-C 的一个方法被调用时，堆栈和寄存器是为 objc_msgSend 调用配置的，objc_msgSend 路由执行。objc_msgSend 会在类对象中查找函数表对应定向到的函数，找到目标函数就跳转，参数寄存器不会重新调整。</p>
<p>因此可以在这里 hook 住做统一处理。hook objc_msgSend 还可以获取启动方法列表，用于二进制重排方案中所需要的 AppOrderFiles，不过  AppOrderFiles 还可以通过 Clang SanitizerCoverage 获得，具体可以看宝藏男孩 Michael Eisel 这个这篇博客《<a href="https://eisel.me/order" target="_blank" rel="external">Improving App Performance with Order Files</a>》 的介绍。</p>
<p>objc_msgSend 可以通过 fishhook 指定到你定义的 hook 方法中，也可以使用创建跳转 page 的方式来 hook。做法是先用 mmap 分配一个跳转的 page，这个内存后面会用来执行原函数，使用特殊指令集将CPU重定向到内存的任意位置。创建一个内联汇编函数用来放置跳转的地址，利用 C 编译器自动复制跳转 page 的结构，指向 hook 的函数，之前把指令复制到跳转 page 中。ARM64 是一个 RISC 架构，需要根据<a href="https://www.element14.com/community/servlet/JiveServlet/previewBody/41836-102-1-229511/ARM.Reference_Manual.pdf" target="_blank" rel="external">指令种类</a>检查分支指令。可以在 <a href="https://opensource.apple.com/source/objc4/objc4-647/runtime/Messengers.subproj/objc-msg-arm64.s" target="_blank" rel="external">_objc_msgSend</a> 里找到 b 指令的检查。相关代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ENTRY _objc_msgSend</div><div class="line">MESSENGER_START</div><div class="line"></div><div class="line">cmp x0, #<span class="number">0</span>          <span class="comment">// nil check and tagged pointer check</span></div><div class="line">b.le    LNilOrTagged        <span class="comment">//  (MSB tagged pointer looks negative)</span></div><div class="line">ldr x13, [x0]       <span class="comment">// x13 = isa</span></div><div class="line"><span class="keyword">and</span> x9, x13, #ISA_MASK  <span class="comment">// x9 = class</span></div></pre></td></tr></table></figure>
<p>检查通过就可以用这个指针读取偏移量，并修改指向跳转地址，跳转page完成，hook 函数就可以被调用了。</p>
<p>接下来看下 hook _objc_msgSend 的函数，这个我在以前博客《<a href="https://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/">深入剖析 iOS 性能优化</a>》写过，不过多赘述，只做点补充说明。从<a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallTraceCore.c" target="_blank" rel="external">这里的源码</a>可以看实现，其中的attribute((naked)) 表示无参数准备和栈初始化， asm 表示其后面是汇编代码，volatile 是让后面的指令避免被编译优化到缓存寄存器中和改变指令顺序，volatile 使其修饰变量被访问时都会在共享内存里重新读取，变量值变化时也能写到共享内存中，这样不同线程看到的变量都是一个值。如果你发现不加 volatile 也没有问题，你可以把编译优化选项调到更优试试。stp表示操作两个寄存器，中括号部分表示压栈存入sp偏移地址，!符号表合并了压栈指令。</p>
<p>save() 的作用是把传递参数寄存器入栈保存，call(b, value)用来跳到指定函数地址，call(blr, &amp;before_objc_msgSend) 是调用原 _objc_msgSend 之前指定执行函数，call(blr, orig_objc_msgSend) 是调用 objc_msgSend 函数，call(blr, &amp;after_objc_msgSend) 是调用原 _objc_msgSend 之后指定执行函数。before_objc_msgSend 和 after_objc_msgSend 分别记录时间，差值就是方法调用执行的时长。</p>
<p>调用之间通过 save() 保存参数，通过 load() 来读取参数。call 的第一个参数是blr，blr 是指跳转到寄存器地址后会返回，由于 blr 会改变 lr 寄存器X30的值，影响 ret 跳到原方法调用方地址，崩溃堆栈找方法调研栈也依赖 lr 在栈上记录的地址，所以需要在 call() 之前对 lr 进行保存，call() 都调用完后再进行恢复。跳转到hook函数，hook函数可以执行我们自定义的事情，完成后恢复CPU状态。</p>
<h2 id="进入主图后的优化"><a href="#进入主图后的优化" class="headerlink" title="进入主图后的优化"></a>进入主图后的优化</h2><p>进入主图后，用户就可以点击按钮进入不同功能了，是否能够快速响应按钮点击操作也是启动体验感知很重要的事情。按钮点击的两个事件 didTouchUp 和 didTouchDown 之间也会有延时，因此可以在 didTouchDown 时在主线程先 async 初始化下一个 VC，把初始化提前完成，这样做可以提高50ms-100ms的速度，甚至更多，具体收益依赖当前主线程繁忙情况和下一个页面 viewDidLoad 等初始化方法里的耗时，启动阶段主线程一定不会闲，即使点击后主线程阻塞，使用 async 也能保证下一个页面的初始化不会停。</p>
<h2 id="线程调度和任务编排"><a href="#线程调度和任务编排" class="headerlink" title="线程调度和任务编排"></a>线程调度和任务编排</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>对于任务编排有种打法，就是先把所有任务滞后，然后再看哪个是启动开始必须要加载的。效果立竿见影，很快就能看到最好的结果，后面就是反复斟酌，严格把关谁才是必要的启动任务了。</p>
<p>启动阶段的任务，先理出相关依赖关系，在框架中进行配置，有依赖的任务有序执行，无依赖独立任务可以在非密集任务执行期串行分组，组内并发执行。</p>
<p>这里需要注意的是Android 的 SharedPreferences 文件加载导致的 ContextImpl 锁竞争，一种解法是合并文件，不过后期维护成本会高，另一种是使用串行任务加载。你可能会疑惑，我没怎么用锁，那是不是就不会有锁等待的问题了。其实不然，比如在 iOS中，dispatch_once 里有 dispatch_atomic_barrier 方法，此方法就有锁的作用，因此锁其实存在各个 API 之下，如不用工具去做检查，有时还真不容易发现这些问题。</p>
<p>有 IO 操作的任务除了锁等待问题，还有效率方面也需要特别注意，比如 iOS 的 Fundation 库使用的是 NSData writeToFile:atomically: 方法，此方法会调用系统提供的 fsync 函数将文件描述符 fd 里修改的数据强写到磁盘里，fsync 相比较与 fcntl 效率高但写入物理磁盘会有等待，可能会在系统异常时出现写入顺序错乱的情况。系统提供的 write() 和 mmap() 函数都会用到内核页缓存，是否写入磁盘不由调用返回是否成功决定，另外 c 的标准库的读写 API fread 和 fwrite 还会在系统内核页缓存同步对应由保存了缓冲区基地址的 FILE 结构体的内部缓冲区。因此启动阶段 IO 操作方法需要综合做效率、准确和重要性三方面因素的权衡考虑，再进行有 IO 操作的任务编排。</p>
<p>针对初始化耗时的库，比如埋点库，可以延后初始化，先将所需要的数据存储到内存中，待到埋点库初始化时再进行记录。对一些主图上业务网络可以延后请求，比如闪屏、消息盒子、主图天气、限行控件数据请求、开放图层数据、Wi-Fi信息上报请求等。</p>
<h3 id="多线程共享数据的问题"><a href="#多线程共享数据的问题" class="headerlink" title="多线程共享数据的问题"></a>多线程共享数据的问题</h3><p>并发任务编排缺少一个统一的异步编程模型，并发通信共享数据方式的手段，比如代理和通知会让处理到处飞，闭包这种匿名函数排查问题不方便，而且回调中套回调前期设计后期维护和理解很困难，调试、性能测试也乱。这些通过回调来处理异步，不光复杂难控，还有静态条件、依赖关系、执行顺序这样的额外复杂度，为了解决这些额外复杂度，还需要使用更多的复杂机制来保证线程安全，比如使用低效的 mutex、超高复杂度的读写锁、双重检查锁定、底层原子操作或信号量的方式来保护数据，需要保证数据是正确锁住的，不然会有内存问题，锁粒度要定还要注意避免死锁。</p>
<p>并发线程通信一般都会使用 libdispatch（GCD）这样的共享数据方式来处理，也就异步再回调的方式。libdispatch 的 async 策略是把任务的 block 放到队列链表，使用时会在底层的线程池里找可用线程，有就直接用，没有就新建一个线程（参看 <a href="https://github.com/apple/swift-corelibs-libdispatch" target="_blank" rel="external">libdispatch</a> 源码，监控线程池 <a href="https://github.com/apple/swift-corelibs-libdispatch/blob/main/src/event/workqueue.c" target="_blank" rel="external">workqueue.c</a>，队列调度 <a href="https://github.com/apple/swift-corelibs-libdispatch/blob/main/src/queue.c" target="_blank" rel="external">queue.c</a>），使用这样的策略来减少线程创建。当并发任务多时，比如启动期间，即使线程没爆，但 CPU 在各个线程切换处理任务时也是会有时间开销的，每次切换线程，CPU 都需要执行调度程序增加调度成本和增加 CPU 使用率，并且还容易出现多线程竞争问题。单次线程切换看起来不长，但整个启动，切换频率高的话，整体时间就会增大。</p>
<p>多线程的问题以及处理方式，带来了开发和排查问题的复杂性，以及出现问题机率的提高，资源和功能云化也有类似的问题，云化和本地的耦合依赖、云化之间的关系处理、版本兼容问题会带来更复杂的开发以及测试挑战，还有问题排查的复杂度。这些都需要去做权衡，对基础建设方案提出了更高的要求，对容错回滚的响应速度也有更高的要求。</p>
<p>这里有个 <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html" target="_blank" rel="external">book</a> 专门来说并行编程难的，并告诉你该怎么做。<a href="https://gist.github.com/tclementdev/6af616354912b0347cdf6db159c37057" target="_blank" rel="external">这里有篇文章</a> 列出了苹果公司 libdispatch 的维护者 Pierre Habouzit 关于 libdispatch 的讨论邮件。</p>
<p>说了一堆共享数据方式的问题，没有体感，下面我说个最近碰到的多线程问题，你也看看排查有多费劲。</p>
<h3 id="一个具体多线程问题排查思路"><a href="#一个具体多线程问题排查思路" class="headerlink" title="一个具体多线程问题排查思路"></a>一个具体多线程问题排查思路</h3><p>问题是工程引入一个系统库，暂叫 A 库，出现的问题现象是 CoreMotion 不回调，网络请求无法执行，除了全局并发队列会 pending block 外主线程和其它队列工作正常。</p>
<p>第一阶段，排查思路看是否跟我们工程相关，首先看是不是各个系统都有此问题，发现 iOS14 和 iOS13 都有问题。然后把A库放到一个纯净 Demo 工程中，发现没有出问题了。基于上面两种情况，推测只有将A库引入我们工程才会出现问题。在纯净 Demo 工程中，A库使用时 CPU 会占用60%-80%，集成到我们工程后涨到100%，所以下个阶段排查方向就是性能。</p>
<p>第二阶段的打法是看是否是由性能引起的问题。先在纯净工程中创建大量线程，直到线程打满，然后进行大量浮点运算使 CPU 到100%，但是没法复现，任务通过 libdispatch 到全局并发队列能正常工作。</p>
<p>怎么在 Demo 里看到出线程已爆满了呢？</p>
<p>libdispatch 可以使用线程数是有上限的，在 libdispatch 的<a href="https://opensource.apple.com/tarballs/libdispatch/" target="_blank" rel="external">源码</a>里可以看到 libdispatch 的队列初始化时使用 pthread 线程池相关代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></div><div class="line">_dispatch_root_queue_init_pthread_pool(<span class="keyword">dispatch_queue_global_t</span> dq,</div><div class="line">        <span class="keyword">int</span> pool_size, <span class="keyword">dispatch_priority_t</span> pri)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">dispatch_pthread_root_queue_context_t</span> pqc = dq-&gt;do_ctxt;</div><div class="line">    <span class="keyword">int</span> thread_pool_size = DISPATCH_WORKQ_MAX_PTHREAD_COUNT;</div><div class="line">    <span class="keyword">if</span> (!(pri &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT)) &#123;</div><div class="line">        thread_pool_size = (<span class="keyword">int32_t</span>)dispatch_hw_config(active_cpus);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (pool_size &amp;&amp; pool_size &lt; thread_pool_size) thread_pool_size = pool_size;</div><div class="line">    ... <span class="comment">// 省略不相关代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面代码所示，dispatch_hw_config 会用 dispatch_source 来监控逻辑 CPU、物理 CPU、激活 CPU 的情况计算出线程池最大线程数量，如果当前状态是 DISPATCH_PRIORITY_FLAG_OVERCOMMIT，也就是会出现 overcommit 队列时，线程池最大线程数就按照 DISPATCH_WORKQ_MAX_PTHREAD_COUNT 这个宏定义的数量来，这个宏对应的值是255。因此通过查看是否出现 overcommit 队列可以看出线程池是否已满。</p>
<p>什么时候 libdispatch 会创建一个新线程？</p>
<p>当 libdispatch 要执行队列里 block 时会去检查是否有可用的线程，发现有可用线程时，在可用线程去执行 block，如果没有，通过 pthread_create 新建一个线程，在上面执行，函数关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span></div><div class="line">_dispatch_root_queue_poke_slow(<span class="keyword">dispatch_queue_global_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 如果状态是overcommit，那么就继续添加到pending</span></div><div class="line">    <span class="keyword">bool</span> overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</div><div class="line">    <span class="keyword">if</span> (overcommit) &#123;</div><div class="line">        os_atomic_add2o(dq, dgq_pending, remaining, relaxed);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!os_atomic_cmpxchg2o(dq, dgq_pending, <span class="number">0</span>, remaining, relaxed)) &#123;</div><div class="line">            _dispatch_root_queue_debug(<span class="string">"worker thread request still pending for "</span></div><div class="line">                    <span class="string">"global queue: %p"</span>, dq);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">    t_count = os_atomic_load2o(dq, dgq_thread_pool_size, ordered);</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        can_request = t_count &lt; <span class="built_in">floor</span> ? <span class="number">0</span> : t_count - <span class="built_in">floor</span>;</div><div class="line">        <span class="comment">// 是否有可用</span></div><div class="line">        <span class="keyword">if</span> (remaining &gt; can_request) &#123;</div><div class="line">            _dispatch_root_queue_debug(<span class="string">"pthread pool reducing request from %d to %d"</span>,</div><div class="line">                    remaining, can_request);</div><div class="line">            os_atomic_sub2o(dq, dgq_pending, remaining - can_request, relaxed);</div><div class="line">            remaining = can_request;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 线程满</span></div><div class="line">        <span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</div><div class="line">            _dispatch_root_queue_debug(<span class="string">"pthread pool is full for root queue: "</span></div><div class="line">                    <span class="string">"%p"</span>, dq);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (!os_atomic_cmpxchgvw2o(dq, dgq_thread_pool_size, t_count,</div><div class="line">            t_count - remaining, &amp;t_count, acquire));</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        _dispatch_retain(dq); <span class="comment">// 在 _dispatch_worker_thread 里取任务并执行</span></div><div class="line">        <span class="keyword">while</span> ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</div><div class="line">            <span class="keyword">if</span> (r != EAGAIN) &#123;</div><div class="line">                (<span class="keyword">void</span>)dispatch_assume_zero(r);</div><div class="line">            &#125;</div><div class="line">            _dispatch_temporary_resource_shortage();</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">while</span> (--remaining);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面代码所示，can_request 表示可用线程数，通过当前最大可用线程数减去已用线程数获得，赋给 remaining后，用来判断线程是否满和控制线程创建。dispatch_worker_thread 会取任务并执行。</p>
<p>当 libdispatch 使用的线程池中线程过多，并且有 pending 标记，当等待超时，也就是 libdispatch 里 DISPATCH_CONTENTION_USLEEP_MAX 宏定义的时间后，也会触发创建一个新的待处理线程。libdispatch 对应函数关键代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span></div><div class="line">__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(<span class="keyword">dispatch_queue_global_t</span> dq,</div><div class="line">        <span class="keyword">int</span> (*predicate)(<span class="keyword">dispatch_queue_global_t</span> dq))</div><div class="line">&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">bool</span> pending = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">if</span> (!pending) &#123;</div><div class="line">            <span class="comment">// 添加pending标记</span></div><div class="line">            (<span class="keyword">void</span>)os_atomic_inc2o(dq, dgq_pending, relaxed);</div><div class="line">            pending = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        _dispatch_contention_usleep(sleep_time);</div><div class="line">        ...</div><div class="line">        sleep_time *= <span class="number">2</span>;</div><div class="line">    &#125; <span class="keyword">while</span> (sleep_time &lt; DISPATCH_CONTENTION_USLEEP_MAX);</div><div class="line">    ...</div><div class="line">    <span class="keyword">if</span> (pending) &#123;</div><div class="line">        (<span class="keyword">void</span>)os_atomic_dec2o(dq, dgq_pending, relaxed);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (status == DISPATCH_ROOT_QUEUE_DRAIN_WAIT) &#123;</div><div class="line">        _dispatch_root_queue_poke(dq, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 创建新线程</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> status == DISPATCH_ROOT_QUEUE_DRAIN_READY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上所示，在创建新的待处理线程后，会退出当前线程，负载没了就会去用新建的线程。</p>
<p>接下来使用 Instruments 进行分析 Trace 文件，发现启动阶段立刻开始使用A库的话，CPU 会突然上升，如果使用 A 库稍晚些，CPU 使用率就是稳定正常的。这说明在第一个阶段性能相关结论只是偶现情况才会出现，出问题时，并没有出现系统资源紧张的情况，可以得出并不是性能问题的结论。那么下一个阶段只能从A库的使用和排查我们工程其它功能的问题。</p>
<p>第三个阶段的思路是使用功能二分排查法，先排出 A 库使用问题，做法是在使用最简单的 A 库初始化一个页面在首屏也会复现问题。</p>
<p>我们的功能主要分为渲染、引擎、网络库、基础功能、业务几个部分。将渲染、引擎、网络库拉出来建个Demo，发现这个 Demo 不会出现问题。那么有问题的就可能在基础功能、业务上。</p>
<p>先去掉的功能模块有 CoreMotion、网络、日志模块、定时任务（埋点上传），依然复现。接下来去掉队列里的 libdispatch 任务，队列里的任务主要是由 Operation 和 libdispatch 两种方式放入。其中 Operation 最后是使用 libdispatch 将任务 block 放入队列，期间会做优先级和并发数的判断。对于 libdispatch 可以 Hook 住可以把任务 block 放到队列的 libdispatch 方法，有 dispatch_async、dispatch_after、dispatch_barrier_async、dispatch_apply 这些方法。任务直接返回，还是有问题。</p>
<p>推测验证基础能力和业务对出现问题队列有影响，instruments 只能分析线程，无法分析队列，因此需要写工具分析队列情况。</p>
<p>接下来进入第四个阶段。</p>
<p>先 hook 时截获任务 block 使用的 libdispatch 方法、执行队列名、优先级、做唯一标识的入队时间、当前队列的任务数、还有执行堆栈的信息。通过截获的内容按照时间线看，当出现全局并发队列 pending block 数量堆积时，新的使用 libdispatch 加入的部分任务可以得到执行，也有没执行的，都执行了也会有问题。</p>
<p>然后去掉 Operation 的任务：通过日志还能发现 Operation 调用 libdispatch 的任务直接 hook libdispatch 的方法是获取不到的，可能是 Operation 调用方法有变化。另外在无法执行任务的线程上新建的 libdispatch 任务也无法执行，无法执行的 Operation 任务达到所设置的 maxConcurrentOperationCount，对应的 OperationQueue 就会在 Operation 的队列里 pending。由此可以推断出，在局并发队列 pending 的 block 包含了直接使用 libdispatch 的和 Operation 的任务，pending 的任务。因此还需要 hook 住 Operation，过滤掉所有添加到 Operation Queue 的任务，但结果还是复现问题。</p>
<p>此时很崩溃，本来做好了一个一个下掉功能的准备（成本高），这时，有同学发现前阶段两个不对的结论。</p>
<p>这个阶段定为第五阶段。</p>
<p>第一个不对的结论是经 QA 同学长时间多轮测试，只在14.2及以上系统版本有问题，由于只有这个版本才开始有此问题，推断可能是系统 bug；第二个不对的是只有渲染、引擎、网络库的 Demo 再次检查，可复现问题，因此可以针对这个 Demo 进行进一步二分排查。</p>
<p>于是，咱们针对两个先前错误结论，再次出发，同步进行验证。对 Demo 排除了网络库依然复现，后排除引擎还是复现，同时使用了自己的示例工程在iOS14.2上复现了问题，和第一阶段纯净Demo的区别是往全局并发队列里方式，官方 Demo 是 Operation，我们的是 libdispatch。</p>
<p>因此得出结论是苹果系统升级问题，原因可能在 OperationQueue，问题重现后，不再运行其中的 operation。14.3beta 版还没有解决。五个阶段总结如下图所示：</p>
<p><img src="/uploads/thinking-in-how-to-speed-up-app/13.png" alt=""></p>
<p>那么看下 Operation 实现，分析下系统 bug 原因。</p>
<p><a href="https://github.com/apportable/Foundation" target="_blank" rel="external">ApportableFoundation</a> 里有Operation的开源实现 <a href="https://github.com/apportable/Foundation/blob/master/System/Foundation/src/NSOperation.m" target="_blank" rel="external">NSOperation.m</a>，相比较 <a href="http://www.gnustep.org/" target="_blank" rel="external">GNUstep</a> 和 <a href="http://www.cocotron.org/" target="_blank" rel="external">Cocotron</a> 更完善，可以看到 Operation 如何在 _schedulerRun 函数里通过 libdispatch 的 async 方法将 operation 的任务放到队列执行。</p>
<p><a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="external">swift源码</a>里的fundation也有实现 <a href="https://github.com/apple/swift-corelibs-foundation/blob/main/Sources/Foundation/Operation.swift" target="_blank" rel="external">Operation</a>，我们看看 _schedule 函数的关键代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> _schedule<span class="params">()</span></span> &#123;</div><div class="line">    ...</div><div class="line">    <span class="comment">// 按优先级顺序执行</span></div><div class="line">    <span class="keyword">for</span> prio <span class="keyword">in</span> <span class="type">Operation</span>.<span class="type">QueuePriority</span>.priorities &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> operation = op?.takeUnretainedValue() &#123;</div><div class="line">            ...</div><div class="line">            <span class="keyword">let</span> next = operation.__nextPriorityOperation</div><div class="line">            ...</div><div class="line">            <span class="keyword">if</span> <span class="type">Operation</span>.__NSOperationState.enqueued == operation._state &amp;&amp; operation._fetchCachedIsReady(&amp;retest) &#123;</div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> previous = prev?.takeUnretainedValue() &#123;</div><div class="line">                    previous.__nextPriorityOperation = next</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    _setFirstPriorityOperation(prio, next)</div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                <span class="keyword">if</span> __mainQ &#123;</div><div class="line">                    queue = <span class="type">DispatchQueue</span>.main</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    queue = __dispatch_queue ?? _synthesizeBackingQueue()</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> <span class="keyword">let</span> schedule = operation.__schedule &#123;</div><div class="line">                    <span class="keyword">if</span> operation <span class="keyword">is</span> _BarrierOperation &#123;</div><div class="line">                        queue.async(flags: .barrier, execute: &#123;</div><div class="line">                            schedule.perform()</div><div class="line">                        &#125;)</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        queue.async(execute: schedule)</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                op = next</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                ... <span class="comment">// 添加</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码可见，可以看到 _schedule 函数根据 Operation.QueuePriority.priorities 优先级数组顺序，从最高 barrier 开始到 veryHigh、high、normal、low 到最低的 veryLow，根据 operation 属性设置决定 libdispatch 的 queue 是什么类型的，最后通过 async 函数分配到对应的队列上执行。</p>
<p>查看 operation 代码更新情况，最新 operation 提交修复了一个问题，commit <a href="https://github.com/apple/swift-corelibs-foundation/commit/9f44ed353c77a438d6f4ba879b2b388210e2107f" target="_blank" rel="external">在这</a>，根据修复问题的描述来看，和 A 库引入导致队列不可添加 OperationQueue 的情况非常类似。修复的地方可以看下图：<br><img src="/uploads/thinking-in-how-to-speed-up-app/8.png" alt=""></p>
<p>如图所示，在先前 _schedule 函数里使用 nextOperation 而不用 nextPriorityOperation 会导致主操作列表里的不同优先级操作列表交叉连接，可能会在执行后面操作时被挂起，而 A 库里的 OperationQueue 都是高优的，如果有其它优先级的 OperationQueue 加进来就会出现挂起的问题。</p>
<p>从提交记录看，19年6月12日的那次提交变更了很多代码逻辑，描述上看是为了更接近 objc 的实现，changePriority 函数就是那个时候加进去的。提交的 commit 如下图所示：<br><img src="/uploads/thinking-in-how-to-speed-up-app/9.png" alt=""></p>
<p>怀疑（只是怀疑，苹果官方并没有说）可能是在 iOS14 引入 swift 版的 Operation，因此这个 Operation 针对 objc 调用做了适配。之所以14.2之前 Operation 重构后的 bug 没有引起问题，可能是当时 A 库的 Queue 优先级还没调高，14.2版本A库的 Queue 优先级开始调高了，所以出现了优先级交叉挂起的情况。</p>
<p>从这次排查可以发现，目前对于并发的监测还是非常复杂的。那么并发问题在 iOS 的将来会得到解决吗？</p>
<h3 id="多线程并行计算模型"><a href="#多线程并行计算模型" class="headerlink" title="多线程并行计算模型"></a>多线程并行计算模型</h3><p>既然共享数据方式问题多，那还有其它选择吗？</p>
<p>实际上在服务端大量使用着 Actor 这样的并行计算模型，在并行世界里，一切都是 actor，actor 就像一个容器，会有自己的状态、行为、串行队列的消息邮箱。actor 之间使用消息来通信，会把消息发到接受消息 actor 的消息邮箱里，消息盒子可并行接受消息，消息的处理是依次进行，当前处理完才处理下一个，消息邮箱这套机制就好像 actor 们的大管家，让 actor 之间的沟通井然有序。</p>
<p>有谁是在使用 actor 模型呢？</p>
<p>actor 历史悠久，<a href="https://www.erlang.org/" target="_blank" rel="external">Erlang</a>（<a href="http://erlang.org/download/armstrong_thesis_2003.pdf" target="_blank" rel="external">Elang设计论文</a>），<a href="http://akka.io/" target="_blank" rel="external">Akka</a>（<a href="https://www.scala-lang.org/" target="_blank" rel="external">Scala</a> 编写的 <a href="http://doc.akka.io/docs/akka/current/scala/actors.html" target="_blank" rel="external">Akka actor</a> 系统，Akka 使用多，相对成熟）、Go（使用的 goroutine，基于 <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank" rel="external">CSP</a> 构建）都是基于 actor 模型实现数据隔离。</p>
<p><a href="https://forums.swift.org/t/swift-concurrency-roadmap/41611" target="_blank" rel="external">Swift并发路线图</a>也预示着 Swift 要加入 actor，Chris Lattner 也希望 Swift 能够在多核机器，还有大型服务集群能够得到方便的使用，分布式硬件的发展趋势必定是多核，去共享内存的硬件的，因为共享内存的编程不光复杂而且原子性访问比非原子性要慢近百倍。提案中设计到 actor 的设计是把 actor 设计成一种特殊类，让这个类有引用语义，能形成 map，可以 weak 或 unowned 引用。actor 类中包含一些只有 actor 才有的方法，这些方法提供 actor 编程模型所需安全性。但 actor 类不能继承自非 actor 类，因为这样 actor 状态可能会有机会以不安全的方式泄露。actor 和它的函数和属性之间是静态关系，这样可以通过编译方式避免数据竞争，对数据隔离，如果不是安全访问 actor 属性的上下文，编译器可以处理切换到那个上下文中。对于 actor 隔离会借鉴<a href="https://github.com/apple/swift-evolution/blob/main/proposals/0176-enforce-exclusive-access-to-memory.md" target="_blank" rel="external">强制执行对内存的独占访问</a>提案的思想，比如局部变量、inout参数、结构体属性编译器可以分析变量的所有访问，有冲突就可以报错，类属性和全局变量要在运行时可以跟踪在进行的访问，有冲突报错。而全局内存还是没法避免数据竞争，这个需要增加一个全局 actor 保护。</p>
<p>按 actor 模型对任务之间通讯重新调整，不用回调代理等手段，将发送消息放到消息邮箱里进行类似 RxSwift 那样 next 的方式一个一个串行传递。说到 RxSwift，那 RxSwift 和 Combine 这样的框架能替代 actor 吗？</p>
<p>对这些响应式框架来说解决线程通信只是其中很小的一部分，其还是会面临闭包、调试和维护复杂的问题，而且还要使用响应式编程范式，显然还是有些重了，除非你已经习惯了响应式编程。</p>
<p>任务都按 actor 模型方式来写，还能够做到功能之间的解耦，如果是服务器应用，actor 可以布到不同的进程甚至是不同机器上。</p>
<p>actor 中消息邮件在同一时间只能处理一个消息，这样等待返回一个值的方式，需要暂停，内部有返回再继续执行，这要怎么实现呢？</p>
<p>答案是使用 Coroutine</p>
<p>在 Swift 并发路线提案里还提到了基于 coroutine 的 async/await 语法，这种语法风格已经被广泛采纳，比如Python、Dart、JavaScript 都有实现，这样能够写出简洁好维护的并发代码。</p>
<p>上述只是提案，最快也需要两个版本的等待，那么语言上的支持还没有来，怎么能提前享用 coroutine 呢？</p>
<p><img src="/uploads/thinking-in-how-to-speed-up-app/14.png" alt=""></p>
<p>处理暂停恢复操作，可以使用 context 处理函数 setjmp 和 longjmp，但 setjmp 和 longjmp 较难实现临时切换到不同的执行路径，然后恢复到停止执行的地方，所以服务器用一般都会使用 ucontext 来实现，gnu 的举的例子 <a href="https://www.gnu.org/software/libc/manual/html_mono/libc.html#System-V-contexts" target="_blank" rel="external">GNU C Library: Complete Context Control</a>，这个例子在于创建 context 堆栈，swapcontext 来保存 context，这样可以在其它地方能执行回到原来的地方。创建 context 堆栈代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">uc[<span class="number">1</span>].uc_link = &amp;uc[<span class="number">0</span>];</div><div class="line">uc[<span class="number">1</span>].uc_stack.ss_sp = st1;</div><div class="line">uc[<span class="number">1</span>].uc_stack.ss_size = <span class="keyword">sizeof</span> st1;</div><div class="line">makecontext (&amp;uc[<span class="number">1</span>], (<span class="keyword">void</span> (*) (<span class="keyword">void</span>)) f, <span class="number">1</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure>
<p>上面代码中 uc_link 表示的是主 context。保存 context 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">swapcontext (&amp;uc[n], &amp;uc[<span class="number">3</span> - n]);</div></pre></td></tr></table></figure>
<p>但是在 Xcode 里一试，出现错误提示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">implicit declaration of function &apos;swapcontext&apos; is invalid in c99</div></pre></td></tr></table></figure>
<p>原来最新的 POSXI 标准已经没有这个函数了，IEEE Std 1003.1-2001 / Cor 2-2004，应用了项目XBD/TC2/D6/28，标注 getcontext()、makecontext()、setcontext()和swapcontext() 函数过时了。在 POSIX  2004第743页说明了原因，大概意思就是建议使用 pthread 这种系统编程上，后来的 Rust 和 Swift coroutine 的提案里都是使用的系统编程来实现 coroutine，长期看系统编程实现 coroutine 肯定是趋势。那么在 swift 升级之前还有办法在 iOS 用 ucontext 这种轻量级的 coroutine 吗？</p>
<p>其实也是有的，可以考虑临时过渡一下。具体可以看看 ucontext 的汇编实现，重新在自己工程里实现出来就可以了。<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/getcontext.S.html" target="_blank" rel="external">getcontext</a>、<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/setcontext.S.html" target="_blank" rel="external">setcontext</a>、<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/makecontext.c.html" target="_blank" rel="external">makecontext</a>、<a href="https://code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/x86_64/swapcontext.S.html" target="_blank" rel="external">swapcontext</a> 的在 linux 系统代码里能看到。ucontext_t 结构体里的 uc_stack 会记录 context 使用的栈。getcontext() 是把各个寄存器保存到内存结构体里，setcontext() 是把来自 makecontext() 和 getcontext() 的各寄存器恢复到当前 context 的寄存器里。switchcontext() 合并了 getcontext() 和 setcontext()。</p>
<p>ucontext_t 的结构体设计如下：<br><img src="/uploads/thinking-in-how-to-speed-up-app/6.png" alt=""></p>
<p>如上图所示，ucontext_t 还包含了一个更高层次的 context 封装 uc_mcontext，uc_mcontext 会保存调用线程的寄存器。上图中 eax 是函数入参地址，寄存器值入栈操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">movl    $<span class="number">0</span>, oEAX(%eax)</div><div class="line">movl    %ecx, oECX(%eax)</div><div class="line">movl    %edx, oEDX(%eax)</div><div class="line">movl    %edi, oEDI(%eax)</div><div class="line">movl    %esi, oESI(%eax)</div><div class="line">movl    %ebp, oEBP(%eax)</div></pre></td></tr></table></figure>
<p>以上代码中 oECX、oEDX 等表示相应寄存器在内存结构体里的位置。esp 指向返回地址值，由 eip 字段记录，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movl    (%esp), %ecx</div><div class="line">movl    %ecx, oEIP(%eax)</div></pre></td></tr></table></figure>
<p>edx 是 getcontext() 的栈寄存器会记录 ucontext_t.uc_stack.ss_sp 栈顶的值，oSS_SIZE 是栈大小，通过指令addl 可以找到栈底。makecontext() 会根据 ecx 里的参数去设置栈，setcontext() 是 getcontext 的逆操作，设置当前 context，栈顶在 esp 寄存器。</p>
<p>轻量级的 coroutine 实现了，下面咱们可以通过 Swift <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md" target="_blank" rel="external">async/await提案</a>（已加了编号0296，表示核心团队已经认可，上线可期）看下系统编程的 coroutine 是怎么实现的。Swift async/await 提案中的思路是让开发者编写异步操作逻辑，编译器用来转换和生成所需的隐式操作闭包。可以看作是个语法糖，并像其它实现那样会改变完成处理程序被调用的队列。工作原理类似 try，也不需要捕获 self 的转义闭包。挂起会中断原子性，比如一个串行队列中任务要挂起，让其它任务在一个串行队列中交错运行，因此异步函数最好是不阻塞线程。将异步函数当作一般函数调用，这样的调用会暂时离开线程，等待当前线程任务完成再从它离开的地方恢复执行这个函数，并保证是在先前的actor里执行完成。</p>
<h2 id="启动性能分析工具"><a href="#启动性能分析工具" class="headerlink" title="启动性能分析工具"></a>启动性能分析工具</h2><h3 id="iOS-官方工具"><a href="#iOS-官方工具" class="headerlink" title="iOS 官方工具"></a>iOS 官方工具</h3><p>Instruments 中 Time Profiles 中的 Profile 可以方便的分析模块中每个方法的耗时。Time Profiles 中的 Samples 分析将更加准确的显示出 App 启动后每一个 CPU 核心在一个时间片内所执行的代码。如果在模块开发中有以下的需求，可以考虑使用 Samples 分析：</p>
<ol>
<li>希望更精确的分析某个方法具体执行代码的耗时</li>
<li>想知道一个方法到另一个方法的耗时情况（跨方法耗时分析）</li>
</ol>
<p>MetricKit 2.0 开始加强了诊断特性，通过收集调用栈信息能够方便我们来进行问题的诊断，通过 didReceive 回调 MXMetricPayload 性能数据，可包含 MXSignpostMetric 自定义采集数据，甚至是你捕获不到的崩溃信号的系统强杀崩溃信息传到自己服务器进行分析和报警。</p>
<h3 id="如何在-iOS-真机和模拟器上实现自动化性能分析"><a href="#如何在-iOS-真机和模拟器上实现自动化性能分析" class="headerlink" title="如何在 iOS 真机和模拟器上实现自动化性能分析"></a>如何在 iOS 真机和模拟器上实现自动化性能分析</h3><p>苹果有个 usbmux 协议会给自己 macOS 程序和设备进行通信，场景有备份 iPhone 还有真机调试。macOS 对应的是/System/Library/PrivateFrameworks/MobileDevice.framework/Versions/A/Resources/ 下的 usbmuxd 程序，usbmuxd 是 IPC socket 和 TCP socket 用来进行进程间通信，<a href="https://github.com/libimobiledevice/usbmuxd" target="_blank" rel="external">这里</a>有他的一个开源实现。对于在手机端是 lockdown 来起服务。因此利用 usbmuxd 的协议，就可以自建和设备通信的应用比如 lookin，实现方式可以参考这个 <a href="https://github.com/rsms/peertalk" target="_blank" rel="external">demo</a>。使用 usbmux 协议的 <a href="https://github.com/libimobiledevice/libimobiledevice" target="_blank" rel="external">libimobiledevice</a>（相当于 Android 的 adb）提供了更多能力，可以获取设备的信息、搭载 <a href="https://github.com/libimobiledevice/ifuse" target="_blank" rel="external">ifuse</a> 访问设备文件系统（没越狱可访问照片媒体、沙盒、日志）、与调试服务器连接远程调试。无侵入的库还有 <a href="https://www.gamebench.net/" target="_blank" rel="external">gamebench</a> 也用到了 libimobiledevice。</p>
<p>instruments 可以导出 .trace 文件，以前只能用 instruments 打开，Xcode12 提供了 xctrace 命令行工具可以导出可分析的数据。Xcode12 之前的时候是能使用 <a href="https://github.com/Qusic/TraceUtility" target="_blank" rel="external">TraceUtility</a> 这个库，TraceUtility 的做法是链上 Xcode 里 instruments 用的那些库，比如 DVTFoundation 和 InstrumentsKit 等，调用对应的方法去获取.trace文件。使用 libimobiledevice 能构造操作 instruments 的应用，将 instruments 的能力自动化。</p>
<p><a href="https://perfdog.qq.com/" target="_blank" rel="external">perfdog</a>就是使用了libimobiledevice调用了instruments的接口（见<a href="https://recon.cx/2018/montreal/schedule/system/event_attachments/attachments/000/000/043/original/RECON-MTL-2018-Discovering_the_iOS_Instruments_Server.pdf" target="_blank" rel="external">接口研究</a>，<a href="https://github.com/troybowman/ios_instruments_client" target="_blank" rel="external">实现代码</a>）来实现instruments的一些功能，并进行了扩展定制，无侵入的构建本地性能监控并集成到自动测试中出数据，减少人工成本。无侵入的另一个好处就是可以方便用同一套标准看到其他APP的表现情况。</p>
<p>要到具体场景去跑 case 还需要流程自动化。Appium 使用的是 Facebook 开发的一套基于 W3C 标准交互协议 <a href="https://w3c.github.io/webdriver/" target="_blank" rel="external">WebDriver</a> 的库 <a href="https://github.com/facebookarchive/WebDriverAgent" target="_blank" rel="external">WebDriverAgent</a>，python 版可以看<a href="https://github.com/openatx/facebook-wda" target="_blank" rel="external">这个</a>，不过后来 Facebook 开发了新的一套命令行工具<a href="https://github.com/facebook/idb/" target="_blank" rel="external">idb(iOS Development Bridge)</a>，归档了 WebDriverAgent。idb 可以对 iOS 模拟器和设备跑自动化测试，idb 主要有两个基于 macOS 系统库 CoreSimulator.framework、MobileDevice.framework，包装的 FBSimulatorControl 和 FBDeviceControl 库。FBSimulatorControl 包含了 iOS 模拟器的所有功能，Xcode 和 simctl 都是用的 CoreSimulator，自动化中输入事件是逆向了 iOS 模拟器 Indigo 服务的协议，Indigo 是模拟器通过 mach IPC 通道 mach_msg_send 接受触摸等输入事件的协议。破解后就可以模拟输入事件了。MobileDevice.framework 也是 macOS 的私有库，macOS 上的 Finder、Xcode、Photos 这些会使用 iOS 设备的应用都是用了 MobileDevice，文件读写用的是包装了 AMDServiceConnection 协议的 AFC 文件操作 API，idb 的 instruments 相关功能是在<a href="https://github.com/facebook/idb/blob/master/FBDeviceControl/Management/FBInstrumentsClient.h" target="_blank" rel="external">这里</a>实现了 DTXConnectionServices 服务协议。libmobiledevice 可以看作是重新实现了 MobileDevice.framework。<a href="https://github.com/iOSForensics/pymobiledevice" target="_blank" rel="external">pymobiledevice</a>、<a href="https://github.com/mountainstorm/MobileDevice" target="_blank" rel="external">MobileDevice</a>、C 编写的 <a href="https://github.com/samdmarshall/SDMMobileDevice/" target="_blank" rel="external">SDMMobileDevice</a>，还有Objective-C 编写的 <a href="https://github.com/cipi1965/MobileDeviceAccess" target="_blank" rel="external">MobileDeviceAccess</a>，这些库也是用的 MobileDevice.framework。</p>
<p>总结如下图所示：</p>
<p><img src="/uploads/thinking-in-how-to-speed-up-app/15.png" alt=""></p>
<h3 id="Android-Profiler"><a href="#Android-Profiler" class="headerlink" title="Android Profiler"></a>Android Profiler</h3><p>Android Profiler 是 Android 中常用的耗时分析工具，以各种图表的形式展示函数执行时间，帮助开发者分析耗时问题。</p>
<p>启动优化着实是牵一发动全身的事情，手段既琐碎又复杂。如何能够将监控体系建设起来，并融入到整个研发到上线流程中，是个庞大的工程。下面给你介绍下我们是如何做的吧。</p>
<h2 id="管控流程体系保障平台建设"><a href="#管控流程体系保障平台建设" class="headerlink" title="管控流程体系保障平台建设"></a>管控流程体系保障平台建设</h2><p>APM自动化管控和流程体系保障平台，目标是通过稳定环境更自动化的测试，采集到的性能数据能够通过分析检测，发现问题能够更低成本定位分发告警，同时大盘能够展示趋势和详情。平台设计如下图：</p>
<p><img src="/uploads/thinking-in-how-to-speed-up-app/10.png" alt=""></p>
<p>开发过程会 daily 出迭代报告，开发完成后，会有集成卡口，提前卡住迭代性能问题。</p>
<p>集成后，在集成构建平台能够构建正式包和线下性能包，进行线下测试和线上性能数据采集，线下支持录制回放、Monkey 等自动化测试手段，测试期间会有生成版本报告，发布上线前也会有发布卡口，及时处理版本问题。</p>
<p>发布后，通过云控进行指标配置、阈值配置还有采集比例等。性能数据上传服务经异常检测发现问题会触发报警，自动在 Bug 平台创建工单进行跟踪，以便及时修复问题减少用户体验损失。服务还会做统计、分级、基线对比、版本关联以及过滤等数据分析操作，这些分析后的性能数据最终会通过版本、迭代趋势等统计报表方式在大盘上展示，还能展示详情，包括对比展示、问题详情、场景分类、条件查询等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/thinking-in-how-to-speed-up-app/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>2020年涂图</title>
    <link href="http://ming1016.github.io/2020/05/04/draw-in-2020/"/>
    <id>http://ming1016.github.io/2020/05/04/draw-in-2020/</id>
    <published>2020-05-04T15:47:57.000Z</published>
    <updated>2020-11-07T04:26:06.378Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-in-2020/01.jpg" alt=""><br><img src="/uploads/draw-in-2020/02.jpg" alt=""><br><img src="/uploads/draw-in-2020/03.jpg" alt=""><br><img src="/uploads/draw-in-2020/04.png" alt=""><br><img src="/uploads/draw-in-2020/05.png" alt=""><br><img src="/uploads/draw-in-2020/06.jpg" alt=""><br><img src="/uploads/draw-in-2020/07.jpg" alt=""><br><img src="/uploads/draw-in-2020/08.jpg" alt=""><br><img src="/uploads/draw-in-2020/09.png" alt=""><br><img src="/uploads/draw-in-2020/10.png" alt=""><br><img src="/uploads/draw-in-2020/11.jpg" alt=""><br><img src="/uploads/draw-in-2020/12.jpg" alt=""><br><img src="/uploads/draw-in-2020/13.jpg" alt=""><br><img src="/uploads/draw-in-2020/14.png" alt=""><br><img src="/uploads/draw-in-2020/15.png" alt=""></p>
<p><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/08.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/09.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/10.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/11.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/12.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/13.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/14.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/15.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/16.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/17.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/19.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/20.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/21.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/22.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/23.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/24.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/25.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/26.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/27.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-in-2020/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-in-2020/02.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-in-2020/03.
    
    </summary>
    
      <category term="My painting" scheme="http://ming1016.github.io/categories/My-painting/"/>
    
    
      <category term="Painting" scheme="http://ming1016.github.io/tags/Painting/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
      <category term="Procreate" scheme="http://ming1016.github.io/tags/Procreate/"/>
    
  </entry>
  
  <entry>
    <title>我为什么写了《跟戴铭学iOS编程》这本书</title>
    <link href="http://ming1016.github.io/2020/04/12/why_write_study_ios_programming_with_daiming_book_and_draw_recently/"/>
    <id>http://ming1016.github.io/2020/04/12/why_write_study_ios_programming_with_daiming_book_and_draw_recently/</id>
    <published>2020-04-12T12:31:03.000Z</published>
    <updated>2020-05-04T16:32:41.548Z</updated>
    
    <content type="html"><![CDATA[<p>在我改了几次封面后，书已上架。</p>
<p><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/01.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/02.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/03.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/04.png" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/05.jpg" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/06.png" alt=""><br><img src="/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/07.png" alt=""></p>
<h2 id="为什么写《跟戴铭学iOS编程》"><a href="#为什么写《跟戴铭学iOS编程》" class="headerlink" title="为什么写《跟戴铭学iOS编程》"></a>为什么写《跟戴铭学iOS编程》</h2><p>又到了新的一年开始换工作的季节，我身边好多熟人也都开始寻找机会，看起来离职原因各有不同，有绩效不好的、和领导处不好的、多年难晋升的、做的事情难提升自己的、有更好机会的。但究其核心，我觉得还是危机感，想着如果脱离现在所处公司环境，没有现在的级别位置，自己还剩下什么，在一群候选人里，自己有没有胜于其他人的亮点，是否能够脱颖而出。我时常会思考这些问题，做了多年技术，一直在想，相同时间里接触和学习什么知识才是物有所值的。</p>
<p>计算机领域，作为开发者最开始接触，同时也是运用最多的就是编程语言，现在学习 iOS 开发一定要选择用 Swift。那么，从 Swift 官方手册学习完 Swift 语法，熟练进行 App 开发上架及日常迭代开发后，还要学习什么才能够让自己能够更进一步呢，才能让自己更有竞争力，我觉得这个是需要反复思考的。我不觉得无休止的跟进每年系统升级新特性，比如 ARKit、WatchKit、Force Touch、iBeacon、SiriKit 等，或者熟练系统和开源控件，比如Segmented Control、Picker View、Pop、能够对自己有本质的提高。不是说学这些没用，而是够用就行，毕竟开发 App 来服务用户，最终还是需要由这些来支持功能开发。</p>
<p>我想表达的是，对于你个人来说，当你要从普通开发者往架构设计师这条路上走，除了满足用户功能需求的开发，还需要了解更多技术选型，才能为团队开发效率和质量提供支持保障。这不光是凭借经验就能够做到的，还需要对编程语言和编程范式有更多的了解，我在写《跟戴铭学iOS编程》这本书时，我对 Swift 语言做了深挖，而不是照搬手册，也是想让你能够通过泛型，集合、内存和范式更多了解 Swfit 这门语言。同时结合实际开发中使用最频繁的场景，比如 JSON 数据处理，网络请求和界面布局，从底层源码层面来剖析这些应用场景背后的代码实现原理。本书 Swift 章节最后还详细说了怎么用 Swift 开发了语言转换器和解释器，一步一步掌握语言解析的过程，这部分内容是对上次我在 @Swift 大会上讲的内容的补充，大会幻灯片可见：<a href="https://ming1016.github.io/2018/09/17/produce-slides-of-third-at-swift-conference/">这次swift大会分享准备的幻灯片和 demo | 戴铭的博客 - 星光社</a>。</p>
<p>对语言编译过程的学习，价值是很高的，本书也着重介绍了编译以及编译产物的知识和运用。你可以回想下，当碰到一个以前没有做过的需求，解决一个没有碰到过的线上问题时，处理的方案肯定是有高低之分的，了解的越多越深入，方案就更有效，比如先前热修复时期，为了能够让原生开发不学前端代码进行热修复，利用 Clang 进行代码转换，从而节省了学习成本，再到后来，为了提升修复代码性能而内置解释器解释编译出的字节码，说明了贫穷往往会限制想象力，而富有的知识能够提高想象空间。当然编译的知识不光只限于这些，比如使用 LLVM 中的静态检查能力可以辅助监控代码质量，学习编译前端知识也能够使自己具有动手处理代码的能力，比如根据自己工程特点进行代码的批量处理，省时省力。我在最近做启动优化时发现，使用编译前端的知识还能够很轻松的处理特定规则的文件，甚至直接从代码中提取需要的部分，从而提高分析启动问题的效率。</p>
<p>对编译产物结构进行了解，不光能逆向看竞品，还能够了解和处理其它很多其它事情，比如 c 语言方法 hook，方法调用堆栈符号化的原理，启动时二进制加载过程的了解等。这些知识点既不容易过时也具有通用性，这些年来，计算机底层不断演进，系统不断趋同，特别是数据结构的设计就有很多值得学习和借鉴的，比如去了解编译产物导出符号为什么 trie 数据结构，能够学习到时间和空间复杂度在实际场景中是如何做选择的。</p>
<p>现在各公司正在尝试运用跨端技术，当你从 React Native 到 Weex，再到小程序，直到现在 Google 出的 Flutter，一路跟过来，你一定会觉得很疲惫，即使你都已熟练掌握了怎么使用，开发了很多功能，趟过了无数坑，当你面对下一个流行框架时，你可能又要重新来过。那怎样才能够使自己价值提高呢，一个合格的架构师需要具有的是看清技术本质和趋势的能力。而了解这些技术本质是了解隐藏在这些跨端技术背后的实现，这些实现主要用到了 DSL 转义、热更新、JavaScriptCore 桥接原生、解释器、WebCore 渲染的改造（Flutter），这些在本书中都会详细的跟你说，特别是最后大前端技术那章，会深入介绍WebKit 中的 JavaScriptCore 和 WebCore 的原理和源码实现，以求让你能够知其然知其所以然。</p>
<p>你会发现当你学习了上面提到的知识并加以实际运用后，工作中处理问题，甚至是疑难杂症时，你的脑海中就不再是一张白纸无从下手，而是满满的一书柜整理好的资料信手拈来。同时自己的竞争力也能够得到提升。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>书出版后，巧哥在公众号上做了推荐《<a href="https://mp.weixin.qq.com/s/82ZZTmGRNcYINuVqEGz38A" target="_blank" rel="external">iOS 界的黑客与画家 - 戴铭</a>》，硬核号主冬瓜的文章也介绍了这本书《<a href="https://mp.weixin.qq.com/s/1eG5alckPs8ODh72tzA77w" target="_blank" rel="external">说一说戴铭老师新书中的技术侧重</a>》</p>
<p>欲购《跟戴铭学iOS编程》这本书，通过这个<a href="https://item.m.jd.com/product/12839082.html?dist=jd" target="_blank" rel="external">京东链接</a>可以以全网最低价49元买到，也可加我微信 allstarming，备注“购书”来购买。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我改了几次封面后，书已上架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/why_write_study_ios_programming_with_daiming_book_and_draw_recently/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="book" scheme="http://ming1016.github.io/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Apple 操作系统可执行文件 Mach-O</title>
    <link href="http://ming1016.github.io/2020/03/29/apple-system-executable-file-macho/"/>
    <id>http://ming1016.github.io/2020/03/29/apple-system-executable-file-macho/</id>
    <published>2020-03-29T08:13:45.000Z</published>
    <updated>2020-04-06T12:38:59.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Mach-O 的全称是 Mach Object File Format。可以是可执行文件，目标代码或共享库，动态库。Mach 内核的操作系统比如 macOS，iPadOS 和 iOS 都是用的 Mach-O。Mach-O 包含程序的核心逻辑，以及入口点主要功能。</p>
<p>通过学习 Mach-O，可以了解应用程序是如何加载到系统的，如何执行的。还能了解符号查找，函数调用堆栈符号化等。更重要的是能够了解如何设计数据结构，这对于日后开发生涯的收益是长期的。了解这些对于了解编译和逆向工程都会有帮助，你还会了解到动态链接器的内部工作原理以及字节码格式的信息，Leb128字节流，Mach 导出时 Trie 二进制 image 压缩。</p>
<p>对于 Mach-O，你一定不陌生，但是对于它内部逻辑你一定会好奇，比如它是怎么构建出来的，组织方式如何，怎么加载的，如何工作，谁让它工作的，怎样导入和导出符号的。</p>
<p>接下来我们先看看怎么构建一个 Mach-O 文件的吧。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>构建 Mach-O 文件，主要需要用到编译器和静态链接器，编译器可以将编写的高级语言代码转成中间目标文件，然后用静态链接器把中间目标文件组合成 Mach-O。</p>
<p>编译器驱动程序使用的是 clang，有编译、组装和链接的能力，调用 Xcode Tools 里的其他工具来实现源码到 Mach-O 文件生成。其他工具包括将汇编代码创建为中间目标文件的 as 汇编程序，组合中间目标文件成 Mach-O 文件的静态链接器 ld，还有创建静态库或共享库的 libtool。</p>
<p>构建成 Mach-O 包括中间对象文件（MH_OBJECT）、可执行二进制（MH_EXECUTE）、VM 共享库文件（MH_FVMLIB）、Crash 产生的 Core 文件（MH_CORE）、preload（MH_PRELOAD）、动态共享库（MH_DYLIB）、动态链接器（MH_DYLINKER）、静态链接文件（MH_DYLIB_STUB）、符号文件和调试信息（MH_DSYM）这几种类型。其中框架会包含Mach-O和图片、文档、接口等相关资源。</p>
<p>写个 main.c 文件代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name = argv[<span class="number">1</span>];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 clang 构建成 Mach-O 文件 a.out。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang main.c</div></pre></td></tr></table></figure>
<p>如果有多个文件，先将多个文件生成中间目标文件，后缀是.o，使用 clang 的选项 -c。每个目标文件都是模块。使用静态链接器可以把多个模块组合成一个动态共享库。通过 ld 可以完成这个操作。使用 libtool 的选项 -static 可以构建静态库。</p>
<p>组合成动态库可以使用 clang 的 -dynamiclib 选项，命令如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -dynamiclib command.c header.c -fvisibility=hidden -o mac.dylib</div></pre></td></tr></table></figure>
<p>静态链接就是把各个模块组合成一个整体，生成新的 Mach-O，链接的内容就是把各个模块间相互的引用能够正确的链接好，原理就是把一些指令对其他符号的地址引用进行修正。过程包含地址和空间分配，符号解析和围绕符号进行的重定位。核心是重定位，X86-64寻址方式是 RIP-relative 寻址，就是基于 RIP 来计算目标地址，通过 jumpq 跳转目标地址，就是当前指令下一条指令地址来加偏移量。</p>
<p>构建完 Mach-O。那你一定好奇 Mach-O 里面都有什么呢？分析 Mach-O 的工具有分析体系结构的 lipo，显式文件类型的 file，列 Data 内容的 otool，分析 image 每个逻辑信息符号的 pagestuff，符号表显示的 nm。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>Mach-O 会将数据流分组，每组都会有自己的意义，主要分三大部分，分别是 Mach Header、Load Command、Data。</p>
<h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Mach Header 里会有 Mach-O 的 CPU 信息，以及 Load Command 的信息。可以使用 otool 查看内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -h a.out</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Mach header</div><div class="line">      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags</div><div class="line">MH_MAGIC_64  X86_64        ALL  <span class="number">0x00</span>     EXECUTE    <span class="number">16</span>       <span class="number">1368</span>   NOUNDEFS DYLDLINK TWOLEVEL PIE</div></pre></td></tr></table></figure>
<p>通过 _dyld_get_image_header 函数可以获取 mach_header 结构体。<a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallStack.m" target="_blank" rel="external">GCDFetchFeed/SMCallStack.m at master · ming1016/GCDFetchFeed · GitHub</a> 里这段代码里有判断 Mach Header 结构体魔数的函数 smCmdFirstPointerFromMachHeader，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uintptr_t</span> smCmdFirstPointerFromMachHeader(<span class="keyword">const</span> struct mach_header* <span class="keyword">const</span> machHeader) &#123;</div><div class="line">    <span class="keyword">switch</span> (machHeader-&gt;magic) &#123;</div><div class="line">        <span class="keyword">case</span> MH_MAGIC:</div><div class="line">        <span class="keyword">case</span> MH_CIGAM:</div><div class="line">        <span class="keyword">case</span> MH_MAGIC_64:</div><div class="line">        <span class="keyword">case</span> MH_CIGAM_64:</div><div class="line">            <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)(((machHeaderByCPU*)machHeader) + <span class="number">1</span>);</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// Header 不合法</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有 Fat Header，里面会包含多个架构的 Header。</p>
<p>LLVM 中生成 Mach Header 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::writeMachHeader() &#123;</div><div class="line">  <span class="keyword">auto</span> cpusubtype = MachOLinkingContext::cpuSubtypeFromArch(_file.arch);</div><div class="line">  <span class="comment">// dynamic x86 executables on newer OS version should also set the</span></div><div class="line">  <span class="comment">// CPU_SUBTYPE_LIB64 mask in the CPU subtype.</span></div><div class="line">  <span class="comment">// <span class="doctag">FIXME:</span> Check that this is a dynamic executable, not a static one.</span></div><div class="line">  <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_EXECUTE &amp;&amp;</div><div class="line">      cpusubtype == CPU_SUBTYPE_X86_64_ALL &amp;&amp;</div><div class="line">      _file.os == MachOLinkingContext::OS::macOSX) &#123;</div><div class="line">    <span class="keyword">uint32_t</span> version;</div><div class="line">    <span class="keyword">bool</span> failed = MachOLinkingContext::parsePackedVersion(<span class="string">"10.5"</span>, version);</div><div class="line">    <span class="keyword">if</span> (!failed &amp;&amp; _file.minOSverson &gt;= version)</div><div class="line">      cpusubtype |= CPU_SUBTYPE_LIB64;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  mach_header *mh = <span class="keyword">reinterpret_cast</span>&lt;mach_header*&gt;(_buffer);</div><div class="line">  mh-&gt;magic = _is64 ? llvm::MachO::MH_MAGIC_64 : llvm::MachO::MH_MAGIC;</div><div class="line">  mh-&gt;cputype =  MachOLinkingContext::cpuTypeFromArch(_file.arch);</div><div class="line">  mh-&gt;cpusubtype = cpusubtype;</div><div class="line">  mh-&gt;filetype = _file.fileType;</div><div class="line">  mh-&gt;ncmds = _countOfLoadCommands;</div><div class="line">  mh-&gt;sizeofcmds = _endOfLoadCommands - _startOfLoadCommands;</div><div class="line">  mh-&gt;flags = _file.flags;</div><div class="line">  <span class="keyword">if</span> (_swap)</div><div class="line">    swapStruct(*mh);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Load-Command"><a href="#Load-Command" class="headerlink" title="Load Command"></a>Load Command</h3><p>Load Command 包含 Mach-O 里命令类型信息，名称和二进制文件的位置。</p>
<p>使用 otool 命令可以查看详细：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">otool -v -l a.out</div></pre></td></tr></table></figure>
<p>遍历 Mach Header 里的 ncmds 可以取到所有 Load Command。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> iCmd = <span class="number">0</span>; iCmd &lt; machHeader-&gt;ncmds; iCmd++) &#123;</div><div class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>* <span class="title">loadCmd</span> = (<span class="title">struct</span> <span class="title">load_command</span>*)<span class="title">cmdPointer</span>;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>load<em>command 里的 cmd 是以 LC</em> 开头定义的宏，可以参看 loader.h 里的定义，有50多个，主要的是：</p>
<ul>
<li>LC_SEGMENT_64(_PAGEZERO)</li>
<li>LC_SEGMENT_64(_TEXT)</li>
<li>LC_SEGMENT_64(_DATA)</li>
<li>LC_SEGMENT_64(_LINKEDIT)</li>
<li>LC_DYLD_INFO_ONLY</li>
<li>LC_SYMTAB</li>
<li>LC_DYSYMTAB</li>
<li>LC_LOAD_DYLINKER</li>
<li>LC_UUID</li>
<li>LC_BUILD_VERSION</li>
<li>LC_SOURCE_VERSION</li>
<li>LC_MAIN</li>
<li>LC_LOAD_DYLIB(libSystem.B.dylib)</li>
<li>LC_FUNCTION_STARTS</li>
<li>LC_DATA_IN_CODE</li>
</ul>
<p>每个 command 的结构都是独立的，前两个字段 cmd 和 cmdsize 是一样的。</p>
<p>根据 Load Command 可以得到 Segment 的偏移量。</p>
<p>生成 Load Command 的代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div></pre></td><td class="code"><pre><div class="line">llvm::Error MachOFileLayout::writeLoadCommands() &#123;</div><div class="line">  <span class="keyword">uint8_t</span> *lc = &amp;_buffer[_startOfLoadCommands];</div><div class="line">  <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_OBJECT) &#123;</div><div class="line">    <span class="comment">// Object files have one unnamed segment which holds all sections.</span></div><div class="line">    <span class="keyword">if</span> (_is64) &#123;</div><div class="line">     <span class="keyword">if</span> (<span class="keyword">auto</span> ec = writeSingleSegmentLoadCommand&lt;MachO64Trait&gt;(lc))</div><div class="line">       <span class="keyword">return</span> ec;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> ec = writeSingleSegmentLoadCommand&lt;MachO32Trait&gt;(lc))</div><div class="line">        <span class="keyword">return</span> ec;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Add LC_SYMTAB with symbol table info</span></div><div class="line">    symtab_command* st = <span class="keyword">reinterpret_cast</span>&lt;symtab_command*&gt;(lc);</div><div class="line">    st-&gt;cmd     = LC_SYMTAB;</div><div class="line">    st-&gt;cmdsize = <span class="keyword">sizeof</span>(symtab_command);</div><div class="line">    st-&gt;symoff  = _startOfSymbols;</div><div class="line">    st-&gt;nsyms   = _file.stabsSymbols.size() + _file.localSymbols.size() +</div><div class="line">                  _file.globalSymbols.size() + _file.undefinedSymbols.size();</div><div class="line">    st-&gt;stroff  = _startOfSymbolStrings;</div><div class="line">    st-&gt;strsize = _endOfSymbolStrings - _startOfSymbolStrings;</div><div class="line">    <span class="keyword">if</span> (_swap)</div><div class="line">      swapStruct(*st);</div><div class="line">    lc += <span class="keyword">sizeof</span>(symtab_command);</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_VERSION_MIN_MACOSX, LC_VERSION_MIN_IPHONEOS,</span></div><div class="line">    <span class="comment">// LC_VERSION_MIN_WATCHOS, LC_VERSION_MIN_TVOS</span></div><div class="line">    writeVersionMinLoadCommand(_file, _swap, lc);</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_FUNCTION_STARTS if needed.</span></div><div class="line">    <span class="keyword">if</span> (_functionStartsSize != <span class="number">0</span>) &#123;</div><div class="line">      linkedit_data_command* dl = <span class="keyword">reinterpret_cast</span>&lt;linkedit_data_command*&gt;(lc);</div><div class="line">      dl-&gt;cmd      = LC_FUNCTION_STARTS;</div><div class="line">      dl-&gt;cmdsize  = <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">      dl-&gt;dataoff  = _startOfFunctionStarts;</div><div class="line">      dl-&gt;datasize = _functionStartsSize;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dl);</div><div class="line">      lc += <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_DATA_IN_CODE if requested.</span></div><div class="line">    <span class="keyword">if</span> (_file.generateDataInCodeLoadCommand) &#123;</div><div class="line">      linkedit_data_command* dl = <span class="keyword">reinterpret_cast</span>&lt;linkedit_data_command*&gt;(lc);</div><div class="line">      dl-&gt;cmd      = LC_DATA_IN_CODE;</div><div class="line">      dl-&gt;cmdsize  = <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">      dl-&gt;dataoff  = _startOfDataInCode;</div><div class="line">      dl-&gt;datasize = _dataInCodeSize;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dl);</div><div class="line">      lc += <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Final linked images have sections under segments.</span></div><div class="line">    <span class="keyword">if</span> (_is64) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> ec = writeSegmentLoadCommands&lt;MachO64Trait&gt;(lc))</div><div class="line">        <span class="keyword">return</span> ec;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> ec = writeSegmentLoadCommands&lt;MachO32Trait&gt;(lc))</div><div class="line">        <span class="keyword">return</span> ec;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_ID_DYLIB command for dynamic libraries.</span></div><div class="line">    <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_DYLIB) &#123;</div><div class="line">      dylib_command *dc = <span class="keyword">reinterpret_cast</span>&lt;dylib_command*&gt;(lc);</div><div class="line">      StringRef path = _file.installName;</div><div class="line">      <span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(dylib_command) + pointerAlign(path.size() + <span class="number">1</span>);</div><div class="line">      dc-&gt;cmd                         = LC_ID_DYLIB;</div><div class="line">      dc-&gt;cmdsize                     = size;</div><div class="line">      dc-&gt;dylib.name                  = <span class="keyword">sizeof</span>(dylib_command); <span class="comment">// offset</span></div><div class="line">      <span class="comment">// needs to be some constant value different than the one in LC_LOAD_DYLIB</span></div><div class="line">      dc-&gt;dylib.timestamp             = <span class="number">1</span>;</div><div class="line">      dc-&gt;dylib.current_version       = _file.currentVersion;</div><div class="line">      dc-&gt;dylib.compatibility_version = _file.compatVersion;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dc);</div><div class="line">      <span class="built_in">memcpy</span>(lc + <span class="keyword">sizeof</span>(dylib_command), path.begin(), path.size());</div><div class="line">      lc[<span class="keyword">sizeof</span>(dylib_command) + path.size()] = <span class="string">'\0'</span>;</div><div class="line">      lc += size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_DYLD_INFO_ONLY.</span></div><div class="line">    dyld_info_command* di = <span class="keyword">reinterpret_cast</span>&lt;dyld_info_command*&gt;(lc);</div><div class="line">    di-&gt;cmd            = LC_DYLD_INFO_ONLY;</div><div class="line">    di-&gt;cmdsize        = <span class="keyword">sizeof</span>(dyld_info_command);</div><div class="line">    di-&gt;rebase_off     = _rebaseInfo.size() ? _startOfRebaseInfo : <span class="number">0</span>;</div><div class="line">    di-&gt;rebase_size    = _rebaseInfo.size();</div><div class="line">    di-&gt;bind_off       = _bindingInfo.size() ? _startOfBindingInfo : <span class="number">0</span>;</div><div class="line">    di-&gt;bind_size      = _bindingInfo.size();</div><div class="line">    di-&gt;weak_bind_off  = <span class="number">0</span>;</div><div class="line">    di-&gt;weak_bind_size = <span class="number">0</span>;</div><div class="line">    di-&gt;lazy_bind_off  = _lazyBindingInfo.size() ? _startOfLazyBindingInfo : <span class="number">0</span>;</div><div class="line">    di-&gt;lazy_bind_size = _lazyBindingInfo.size();</div><div class="line">    di-&gt;export_off     = _exportTrie.size() ? _startOfExportTrie : <span class="number">0</span>;</div><div class="line">    di-&gt;export_size    = _exportTrie.size();</div><div class="line">    <span class="keyword">if</span> (_swap)</div><div class="line">      swapStruct(*di);</div><div class="line">    lc += <span class="keyword">sizeof</span>(dyld_info_command);</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_SYMTAB with symbol table info.</span></div><div class="line">    symtab_command* st = <span class="keyword">reinterpret_cast</span>&lt;symtab_command*&gt;(lc);</div><div class="line">    st-&gt;cmd     = LC_SYMTAB;</div><div class="line">    st-&gt;cmdsize = <span class="keyword">sizeof</span>(symtab_command);</div><div class="line">    st-&gt;symoff  = _startOfSymbols;</div><div class="line">    st-&gt;nsyms   = _file.stabsSymbols.size() + _file.localSymbols.size() +</div><div class="line">                  _file.globalSymbols.size() + _file.undefinedSymbols.size();</div><div class="line">    st-&gt;stroff  = _startOfSymbolStrings;</div><div class="line">    st-&gt;strsize = _endOfSymbolStrings - _startOfSymbolStrings;</div><div class="line">    <span class="keyword">if</span> (_swap)</div><div class="line">      swapStruct(*st);</div><div class="line">    lc += <span class="keyword">sizeof</span>(symtab_command);</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_DYSYMTAB</span></div><div class="line">    <span class="keyword">if</span> (_file.fileType != llvm::MachO::MH_PRELOAD) &#123;</div><div class="line">      dysymtab_command* dst = <span class="keyword">reinterpret_cast</span>&lt;dysymtab_command*&gt;(lc);</div><div class="line">      dst-&gt;cmd            = LC_DYSYMTAB;</div><div class="line">      dst-&gt;cmdsize        = <span class="keyword">sizeof</span>(dysymtab_command);</div><div class="line">      dst-&gt;ilocalsym      = _symbolTableLocalsStartIndex;</div><div class="line">      dst-&gt;nlocalsym      = _file.stabsSymbols.size() +</div><div class="line">                            _file.localSymbols.size();</div><div class="line">      dst-&gt;iextdefsym     = _symbolTableGlobalsStartIndex;</div><div class="line">      dst-&gt;nextdefsym     = _file.globalSymbols.size();</div><div class="line">      dst-&gt;iundefsym      = _symbolTableUndefinesStartIndex;</div><div class="line">      dst-&gt;nundefsym      = _file.undefinedSymbols.size();</div><div class="line">      dst-&gt;tocoff         = <span class="number">0</span>;</div><div class="line">      dst-&gt;ntoc           = <span class="number">0</span>;</div><div class="line">      dst-&gt;modtaboff      = <span class="number">0</span>;</div><div class="line">      dst-&gt;nmodtab        = <span class="number">0</span>;</div><div class="line">      dst-&gt;extrefsymoff   = <span class="number">0</span>;</div><div class="line">      dst-&gt;nextrefsyms    = <span class="number">0</span>;</div><div class="line">      dst-&gt;indirectsymoff = _startOfIndirectSymbols;</div><div class="line">      dst-&gt;nindirectsyms  = _indirectSymbolTableCount;</div><div class="line">      dst-&gt;extreloff      = <span class="number">0</span>;</div><div class="line">      dst-&gt;nextrel        = <span class="number">0</span>;</div><div class="line">      dst-&gt;locreloff      = <span class="number">0</span>;</div><div class="line">      dst-&gt;nlocrel        = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dst);</div><div class="line">      lc += <span class="keyword">sizeof</span>(dysymtab_command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If main executable, add LC_LOAD_DYLINKER</span></div><div class="line">    <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_EXECUTE) &#123;</div><div class="line">      <span class="comment">// Build LC_LOAD_DYLINKER load command.</span></div><div class="line">      <span class="keyword">uint32_t</span> size=pointerAlign(<span class="keyword">sizeof</span>(dylinker_command)+dyldPath().size()+<span class="number">1</span>);</div><div class="line">      dylinker_command* dl = <span class="keyword">reinterpret_cast</span>&lt;dylinker_command*&gt;(lc);</div><div class="line">      dl-&gt;cmd              = LC_LOAD_DYLINKER;</div><div class="line">      dl-&gt;cmdsize          = size;</div><div class="line">      dl-&gt;name             = <span class="keyword">sizeof</span>(dylinker_command); <span class="comment">// offset</span></div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dl);</div><div class="line">      <span class="built_in">memcpy</span>(lc+<span class="keyword">sizeof</span>(dylinker_command), dyldPath().data(), dyldPath().size());</div><div class="line">      lc[<span class="keyword">sizeof</span>(dylinker_command)+dyldPath().size()] = <span class="string">'\0'</span>;</div><div class="line">      lc += size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_VERSION_MIN_MACOSX, LC_VERSION_MIN_IPHONEOS, LC_VERSION_MIN_WATCHOS,</span></div><div class="line">    <span class="comment">// LC_VERSION_MIN_TVOS</span></div><div class="line">    writeVersionMinLoadCommand(_file, _swap, lc);</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_SOURCE_VERSION</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">// Note, using a temporary here to appease UB as we may not be aligned</span></div><div class="line">      <span class="comment">// enough for a struct containing a uint64_t when emitting a 32-bit binary</span></div><div class="line">      source_version_command sv;</div><div class="line">      sv.cmd       = LC_SOURCE_VERSION;</div><div class="line">      sv.cmdsize   = <span class="keyword">sizeof</span>(source_version_command);</div><div class="line">      sv.version   = _file.sourceVersion;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(sv);</div><div class="line">      <span class="built_in">memcpy</span>(lc, &amp;sv, <span class="keyword">sizeof</span>(source_version_command));</div><div class="line">      lc += <span class="keyword">sizeof</span>(source_version_command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If main executable, add LC_MAIN.</span></div><div class="line">    <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_EXECUTE) &#123;</div><div class="line">      <span class="comment">// Build LC_MAIN load command.</span></div><div class="line">      <span class="comment">// Note, using a temporary here to appease UB as we may not be aligned</span></div><div class="line">      <span class="comment">// enough for a struct containing a uint64_t when emitting a 32-bit binary</span></div><div class="line">      entry_point_command ep;</div><div class="line">      ep.cmd       = LC_MAIN;</div><div class="line">      ep.cmdsize   = <span class="keyword">sizeof</span>(entry_point_command);</div><div class="line">      ep.entryoff  = _file.entryAddress - _seg1addr;</div><div class="line">      ep.stacksize = _file.stackSize;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(ep);</div><div class="line">      <span class="built_in">memcpy</span>(lc, &amp;ep, <span class="keyword">sizeof</span>(entry_point_command));</div><div class="line">      lc += <span class="keyword">sizeof</span>(entry_point_command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_LOAD_DYLIB commands</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> DependentDylib &amp;dep : _file.dependentDylibs) &#123;</div><div class="line">      dylib_command* dc = <span class="keyword">reinterpret_cast</span>&lt;dylib_command*&gt;(lc);</div><div class="line">      <span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(dylib_command) + pointerAlign(dep.path.size()+<span class="number">1</span>);</div><div class="line">      dc-&gt;cmd                         = dep.kind;</div><div class="line">      dc-&gt;cmdsize                     = size;</div><div class="line">      dc-&gt;dylib.name                  = <span class="keyword">sizeof</span>(dylib_command); <span class="comment">// offset</span></div><div class="line">      <span class="comment">// needs to be some constant value different than the one in LC_ID_DYLIB</span></div><div class="line">      dc-&gt;dylib.timestamp             = <span class="number">2</span>;</div><div class="line">      dc-&gt;dylib.current_version       = dep.currentVersion;</div><div class="line">      dc-&gt;dylib.compatibility_version = dep.compatVersion;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dc);</div><div class="line">      <span class="built_in">memcpy</span>(lc+<span class="keyword">sizeof</span>(dylib_command), dep.path.begin(), dep.path.size());</div><div class="line">      lc[<span class="keyword">sizeof</span>(dylib_command)+dep.path.size()] = <span class="string">'\0'</span>;</div><div class="line">      lc += size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_RPATH</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> StringRef &amp;path : _file.rpaths) &#123;</div><div class="line">      rpath_command *rpc = <span class="keyword">reinterpret_cast</span>&lt;rpath_command *&gt;(lc);</div><div class="line">      <span class="keyword">uint32_t</span> size = pointerAlign(<span class="keyword">sizeof</span>(rpath_command) + path.size() + <span class="number">1</span>);</div><div class="line">      rpc-&gt;cmd                         = LC_RPATH;</div><div class="line">      rpc-&gt;cmdsize                     = size;</div><div class="line">      rpc-&gt;path                        = <span class="keyword">sizeof</span>(rpath_command); <span class="comment">// offset</span></div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*rpc);</div><div class="line">      <span class="built_in">memcpy</span>(lc+<span class="keyword">sizeof</span>(rpath_command), path.begin(), path.size());</div><div class="line">      lc[<span class="keyword">sizeof</span>(rpath_command)+path.size()] = <span class="string">'\0'</span>;</div><div class="line">      lc += size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_FUNCTION_STARTS if needed.</span></div><div class="line">    <span class="keyword">if</span> (_functionStartsSize != <span class="number">0</span>) &#123;</div><div class="line">      linkedit_data_command* dl = <span class="keyword">reinterpret_cast</span>&lt;linkedit_data_command*&gt;(lc);</div><div class="line">      dl-&gt;cmd      = LC_FUNCTION_STARTS;</div><div class="line">      dl-&gt;cmdsize  = <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">      dl-&gt;dataoff  = _startOfFunctionStarts;</div><div class="line">      dl-&gt;datasize = _functionStartsSize;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dl);</div><div class="line">      lc += <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Add LC_DATA_IN_CODE if requested.</span></div><div class="line">    <span class="keyword">if</span> (_file.generateDataInCodeLoadCommand) &#123;</div><div class="line">      linkedit_data_command* dl = <span class="keyword">reinterpret_cast</span>&lt;linkedit_data_command*&gt;(lc);</div><div class="line">      dl-&gt;cmd      = LC_DATA_IN_CODE;</div><div class="line">      dl-&gt;cmdsize  = <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">      dl-&gt;dataoff  = _startOfDataInCode;</div><div class="line">      dl-&gt;datasize = _dataInCodeSize;</div><div class="line">      <span class="keyword">if</span> (_swap)</div><div class="line">        swapStruct(*dl);</div><div class="line">      lc += <span class="keyword">sizeof</span>(linkedit_data_command);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> llvm::Error::success();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>Data 由 Segment 的数据组成，是 Mach-O 占比最多的部分，有代码有数据，比如符号表。Data 共三个 Segment，<strong>TEXT、</strong>DATA、<strong>LINKEDIT。其中 </strong>TEXT 和 <strong>DATA 对应一个或多个 Section，</strong>LINKEDIT 没有 Section，需要配合 LC_SYMTAB 来解析 symbol table 和 string table。这些里面是 Mach-O 的主要数据。</p>
<p>生成 __LINKEDIT 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::buildLinkEditInfo() &#123;</div><div class="line">  buildRebaseInfo();</div><div class="line">  buildBindInfo();</div><div class="line">  buildLazyBindInfo();</div><div class="line">  buildExportTrie();</div><div class="line">  computeSymbolTableSizes();</div><div class="line">  computeFunctionStartsSize();</div><div class="line">  computeDataInCodeSize();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> MachOFileLayout::writeLinkEditContent() &#123;</div><div class="line">  <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_OBJECT) &#123;</div><div class="line">    writeRelocations();</div><div class="line">    writeFunctionStartsInfo();</div><div class="line">    writeDataInCodeInfo();</div><div class="line">    writeSymbolTable();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    writeRebaseInfo();</div><div class="line">    writeBindingInfo();</div><div class="line">    writeLazyBindingInfo();</div><div class="line">    <span class="comment">// <span class="doctag">TODO:</span> add weak binding info</span></div><div class="line">    writeExportInfo();</div><div class="line">    writeFunctionStartsInfo();</div><div class="line">    writeDataInCodeInfo();</div><div class="line">    writeSymbolTable();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过生成 <strong>LINKEDIT 的代码可以看出 </strong>LINKEDIT 里包含 dyld 所需各种数据，比如符号表、间接符号表、rebase 操作码、绑定操作码、导出符号、函数启动信息、数据表、代码签名等。</p>
<p>__DATA 包含 lazy 和 non lazy 符号指针，还会包含静态数据和全局变量等。可重定位的 Mach-O 文件还会有一个重定位的区域用来存储重定位信息，如果哪个 section 有重定位字节，就会有一个 relocation table 对应。</p>
<p>生成 relocation 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::writeRelocations() &#123;</div><div class="line">  <span class="keyword">uint32_t</span> relOffset = _startOfRelocations;</div><div class="line">  <span class="keyword">for</span> (Section sect : _file.sections) &#123;</div><div class="line">    <span class="keyword">for</span> (Relocation r : sect.relocations) &#123;</div><div class="line">      any_relocation_info* rb = <span class="keyword">reinterpret_cast</span>&lt;any_relocation_info*&gt;(</div><div class="line">                                                           &amp;_buffer[relOffset]);</div><div class="line">      *rb = packRelocation(r, _swap, _bigEndianArch);</div><div class="line">      relOffset += <span class="keyword">sizeof</span>(any_relocation_info);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 size 命令可以看到内容的分布，使用前面生成的 a.out 来看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m a.out</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: <span class="number">0x100000000</span> (vmaddr <span class="number">0x0</span> fileoff <span class="number">0</span>)</div><div class="line">Segment __TEXT: <span class="number">0x1000</span> (vmaddr <span class="number">0x100000000</span> fileoff <span class="number">0</span>)</div><div class="line">    Section __text: <span class="number">0x41</span> (addr <span class="number">0x100000f50</span> offset <span class="number">3920</span>)</div><div class="line">    Section __stubs: <span class="number">0x6</span> (addr <span class="number">0x100000f92</span> offset <span class="number">3986</span>)</div><div class="line">    Section __stub_helper: <span class="number">0x1a</span> (addr <span class="number">0x100000f98</span> offset <span class="number">3992</span>)</div><div class="line">    Section __cstring: <span class="number">0x4</span> (addr <span class="number">0x100000fb2</span> offset <span class="number">4018</span>)</div><div class="line">    Section __unwind_info: <span class="number">0x48</span> (addr <span class="number">0x100000fb8</span> offset <span class="number">4024</span>)</div><div class="line">    total <span class="number">0xad</span></div><div class="line">Segment __DATA_CONST: <span class="number">0x1000</span> (vmaddr <span class="number">0x100001000</span> fileoff <span class="number">4096</span>)</div><div class="line">    Section __got: <span class="number">0x8</span> (addr <span class="number">0x100001000</span> offset <span class="number">4096</span>)</div><div class="line">    total <span class="number">0x8</span></div><div class="line">Segment __DATA: <span class="number">0x1000</span> (vmaddr <span class="number">0x100002000</span> fileoff <span class="number">8192</span>)</div><div class="line">    Section __la_symbol_ptr: <span class="number">0x8</span> (addr <span class="number">0x100002000</span> offset <span class="number">8192</span>)</div><div class="line">    Section __data: <span class="number">0x8</span> (addr <span class="number">0x100002008</span> offset <span class="number">8200</span>)</div><div class="line">    total <span class="number">0x10</span></div><div class="line">Segment __LINKEDIT: <span class="number">0x1000</span> (vmaddr <span class="number">0x100003000</span> fileoff <span class="number">12288</span>)</div><div class="line">total <span class="number">0x100004000</span></div></pre></td></tr></table></figure>
<p>其中__TEXT Segment 的内容有：</p>
<ul>
<li>Section64(<strong>TEXT,</strong>text)</li>
<li>Section64(<strong>TEXT,</strong>stubs)</li>
<li>Section64(<strong>TEXT,</strong>stub_helper)</li>
<li>Section64(<strong>TEXT,</strong>cstring)</li>
<li>Section64(<strong>TEXT,</strong>unwind_info)</li>
</ul>
<p>__DATA Segment 的内容有：</p>
<ul>
<li>Section64(<strong>DATA,</strong>nl_symbol_ptr)</li>
<li>Section64(<strong>DATA,</strong>la_symbol_ptr)</li>
</ul>
<p>__LINKEDIT 的内容是：</p>
<ul>
<li>Dynamic Loader Info</li>
<li>Function Starts</li>
<li>Symbol Table</li>
<li>Data in Code Entries</li>
<li>Dynamic Symbol Table</li>
<li>String Table</li>
</ul>
<p>如果是 Objective-C 代码生成的 Mach-O 会多出很多和 Objective-C 相关的 Section ，我拿<a href="https://github.com/ming1016/GCDFetchFeed" target="_blank" rel="external">已阅</a>项目生成的 Mach-O 来看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun size -x -l -m GCDFetchFeed</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: <span class="number">0x100000000</span> (vmaddr <span class="number">0x0</span> fileoff <span class="number">0</span>)</div><div class="line">Segment __TEXT: <span class="number">0xa8000</span> (vmaddr <span class="number">0x100000000</span> fileoff <span class="number">0</span>)</div><div class="line">    Section __text: <span class="number">0x89084</span> (addr <span class="number">0x1000020e0</span> offset <span class="number">8416</span>)</div><div class="line">    Section __stubs: <span class="number">0x588</span> (addr <span class="number">0x10008b164</span> offset <span class="number">569700</span>)</div><div class="line">    Section __stub_helper: <span class="number">0x948</span> (addr <span class="number">0x10008b6ec</span> offset <span class="number">571116</span>)</div><div class="line">    Section __gcc_except_tab: <span class="number">0x1318</span> (addr <span class="number">0x10008c034</span> offset <span class="number">573492</span>)</div><div class="line">    Section __cstring: <span class="number">0xbebd</span> (addr <span class="number">0x10008d34c</span> offset <span class="number">578380</span>)</div><div class="line">    Section __objc_methname: <span class="number">0xa20f</span> (addr <span class="number">0x100099209</span> offset <span class="number">627209</span>)</div><div class="line">    Section __objc_classname: <span class="number">0x11d9</span> (addr <span class="number">0x1000a3418</span> offset <span class="number">668696</span>)</div><div class="line">    Section __objc_methtype: <span class="number">0x2185</span> (addr <span class="number">0x1000a45f1</span> offset <span class="number">673265</span>)</div><div class="line">    Section __const: <span class="number">0x23c</span> (addr <span class="number">0x1000a6780</span> offset <span class="number">681856</span>)</div><div class="line">    Section __ustring: <span class="number">0x23e</span> (addr <span class="number">0x1000a69bc</span> offset <span class="number">682428</span>)</div><div class="line">    Section __entitlements: <span class="number">0x184</span> (addr <span class="number">0x1000a6bfa</span> offset <span class="number">683002</span>)</div><div class="line">    Section __unwind_info: <span class="number">0x1274</span> (addr <span class="number">0x1000a6d80</span> offset <span class="number">683392</span>)</div><div class="line">    total <span class="number">0xa5f08</span></div><div class="line">Segment __DATA: <span class="number">0x2f000</span> (vmaddr <span class="number">0x1000a8000</span> fileoff <span class="number">688128</span>)</div><div class="line">    Section __nl_symbol_ptr: <span class="number">0x8</span> (addr <span class="number">0x1000a8000</span> offset <span class="number">688128</span>)</div><div class="line">    Section __got: <span class="number">0x258</span> (addr <span class="number">0x1000a8008</span> offset <span class="number">688136</span>)</div><div class="line">    Section __la_symbol_ptr: <span class="number">0x760</span> (addr <span class="number">0x1000a8260</span> offset <span class="number">688736</span>)</div><div class="line">    Section __const: <span class="number">0x4238</span> (addr <span class="number">0x1000a89c0</span> offset <span class="number">690624</span>)</div><div class="line">    Section __cfstring: <span class="number">0x9d80</span> (addr <span class="number">0x1000acbf8</span> offset <span class="number">707576</span>)</div><div class="line">    Section __objc_classlist: <span class="number">0x510</span> (addr <span class="number">0x1000b6978</span> offset <span class="number">747896</span>)</div><div class="line">    Section __objc_nlclslist: <span class="number">0x40</span> (addr <span class="number">0x1000b6e88</span> offset <span class="number">749192</span>)</div><div class="line">    Section __objc_catlist: <span class="number">0x90</span> (addr <span class="number">0x1000b6ec8</span> offset <span class="number">749256</span>)</div><div class="line">    Section __objc_nlcatlist: <span class="number">0x10</span> (addr <span class="number">0x1000b6f58</span> offset <span class="number">749400</span>)</div><div class="line">    Section __objc_protolist: <span class="number">0x80</span> (addr <span class="number">0x1000b6f68</span> offset <span class="number">749416</span>)</div><div class="line">    Section __objc_imageinfo: <span class="number">0x8</span> (addr <span class="number">0x1000b6fe8</span> offset <span class="number">749544</span>)</div><div class="line">    Section __objc_const: <span class="number">0x182e8</span> (addr <span class="number">0x1000b6ff0</span> offset <span class="number">749552</span>)</div><div class="line">    Section __objc_selrefs: <span class="number">0x2bf8</span> (addr <span class="number">0x1000cf2d8</span> offset <span class="number">848600</span>)</div><div class="line">    Section __objc_protorefs: <span class="number">0x8</span> (addr <span class="number">0x1000d1ed0</span> offset <span class="number">859856</span>)</div><div class="line">    Section __objc_classrefs: <span class="number">0x858</span> (addr <span class="number">0x1000d1ed8</span> offset <span class="number">859864</span>)</div><div class="line">    Section __objc_superrefs: <span class="number">0x370</span> (addr <span class="number">0x1000d2730</span> offset <span class="number">862000</span>)</div><div class="line">    Section __objc_ivar: <span class="number">0xb48</span> (addr <span class="number">0x1000d2aa0</span> offset <span class="number">862880</span>)</div><div class="line">    Section __objc_data: <span class="number">0x32a0</span> (addr <span class="number">0x1000d35e8</span> offset <span class="number">865768</span>)</div><div class="line">    Section __data: <span class="number">0x604</span> (addr <span class="number">0x1000d6888</span> offset <span class="number">878728</span>)</div><div class="line">    Section __bss: <span class="number">0x158</span> (addr <span class="number">0x1000d6e90</span> offset <span class="number">0</span>)</div><div class="line">    total <span class="number">0x2efe4</span></div><div class="line">Segment __LINKEDIT: <span class="number">0xae000</span> (vmaddr <span class="number">0x1000d7000</span> fileoff <span class="number">880640</span>)</div><div class="line">total <span class="number">0x100185000</span></div></pre></td></tr></table></figure>
<p>可以看到 __objc 前缀的都是为了支持 Objective-C 语言新增加的。</p>
<p>那么 Swift 语言代码构建的 Mach-O 是怎样的呢？</p>
<p>使用我做启动优化时用 Swift 写的工具 <a href="https://github.com/ming1016/MethodTraceAnalyze" target="_blank" rel="external">MethodTraceAnalyze</a> 看下内容有什么。结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Segment __PAGEZERO: <span class="number">0x100000000</span> (vmaddr <span class="number">0x0</span> fileoff <span class="number">0</span>)</div><div class="line">Segment __TEXT: <span class="number">0x115000</span> (vmaddr <span class="number">0x100000000</span> fileoff <span class="number">0</span>)</div><div class="line">    Section __text: <span class="number">0xfd540</span> (addr <span class="number">0x1000019b0</span> offset <span class="number">6576</span>)</div><div class="line">    Section __stubs: <span class="number">0x6f6</span> (addr <span class="number">0x1000feef0</span> offset <span class="number">1044208</span>)</div><div class="line">    Section __stub_helper: <span class="number">0xbaa</span> (addr <span class="number">0x1000ff5e8</span> offset <span class="number">1045992</span>)</div><div class="line">    Section __swift5_typeref: <span class="number">0xf56</span> (addr <span class="number">0x100100192</span> offset <span class="number">1048978</span>)</div><div class="line">    Section __swift5_capture: <span class="number">0x3b4</span> (addr <span class="number">0x1001010e8</span> offset <span class="number">1052904</span>)</div><div class="line">    Section __cstring: <span class="number">0x7011</span> (addr <span class="number">0x1001014a0</span> offset <span class="number">1053856</span>)</div><div class="line">    Section __const: <span class="number">0x4754</span> (addr <span class="number">0x1001084c0</span> offset <span class="number">1082560</span>)</div><div class="line">    Section __swift5_fieldmd: <span class="number">0x2bf4</span> (addr <span class="number">0x10010cc14</span> offset <span class="number">1100820</span>)</div><div class="line">    Section __swift5_types: <span class="number">0x1f0</span> (addr <span class="number">0x10010f808</span> offset <span class="number">1112072</span>)</div><div class="line">    Section __swift5_builtin: <span class="number">0x78</span> (addr <span class="number">0x10010f9f8</span> offset <span class="number">1112568</span>)</div><div class="line">    Section __swift5_reflstr: <span class="number">0x2740</span> (addr <span class="number">0x10010fa70</span> offset <span class="number">1112688</span>)</div><div class="line">    Section __swift5_proto: <span class="number">0x154</span> (addr <span class="number">0x1001121b0</span> offset <span class="number">1122736</span>)</div><div class="line">    Section __swift5_assocty: <span class="number">0x120</span> (addr <span class="number">0x100112304</span> offset <span class="number">1123076</span>)</div><div class="line">    Section __objc_methname: <span class="number">0x7a5</span> (addr <span class="number">0x100112424</span> offset <span class="number">1123364</span>)</div><div class="line">    Section __swift5_protos: <span class="number">0x8</span> (addr <span class="number">0x100112bcc</span> offset <span class="number">1125324</span>)</div><div class="line">    Section __unwind_info: <span class="number">0x1c70</span> (addr <span class="number">0x100112bd4</span> offset <span class="number">1125332</span>)</div><div class="line">    Section __eh_frame: <span class="number">0x7b0</span> (addr <span class="number">0x100114848</span> offset <span class="number">1132616</span>)</div><div class="line">    total <span class="number">0x11362c</span></div><div class="line">Segment __DATA_CONST: <span class="number">0x4000</span> (vmaddr <span class="number">0x100115000</span> fileoff <span class="number">1134592</span>)</div><div class="line">    Section __got: <span class="number">0x4a8</span> (addr <span class="number">0x100115000</span> offset <span class="number">1134592</span>)</div><div class="line">    Section __const: <span class="number">0x32f8</span> (addr <span class="number">0x1001154a8</span> offset <span class="number">1135784</span>)</div><div class="line">    Section __objc_classlist: <span class="number">0xd0</span> (addr <span class="number">0x1001187a0</span> offset <span class="number">1148832</span>)</div><div class="line">    Section __objc_protolist: <span class="number">0x10</span> (addr <span class="number">0x100118870</span> offset <span class="number">1149040</span>)</div><div class="line">    Section __objc_imageinfo: <span class="number">0x8</span> (addr <span class="number">0x100118880</span> offset <span class="number">1149056</span>)</div><div class="line">    total <span class="number">0x3888</span></div><div class="line">Segment __DATA: <span class="number">0x8000</span> (vmaddr <span class="number">0x100119000</span> fileoff <span class="number">1150976</span>)</div><div class="line">    Section __la_symbol_ptr: <span class="number">0x948</span> (addr <span class="number">0x100119000</span> offset <span class="number">1150976</span>)</div><div class="line">    Section __objc_const: <span class="number">0x2018</span> (addr <span class="number">0x100119948</span> offset <span class="number">1153352</span>)</div><div class="line">    Section __objc_selrefs: <span class="number">0xb0</span> (addr <span class="number">0x10011b960</span> offset <span class="number">1161568</span>)</div><div class="line">    Section __objc_protorefs: <span class="number">0x10</span> (addr <span class="number">0x10011ba10</span> offset <span class="number">1161744</span>)</div><div class="line">    Section __objc_classrefs: <span class="number">0x38</span> (addr <span class="number">0x10011ba20</span> offset <span class="number">1161760</span>)</div><div class="line">    Section __objc_data: <span class="number">0x98</span> (addr <span class="number">0x10011ba58</span> offset <span class="number">1161816</span>)</div><div class="line">    Section __data: <span class="number">0x1f88</span> (addr <span class="number">0x10011baf0</span> offset <span class="number">1161968</span>)</div><div class="line">    Section __bss: <span class="number">0x2a68</span> (addr <span class="number">0x10011da80</span> offset <span class="number">0</span>)</div><div class="line">    Section __common: <span class="number">0x50</span> (addr <span class="number">0x1001204e8</span> offset <span class="number">0</span>)</div><div class="line">    total <span class="number">0x7530</span></div><div class="line">Segment __LINKEDIT: <span class="number">0x152000</span> (vmaddr <span class="number">0x100121000</span> fileoff <span class="number">1171456</span>)</div><div class="line">total <span class="number">0x100273000</span></div></pre></td></tr></table></figure>
<p>可以看到 <strong>DATA Segment 部分还是有 </strong>objc 前缀的 Section，<strong>TEXT Segment 里已经都是 </strong>swift5 为前缀的 Section 了。</p>
<p>使用 otool 可以查看某个 Section 内容。比如查看 <strong>TEXT Segment 的 </strong>text Section 的内容，使用如下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -s __TEXT __text a.out</div></pre></td></tr></table></figure>
<p>使用 otool 可以直接看 Mach-O 汇编内容 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun otool -v -t a.out</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">a.out:</div><div class="line">(__TEXT,__text) section</div><div class="line">_main:</div><div class="line"><span class="number">0000000100000f</span>50    pushq   %rbp</div><div class="line"><span class="number">0000000100000f</span>51    movq    %rsp, %rbp</div><div class="line"><span class="number">0000000100000f</span>54    subq    $<span class="number">0x20</span>, %rsp</div><div class="line"><span class="number">0000000100000f</span>58    movl    $<span class="number">0x0</span>, <span class="number">-0x4</span>(%rbp)</div><div class="line"><span class="number">0000000100000f</span>5f    movl    %edi, <span class="number">-0x8</span>(%rbp)</div><div class="line"><span class="number">0000000100000f</span>62    movq    %rsi, <span class="number">-0x10</span>(%rbp)</div><div class="line"><span class="number">0000000100000f</span>66    movq    <span class="number">-0x10</span>(%rbp), %rax</div><div class="line"><span class="number">0000000100000f</span>6a    movq    <span class="number">0x8</span>(%rax), %rax</div><div class="line"><span class="number">0000000100000f</span>6e    movq    %rax, <span class="number">-0x18</span>(%rbp)</div><div class="line"><span class="number">0000000100000f</span>72    movq    <span class="number">-0x18</span>(%rbp), %rsi</div><div class="line"><span class="number">0000000100000f</span>76    leaq    <span class="number">0x35</span>(%rip), %rdi</div><div class="line"><span class="number">0000000100000f</span>7d    movb    $<span class="number">0x0</span>, %al</div><div class="line"><span class="number">0000000100000f</span>7f    callq   <span class="number">0x100000f92</span></div><div class="line"><span class="number">0000000100000f</span>84    xorl    %ecx, %ecx</div><div class="line"><span class="number">0000000100000f</span>86    movl    %eax, <span class="number">-0x1c</span>(%rbp)</div><div class="line"><span class="number">0000000100000f</span>89    movl    %ecx, %eax</div><div class="line"><span class="number">0000000100000f</span>8b    addq    $<span class="number">0x20</span>, %rsp</div><div class="line"><span class="number">0000000100000f</span>8f    popq    %rbp</div><div class="line"><span class="number">0000000100000f</span>90    retq</div></pre></td></tr></table></figure>
<p>构建中查看代码生成汇编可以使用 clang 以下选项：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -S -o - main.c</div></pre></td></tr></table></figure>
<p> 生成汇编如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">    .section    __TEXT,__text,regular,pure_instructions</div><div class="line">    .build_version macos, <span class="number">10</span>, <span class="number">15</span>    sdk_version <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span></div><div class="line">    .globl  _main                   ## -- Begin function main</div><div class="line">    .p2align    <span class="number">4</span>, <span class="number">0x90</span></div><div class="line">_main:                                  ## @main</div><div class="line">    .cfi_startproc</div><div class="line">## %bb<span class="number">.0</span>:</div><div class="line">    pushq   %rbp</div><div class="line">    .cfi_def_cfa_offset <span class="number">16</span></div><div class="line">    .cfi_offset %rbp, <span class="number">-16</span></div><div class="line">    movq    %rsp, %rbp</div><div class="line">    .cfi_def_cfa_register %rbp</div><div class="line">    subq    $<span class="number">32</span>, %rsp</div><div class="line">    movl    $<span class="number">0</span>, <span class="number">-4</span>(%rbp)</div><div class="line">    movl    %edi, <span class="number">-8</span>(%rbp)</div><div class="line">    movq    %rsi, <span class="number">-16</span>(%rbp)</div><div class="line">    movq    <span class="number">-16</span>(%rbp), %rax</div><div class="line">    movq    <span class="number">8</span>(%rax), %rax</div><div class="line">    movq    %rax, <span class="number">-24</span>(%rbp)</div><div class="line">    movq    <span class="number">-24</span>(%rbp), %rsi</div><div class="line">    leaq    L_.str(%rip), %rdi</div><div class="line">    movb    $<span class="number">0</span>, %al</div><div class="line">    callq   _printf</div><div class="line">    xorl    %ecx, %ecx</div><div class="line">    movl    %eax, <span class="number">-28</span>(%rbp)         ## <span class="number">4</span>-byte Spill</div><div class="line">    movl    %ecx, %eax</div><div class="line">    addq    $<span class="number">32</span>, %rsp</div><div class="line">    popq    %rbp</div><div class="line">    retq</div><div class="line">    .cfi_endproc</div><div class="line">                                        ## -- End function</div><div class="line">    .section    __TEXT,__cstring,cstring_literals</div><div class="line">L_.str:                                 ## @.str</div><div class="line">    .asciz  <span class="string">"%s\n"</span></div></pre></td></tr></table></figure>
<p>可以发现两者汇编逻辑是一样的。点符号开头的都是汇编指令，比如.section 就是告知会执行哪个 segment，.p2align 指令明确后面代码对齐方式，这里是16(2^4) 字节对齐，0x90 补齐。在 <strong>TEXT Segment 的 </strong>text Section 里会创建一个调用帧堆栈，进行函数调用，callq printf 函数前会用到 L<em>.str(%rip)，L</em>.str 标签会指向字符串，leaq 会把字符串的指针加载到 rdi 寄存器。最后会销毁调用帧堆栈，进行 retq 返回。</p>
<p>主要 Section：</p>
<ul>
<li>__nl_symbol_ptr：包含 non-lazy 符号指针，mach-o/loader.h 里有详细说明。服务 dyld_stub_binder 处理的符号。</li>
<li><strong>la_symbol_ptr：</strong>stubs 第一个 jump 目标地址。动态库的符号指针地址。</li>
<li><strong>got：二进制文件的全局偏移表 GOT，也包含 S_NON_LAZY_SYMBOL_POINTERS 标记的 non-lazy 符号指针。服务于 </strong>TEXT Segment 里的符号。可以将<strong>got 看作一个表，里面每项都是一个地址值。</strong>got 的每项在加载期间都会被 dyld 重写，所以会在 <strong>DATA Segment 中。</strong>got 用来存放 non-lazy 符号最终地址，为 dyld 所用。dylib 外部符号对于全局变量和常量引用地址会指到 __got。</li>
<li>__lazy_symbol：包含 lazy 符号，首次使用时绑定。</li>
<li><strong>stubs：跳转表，重定向到 lazy 和 non-lazy 符号的 section。被标记为 S_SYMBOL_STUBS。</strong>TEXT Segment 里代码和 dylib 外部符号的引用地址对函数符号的引用都指向了 <strong>stubs。其中每项都是 jmp 代码间接寻址，可跳到 </strong>la_symbol_ptr Section 中。</li>
<li><strong>stub_helper：lazy 动态绑定符号的辅助函数。可跳到 </strong>nl_symbol_ptr Section 中。</li>
<li>__text：机器码，也是实际代码，包含所有功能。</li>
<li>__cstring：常量。只读 C 字符串。</li>
<li>__const：初始化过的常量。</li>
<li>_<em>objc</em>：Objective-C 语言 runtime 的支持。</li>
<li>__data：初始化过的变量。</li>
<li>__bss：未初始化的静态变量。</li>
<li>__unwind_info：生成异常处理信息。</li>
<li>__eh_frame：DWARF2 unwind 可执行文件代码信息，用于调试。</li>
<li>string table：以空值终止的字符串序列。</li>
<li>symbol table：通过 LC_SYMTAB 命令找到 symbol table，其包含所有用到的符号信息。结构体 nlist_64描述了符号的基本信息。nlist_64 结构体中 n_type 字段是一个8位复合字段，其中bit[0:1]表示是外部符号，bit[5:8]表调试符号，bit[4:5]表示私有 external 符号，bit[1:4]是符号类型，有 N_UNDF 未定义、N_ABS 绝对地址、N_SECT 本地符号、N_PBUD 预绑定符号、N_INDR 同名符号几种类型。</li>
<li>indirect symbol table：每项都是一个 index 值，指向 symbol table 中的项。由 LC_DYSYMTAB 定义，和<strong>nl_symbol_ptr 和 </strong>lazy_symbol 一起为 <strong>stubs 和 </strong>got 等 Section 服务。</li>
</ul>
<p>生成 Section 的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::writeSectionContent() &#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Section &amp;s : _file.sections) &#123;</div><div class="line">    <span class="comment">// Copy all section content to output buffer.</span></div><div class="line">    <span class="keyword">if</span> (isZeroFillSection(s.type))</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">if</span> (s.content.empty())</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    <span class="keyword">uint32_t</span> offset = _sectInfo[&amp;s].fileOffset;</div><div class="line">    <span class="keyword">uint8_t</span> *p = &amp;_buffer[offset];</div><div class="line">    <span class="built_in">memcpy</span>(p, &amp;s.content[<span class="number">0</span>], s.content.size());</div><div class="line">    p += s.content.size();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 symble table 生成的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::writeSymbolTable() &#123;</div><div class="line">  <span class="comment">// Write symbol table and symbol strings in parallel.</span></div><div class="line">  <span class="keyword">uint32_t</span> symOffset = _startOfSymbols;</div><div class="line">  <span class="keyword">uint32_t</span> strOffset = _startOfSymbolStrings;</div><div class="line">  <span class="comment">// Reserve n_strx offset of zero to mean no name.</span></div><div class="line">  _buffer[strOffset++] = <span class="string">' '</span>;</div><div class="line">  _buffer[strOffset++] = <span class="string">'\0'</span>;</div><div class="line">  appendSymbols(_file.stabsSymbols, symOffset, strOffset);</div><div class="line">  appendSymbols(_file.localSymbols, symOffset, strOffset);</div><div class="line">  appendSymbols(_file.globalSymbols, symOffset, strOffset);</div><div class="line">  appendSymbols(_file.undefinedSymbols, symOffset, strOffset);</div><div class="line">  <span class="comment">// Write indirect symbol table array.</span></div><div class="line">  <span class="keyword">uint32_t</span> *indirects = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint32_t</span>*&gt;</div><div class="line">                                            (&amp;_buffer[_startOfIndirectSymbols]);</div><div class="line">  <span class="keyword">if</span> (_file.fileType == llvm::MachO::MH_OBJECT) &#123;</div><div class="line">    <span class="comment">// Object files have sections in same order as input normalized file.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Section &amp;section : _file.sections) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> index : section.indirectSymbols) &#123;</div><div class="line">        <span class="keyword">if</span> (_swap)</div><div class="line">          *indirects++ = llvm::sys::getSwappedBytes(index);</div><div class="line">        <span class="keyword">else</span></div><div class="line">          *indirects++ = index;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Final linked images must sort sections from normalized file.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Segment &amp;seg : _file.segments) &#123;</div><div class="line">      SegExtraInfo &amp;segInfo = _segInfo[&amp;seg];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> Section *section : segInfo.sections) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">uint32_t</span> index : section-&gt;indirectSymbols) &#123;</div><div class="line">          <span class="keyword">if</span> (_swap)</div><div class="line">            *indirects++ = llvm::sys::getSwappedBytes(index);</div><div class="line">          <span class="keyword">else</span></div><div class="line">            *indirects++ = index;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取 Segment 信息的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmentWalk</span><span class="params">(<span class="keyword">void</span> *segment_command)</span> </span>&#123;</div><div class="line">  <span class="keyword">uint32_t</span> nsects;</div><div class="line">  <span class="keyword">void</span> *section;</div><div class="line"></div><div class="line">  section = segment_command + <span class="keyword">sizeof</span>(struct segment_command);</div><div class="line">  nsects = ((struct segment_command *) segment_command)-&gt;nsects;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (nsects--) &#123;</div><div class="line">    section += <span class="keyword">sizeof</span>(struct s_section);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取对应符号的方法代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义参看 &lt;mach-o/nlist.h&gt;</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_UNDF  0x0  <span class="comment">// 未定义</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_ABS 0x2    <span class="comment">// 绝对地址</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_SECT 0xe   <span class="comment">// 本地符号</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_PBUD 0xc   <span class="comment">// 预定义符号</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_INDR 0xa   <span class="comment">// 同名符号</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_STAB 0xe0  <span class="comment">// 调试符号</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_PEXT 0x10  <span class="comment">// 私有 external 符号</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TYPE 0x0e  <span class="comment">// 类型位的掩码</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N_EXT 0x01   <span class="comment">// external 符号</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">symbolical</span><span class="params">(sym)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (N_STAB &amp; sym-&gt;type)</div><div class="line">    <span class="keyword">return</span> <span class="string">'-'</span>; </div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((N_TYPE &amp; sym-&gt;type) == N_UNDF) &#123;</div><div class="line">    <span class="keyword">if</span> (sym-&gt;name_not_found)</div><div class="line">     <span class="keyword">return</span> <span class="string">'C'</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sym-&gt;type &amp; N_EXT)</div><div class="line">     <span class="keyword">return</span> = <span class="string">'U'</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">     <span class="keyword">return</span> = <span class="string">'?'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((N_TYPE &amp; sym-&gt;type) == N_SECT) &#123;</div><div class="line">    <span class="keyword">return</span> matched(saved_sections, sym);</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((N_TYPE &amp; sym-&gt;type) == N_ABS) &#123;</div><div class="line">    <span class="keyword">return</span> = <span class="string">'A'</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((N_TYPE &amp; sym-&gt;type) == N_INDR) &#123;</div><div class="line">    <span class="keyword">return</span> = <span class="string">'I'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">matched</span><span class="params">(saved_sections, symbol)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (sect = find_mysection(saved_sections, symbol-&gt;n_sect)) # </div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (!ft_strcmp(sect-&gt;name, SECT_TEXT))</div><div class="line">      ret = <span class="string">'T'</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!ft_strcmp(sect-&gt;name, SECT_DATA))</div><div class="line">      ret = <span class="string">'D'</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!ft_strcmp(sect-&gt;name, SECT_BSS))</div><div class="line">      ret = <span class="string">'B'</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      ret = <span class="string">'S'</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(mysym-&gt;type &amp; N_EXT))</div><div class="line">       ret -= <span class="string">'A'</span> - <span class="string">'a'</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="加载运行"><a href="#加载运行" class="headerlink" title="加载运行"></a>加载运行</h2><p>程序要和其他库还有模块一起运行，需要在运行时对这些库和模块的符号引用进行解析，运行时，你应用程序使用的模块符号都在共享名称空间。macOS 使用的是两级名称空间来确保不同模块符号名不会冲突，同时增强向前兼容。</p>
<p>选择要加载的 Mach-O 后，系统内核会先确定该文件是否是 Mach-O 文件。</p>
<p>文件的第一个字节是魔数，通过魔数可以推断是不是 Mach-O，mach-o/loader.h 里定义了四个魔数标识。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC    0xfeedface</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM    NXSwapInt(MH_MAGIC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64 NXSwapInt(MH_MAGIC_64)</span></div></pre></td></tr></table></figure>
<p>以上四个魔数标识是 Mach-O 文件。</p>
<p>然后内核系统会用 fork 函数创建一个进程，然后通过 execve 函数开始程序加载过程，execve 有多个种类，比如 execl、execv 等，只是在参数和环境变量上有不同，最终都会到内核的 execve 函数。</p>
<p>接着会检查 Mach-O header，加载 dyld 和程序到 Load Command 指定的地址空间。执行动态链接器。动态链接器通过 dyld_stub_binder 调用，这个函数的参数不直接指定要绑定的符号，而是通过给 dyld_stub_binder 偏移量到 dyld 解释的特殊字节码 Segment 中。dyld_stub_binder 函数的代码在这里：<a href="https://opensource.apple.com/source/dyld/dyld-635.2/src/dyld_stub_binder.s.auto.html" target="_blank" rel="external">dyld_stub_binder.s</a>。dyld 分为 rebase、binding、lazy binding、导出几个部分。dyld 可以 hook，使用 DYLD_INSERT_LIBRARIES，类似 ld 的 LD_PRELOAD 还有 DYLD_LIBRARY_PATH。</p>
<p><strong>text 里需要被 lazy binding 的符号引用，访问时回到 stub 中，目标地址在 </strong>la_symbol_ptr，对应 <strong>la_symbol_ptr 的内容会指向 </strong>stub_helper，其中逻辑会调到 dyld_stub_binder 函数，这个函数会通过 dyld 找到符号的真实地址，最后 dyld_stub_binder 会把得到的地址写入 <strong>la_symbol_ptr 里后，会跳转到符号的真实地址。由于地址已经在 </strong>la_symbol_ptr 里了，所以再访问符号时会通过 stub 的 jum 指令直接跳转到真实地址。</p>
<p>通过 dyld 加载主程序链接到的所有依赖库，执行符号绑定也就是non lazy binding。绑定解析其他模块的功能和数据的引用过程，也叫导入符号。</p>
<h3 id="导入导出符号"><a href="#导入导出符号" class="headerlink" title="导入导出符号"></a>导入导出符号</h3><p>执行绑定时，链接程序会用实际定义的地址替换程序的每个导入引用。通过构建时的选项设置，dyld 可以即时绑定，也叫延迟绑定，首次使用引用时的绑定，在使用符号前不会将程序的引用绑定到共享库的符号。使用 -bind_at_load 可以加载时绑定，动态链接程序在加载程序时立即绑定所有导入的引用，如果没有设置这个选项，默认按即时绑定来。设置 -prebind，程序引用的共享库都会在指定的地址预先绑定。</p>
<p>根据 Code Fragment Manager 设计的弱引用允许程序有选择的绑定到指定的共享库，如果 dyld 找不到弱引用的定义，会设置为 NULL，然后可以继续加载程序。代码上可以写判断，如果引用为空进行相应的处理。</p>
<p>过程链接表 PLT，会在运行时确定函数地址。callq 指令在 dyld_stub 调用 PLT 条目，符号 stub 位于 <strong>TEXT Segment 的 </strong>stubs Section 中。每个 Mach-O 符号 stub 都是一个 jumpq 指令，它会调用 dyld 找到符号，然后执行。</p>
<p>Mach-O 的导入和导出都会存在 __LINKEDIT 里。使用 FSA 接受 Leb128 参数，也就是绑定操作码。LEB 会把整数值编码成可变长度的字节序列，最后一个字节才设置最高有效位。</p>
<p>当 FSA 循环或递归时，会用0xF0对其进行掩码获得操作码，所有导入绑定操作码都会对应有宏名称和对应的功能。比如 0xb0 对应宏是 BIND_OPCODE_DO_BIND_ADD_ADDR_IMM_SCALED，功能是将记录放到导入堆栈中，然后把当前记录的地址偏移量设为 seg_offset = seg_offset + (scale * sizeofptr) + sizeofptr ，其中 scale 是立即数中包含的值，sizeofptr 是指针对应平台的大小。</p>
<p>Mach-O 导出符号是 <a href="https://en.wikipedia.org/wiki/Trie" target="_blank" rel="external">trie</a> 的数据结构，trie 节点最多有一个终端字符串信息，如果没有终端信息，就以0x00字节标记。有的化，就用 Leb128 代替该节点的终端字符串信息大小。节点导出信息后，类型信息类型使用0x3对标志进行位掩码获得。0x00表示常规符号，0x01表示线程本地符号，0x02标识绝对符号，0x4表示弱引用符号，0x8表示重新导出，0x10是 stub，具有 Leb128的 stub 偏移量。大部分符号都是常规符号，会将 Mach-O 的偏移量给符号。</p>
<p>生成 trie 数据结构的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> MachOFileLayout::buildExportTrie() &#123;</div><div class="line">  <span class="keyword">if</span> (_file.exportInfo.empty())</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// For all temporary strings and objects used building trie.</span></div><div class="line">  BumpPtrAllocator allocator;</div><div class="line"></div><div class="line">  <span class="comment">// Build trie of all exported symbols.</span></div><div class="line">  <span class="keyword">auto</span> *rootNode = <span class="keyword">new</span> (allocator) TrieNode(StringRef());</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrieNode*&gt; allNodes;</div><div class="line">  allNodes.reserve(_file.exportInfo.size()*<span class="number">2</span>);</div><div class="line">  allNodes.push_back(rootNode);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Export&amp; entry : _file.exportInfo) &#123;</div><div class="line">    rootNode-&gt;addSymbol(entry, allocator, allNodes);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrieNode*&gt; orderedNodes;</div><div class="line">  orderedNodes.reserve(allNodes.size());</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> Export&amp; entry : _file.exportInfo)</div><div class="line">    rootNode-&gt;addOrderedNodes(entry, orderedNodes);</div><div class="line"></div><div class="line">  <span class="comment">// Assign each node in the vector an offset in the trie stream, iterating</span></div><div class="line">  <span class="comment">// until all uleb128 sizes have stabilized.</span></div><div class="line">  <span class="keyword">bool</span> more;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="keyword">uint32_t</span> offset = <span class="number">0</span>;</div><div class="line">    more = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (TrieNode* node : orderedNodes) &#123;</div><div class="line">      <span class="keyword">if</span> (node-&gt;updateOffset(offset))</div><div class="line">        more = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">while</span> (more);</div><div class="line"></div><div class="line">  <span class="comment">// Serialize trie to ByteBuffer.</span></div><div class="line">  <span class="keyword">for</span> (TrieNode* node : orderedNodes) &#123;</div><div class="line">    node-&gt;appendToByteBuffer(_exportTrie);</div><div class="line">  &#125;</div><div class="line">  _exportTrie.align(_is64 ? <span class="number">8</span> : <span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Trie 也叫数字树或前缀树，是一种搜索树。查找复杂度 O(m)，m 是字符串的长度。和散列表相比，散列最差复杂度是 O(N)，一般都是 O(1)，用 O(m)时间评估 hash。散列缺点是会分配一大块内存，内容越多所占内存越大。Trie 不仅查找快，插入和删除都很快，适合存储预测性文本或自动完成词典。为了进一步优化所占空间，可以将 Trie 这种树形的确定性有限自动机压缩成确定性非循环有限状态自动体（DAFSA），其空间小，做法是会压缩相同分支。对于更大内容，还可以做更进一步的优化，比如使用字母缩减的实现技术，把原来的字符串重新解释为较长的字符串；使用单链式列表，节点设计为由符号、子节点、下一个节点来表示；将字母表数组存储为代表 ASCII 字母表的256位的位图。</p>
<p>对于动态库，有几个易于理解的公共符号比导出所有符号更易于使用，让公共符号集少，私有符号集丰富，维护起来更加方便。更新时也不会影响较早版本。导出最少数量的符号，还能够优化动态加载程序到进程的时间，动态库导出符号越少，dyld 加载就越快。</p>
<p>静态存储类是表明不想导出符号的最简单的方法。将可见性属性放置在实现文件中的符号定义里，设置符号可见性也能够更精确的控制哪些符号是公共符号还是私有符号。在编译选项 -fvisbility 可以指定未指定可见性符号的可见性。使用 -weak_library 选项会告诉编译器将库里所有导出符号都设为弱链接符号。使用 nm 的 -gm 选项可以查看 Mach-O 导出的符号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nm -gm header.dylib</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(undefined) external ___cxa_atexit (from libSystem)</div><div class="line">(undefined) external _printf (from libSystem)</div><div class="line">(undefined) <span class="function">external <span class="title">dyld_stub_binder</span> <span class="params">(from libSystem)</span></span></div></pre></td></tr></table></figure>
<p>另外可以通过导出的符号文件，列出要导出的符号来控制导出符号数量，其他符号都会被隐藏。导出符号文件 list 如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_foo</div><div class="line">_header</div></pre></td></tr></table></figure>
<p>使用 -exported_symbols_list 选项编译就可以仅导出文件中指定的符号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">clang -dynamiclib header.c -exported_symbols_list <span class="built_in">list</span> -o header.dylib</div></pre></td></tr></table></figure>
<h3 id="符号绑定范围"><a href="#符号绑定范围" class="headerlink" title="符号绑定范围"></a>符号绑定范围</h3><p>符号可能存在与多个作用域级别。未定义的外部符号是在当前文件之外的文件中，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> count;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<p>私有定义符号，其他模块不可见</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> count;</div></pre></td></tr></table></figure>
<p>私有外部符号可以使用 <strong>private_extern</strong>关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__private_extern__ <span class="keyword">int</span> count = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<p>指定一个函数为弱引用，可以使用 weak_import 属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void foo(void) __attribute__((weak_import));</div></pre></td></tr></table></figure>
<p>在符号声明中添加 weak 属性来指定将符号设置为合并的弱引用：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void foo(void) __attribute__((weak));</div></pre></td></tr></table></figure>
<h3 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h3><p>符号绑定结果放到 LC_DYSYMTAB 指定的 section，解析后的地址会放到 <strong>DATA segment 的 </strong>nl_symbol_ptr 和 <strong>got 里。dyld 使用 Load Command 指定 Mach-O 中的数据以各种方式链接依赖项。Mach-O 的 Segment 按照 Load Command 中指定映射到内存中。 初始化后，会调用 LC_MAIN 指定的入口点，这个点是 </strong>TEXT Segment 的 <strong>text Section 的开始。使用 </strong>stubs 将 <strong>la_symbol_ptr 指向 </strong>stub_helpers，dyld_stub_binder 执行解析，然后更新 __la_symbol_ptr 的地址。</p>
<p>Mach-O 和链接器之间是通过 assembly trampoline 进行的桥接，Mach-O 接口的 ABI 和 ELF 相同，但策略不同。macOS 在调用 dyld 前后都会保存和恢复 SSE 寄存器。</p>
<h3 id="动态库构造函数和析构函数"><a href="#动态库构造函数和析构函数" class="headerlink" title="动态库构造函数和析构函数"></a>动态库构造函数和析构函数</h3><p>动态库加载可能需要执行特殊的初始化或者需要做些准备工作，这里可以使用初始化函数也就是构造函数。结束的时候可以加析构函数。</p>
<p>举个例子，先定义一个 header.c，在里面加上构造函数和析构函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line">__attribute__((constructor))</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"prepare"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((destructor))</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"end"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showHeader</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"header"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 header.c 构建成一个动态库 header.dylib。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang -dynamiclib header.c -fvisibility=hidden -o header.dylib</div></pre></td></tr></table></figure>
<p>将 header.dylib 和 main.c 构建成一个中间目标文件 main.o。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun clang main.c header.dylib -o main</div></pre></td></tr></table></figure>
<p>运行看结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ming@mingdeMacBook-Pro macho_demo % ./main <span class="string">"hi"</span></div><div class="line">prepare</div><div class="line">hi</div><div class="line">end</div></pre></td></tr></table></figure>
<p>可以看到，动态库的构造函数 prepare 和析构函数 end 都执行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Mach-O 的全称是 Mach Object File Format。可以是可执行文件，目标代码或共享库，动态库。Mach 内核的操作系统
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Apple" scheme="http://ming1016.github.io/tags/Apple/"/>
    
      <category term="Mach-O" scheme="http://ming1016.github.io/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>在快手做分享、无用类检查、在广州做 SwiftUI 学习笔记分享、InfoQ二叉树视频</title>
    <link href="http://ming1016.github.io/2020/01/05/kuaishou-unused-class-swiftui-note-binary-tree-interview/"/>
    <id>http://ming1016.github.io/2020/01/05/kuaishou-unused-class-swiftui-note-binary-tree-interview/</id>
    <published>2020-01-05T07:57:05.000Z</published>
    <updated>2020-01-05T12:37:35.887Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在快手做分享"><a href="#在快手做分享" class="headerlink" title="在快手做分享"></a>在快手做分享</h2><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/00.jpeg" alt=""></p>
<p>前滴滴同事邀请我去快手做分享。下面是分享时的 Slides：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/01.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/02.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/03.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/04.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/05.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/06.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/07.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/08.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/09.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/10.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/11.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/12.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/13.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/14.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/15.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/16.png" alt=""></p>
<p>详细文章介绍：<a href="https://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/">如何对 iOS 启动阶段耗时进行分析 | 星光社 - 戴铭的博客</a></p>
<p>代码：<a href="https://github.com/ming1016/MethodTraceAnalyze" target="_blank" rel="external">GitHub - ming1016/MethodTraceAnalyze: 方法耗时分析</a></p>
<h2 id="无用类检查"><a href="#无用类检查" class="headerlink" title="无用类检查"></a>无用类检查</h2><p>如果包里有一堆没用的类，不光会影响用户下载速度，也会影响启动加载速度。检查无用类，一次是无法获得全部无用类的，因为无用的类里用了其他无用的类就算是有用了，所以需要进行递归查找，这样才能够连根拔起。这个过程如果是手动做比较费劲、收益无法一次评估，很难推动。同时还需要在线上灰度运行时检查实际类的使用情况，很多静态层面关联的类使用，实际运行过程中也可能用不到。</p>
<p>思路和关键代码如下。</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>使用 <a href="https://github.com/ming1016/MethodTraceAnalyze" target="_blank" rel="external">MethodTraceAnalyze</a> 里 ParseOC 类的 ocNodes 函数，通过传入 workspace 路径获取所有节点的结构体 OCNode。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> allNodes = <span class="type">ParseOC</span>.ocNodes(workspacePath: workSpacePath)</div></pre></td></tr></table></figure>
<p>找出类型是方法的结构体，因为类的初始化和使用都是在这些方法中进行的。OCNode 针对不同类型所存储的数据也是不同的，所以我定义一个 OCNodeValueProtocol 协议属性，这样就可以针对不同类型的节点存储不同的数据。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">OCNodeDefaultValue</span>: <span class="title">OCNodeValueProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> defaultValue: <span class="type">String</span></div><div class="line">    <span class="keyword">init</span>() &#123;</div><div class="line">        defaultValue = <span class="string">""</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">OCNodeMethod</span>: <span class="title">OCNodeValueProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> belongClass: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> methodName: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> tokenNodes: [<span class="type">OCTokenNode</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">OCNodeClass</span>: <span class="title">OCNodeValueProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> className: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> baseClass: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> hMethod: [<span class="type">String</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> mMethod: [<span class="type">String</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> baseClasses: [<span class="type">String</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到对方法类型会存所属类、方法名和方法内所有 token以便进行进一步分析。对类这种类型会记录他的基类、类名、头文件方法列表和实现文件方法列表，还用一个栈记录继承链。</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>获取所有类的节点，通过对方法内所有 token 的分析来看使用了哪些类，并记录使用的类。</p>
<p>获取所有类节点的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取所有类节点</span></div><div class="line"><span class="keyword">var</span> allClassSet:<span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()</div><div class="line"><span class="keyword">for</span> aNode <span class="keyword">in</span> allNodes &#123;</div><div class="line">    <span class="keyword">if</span> aNode.type == .<span class="keyword">class</span> &#123;</div><div class="line">        <span class="keyword">let</span> classValue = aNode.value <span class="keyword">as</span>! <span class="type">OCNodeClass</span></div><div class="line">        allClassSet.insert(classValue.className)</div><div class="line">        <span class="keyword">if</span> classValue.baseClass.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">            baseClasses.insert(classValue.baseClass)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125; <span class="comment">// end for aNode in allNodes</span></div></pre></td></tr></table></figure>
<p>记录使用的类关键代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">parseAMethodUsedClass</span><span class="params">(node: OCNode, allClass: Set&lt;String&gt;)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    <span class="keyword">var</span> usedClassSet:<span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()</div><div class="line">    <span class="keyword">guard</span> node.type == .method <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> usedClassSet</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> methodValue:<span class="type">OCNodeMethod</span> = node.value <span class="keyword">as</span>! <span class="type">OCNodeMethod</span></div><div class="line">    <span class="keyword">for</span> aNode <span class="keyword">in</span> methodValue.tokenNodes &#123;</div><div class="line">        <span class="keyword">if</span> allClass.<span class="built_in">contains</span>(aNode.value) &#123;</div><div class="line">            usedClassSet.insert(aNode.value)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> usedClassSet</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>有了所有使用的类和所有的类，就能够获取没用到的类。为了跑一次就能够将所有没用的类找出，所以需要在找到无用类后，将这些类自动去掉再进行下一次查找。我这里写了个递归来干这件事。具体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> recursiveCount = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursiveCheckUnUsedClass</span><span class="params">(unUsed:Set&lt;String&gt;)</span></span> -&gt; <span class="type">Set</span>&lt;<span class="type">String</span>&gt; &#123;</div><div class="line">    recursiveCount += <span class="number">1</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"into recursive!!!!第<span class="subst">\(recursiveCount)</span>次"</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"----------------------\n"</span>)</div><div class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> unUsed &#123;</div><div class="line">        <span class="built_in">print</span>(a)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> unUsedClassSet = unUsed</div><div class="line">    </div><div class="line">    <span class="comment">// 缩小范围</span></div><div class="line">    <span class="keyword">for</span> aUnUsed <span class="keyword">in</span> unUsedClassSet &#123;</div><div class="line">        <span class="keyword">if</span> allClassSet.<span class="built_in">contains</span>(aUnUsed) &#123;</div><div class="line">            allClassSet.remove(aUnUsed)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> allUsedClassSet:<span class="type">Set</span>&lt;<span class="type">String</span>&gt; = <span class="type">Set</span>()</div><div class="line">    <span class="keyword">for</span> aNode <span class="keyword">in</span> allNodes &#123;</div><div class="line">        <span class="keyword">if</span> aNode.type == .method &#123;</div><div class="line">            <span class="keyword">let</span> nodeValue:<span class="type">OCNodeMethod</span> = aNode.value <span class="keyword">as</span>! <span class="type">OCNodeMethod</span></div><div class="line">            <span class="comment">// 过滤已判定无用类里的方法</span></div><div class="line">            <span class="keyword">guard</span> !unUsedClassSet.<span class="built_in">contains</span>(nodeValue.belongClass) <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> usedSet = <span class="type">ParseOCMethodContent</span>.parseAMethodUsedClass(node: aNode, allClass: allClassSet)</div><div class="line">            <span class="keyword">if</span> usedSet.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">                <span class="keyword">for</span> aSet <span class="keyword">in</span> usedSet &#123;</div><div class="line">                    allUsedClassSet.insert(aSet)</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="comment">// end if usedSet.count &gt; 0</span></div><div class="line">        &#125; <span class="comment">// end if aNode.type == .method</span></div><div class="line">    &#125; <span class="comment">// end for aNode in allNodes</span></div><div class="line">    <span class="keyword">var</span> hasUnUsed = <span class="literal">false</span></div><div class="line">    <span class="comment">// 找出无用类</span></div><div class="line">    <span class="keyword">for</span> aSet <span class="keyword">in</span> allClassSet &#123;</div><div class="line">        <span class="keyword">if</span> !allUsedClassSet.<span class="built_in">contains</span>(aSet) &#123;</div><div class="line">            unUsedClassSet.insert(aSet)</div><div class="line">            hasUnUsed = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> hasUnUsed &#123;</div><div class="line">        <span class="comment">// 如果发现还有无用的类，需要继续递归调用进行分析</span></div><div class="line">        <span class="keyword">return</span> recursiveCheckUnUsedClass(unUsed: unUsedClassSet)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> unUsedClassSet</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 递归调用</span></div><div class="line"><span class="keyword">var</span> unUsedClassFromRecursive = recursiveCheckUnUsedClass(unUsed: <span class="type">Set</span>&lt;<span class="type">String</span>&gt;())</div></pre></td></tr></table></figure>
<p>通过递归进行多次能够取到最终的结果。</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>对于继承和系统的类还需要进行过滤，进一步提高准确性。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> unUsedClassSetCopy = unUsedClassFromRecursive</div><div class="line"><span class="keyword">for</span> aSet <span class="keyword">in</span> unUsedClassSetCopy &#123;</div><div class="line">    <span class="comment">// 过滤系统控件</span></div><div class="line">    <span class="keyword">let</span> filters = [<span class="string">"NS"</span>,<span class="string">"UI"</span>]</div><div class="line">    <span class="keyword">var</span> shouldFilter = <span class="literal">false</span></div><div class="line">    <span class="keyword">for</span> <span class="built_in">filter</span> <span class="keyword">in</span> filters &#123;</div><div class="line">        <span class="keyword">if</span> aSet.hasPrefix(<span class="built_in">filter</span>) &#123;</div><div class="line">            shouldFilter = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 过滤基类</span></div><div class="line">    <span class="keyword">if</span> baseClasses.<span class="built_in">contains</span>(aSet) &#123;</div><div class="line">        shouldFilter = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 开始过滤</span></div><div class="line">    <span class="keyword">if</span> shouldFilter &#123;</div><div class="line">        unUsedClassFromRecursive.remove(aSet)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>清理了通过这种静态扫描出的无用类，还可以通过运行时来判断类是否被初始化了，从而找出无用类。类运行时是否初始化的这个信息是个布尔值，叫 isInitialized，存储在元类 class_rw_t 结构体的 flags 字段里，在 1&lt;&lt;29 位记录。</p>
<p>完整代码见 ParseOCMethodContent 文件：<a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCMethodContent.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseOCMethodContent.swift at master · ming1016/MethodTraceAnalyze · GitHub</a></p>
<h2 id="在广州做的-SwiftUI-学习笔记分享"><a href="#在广州做的-SwiftUI-学习笔记分享" class="headerlink" title="在广州做的 SwiftUI 学习笔记分享"></a>在广州做的 SwiftUI 学习笔记分享</h2><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/45.jpg" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/46.jpg" alt=""></p>
<p>下面是笔记内容：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/24.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/25.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/26.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/27.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/28.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/29.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/30.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/31.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/32.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/33.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/34.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/35.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/36.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/37.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/38.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/39.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/40.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/41.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/42.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/43.png" alt=""><br><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/44.png" alt=""></p>
<p>推荐喵神的 SwiftUI 新书，<a href="https://objccn.io/products/swift-ui" target="_blank" rel="external">ObjC 中国 - SwiftUI 与 Combine 编程</a>。</p>
<p>这本介绍 Combine 的书也介绍的非常详细：<a href="https://heckj.github.io/swiftui-notes/" target="_blank" rel="external">Using Combine</a></p>
<p>这个网站有大量 SwiftUI 的控件使用范例可以参考：<a href="https://www.hackingwithswift.com/quick-start/swiftui" target="_blank" rel="external">SwiftUI by Example - free quick start tutorials for Swift developers</a></p>
<p>这个博客每篇都是 SwiftUI 相关的，而且更新非常频繁：<a href="https://swiftwithmajid.com/" target="_blank" rel="external">Home | Majid’s blog about Swift development</a></p>
<h2 id="InfoQ二叉树视频"><a href="#InfoQ二叉树视频" class="headerlink" title="InfoQ二叉树视频"></a>InfoQ二叉树视频</h2><p>五分钟的视频，在导演构思下需要一天在四个地方进行拍摄，由于前一天晚上庆功宴喝高了，拍摄当天 iPad 笔也忘带了，头还有些懵。导演中午饭都没吃专门回家拿了他的笔给我用。下午地点安排在央美，先访谈再画一张。北京电影学院毕业14年专业绘画经验的导演贾成斌，在我画时边帮我改画边传授了经验，我觉得这些经验会让我更进一步。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/17.jpg" alt=""></p>
<p>下面是记者剡沛在 InfoQ 上发布的采访内容和视频，原文在：<a href="https://mp.weixin.qq.com/s/Xz2TcGjG14AXr_zmXMwUxg" target="_blank" rel="external">“创造，就值得被肯定”，一名程序员的艺术人生丨二叉树视频</a></p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/18.jpg" alt=""></p>
<p>他是一名程序员，同时也用自己的业余时间画画。无论是技术分享还是珍藏回忆，他都用画笔记录自己，连接他人。他觉得程序员很酷，无论编程还是画画，都是在创造，这就是最值得肯定的事情。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/19.jpg" alt=""></p>
<p>他在高德负责架构研发工作，也是大家眼中的艺术家，在他身上总能看到那些执念与决心，它们发着光，无时无刻不影响着周围的人。</p>
<p>他就是戴铭，一名酷酷的程序员。</p>
<p>当聊到”连接“这个词的时候，他的眼神异常坚定。</p>
<p>他觉得自己坚持创作，坚持做很多没有门槛的技术分享，很大一部分动力就来自这种渴望，渴望连接自己的过去，也渴望连接他人。</p>
<p>他就是戴铭，一个有点酷，还有点文艺的程序员，在高德地图负责架构研发工作。除了把自己活的很年轻，在他身上总能看到一些发着光的东西。</p>
<p>“是信念吗？”</p>
<p>“是执念。”</p>
<h3 id="“当漫画家，可能连饭都吃不饱。”"><a href="#“当漫画家，可能连饭都吃不饱。”" class="headerlink" title="“当漫画家，可能连饭都吃不饱。”"></a>“当漫画家，可能连饭都吃不饱。”</h3><p>故事的开头，多少有些遗憾。</p>
<p>戴铭最早接触画画，是小学之前报过的一个高阶国画班，因为老师在上海，所以他每画完一张都要寄过去并等待回信，当其中一幅画改到第三遍的时候老师回信说：这孩子可能没什么天赋。因为这件事，当时戴铭心里对画画的渴望，几乎降到了冰点，对于画画的兴趣也就此搁置。</p>
<p>直到六年级的一次美术作业，平时酷爱看漫画的戴铭，才再一次下定决心把自己喜欢的角色搬到纸上。</p>
<p>“同学都说画的太像了，那种被再次肯定的开心，很难忘记。”</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/21.jpg" alt=""></p>
<p>后来整个初中，戴铭都在课余时间画漫画，也没再报班，一直到初中毕业戴铭跟父亲说不想上学了，“想去画漫画，做一名漫画家”。不难预料，这个想法并没有得到父亲的支持，“当漫画家，可能连饭都吃不饱”。</p>
<p>但从戴铭的话语中，并没有因为父亲这次选择而听到丝毫气馁，似乎心里的种子已经生根。</p>
<p>“兴趣不是说喜欢漫画，就要去从事漫画。当我们从被动的行为中获得成就感时，也会在无形中培养出兴趣，画画如此，编程也是一样。“</p>
<h3 id="“我不想让自己投入了生命的热爱，停滞不前。”"><a href="#“我不想让自己投入了生命的热爱，停滞不前。”" class="headerlink" title="“我不想让自己投入了生命的热爱，停滞不前。”"></a>“我不想让自己投入了生命的热爱，停滞不前。”</h3><p>“从那后来，就一直在坚持画画了。”</p>
<p>从临摹简单的漫画，到更复杂的画风、更多元的角色，再到临摹写实人物、影视剧照，期间还专门自学过素描，直到现在的再创作，戴铭除了把自己的爱好和回忆画出来，还把自己的专业内容做成漫画，用更容易传达的方式去做每一次技术分享。</p>
<p>“大概是从四、五年前开始，空闲的时候会花很长的时间画画，平时每天也会挤出一个多小时坚持练手，因为我不希望自己热爱的东西，停滞不前，兴趣不该只是兴趣而已。”</p>
<p>后来戴铭接触了数绘，就开始把很多创作留在屏幕上。</p>
<p>“用 ipad 画，更适合我现在的角色，因为可以随时开始和结束，不受环境和工具的影响，另一方面数字绘图也让他的作品在色彩方面，有了更多的提升空间。”</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/22.jpg" alt=""></p>
<p>从容地掏出平板，只要自己想，就能随时还原周遭的一切。这种感觉，就跟戴铭看待程序员时的表达一样，“都是很酷的事情，因为无论程序员的人还是艺术家，他们都在创造新的事物，仅这一点，就值得被肯定。”</p>
<h3 id="“工作不用心的人，生活也不会太精彩”"><a href="#“工作不用心的人，生活也不会太精彩”" class="headerlink" title="“工作不用心的人，生活也不会太精彩”"></a>“工作不用心的人，生活也不会太精彩”</h3><p>类似画画这种需要大量时间去“熬”的爱好，坚持总是最难的部分。</p>
<p>“时间永远都是紧缺的，这是肯定。如果工作很忙，就先把时间全部投入到工作上，用最快的速度做好、做完，才能有更多的精力和心情去做其他事情”。</p>
<p>戴铭上一份工作在滴滴，刚入职就希望拓宽自己的能力范围，几乎承担整个部门的研发任务，后来临近发版 Bug 实在解不完，第二天来公司发现都被领导默默解掉了，才意识到一个人的力量始终有限，“一个手指，肯定比不过一个拳头的力量。”</p>
<p>即便如此，戴铭也始终保持着对工作的热血，当时间不够用的时候，他会换个角度去看待问题。</p>
<p>“我觉得工作上面不上心、不拼命的人，生活也不会太精彩。工作是跟每个人的一生切实相关的事情，如果连这个都做不好，又如何能在其他事情上更用心的经营？”</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/23.jpg" alt=""></p>
<p>时间看透了，剩下的就是坚持。</p>
<p>当聊到坚持的原动力时，除了用回忆和分享去推动自己，在戴铭身上总散发着一股劲儿。一个兴趣爱好而已，谈信念可能过于悲壮，所以他认为，这股劲儿更像是决心和执念。</p>
<p>有刚入进入滴滴时，想肩扛所有工作的执念；</p>
<p>有为了兴趣上一个台阶，努力获得央美朋友肯定的执念；</p>
<p>也有怕自己的作品破坏了心中的完美角色，重复打磨的执念。</p>
<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>戴铭是很强大的人，他讲过的一段话令人印象深刻：</p>
<p>“幸福是面对过去，恐惧是面对未知的未来。我也忘记是从哪里看到的这句话，但我自己会这样理解：回忆是让人幸福的，未知是令人恐惧的。但如果我们沉湎在回忆中不敢面对未来，幸福始终是有限的，当我们用决心去面对未来，幸福就会越来越多，恐惧也会越来越少。”</p>
<p>裹着决心这把利剑，酷酷的戴铭就这样用代码和画笔勾勒着自己的一生，而画卷展开的部分就已经足够精彩，余下的，定会更值得期待。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/20.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在快手做分享&quot;&gt;&lt;a href=&quot;#在快手做分享&quot; class=&quot;headerlink&quot; title=&quot;在快手做分享&quot;&gt;&lt;/a&gt;在快手做分享&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/uploads/kuaishou-unused-class-swiftui-note-
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="SwiftUI" scheme="http://ming1016.github.io/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>日本游玩</title>
    <link href="http://ming1016.github.io/2019/12/28/japan-travel/"/>
    <id>http://ming1016.github.io/2019/12/28/japan-travel/</id>
    <published>2019-12-28T01:21:26.000Z</published>
    <updated>2020-01-06T04:07:54.724Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li>从羽田机场到酒店</li>
<li>秋叶原</li>
<li>从银座回酒店</li>
<li>浅草寺</li>
<li>新宿</li>
<li>涉谷</li>
<li>藤子不二雄博物馆</li>
<li>镰仓</li>
<li>台场</li>
<li>东京迪斯尼海洋</li>
<li>大阪</li>
<li>大阪环球影城</li>
<li>大阪海洋馆</li>
<li>京都晴鸭楼</li>
<li>清水寺</li>
<li>晴空塔</li>
<li>山鹰市</li>
<li>东京迪斯尼</li>
<li>下北泽</li>
<li>东京皇宫</li>
<li>上野 Mandarake</li>
<li>表参道</li>
<li>吉祥寺</li>
<li>京都站</li>
<li>岚山</li>
<li>京都国际漫画博物馆</li>
<li>大阪城</li>
<li>道顿掘</li>
</ol>
<p><img src="/uploads/japan-travel/01.JPG" alt=""><br><img src="/uploads/japan-travel/02.JPG" alt=""><br><img src="/uploads/japan-travel/03.JPG" alt=""><br><img src="/uploads/japan-travel/04.JPG" alt=""><br><img src="/uploads/japan-travel/05.JPG" alt=""><br><img src="/uploads/japan-travel/06.JPG" alt=""><br><img src="/uploads/japan-travel/07.JPG" alt=""><br><img src="/uploads/japan-travel/08.JPG" alt=""><br><img src="/uploads/japan-travel/09.JPG" alt=""><br><img src="/uploads/japan-travel/10.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/11.JPG" alt=""><br><img src="/uploads/japan-travel/12.JPG" alt=""><br><img src="/uploads/japan-travel/13.JPG" alt=""><br><img src="/uploads/japan-travel/14.JPG" alt=""><br><img src="/uploads/japan-travel/15.JPG" alt=""><br><img src="/uploads/japan-travel/16.JPG" alt=""><br><img src="/uploads/japan-travel/17.JPG" alt=""><br><img src="/uploads/japan-travel/18.JPG" alt=""><br><img src="/uploads/japan-travel/19.JPG" alt=""><br><img src="/uploads/japan-travel/20.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/21.JPG" alt=""><br><img src="/uploads/japan-travel/22.JPG" alt=""><br><img src="/uploads/japan-travel/23.JPG" alt=""><br><img src="/uploads/japan-travel/24.JPG" alt=""><br><img src="/uploads/japan-travel/25.JPG" alt=""><br><img src="/uploads/japan-travel/26.JPG" alt=""><br><img src="/uploads/japan-travel/27.JPG" alt=""><br><img src="/uploads/japan-travel/28.JPG" alt=""><br><img src="/uploads/japan-travel/29.JPG" alt=""><br><img src="/uploads/japan-travel/30.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/31.JPG" alt=""><br><img src="/uploads/japan-travel/32.JPG" alt=""><br><img src="/uploads/japan-travel/33.JPG" alt=""><br><img src="/uploads/japan-travel/34.JPG" alt=""><br><img src="/uploads/japan-travel/35.JPG" alt=""><br><img src="/uploads/japan-travel/36.JPG" alt=""><br><img src="/uploads/japan-travel/37.JPG" alt=""><br><img src="/uploads/japan-travel/38.JPG" alt=""><br><img src="/uploads/japan-travel/39.JPG" alt=""><br><img src="/uploads/japan-travel/40.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/41.JPG" alt=""><br><img src="/uploads/japan-travel/42.JPG" alt=""><br><img src="/uploads/japan-travel/43.JPG" alt=""><br><img src="/uploads/japan-travel/44.JPG" alt=""><br><img src="/uploads/japan-travel/45.JPG" alt=""><br><img src="/uploads/japan-travel/46.JPG" alt=""><br><img src="/uploads/japan-travel/47.JPG" alt=""><br><img src="/uploads/japan-travel/48.JPG" alt=""><br><img src="/uploads/japan-travel/49.JPG" alt=""><br><img src="/uploads/japan-travel/50.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/51.JPG" alt=""><br><img src="/uploads/japan-travel/52.JPG" alt=""><br><img src="/uploads/japan-travel/53.JPG" alt=""><br><img src="/uploads/japan-travel/54.JPG" alt=""><br><img src="/uploads/japan-travel/55.JPG" alt=""><br><img src="/uploads/japan-travel/56.JPG" alt=""><br><img src="/uploads/japan-travel/57.JPG" alt=""><br><img src="/uploads/japan-travel/58.JPG" alt=""><br><img src="/uploads/japan-travel/59.JPG" alt=""><br><img src="/uploads/japan-travel/60.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/61.JPG" alt=""><br><img src="/uploads/japan-travel/62.JPG" alt=""><br><img src="/uploads/japan-travel/63.JPG" alt=""><br><img src="/uploads/japan-travel/64.JPG" alt=""><br><img src="/uploads/japan-travel/65.JPG" alt=""><br><img src="/uploads/japan-travel/66.JPG" alt=""><br><img src="/uploads/japan-travel/67.JPG" alt=""><br><img src="/uploads/japan-travel/68.JPG" alt=""><br><img src="/uploads/japan-travel/69.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/70.JPG" alt=""><br><img src="/uploads/japan-travel/71.JPG" alt=""><br><img src="/uploads/japan-travel/72.JPG" alt=""><br><img src="/uploads/japan-travel/73.JPG" alt=""><br><img src="/uploads/japan-travel/74.JPG" alt=""><br><img src="/uploads/japan-travel/75.JPG" alt=""><br><img src="/uploads/japan-travel/76.JPG" alt=""><br><img src="/uploads/japan-travel/77.JPG" alt=""><br><img src="/uploads/japan-travel/78.JPG" alt=""><br><img src="/uploads/japan-travel/79.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/80.JPG" alt=""><br><img src="/uploads/japan-travel/81.JPG" alt=""><br><img src="/uploads/japan-travel/82.JPG" alt=""><br><img src="/uploads/japan-travel/83.JPG" alt=""><br><img src="/uploads/japan-travel/84.JPG" alt=""><br><img src="/uploads/japan-travel/85.JPG" alt=""><br><img src="/uploads/japan-travel/86.JPG" alt=""><br><img src="/uploads/japan-travel/87.JPG" alt=""><br><img src="/uploads/japan-travel/88.JPG" alt=""><br><img src="/uploads/japan-travel/89.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/90.JPG" alt=""><br><img src="/uploads/japan-travel/91.JPG" alt=""><br><img src="/uploads/japan-travel/92.JPG" alt=""><br><img src="/uploads/japan-travel/93.JPG" alt=""><br><img src="/uploads/japan-travel/94.JPG" alt=""><br><img src="/uploads/japan-travel/95.JPG" alt=""><br><img src="/uploads/japan-travel/96.JPG" alt=""><br><img src="/uploads/japan-travel/97.JPG" alt=""><br><img src="/uploads/japan-travel/98.JPG" alt=""><br><img src="/uploads/japan-travel/99.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/100.JPG" alt=""><br><img src="/uploads/japan-travel/101.JPG" alt=""><br><img src="/uploads/japan-travel/102.JPG" alt=""><br><img src="/uploads/japan-travel/103.JPG" alt=""><br><img src="/uploads/japan-travel/104.JPG" alt=""><br><img src="/uploads/japan-travel/105.JPG" alt=""><br><img src="/uploads/japan-travel/106.JPG" alt=""><br><img src="/uploads/japan-travel/107.JPG" alt=""><br><img src="/uploads/japan-travel/108.JPG" alt=""><br><img src="/uploads/japan-travel/109.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/110.JPG" alt=""><br><img src="/uploads/japan-travel/111.JPG" alt=""><br><img src="/uploads/japan-travel/112.JPG" alt=""><br><img src="/uploads/japan-travel/113.JPG" alt=""><br><img src="/uploads/japan-travel/114.JPG" alt=""><br><img src="/uploads/japan-travel/115.JPG" alt=""><br><img src="/uploads/japan-travel/116.JPG" alt=""><br><img src="/uploads/japan-travel/117.JPG" alt=""><br><img src="/uploads/japan-travel/118.JPG" alt=""><br><img src="/uploads/japan-travel/119.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/120.JPG" alt=""><br><img src="/uploads/japan-travel/121.JPG" alt=""><br><img src="/uploads/japan-travel/122.JPG" alt=""><br><img src="/uploads/japan-travel/123.JPG" alt=""><br><img src="/uploads/japan-travel/124.JPG" alt=""><br><img src="/uploads/japan-travel/125.JPG" alt=""><br><img src="/uploads/japan-travel/126.JPG" alt=""><br><img src="/uploads/japan-travel/127.JPG" alt=""><br><img src="/uploads/japan-travel/128.JPG" alt=""><br><img src="/uploads/japan-travel/129.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/130.JPG" alt=""><br><img src="/uploads/japan-travel/131.JPG" alt=""><br><img src="/uploads/japan-travel/132.JPG" alt=""><br><img src="/uploads/japan-travel/133.JPG" alt=""><br><img src="/uploads/japan-travel/134.JPG" alt=""><br><img src="/uploads/japan-travel/135.JPG" alt=""><br><img src="/uploads/japan-travel/136.JPG" alt=""><br><img src="/uploads/japan-travel/137.JPG" alt=""><br><img src="/uploads/japan-travel/138.JPG" alt=""><br><img src="/uploads/japan-travel/139.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/140.JPG" alt=""><br><img src="/uploads/japan-travel/141.JPG" alt=""><br><img src="/uploads/japan-travel/142.JPG" alt=""><br><img src="/uploads/japan-travel/143.JPG" alt=""><br><img src="/uploads/japan-travel/144.JPG" alt=""><br><img src="/uploads/japan-travel/145.JPG" alt=""><br><img src="/uploads/japan-travel/146.JPG" alt=""><br><img src="/uploads/japan-travel/147.JPG" alt=""><br><img src="/uploads/japan-travel/148.JPG" alt=""><br><img src="/uploads/japan-travel/149.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/150.JPG" alt=""><br><img src="/uploads/japan-travel/151.JPG" alt=""><br><img src="/uploads/japan-travel/152.JPG" alt=""><br><img src="/uploads/japan-travel/153.JPG" alt=""><br><img src="/uploads/japan-travel/154.JPG" alt=""><br><img src="/uploads/japan-travel/155.JPG" alt=""><br><img src="/uploads/japan-travel/156.JPG" alt=""><br><img src="/uploads/japan-travel/157.JPG" alt=""><br><img src="/uploads/japan-travel/158.JPG" alt=""><br><img src="/uploads/japan-travel/159.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/160.JPG" alt=""><br><img src="/uploads/japan-travel/161.JPG" alt=""><br><img src="/uploads/japan-travel/162.JPG" alt=""><br><img src="/uploads/japan-travel/163.JPG" alt=""><br><img src="/uploads/japan-travel/164.JPG" alt=""><br><img src="/uploads/japan-travel/165.JPG" alt=""><br><img src="/uploads/japan-travel/166.JPG" alt=""><br><img src="/uploads/japan-travel/167.JPG" alt=""><br><img src="/uploads/japan-travel/168.JPG" alt=""><br><img src="/uploads/japan-travel/169.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/170.JPG" alt=""><br><img src="/uploads/japan-travel/171.JPG" alt=""><br><img src="/uploads/japan-travel/172.JPG" alt=""><br><img src="/uploads/japan-travel/173.JPG" alt=""><br><img src="/uploads/japan-travel/174.JPG" alt=""><br><img src="/uploads/japan-travel/175.JPG" alt=""><br><img src="/uploads/japan-travel/176.JPG" alt=""><br><img src="/uploads/japan-travel/177.JPG" alt=""><br><img src="/uploads/japan-travel/178.JPG" alt=""><br><img src="/uploads/japan-travel/179.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/180.JPG" alt=""><br><img src="/uploads/japan-travel/181.JPG" alt=""><br><img src="/uploads/japan-travel/182.JPG" alt=""><br><img src="/uploads/japan-travel/183.JPG" alt=""><br><img src="/uploads/japan-travel/184.JPG" alt=""><br><img src="/uploads/japan-travel/185.JPG" alt=""><br><img src="/uploads/japan-travel/186.JPG" alt=""><br><img src="/uploads/japan-travel/187.JPG" alt=""><br><img src="/uploads/japan-travel/188.JPG" alt=""><br><img src="/uploads/japan-travel/189.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/190.JPG" alt=""><br><img src="/uploads/japan-travel/191.JPG" alt=""><br><img src="/uploads/japan-travel/192.JPG" alt=""><br><img src="/uploads/japan-travel/193.JPG" alt=""><br><img src="/uploads/japan-travel/194.JPG" alt=""><br><img src="/uploads/japan-travel/195.JPG" alt=""><br><img src="/uploads/japan-travel/196.JPG" alt=""><br><img src="/uploads/japan-travel/197.JPG" alt=""><br><img src="/uploads/japan-travel/198.JPG" alt=""><br><img src="/uploads/japan-travel/199.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/200.JPG" alt=""><br><img src="/uploads/japan-travel/201.JPG" alt=""><br><img src="/uploads/japan-travel/202.JPG" alt=""><br><img src="/uploads/japan-travel/203.JPG" alt=""><br><img src="/uploads/japan-travel/204.JPG" alt=""><br><img src="/uploads/japan-travel/205.JPG" alt=""><br><img src="/uploads/japan-travel/206.JPG" alt=""><br><img src="/uploads/japan-travel/207.JPG" alt=""><br><img src="/uploads/japan-travel/208.JPG" alt=""><br><img src="/uploads/japan-travel/209.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/210.JPG" alt=""><br><img src="/uploads/japan-travel/211.JPG" alt=""><br><img src="/uploads/japan-travel/212.JPG" alt=""><br><img src="/uploads/japan-travel/213.JPG" alt=""><br><img src="/uploads/japan-travel/214.JPG" alt=""><br><img src="/uploads/japan-travel/215.JPG" alt=""><br><img src="/uploads/japan-travel/216.JPG" alt=""><br><img src="/uploads/japan-travel/217.JPG" alt=""><br><img src="/uploads/japan-travel/218.JPG" alt=""><br><img src="/uploads/japan-travel/219.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/220.JPG" alt=""><br><img src="/uploads/japan-travel/221.JPG" alt=""><br><img src="/uploads/japan-travel/222.JPG" alt=""><br><img src="/uploads/japan-travel/223.JPG" alt=""><br><img src="/uploads/japan-travel/224.JPG" alt=""><br><img src="/uploads/japan-travel/225.JPG" alt=""><br><img src="/uploads/japan-travel/226.JPG" alt=""><br><img src="/uploads/japan-travel/227.JPG" alt=""><br><img src="/uploads/japan-travel/228.JPG" alt=""><br><img src="/uploads/japan-travel/229.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/230.JPG" alt=""><br><img src="/uploads/japan-travel/231.JPG" alt=""><br><img src="/uploads/japan-travel/232.JPG" alt=""><br><img src="/uploads/japan-travel/233.JPG" alt=""><br><img src="/uploads/japan-travel/234.JPG" alt=""><br><img src="/uploads/japan-travel/235.JPG" alt=""><br><img src="/uploads/japan-travel/236.JPG" alt=""><br><img src="/uploads/japan-travel/237.JPG" alt=""><br><img src="/uploads/japan-travel/238.JPG" alt=""><br><img src="/uploads/japan-travel/239.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/240.JPG" alt=""><br><img src="/uploads/japan-travel/241.JPG" alt=""><br><img src="/uploads/japan-travel/242.JPG" alt=""><br><img src="/uploads/japan-travel/243.JPG" alt=""><br><img src="/uploads/japan-travel/244.JPG" alt=""><br><img src="/uploads/japan-travel/245.JPG" alt=""><br><img src="/uploads/japan-travel/246.JPG" alt=""><br><img src="/uploads/japan-travel/247.JPG" alt=""><br><img src="/uploads/japan-travel/248.JPG" alt=""><br><img src="/uploads/japan-travel/249.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/250.JPG" alt=""><br><img src="/uploads/japan-travel/251.JPG" alt=""><br><img src="/uploads/japan-travel/252.JPG" alt=""><br><img src="/uploads/japan-travel/253.JPG" alt=""><br><img src="/uploads/japan-travel/254.JPG" alt=""><br><img src="/uploads/japan-travel/255.JPG" alt=""><br><img src="/uploads/japan-travel/256.JPG" alt=""><br><img src="/uploads/japan-travel/257.JPG" alt=""><br><img src="/uploads/japan-travel/258.JPG" alt=""><br><img src="/uploads/japan-travel/259.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/260.JPG" alt=""><br><img src="/uploads/japan-travel/261.JPG" alt=""><br><img src="/uploads/japan-travel/262.JPG" alt=""><br><img src="/uploads/japan-travel/263.JPG" alt=""><br><img src="/uploads/japan-travel/264.JPG" alt=""><br><img src="/uploads/japan-travel/265.JPG" alt=""><br><img src="/uploads/japan-travel/266.JPG" alt=""><br><img src="/uploads/japan-travel/267.JPG" alt=""><br><img src="/uploads/japan-travel/268.JPG" alt=""><br><img src="/uploads/japan-travel/269.JPG" alt=""></p>
<p><img src="/uploads/japan-travel/270.JPG" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;从羽田机场到酒店&lt;/li&gt;
&lt;li&gt;秋叶原&lt;/li&gt;
&lt;li&gt;从银座回酒店&lt;/li&gt;
&lt;li&gt;浅草寺&lt;/li&gt;
&lt;li&gt;新宿&lt;/li&gt;
&lt;li&gt;涉谷&lt;/li&gt;
&lt;li&gt;藤子不二雄博物馆&lt;/li&gt;
&lt;li&gt;镰仓&lt;/li&gt;
&lt;li&gt;台场&lt;/li&gt;
&lt;li&gt;东京迪斯尼
    
    </summary>
    
      <category term="travel" scheme="http://ming1016.github.io/categories/travel/"/>
    
    
      <category term="Japan" scheme="http://ming1016.github.io/tags/Japan/"/>
    
  </entry>
  
  <entry>
    <title>如何对 iOS 启动阶段耗时进行分析</title>
    <link href="http://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/"/>
    <id>http://ming1016.github.io/2019/12/07/how-to-analyze-startup-time-cost-in-ios/</id>
    <published>2019-12-07T01:25:33.000Z</published>
    <updated>2020-05-04T16:09:43.406Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/01.png" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>启动优化一役后，超预期将所负责的 App 双端启动的耗时都降低了65%以上，iOS 在iPhone7上速度达到了400毫秒以内。就像产品们用后说的，快到不习惯。由于 App 日活用户过亿，算一下每天为用户省下的时间，还是蛮有成就感的。</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/01.jpeg" alt=""></p>
<h2 id="启动阶段性能多维度分析"><a href="#启动阶段性能多维度分析" class="headerlink" title="启动阶段性能多维度分析"></a>启动阶段性能多维度分析</h2><p>要优化，先要做到的是对启动阶段各个性能纬度做分析，包括主线程耗时、CPU、内存、I/O、网络。这样才能够更加全面的掌握启动阶段的开销，找出不合理的方法调用。启动越快，更多的方法调用就应该做成按需执行，将启动压力分摊，只留下那些启动后方法都会依赖的方法和库的初始化，比如网络库、Crash 库等。而剩下那些需要预加载的功能可以放到启动阶段后再执行。</p>
<p>启动有哪几种类型，启动有哪些阶段呢？</p>
<p>启动类型分为：</p>
<ul>
<li>Cold：App 重启后启动，不在内存里也没有进程存在。</li>
<li>Warm：App 最近结束后再启动，有部分在内存但没有进程存在。</li>
<li>Resume：App 没结束，只是暂停，全在内存中，进程也存在。</li>
</ul>
<p>分析阶段一般都是针对 Cold 类型进行分析，目的就是要让测试环境稳定。为了稳定测试环境有时还需要找些稳定的机型，对于 iOS 来说iPhone7性能中等，稳定性也不错就很适合，Android 的 Vivo 系列也相对稳定，华为和小米系列数据波动就比较大。除了机型外控制测试机温度也很重要，一旦温度过高系统还会降频执行影响测试数据。有时候还会置飞行模式采用 Mock 网络请求的方式来减少不稳定的网络影响测试数据。最好时重启后退 iCloud 账号，放置一段时间再测，更加准确些。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/05.png" alt=""></p>
<p>了解启动的阶段目的就是聚焦范围，从用户体验上来确定哪个阶段要快，以便能够让用户可视和响应用户操作的时间更快。</p>
<p>简单来说 iOS 启动分为加载 Mach-O 和运行时初始化过程，加载 Mach-O 会先判断加载的文件是不是 Mach-O，通过文件第一个字节，也叫魔数来判断，当是下面四种时可以判定是 Mach-O 文件：</p>
<ul>
<li>0xfeedface 对应的 loader.h 里的宏是 MH_MAGIC</li>
<li>0xfeedfact 宏是 MH_MAGIC_64</li>
<li>NXSwapInt(MH_MAGIC) 宏 MH_GIGAM</li>
<li>NXSwapInt(MH_MAGIC_64) 宏 MH_GIGAM_64</li>
</ul>
<p>Mach-O 分为主要分为 中间对象文件（MH_OBJECT）、可执行二进制（MH_EXECUTE）、VM 共享库文件（MH_FVMLIB）、Crash 产生的 Core 文件（MH_CORE）、preload（MH_PRELOAD）、动态共享库（MH_DYLIB）、动态链接器（MH_DYLINKER）、静态链接文件（MH_DYLIB_STUB）、符号文件和调试信息（MH_DSYM）这几种。确定是 Mach-O 后，内核会 fork 一个进程，execve 开始加载。检查 Mach-O Header。随后加载 dyld 和程序到 Load Command 地址空间。通过 dyld_stub_binder 开始执行 dyld，dyld 会进行 rebase、binding、lazy binding、导出符号，也可以通过 DYLD_INSERT_LIBRARIES 进行 hook。dyld_stub_binder 给偏移量到 dyld 解释特殊字节码 Segment 中，也就是真实地址，把真实地址写入到 la_symbol_ptr 里，跳转时通过 stub 的 jump 指令跳转到真实地址。 dyld 加载所有依赖库，将动态库导出的 trie 结构符号执行符号绑定，也就是 non lazybinding，绑定解析其他模块功能和数据引用过程，就是导入符号。</p>
<p>Trie 也叫数字树或前缀树，是一种搜索树。查找复杂度 O(m)，m 是字符串的长度。和散列表相比，散列最差复杂度是 O(N)，一般都是 O(1)，用 O(m)时间评估 hash。散列缺点是会分配一大块内存，内容越多所占内存越大。Trie 不仅查找快，插入和删除都很快，适合存储预测性文本或自动完成词典。为了进一步优化所占空间，可以将 Trie 这种树形的确定性有限自动机压缩成确定性非循环有限状态自动体（DAFSA），其空间小，做法是会压缩相同分支。对于更大内容，还可以做更进一步的优化，比如使用字母缩减的实现技术，把原来的字符串重新解释为较长的字符串；使用单链式列表，节点设计为由符号、子节点、下一个节点来表示；将字母表数组存储为代表 ASCII 字母表的256位的位图。</p>
<p>尽管 Trie 对于性能会做很多优化，但是符号过多依然会增加性能消耗，对于动态库导出的符号不宜太多，尽量保持公共符号少，私有符号集丰富。这样维护起来也方便，版本兼容性也好，还能优化动态加载程序到进程的时间。</p>
<p>然后执行 attribute 的 constructor 函数。举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line">__attribute__((constructor))</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"prepare"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">__attribute__((destructor))</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"end"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showHeader</span><span class="params">()</span> </span>&#123; </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"header"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ming@mingdeMacBook-Pro macho_demo % ./main <span class="string">"hi"</span></div><div class="line">prepare</div><div class="line">hi</div><div class="line">end</div></pre></td></tr></table></figure>
<p>运行时初始化过程 分为：</p>
<ul>
<li>加载类扩展</li>
<li>加载 C++静态对象</li>
<li>调用+load 函数</li>
<li>执行 main 函数</li>
<li>Application 初始化，到 applicationDidFinishLaunchingWithOptions 执行完</li>
<li>初始化帧渲染，到 viewDidAppear 执行完，用户可见可操作。</li>
</ul>
<p>过程概括起来如下图：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/02.png" alt=""></p>
<p>也就是说对启动阶段的分析以 viewDidAppear 为截止。这次优化之前已经对 Application 初始化之前做过优化，效果并不明显，没有本质的提高，所以这次主要针对 Application 初始化到 viewDidAppear 这个阶段各个性能多纬度进行分析。多维度具体包含内容如下图：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/03.png" alt=""></p>
<p>工具的选择其实目前看来是很多的，Apple 提供的 System Trace 会提供全面系统的行为，可以显示底层系统线程和内存调度情况，分析锁、线程、内存、系统调用等问题。总的来说，通过 System Trace 你能清楚知道每时每刻 App 对系统资源使用情况。</p>
<p>System Trace 能查看线程的状态，可以了解高优线程使用相对于 CPU 数量是否合理，可以看到线程在执行、挂起、上下文切换、被打断还是被抢占的情况。虚拟内存使用产生的耗时也能看到，比如分配物理内存，内存解压缩，无缓存时进行缓存的耗时等。甚至是发热情况也能看到。</p>
<p>System Trace 还提供手动打点进行信息显式，在你的代码中 导入 sys/kdebug_signpost.h 后，配对 kdebug_signpost_start 和 kdebug_signpost_end 就可以了。这两个方法有五个参数，第一个是 id，最后一个是颜色，中间都是预留字段。</p>
<p>Xcode11开始 XCTest 还提供了测量性能的 Api。苹果在2019年 WWDC 启动优化专题 <a href="https://developer.apple.com/videos/play/wwdc2019/423/" target="_blank" rel="external">Optimizing App Launch - WWDC 2019 - Videos - Apple Developer</a> 上也介绍了 Instruments 里的最新模板 App launch 如何分析启动性能。但是要想达到对启动数据进行留存取均值、Diff、过滤、关联分析等自动化操作，App launch 目前还没法做到。</p>
<h3 id="主线程耗时"><a href="#主线程耗时" class="headerlink" title="主线程耗时"></a>主线程耗时</h3><p>多个维度性能纬度分析中最重要，最终用户体感到的是主线程耗时分析。对主线程方法耗时可以直接使用<a href="https://everettjf.github.io/2019/05/06/messier/" target="_blank" rel="external">Messier - 简单易用的Objective-C方法跟踪工具 - everettjf - 首先很有趣</a><br>生成 trace json 进行分析，或者参看这个代码<a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallTraceCore.c" target="_blank" rel="external">GCDFetchFeed/SMCallTraceCore.c at master · ming1016/GCDFetchFeed · GitHub</a>，自己手动 hook objc_msgSend 生成一份Objective-C 方法耗时数据进行分析。还有种插桩方式，可以解析 IR（加快编译速度），然后在每个方法前后插入耗时统计函数。文章后面我会着重介绍如何开发工具进一步分析这份数据，以达到监控启动阶段方法耗时的目的。</p>
<p>hook 所有的方法调用，对详细分析时很有用，不过对于整个启动时间影响很大，要想获取启动每个阶段更准确的时间消耗还需要依赖手动埋点。为了更好的分析启动耗时问题，手动埋点也会埋的越来越多，也会影响启动时间精确度，特别是当团队很多，模块很多时，问题会突出。但，每个团队在排查启动耗时往往只会关注自己或相关某几个模块的分析，基于此，可以把不同模块埋点分组，灵活组合，这样就可以照顾到多种需求了。</p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>为什么分析启动慢除了分析主线程方法耗时外，还要分析其它纬度的性能呢？</p>
<p>我们先看看启动慢的表现，启动慢意味着界面响应慢、网络慢（数据量大、请求数多）、CPU 超负荷降频（并行任务多、运算多），可以看出影响启动的因素很多，还需要全面考虑。</p>
<p>对于 CPU 来说，WWDC 的 <a href="https://developer.apple.com/videos/play/wwdc2018/228/" target="_blank" rel="external">What’s New in Energy Debugging - WWDC 2018 - Videos - Apple Developer</a> 里介绍了用 Energy Log 来查 CPU 耗电，当前台三分钟或后台一分钟 CPU 线程连续占用80%以上就判定为耗电，同时记录耗电线程堆栈供分析。还有一个 <a href="https://developer.apple.com/documentation/xcode/improving_your_app_s_performance" target="_blank" rel="external">MetrickKit</a> 专门用来收集电源和性能统计数据，每24小时就会对收集的数据进行汇总上报，Mattt 在 NShipster 网站上也发了篇文章<a href="https://nshipster.com/metrickit/" target="_blank" rel="external">MetricKit - NSHipster</a>专门进行了介绍。那么 CPU 的详细使用情况如何获取呢？也就是说哪个方法用了多少 CPU。</p>
<p>有好几种获取详细 CPU 使用情况的方法。线程是计算机资源调度和分配的基本单位。CPU 使用情况会提现到线程这样的基本单位上。task_theads 的 act_list 数组包含所有线程，使用 thread_info 的接口可以返回线程的基本信息，这些信息定义在 thread_basic_info_t 结构体中。这个结构体内的信息包含了线程运行时间、运行状态以及调度优先级，其中也包含了 CPU 使用信息 cpu_usage。获取方式参看 <a href="https://stackoverflow.com/questions/43866416/get-detailed-ios-cpu-usage-with-different-states" target="_blank" rel="external">objective c - Get detailed iOS CPU usage with different states - Stack Overflow</a>。GT <a href="https://github.com/Tencent/GT" target="_blank" rel="external">GitHub - Tencent/GT: GT (Great Tit) is a portable debugging tool for bug hunting and performance tuning on smartphones anytime and anywhere just as listening music with Walkman. GT can act as the Integrated Debug Environment by directly running on smartphones.</a> 里也有获取 CPU 的代码。</p>
<p>整体 CPU 占用率可以通过 host_statistics 函数可以取到 host_cpu_load_info，其中 cpu_ticks 数组是 CPU 运行的时钟脉冲数量。通过 cpu_ticks 数组里的状态，可以分别获取 CPU_STATE_USER、CPU_STATE_NICE、CPU_STATE_SYSTEM 这三个表示使用中的状态，除以整体 CPU 就可以取到 CPU 的占比。通过 NSProcessInfo 的 activeProcessorCount 还可以得到 CPU 的核数。线上数据分析时会发现相同机型和系统的手机，性能表现却截然不同，这是由于手机过热或者电池损耗过大后系统降低了 CPU 频率所致。所以如果取得 CPU 频率后也可以针对那些降频的手机来进行针对性的优化，以保证流畅体验。获取方式可以参考 <a href="https://github.com/zenny-chen/CPU-Dasher-for-iOS" target="_blank" rel="external">GitHub - zenny-chen/CPU-Dasher-for-iOS: CPU Dasher for iOS source code. It only supports ARMv7 and ARMv7s architectures.</a></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>要想获取 App 真实的内存使用情况可以参看 WebKit 的源码，<a href="https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp" target="_blank" rel="external">webkit/MemoryFootprintCocoa.cpp at 52bc6f0a96a062cb0eb76e9a81497183dc87c268 · WebKit/webkit · GitHub</a> 。JetSam会判断 App 使用内存情况，超出阈值就会杀死 App，JetSam 获取阈值的代码在 <a href="https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/kern/kern_memorystatus.c" target="_blank" rel="external">darwin-xnu/kern_memorystatus.c at 0a798f6738bc1db01281fc08ae024145e84df927 · apple/darwin-xnu · GitHub</a>。整个设备物理内存大小可以通过 NSProcessInfo 的 physicalMemory 来获取。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>对于网络监控可以使用 Fishhook 这样的工具 Hook 网络底层库 CFNetwork。网络的情况比较复杂，所以需要定些和时间相关的关键的指标，指标如下：</p>
<ul>
<li>DNS 时间</li>
<li>SSL 时间</li>
<li>首包时间</li>
<li>响应时间</li>
</ul>
<p>有了这些指标才能够有助于更好的分析网络问题。启动阶段的网络请求是非常多的，所以 HTTP 的性能是非常要注意的。以下是 WWDC 网络相关的 Session：</p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/719/" target="_blank" rel="external">Your App and Next Generation Networks - WWDC 2015 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2015/711/" target="_blank" rel="external">Networking with NSURLSession - WWDC 2015 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/714/" target="_blank" rel="external">Networking for the Modern Internet - WWDC 2016 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/707/" target="_blank" rel="external">Advances in Networking, Part 1 - WWDC 2017 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/709/" target="_blank" rel="external">Advances in Networking, Part 2 - WWDC 2017 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/714/" target="_blank" rel="external">Optimizing Your App for Today’s Internet - WWDC 2018 - Videos - Apple Developer</a></li>
</ul>
<h3 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h3><p>对于 I/O 可以使用 <a href="https://www.frida.re/" target="_blank" rel="external">Frida • A world-class dynamic instrumentation framework | Inject JavaScript to explore native apps on Windows, macOS, GNU/Linux, iOS, Android, and QNX</a> 这种动态二进制插桩技术，在程序运行时去插入自定义代码获取 I/O 的耗时和处理的数据大小等数据。Frida 还能够在其它平台使用。</p>
<p>关于多维度分析更多的资料可以看看历届 WWDC 的介绍。下面我列下16年来 WWDC 关于启动优化的 Session，每场都很精彩。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/04.png" alt=""></p>
<ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/418/" target="_blank" rel="external">Using Time Profiler in Instruments - WWDC 2016 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/719/" target="_blank" rel="external">Optimizing I/O for Performance and Battery Life - WWDC 2016 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="external">Optimizing App Startup Time - WWDC 2016 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="external">App Startup Time: Past, Present, and Future - WWDC 2017 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/407/" target="_blank" rel="external">Practical Approaches to Great App Performance - WWDC 2018 - Videos - Apple Developer</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2019/423/" target="_blank" rel="external">Optimizing App Launch - WWDC 2019 - Videos - Apple Developer</a> </li>
</ul>
<h2 id="延后任务管理"><a href="#延后任务管理" class="headerlink" title="延后任务管理"></a>延后任务管理</h2><p>经过前面所说的对主线程耗时方法和各个纬度性能分析后，对于那些分析出来没必要在启动阶段执行的方法，可以做成按需或延后执行。<br>任务延后的处理不能粗犷的一口气在启动完成后在主线程一起执行，那样用户仅仅只是看到了页面，依然没法响应操作。那该怎么做呢？套路一般是这样，创建四个队列，分别是：</p>
<ul>
<li>异步串行队列</li>
<li>异步并行队列</li>
<li>闲时主线程串行队列</li>
<li>闲时异步串行队列</li>
</ul>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/06.png" alt=""></p>
<p>有依赖关系的任务可以放到异步串行队列中执行。异步并行队列可以分组执行，比如使用 dispatch_group，然后对每组任务数量进行限制，避免 CPU、线程和内存瞬时激增影响主线程用户操作，定义有限数量的串行队列，每个串行队列做特定的事情，这样也能够避免性能消耗短时间突然暴涨引起无法响应用户操作。使用 dispatch_semaphore_t 在信号量阻塞主队列时容易出现优先级反转，需要减少使用，确保QoS传播。可以用dispatch group 替代，性能一样，功能不差。异步编程可以直接 GCD 接口来写，也可以使用阿里的协程框架 coobjc <a href="https://github.com/alibaba/coobjc" target="_blank" rel="external">coobjc</a>。</p>
<p>闲时队列实现方式是监听主线程 runloop 状态，在 kCFRunLoopBeforeWaiting 时开始执行闲时队列里的任务，在 kCFRunLoopAfterWaiting 时停止。</p>
<h2 id="优化后如何保持？"><a href="#优化后如何保持？" class="headerlink" title="优化后如何保持？"></a>优化后如何保持？</h2><p>攻易守难，就像刚到新团队时将包大小减少了48兆，但是一年多一直能够守住除了决心还需要有手段。对于启动优化来说，将各个性能纬度通过监控的方式盯住是必要的，但是发现问题后快速、便捷的定位到问题还是需要找些突破口。我的思路是将启动阶段方法耗时多的按照时间线一条一条排出来，每条包括方法名、方法层级、所属类、所属模块、维护人。考虑到便捷性，最好还能方便的查看方法代码内容。</p>
<p>接下来我通过开发一个工具，跟你详细说说怎么实现这样的效果。设计最终希望展示内容如下：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/07.png" alt=""></p>
<h3 id="解析-json"><a href="#解析-json" class="headerlink" title="解析 json"></a>解析 json</h3><p>如前面所说在输出一份 Chrome trace 规范的方法耗时 json 后，先要解析这份数据。这份 json 数据类似下面的样子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;"name":"[SMVeilweaa]upVeilState:","cat":"catname","ph":"B","pid":2381,"tid":0,"ts":21&#125;,</div><div class="line">&#123;"name":"[SMVeilweaa]tatLaunchState:","cat":"catname","ph":"B","pid":2381,"tid":0,"ts":4557&#125;,</div><div class="line">&#123;"name":"[SMVeilweaa]tatTimeStamp:state:","cat":"catname","ph":"B","pid":2381,"tid":0,"ts":4686&#125;,</div><div class="line">&#123;"name":"[SMVeilweaa]tatTimeStamp:state:","cat":"catname","ph":"E","pid":2381,"tid":0,"ts":4727&#125;,</div><div class="line">&#123;"name":"[SMVeilweaa]tatLaunchState:","cat":"catname","ph":"E","pid":2381,"tid":0,"ts":5732&#125;,</div><div class="line">&#123;"name":"[SMVeilweaa]upVeilState:","cat":"catname","ph":"E","pid":2381,"tid":0,"ts":5815&#125;,</div><div class="line">…</div></pre></td></tr></table></figure></p>
<p>通过 Chrome 的 <a href="https://chromium.googlesource.com/catapult/+/HEAD/tracing/README.md" target="_blank" rel="external">Trace-Viewer</a> 可以生成一个火焰图。其中 name 字段包含了类、方法和参数的信息，cat 字段可以加入其它性能数据，ph 为 B 表示方法开始，为 E 表示方法结束，ts 字段表示。</p>
<h4 id="json-分词"><a href="#json-分词" class="headerlink" title="json 分词"></a>json 分词</h4><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/08.png" alt=""></p>
<p>读取 json 文件<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根据文件路径返回文件内容</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fileContent</span><span class="params">(path: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">try</span> <span class="type">String</span>(contentsOfFile: path, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8)</div><div class="line">    &#125; <span class="keyword">catch</span> &#123;</div><div class="line">        <span class="keyword">return</span> “”</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> bundlePath = <span class="type">Bundle</span>.main.path(forResource: “startTrace”, ofType: “json”)</div><div class="line"><span class="keyword">let</span> jsonPath = bundlePath ?? “”</div><div class="line"><span class="keyword">let</span> jsonContent = <span class="type">FileHandle</span>.fileContent(path: jsonPath)</div></pre></td></tr></table></figure></p>
<p>jsonContent 就是 json 内容字符串。写一个字符切割函数将字符串按照自定义符号集来切割。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">allTkFast</span><span class="params">(operaters:String)</span></span> -&gt; [<span class="type">Token</span>] &#123;</div><div class="line">    <span class="keyword">var</span> nText = text.replacingOccurrences(of: “ “, with: “ starmingspace “)</div><div class="line">    nText = nText.replacingOccurrences(of: “\n”, with: “ starmingnewline “)</div><div class="line">    <span class="keyword">let</span> scanner = <span class="type">Scanner</span>(string: nText)</div><div class="line">    <span class="keyword">var</span> tks = [<span class="type">Token</span>]()</div><div class="line">    <span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">CharacterSet</span>()</div><div class="line">    <span class="keyword">set</span>.insert(charactersIn: operaters)</div><div class="line">    <span class="keyword">set</span>.formUnion(<span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> !scanner.isAtEnd &#123;</div><div class="line">        <span class="keyword">for</span> operater <span class="keyword">in</span> operaters &#123;</div><div class="line">            <span class="keyword">let</span> opStr = operater.description</div><div class="line">            <span class="keyword">if</span> (scanner.scanString(opStr) != <span class="literal">nil</span>) &#123;</div><div class="line">                tks.append(.id(opStr))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> result:<span class="type">NSString</span>?</div><div class="line">        result = <span class="literal">nil</span></div><div class="line">        <span class="keyword">if</span> (scanner.scanUpToCharacters(from: <span class="keyword">set</span>) != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">let</span> resultString = result! <span class="keyword">as</span> <span class="type">String</span></div><div class="line">            <span class="keyword">if</span> resultString == “starmingnewline” &#123;</div><div class="line">                tks.append(.newLine)</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> resultString == “starmingspace” &#123;</div><div class="line">                tks.append(.space)</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                tks.append(.id(result! <span class="keyword">as</span> <span class="type">String</span>))</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    tks.append(.eof)</div><div class="line">    <span class="keyword">return</span> tks</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将切割的字符保存为 Token 结构体的一个个 token。Token 结构体定义如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Token</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> eof</div><div class="line">    <span class="keyword">case</span> newLine</div><div class="line">    <span class="keyword">case</span> space</div><div class="line">    <span class="keyword">case</span> comments(<span class="type">String</span>)      <span class="comment">// 注释</span></div><div class="line">    <span class="keyword">case</span> constant(<span class="type">Constant</span>)    <span class="comment">// float、int</span></div><div class="line">    <span class="keyword">case</span> id(<span class="type">String</span>)            <span class="comment">// string</span></div><div class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)        <span class="comment">// 代码中引号内字符串</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Constant</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> string(<span class="type">String</span>)</div><div class="line">    <span class="keyword">case</span> integer(<span class="type">Int</span>)</div><div class="line">    <span class="keyword">case</span> float(<span class="type">Float</span>)</div><div class="line">    <span class="keyword">case</span> boolean(<span class="type">Bool</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中的 eof 表示 token 是文件结束，newLine 是换行 token。Constant 是枚举关联值，通过枚举关联值可以使枚举能够具有更多层级。后面还需要将枚举值进行判等比较，所以还需要扩展枚举的 Equatable 协议实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Token</span>: <span class="title">Equatable</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Token, rhs: Token)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">switch</span> (lhs, rhs) &#123;</div><div class="line">        <span class="keyword">case</span> (.eof, .eof):</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        <span class="keyword">case</span> (.newLine, .newLine):</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        <span class="keyword">case</span> (.space, .space):</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.constant(<span class="keyword">left</span>), .constant(<span class="keyword">right</span>)):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">left</span> == <span class="keyword">right</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.comments(<span class="keyword">left</span>), .comments(<span class="keyword">right</span>)):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">left</span> == <span class="keyword">right</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.id(<span class="keyword">left</span>), .id(<span class="keyword">right</span>)):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">left</span> == <span class="keyword">right</span></div><div class="line">        <span class="keyword">case</span> <span class="keyword">let</span> (.string(<span class="keyword">left</span>), .string(<span class="keyword">right</span>)):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">left</span> == <span class="keyword">right</span></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通用的 token 结构解析完成。接下来就是设计一个 json 特有的 token 结构。对于 json 来说换行和空格可以过滤掉，写个函数过滤换行和空格的 token：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">allTkFastWithoutNewLineAndWhitespace</span><span class="params">(operaters:String)</span></span> -&gt; [<span class="type">Token</span>] &#123;</div><div class="line">    <span class="keyword">let</span> allToken = allTkFast(operaters: operaters)</div><div class="line">    <span class="keyword">let</span> flAllToken = allToken.<span class="built_in">filter</span> &#123;</div><div class="line">        $<span class="number">0</span> != .newLine</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> fwAllToken = flAllToken.<span class="built_in">filter</span> &#123;</div><div class="line">        $<span class="number">0</span> != .space</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fwAllToken</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>json 的操作符有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&#125;[]”:,</div></pre></td></tr></table></figure>
<p>所以 operaters 参数可以是这些操作符。完整的 Lexer 类代码在 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Core/Lexer.swift" target="_blank" rel="external">MethodTraceAnalyze/Lexer.swift</a>。使用 Lexer 类的 allTkFastWithoutNewLineAndWhitespace 方法可以取得 token 集合。</p>
<h4 id="JSONToken"><a href="#JSONToken" class="headerlink" title="JSONToken"></a>JSONToken</h4><p>为了转成 json 的 token，我先设计一个 json token 的结构 JSONToken。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">JSONToken</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> type: <span class="type">JSONTokenType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> value: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">JSONTokenType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> startDic   <span class="comment">// &#123;</span></div><div class="line">    <span class="keyword">case</span> endDic     <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">case</span> startArray <span class="comment">// [</span></div><div class="line">    <span class="keyword">case</span> endArray   <span class="comment">// ]</span></div><div class="line">    <span class="keyword">case</span> key        <span class="comment">// key</span></div><div class="line">    <span class="keyword">case</span> value      <span class="comment">// value</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据 json 的本身设计，主要分为 key 和 value，另外还需要些符号类型，用来进行进一步的解析。解析过程的状态设计为三种，用 State 枚举表示：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> normal</div><div class="line">    <span class="keyword">case</span> keyStart</div><div class="line">    <span class="keyword">case</span> valueStart</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 normal 状态下，会记录操作符类型的 json token，当遇到{符号后，下一个是“符号就会更改状态为 keyStart。另一种情况就是在遇到,符号后，下一个是”符号也会更改状态为 keyStart。</p>
<p>状态更改成 valueStart 的条件是遇到:符号，当下一个是“时进入 valueStart 状态，如果不是“符号，就需要做区分，是{或者[时直接跳过:符号，然后记录这两个操作符。其它情况表示 value 不是字符而是数字，直接记录为 json token 就可以了。完整 json token 的解析代码见 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/JSON/ParseJSONTokens.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseJSONTokens.swift</a>。</p>
<p>JSONToken 集合目前还只是扁平态，而 json 数据是有 key 和 value 的多级关系在的，比如 value 可能是字符串或数字，也可能是另一组 key value 结构或者 value 的数组集合。所以下面还需要定义一个 JSONItem 结构来容纳多级关系。</p>
<h4 id="JSONItem"><a href="#JSONItem" class="headerlink" title="JSONItem"></a>JSONItem</h4><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/09.png" alt=""></p>
<p>JSONItem 的结构体定义如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">JSONItem</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type: <span class="type">JSONItemType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kvs: [<span class="type">JSONItemKv</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> array: [<span class="type">JSONItem</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 类型</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">JSONItemType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> keyValue</div><div class="line">    <span class="keyword">case</span> value</div><div class="line">    <span class="keyword">case</span> array</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// key value 结构体</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">JSONItemKv</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">JSONItem</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JSONItem 的类型分三种，key value、value 和 array 的，定义在 JSONItemType 枚举中。分别对应的三个存储字段是 kvs，里面是 JSONItemKv 类型的集合；value 为字符串；array 是 JSONItem 的集合。</p>
<p>定义好了多层级的结构，就可以将 JSONToken 的集合进行分析，转到 JSONItem 结构上。思路是在解析过程中碰到闭合符号时，将扁平的闭合区间内的 JSONToken  放到集合里，通过递归函数 recursiveTk 递归出多层级结构出来。所以需要设置四个状态：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">rState</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> normal</div><div class="line">    <span class="keyword">case</span> startDic</div><div class="line">    <span class="keyword">case</span> startArr</div><div class="line">    <span class="keyword">case</span> startKey</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当碰到{符号进入 startDic 状态，遇到[符号进入 startKey 状态，遇到}和]符号时会结束这两个状态。在 startDic 或 startKey 状态中时会收集过程中的 JSONToken 到 recursiveTkArr 集合里。这个分析完整代码在这 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/JSON/ParseJSONItem.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseJSONItem.swift</a>。</p>
<p>来一段简单的 json 测试下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    “key1”: “value1”,</div><div class="line">    “key2”: 22,</div><div class="line">    “key3”: &#123;</div><div class="line">        “subKey1”: “subValue1”,</div><div class="line">        “subKey2”: 40,</div><div class="line">        “subKey3”:[</div><div class="line">            &#123;</div><div class="line">                “sub1Key1”: 10,</div><div class="line">                “sub1Key2”:&#123;</div><div class="line">                    “sub3Key1”: “sub3Value1”,</div><div class="line">                    “sub3Key2”: “sub3Value2”</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                “sub1Key1”: 11,</div><div class="line">                “sub1Key2”: 15</div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line">        “subKey4”: [</div><div class="line">            “value1”,</div><div class="line">            23,</div><div class="line">            “value2”</div><div class="line">        ],</div><div class="line">        “subKey5”: 2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用 ParseJSONItem 来解析<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonOPath = <span class="type">Bundle</span>.main.path(forResource: “test”, ofType: “json”)</div><div class="line"><span class="keyword">let</span> jOrgPath = jsonOPath ?? “”</div><div class="line"><span class="keyword">let</span> jsonOContent = <span class="type">FileHandle</span>.fileContent(path: jOrgPath)</div><div class="line"></div><div class="line"><span class="keyword">let</span> item = <span class="type">ParseJSONItem</span>(input: jsonOContent).parse()</div></pre></td></tr></table></figure></p>
<p>得到的 item 数据如下图所示</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/02.png" alt=""></p>
<p>可以看到，item 的结构和前面的 json 结构是一致的。</p>
<h4 id="json-单测"><a href="#json-单测" class="headerlink" title="json 单测"></a>json 单测</h4><p>为了保证后面对 json 的解析修改和完善对上面列的测试 case 解析结果不会有影响，可以写个简单测试类来做。这个类只需要做到将实际结果和预期值做比较，相等即可通过，不等即可提示并中断，方便定位问题。因此传入参数只需要有运行结果、预期结果、描述就够用了。我写个 Test 协议，通过扩展默认实现一个比较的方法，以后需要单测的类遵循这个协议就可以使用和扩展单测功能了。Test 协议具体代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cs</span><span class="params">(current:String, expect:String, des:String)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// compare string 对比两个字符串值</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">cs</span><span class="params">(current:String, expect: String, des: String)</span></span> &#123;</div><div class="line">        <span class="keyword">if</span> current == expect &#123;</div><div class="line">            <span class="built_in">print</span>(“✅ \(des) ok，符合预期值：\(expect)”)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> msg = “❌ \(des) fail，不符合预期值：\(expect)”</div><div class="line">            <span class="built_in">print</span>(msg)</div><div class="line">            <span class="built_in">assertionFailure</span>(msg)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>写个 TestJSON 遵循 Test 协议进行单测。测试各个解析后的值，比如测试 item第一级 key value 配对数量可以这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = item.array[<span class="number">0</span>].kvs</div><div class="line">cs(current: “\(arr.<span class="built_in">count</span>)”, expect: “<span class="number">3</span>”, des: “all dic <span class="built_in">count</span>”)</div></pre></td></tr></table></figure></p>
<p>打印的结果就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">✅ all dic count ok，符合预期值：3</div></pre></td></tr></table></figure></p>
<p>完整单测代码在这里：<a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/JSON/TestJSON.swift" target="_blank" rel="external">MethodTraceAnalyze/TestJSON.swift</a></p>
<h3 id="解析-Launch-Trace-的-json"><a href="#解析-Launch-Trace-的-json" class="headerlink" title="解析 Launch Trace 的 json"></a>解析 Launch Trace 的 json</h3><p>前面说的 JSONItem 是通用的多层级 json 结构体。对于启动的 json，实际要表现的方法调用链和 json 的层级并不是对应的。方法调用链是通过 ph 字段表示，B 表示方法开始，E 表示方法结束，中间会有其它方法调用的闭合，这些方法在调用链里可以被称为调用方法的子方法。</p>
<p>为了能够表现出这样的调用链关系，我设计了下面的 LaunchItem 结构：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/10.png" alt=""></p>
<p>结构体代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">LaunchItem</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> name: <span class="type">String</span>  <span class="comment">// 调用方法</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> ph: <span class="type">String</span>    <span class="comment">// B 代表开始、E 代表结束、BE 代表合并后的 Item、其它代表描述</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> ts: <span class="type">String</span>    <span class="comment">// 时间戳，开始时间</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cost: <span class="type">Int</span>     <span class="comment">// 耗时 ms</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> times: <span class="type">Int</span>    <span class="comment">// 执行次数</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> subItem: [<span class="type">LaunchItem</span>]   <span class="comment">// 子 item</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> parentItem:[<span class="type">LaunchItem</span>] <span class="comment">// 父 item</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过 ParseJSONTokens 类来获取 JSONToken 的集合。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tks = <span class="type">ParseJSONTokens</span>(input: input).parse()</div></pre></td></tr></table></figure></p>
<p>找出 name、ph、ts 字段数据转到 LaunchItem 结构体中。这部分代码实现在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Launch/ParseLaunchJSON.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseLaunchJSON.swift</a>。</p>
<p>遍历 LaunchItem 集合，完善 LaunchItem 的信息，先完善 LaunchItem 的 cost 和 subItem 的信息。在方法调用链同一级时依据 ph 字段将相同方法 B 和 E 之间的 LaunchItem 都放到一个数组里，通过栈顶和栈底的 ts 字段值相减就能够得到 cost 的值，也就是方法的耗时，代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> b = itemArr[<span class="number">0</span>]</div><div class="line"><span class="keyword">let</span> e = itemArr[itemArr.<span class="built_in">count</span> - <span class="number">1</span>]</div><div class="line"><span class="keyword">let</span> cost = <span class="type">Int</span>(e.ts)! - <span class="type">Int</span>(b.ts)!</div></pre></td></tr></table></figure></p>
<p>当这个数组数量大于2，代表方法里还会调用其它的方法，通过递归将调用链中的子方法都取出来，并放到 subItem 里。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pItem.subItem.append(recusiveMethodTree(parentItem: rPItem, items: newItemArr))</div></pre></td></tr></table></figure></p>
<p>代码见<a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Launch/LaunchJSON.swift" target="_blank" rel="external">MethodTraceAnalyze/LaunchJSON.swift</a>里的 launchJSON 函数。</p>
<h3 id="展示启动方法链"><a href="#展示启动方法链" class="headerlink" title="展示启动方法链"></a>展示启动方法链</h3><p>前面通过 launchJSON 函数取到了方法调用链的根部 LaunchItem。使用 recusiveItemTree 函数递归这个根 LaunchItem ，可以输出方法调用关系图。很多工程在启动阶段会执行大量方法，很多方法耗时很少，可以过滤那些小于10毫秒的方法，让分析更加聚焦。</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/03.png" alt=""></p>
<p>展示效果如上图所示，完整代码在 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Launch/LaunchJSON.swift" target="_blank" rel="external">MethodTraceAnalyze/LaunchJSON.swift</a> 里的 tree 函数里。图中的阶段切换，比如 T1到 T2的切换可以在 recusiveItemTree 函数中设置，对应的处理代码是：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取 T1 到 T5 阶段信息，其中 updateLauncherState 函数名需要替换成自己阶段切换的函数名，最多5个阶段</span></div><div class="line"><span class="keyword">if</span> methodName == “updateLauncherState:” &#123;</div><div class="line">    currentT += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> currentT &gt; <span class="number">5</span> &#123;</div><div class="line">        currentT = <span class="number">5</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>耗时的高低也做了颜色的区分。外部耗时指的是子方法以外系统或没源码的三方方法的耗时，规则是父方法调用的耗时减去其子方法总耗时。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取外部耗时</span></div><div class="line"><span class="keyword">var</span> sysCost = <span class="number">0</span></div><div class="line"><span class="keyword">if</span> aItem.subItem.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">    <span class="keyword">for</span> aSubItem <span class="keyword">in</span> aItem.subItem &#123;</div><div class="line">        sysCost += aSubItem.cost</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">sysCost = (aItem.cost - sysCost) / <span class="number">1000</span></div></pre></td></tr></table></figure></p>
<p>bundle、owner、业务线这三项需要根据自己工程情况来，如果工程使用的是 excel 做的记录可以导出为 csv 格式文件，参考 LaunchJSON 类里的 loadSimpleKeyValueDicWithCsv 函数进行 csv 数据读取。如果数据是在服务端，输出为 json 的话就更好办了，使用前面写的 ParseJSONItem 类就能够进行数据解析了，可以参考 LaunchJSON 类里的 parseBundleOwner 函数。展示示例里我先置为默认的暂无了。</p>
<p>目前为止通过过滤耗时少的方法调用，可以更容易发现问题方法。但是，有些方法单次执行耗时不多，但是会执行很多次，累加耗时会大，这样的情况也需要体现在展示页面里。另外外部耗时高时或者碰到自己不了解的方法时，是需要到工程源码里去搜索对应的方法源码进行分析的，有的方法名很通用时还需要花大量时间去过滤无用信息。</p>
<p>因此接下来还需要做两件事情，首先累加方法调用次数和耗时，体现在展示页面中，另一个是从工程中获取方法源码能够在展示页面中进行点击显示。</p>
<p>对于方法调用次数和总耗时的统计我写在了 LaunchJSON 类的 allMethodAndSubMethods 函数里，思路就是遍历所有的 LaunchItem，碰到相同的 item name 就对次数和耗时进行累加。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> allItems = <span class="type">LaunchJSON</span>.leaf(fileName: fileName, isGetAllItem: <span class="literal">true</span>)</div><div class="line"></div><div class="line"><span class="keyword">var</span> mergeDic = [<span class="type">String</span>:<span class="type">LaunchItem</span>]()</div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> allItems &#123;</div><div class="line">    <span class="keyword">let</span> mergeKey = item.name <span class="comment">// 方法名为标识</span></div><div class="line">    <span class="keyword">if</span> mergeDic[mergeKey] != <span class="literal">nil</span> &#123;</div><div class="line">        <span class="keyword">var</span> newItem = mergeDic[mergeKey]</div><div class="line">        newItem?.cost += item.cost <span class="comment">// 累加耗时</span></div><div class="line">        newItem?.times += <span class="number">1</span> <span class="comment">// 累加次数</span></div><div class="line">        mergeDic[mergeKey] = newItem</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        mergeDic[mergeKey] = item</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展示时判断次数大于1时，耗时大于0时展示出来。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mergeStr = “”</div><div class="line"><span class="keyword">if</span> preMergeItemDic.keys.<span class="built_in">contains</span>(“\(bundleName+className+methodName)”) &#123;</div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">let</span> mItem = preMergeItemDic[“\(bundleName+className+methodName)”]</div><div class="line">    <span class="keyword">if</span> mItem?.times ?? <span class="number">0</span> &gt; <span class="number">1</span> &amp;&amp; (mItem?.cost ?? <span class="number">0</span>) / <span class="number">1000</span> &gt; <span class="number">0</span> &#123;</div><div class="line">        mergeStr = “(总次数\(mItem?.times ?? <span class="number">0</span>)、总耗时\((mItem?.cost ?? <span class="number">0</span>) / <span class="number">1000</span>))”</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>展示的效果如下：</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/04.png" alt=""></p>
<h3 id="展示方法源码"><a href="#展示方法源码" class="headerlink" title="展示方法源码"></a>展示方法源码</h3><p>在页面上展示源码需要先解析 .xcworkspace 文件，通过 .xcworkspace文件取到工程里所有的 .xcodeproj 文件。分析 .xcodeproj 文件取到所有 .m 和.mm 源码文件路径，解析源码，取到方法的源码内容进行展示。</p>
<h4 id="解析-xcworkspace"><a href="#解析-xcworkspace" class="headerlink" title="解析 .xcworkspace"></a>解析 .xcworkspace</h4><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/11.png" alt=""></p>
<p>打开.xcworkspace，可以看到这个包内主要文件是 contents.xcworkspacedata。内容是一个 xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">Workspace</span></span></div><div class="line">   <span class="attr">version</span> = <span class="string">"1.0"</span>&gt;</div><div class="line">   <span class="tag">&lt;<span class="name">FileRef</span></span></div><div class="line">      <span class="attr">location</span> = <span class="string">"group:GCDFetchFeed.xcodeproj"</span>&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">FileRef</span>&gt;</span></div><div class="line">   <span class="tag">&lt;<span class="name">FileRef</span></span></div><div class="line">      <span class="attr">location</span> = <span class="string">"group:Pods/Pods.xcodeproj"</span>&gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">FileRef</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">Workspace</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>所以下面需要对 xml 进行分析。xml 的操作符有 &lt;&gt;=\”/?![]，通过这些操作符能够取到通用的 token 集合 tokens。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens = <span class="type">Lexer</span>(input: input, type: .plain).allTkFast(operaters: “&lt;&gt;=\”/?![]”)</div></pre></td></tr></table></figure></p>
<p>根据 xml 的规则，将解析状态分为 normal、startTag、cdata 三种。定义的枚举为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> normal</div><div class="line">    <span class="keyword">case</span> startTag</div><div class="line">    <span class="keyword">case</span> cdata</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当遇到&lt;符号时，更改解析状态为 startTag。如果&lt;符号后面跟的是![CDATA[表示是 cdata 标签，状态需要改成 cdata。实现代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// &lt;tagname …&gt; 和 &lt;![CDATA[</span></div><div class="line"><span class="keyword">if</span> currentState == .normal &amp;&amp; currentToken == .id(“&lt;“) &#123;</div><div class="line">    <span class="comment">// &lt;![CDATA[</span></div><div class="line">    <span class="keyword">if</span> peekTk() == .id(“!”) &amp;&amp; peekTkStep(step: <span class="number">2</span>) == .id(“[“) &amp;&amp; peekTkStep(step: <span class="number">3</span>) == .id(“<span class="type">CDATA</span>”) &amp;&amp; peekTkStep(step: <span class="number">4</span>) == .id(“[“) &#123;</div><div class="line">        currentState = .cdata</div><div class="line">        advanceTk() <span class="comment">// jump &lt;</span></div><div class="line">        advanceTk() <span class="comment">// jump !</span></div><div class="line">        advanceTk() <span class="comment">// jump [</span></div><div class="line">        advanceTk() <span class="comment">// jump CDATA</span></div><div class="line">        advanceTk() <span class="comment">// jump [</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// &lt;tagname …&gt;</span></div><div class="line">    <span class="keyword">if</span> currentTokens.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">        addTagTokens(type: .value) <span class="comment">// 结束一组</span></div><div class="line">    &#125;</div><div class="line">    currentState = .startTag</div><div class="line">    advanceTk()</div><div class="line">    <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 startTag 和 cdata 状态时会将遇到的 token 装到 currentTokens 里，在结束状态时加入到 XMLTagTokens 这个结构里记录下来。XMLTagTokens 的定义如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XMLTagTokens</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> type: <span class="type">XMLTagTokensType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> tokens: [<span class="type">Token</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>currentTokens 会在状态结束时记录到 XMLTagTokens 的 tokens 里。startTag 会在&gt;符号时结束。cdata 会在]]&gt;时结束。这部分实现代码见 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/XML/ParseStandXMLTagTokens.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseStandXMLTagTokens.swift</a> 。</p>
<p>接下来对 XMLTagTokens 集合进行进一步分析，XML 的 tag 节点分为单标签比如<br>、开标签比如</p><p>、闭合标签比如</p>、标签值、xml 标识说明，这五类。因此我定义了标签节点的类型枚举 XMLTagNodeType：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XMLTagNodeType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> xml</div><div class="line">    <span class="keyword">case</span> single <span class="comment">// 单个标签</span></div><div class="line">    <span class="keyword">case</span> start  <span class="comment">// 开标签 &lt;p&gt;</span></div><div class="line">    <span class="keyword">case</span> value  <span class="comment">// 标签的值 &lt;p&gt;value&lt;/p&gt;</span></div><div class="line">    <span class="keyword">case</span> end    <span class="comment">// 闭合的标签 &lt;/p&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p>
<p>标签节点除了类型信息，还需要有属性集合、标签名和标签值，结构体定义为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XMLTagNode</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> type: <span class="type">XMLTagNodeType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> value: <span class="type">String</span> <span class="comment">// 标签值</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> name: <span class="type">String</span>  <span class="comment">// 标签名</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> attributes: [<span class="type">XMLTagAttribute</span>] <span class="comment">// 标签属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析 XML 标签节点相比较于 HTML 来说会简化些，HTML的规则更加的复杂，以前使用状态机根据 W3C 标准<a href="https://html.spec.whatwg.org/multipage/parsing.html#html-parser" target="_blank" rel="external">HTML Standard</a>专门解析过，状态机比较适合于复杂的场景，具体代码在这里 <a href="https://github.com/ming1016/HTN/blob/master/Sources/Core/HTML/HTMLTokenizer.swift" target="_blank" rel="external">HTN/HTMLTokenizer.swift</a> 。可以看到按照 W3C 的标准，设计了一个 HTNStateType 状态枚举，状态特别多。对于 XML 来说状态会少些：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pTagState</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> start</div><div class="line">    <span class="keyword">case</span> questionMark</div><div class="line">    <span class="keyword">case</span> xml</div><div class="line">    <span class="keyword">case</span> tagName</div><div class="line">    <span class="keyword">case</span> attributeName</div><div class="line">    <span class="keyword">case</span> <span class="built_in">equal</span></div><div class="line">    <span class="keyword">case</span> attributeValue</div><div class="line">    <span class="keyword">case</span> startForwardSlash</div><div class="line">    <span class="keyword">case</span> endForwardSlash</div><div class="line">    <span class="keyword">case</span> startDoubleQuotationMarks</div><div class="line">    <span class="keyword">case</span> backSlash</div><div class="line">    <span class="keyword">case</span> endDoubleQuotationMarks</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>XML  标签节点的解析我没有用状态机，将解析结果记录到了 XMLTagNode 结构体中。标签节点解析过程代码在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/XML/ParseStandXMLTags.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseStandXMLTags.swift</a> 。标签节点解析完后还需要解决 XML 的层级问题，也就是标签包含标签的问题。</p>
<p>先定义一个结构体 XMLNode，用来记录 XML 的节点树：</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/12.png" alt=""></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XMLNode</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> attributes: [<span class="type">XMLTagAttribute</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> subNodes: [<span class="type">XMLNode</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 subNodes 是 XMLNode 的子节点集合，解析出 XMLNode 的思路是根据前面输出的 XMLTagNode 的类型来分析，当遇到类型是 start 到遇到相同 name 的 end 之间不断收集 XMLTagNode 到 currentTagNodeArr 数组里，end 时将这个数组添加到 tagNodeArrs 里，然后开始收集下一组 start 和 end。关键代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当遇到.end 类型时将一组 XMLTagNode 加到 tagNodeArrs 里。然后重置。</span></div><div class="line"><span class="keyword">if</span> node.type == .end &amp;&amp; node.name == currentTagName &#123;</div><div class="line">    currentState = .end</div><div class="line">    currentTagNodeArr.append(node)</div><div class="line">    <span class="comment">// 添加到一级</span></div><div class="line">    tagNodeArrs.append(currentTagNodeArr)</div><div class="line">    <span class="comment">// 重置</span></div><div class="line">    currentTagNodeArr = [<span class="type">XMLTagNode</span>]()</div><div class="line">    currentTagName = “”</div><div class="line">    <span class="keyword">continue</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于 xml 类型标签和 single 类型的会直接保存到 tagNodeArrs 里。接下来对 tagNodeArrs 这些由 XMLTagNode 组成的数组集进行分析。如果 tagNodeArr 的数组数量是1时，表示这一层级的 tag 是 xml 或者单标签的情况比如&lt;?xml version=”1.0” encoding=”UTF-8”?&gt; 或 <link href="“/atom.xml”" rel="“self”/"> 这种。数量是2时表示开闭标签里没有其他的标签，类似</p><p></p>这种。当 tagNodeArr 的数量大于2时，可能有两种情况，一种是 tagNode 为 value 类型比如<p>section value</p>，其他情况就是标签里会嵌套标签，需要递归调用 recusiveParseTagNodes 函数进行下一级的解析。这部分逻辑在 recusiveParseTagNodes 函数里，相关代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> tagNodeArr <span class="keyword">in</span> tagNodeArrs &#123;</div><div class="line">    <span class="keyword">if</span> tagNodeArr.<span class="built_in">count</span> == <span class="number">1</span> &#123;</div><div class="line">        <span class="comment">// 只有一个的情况，即 xml 和 single</span></div><div class="line">        <span class="keyword">let</span> aTagNode = tagNodeArr[<span class="number">0</span>]</div><div class="line">        pNode.subNodes.append(tagNodeToNode(tagNode: aTagNode))</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> tagNodeArr.<span class="built_in">count</span> == <span class="number">2</span> &#123;</div><div class="line">        <span class="comment">// 2个的情况，就是比如 &lt;p&gt;&lt;/p&gt;</span></div><div class="line">        <span class="keyword">let</span> aTagNode = tagNodeArr[<span class="number">0</span>] <span class="comment">// 取 start 的信息</span></div><div class="line">        pNode.subNodes.append(tagNodeToNode(tagNode: aTagNode))</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> tagNodeArr.<span class="built_in">count</span> &gt; <span class="number">2</span> &#123;</div><div class="line">        <span class="comment">// 大于2个的情况</span></div><div class="line">        <span class="keyword">let</span> startTagNode = tagNodeArr[<span class="number">0</span>]</div><div class="line">        <span class="keyword">var</span> startNode = tagNodeToNode(tagNode: startTagNode)</div><div class="line">        <span class="keyword">let</span> secondTagNode = tagNodeArr[<span class="number">1</span>]</div><div class="line">        </div><div class="line">        <span class="comment">// 判断是否是 value 这种情况比如 &lt;p&gt;paragraph&lt;/p&gt;</span></div><div class="line">        <span class="keyword">if</span> secondTagNode.type == .value &#123;</div><div class="line">            <span class="comment">// 有 value 的处理</span></div><div class="line">            startNode.value = secondTagNode.value.trimmingCharacters(<span class="keyword">in</span>: <span class="type">CharacterSet</span>.whitespacesAndNewlines)</div><div class="line">            pNode.subNodes.append(startNode)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 有子标签的情况</span></div><div class="line">            <span class="comment">// 递归得到结果</span></div><div class="line">            <span class="keyword">var</span> newTagNodeArr = tagNodeArr</div><div class="line">            newTagNodeArr.remove(at: tagNodeArr.<span class="built_in">count</span> - <span class="number">1</span>)</div><div class="line">            newTagNodeArr.remove(at: <span class="number">0</span>)</div><div class="line">            pNode.subNodes.append(recusiveParseTagNodes(parentNode: startNode, tagNodes: newTagNodeArr))</div><div class="line">        &#125; <span class="comment">// end else</span></div><div class="line">    &#125; <span class="comment">// end else if</span></div><div class="line">&#125; <span class="comment">// end for</span></div></pre></td></tr></table></figure><p></p>
<p>完成 xcworkspace 的 XML 解析，获取 XML 的节点树如下所示：</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/05.png" alt=""></p>
<p>写个单测，保证后面增加功能和更新优化解析后不会影响结果。单测代码在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/XML/TestXML.swift" target="_blank" rel="external">MethodTraceAnalyze/TestXML.swift</a>。</p>
<h4 id="解析-xcodeproj"><a href="#解析-xcodeproj" class="headerlink" title="解析 .xcodeproj"></a>解析 .xcodeproj</h4><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/13.png" alt=""></p>
<p>通过 XML 的解析可以获取 FileRef 节点内容， xcodeproj 的文件路径就在 FileRef 节点的 location 属性里。每个 xcodeproj 文件里会有 project 工程的源码文件。为了能够获取方法的源码进行展示，那么就先要取出所有 project 工程里包含的源文件的路径。</p>
<p>取 xcodeproj 文件路径的方式如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> aFile.fileName == “contents.xcworkspacedata” &#123;</div><div class="line">    <span class="keyword">let</span> root = <span class="type">ParseStandXML</span>(input: aFile.content).parse()</div><div class="line">    <span class="keyword">let</span> workspace = root.subNodes[<span class="number">1</span>]</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> fileRef <span class="keyword">in</span> workspace.subNodes &#123;</div><div class="line">        <span class="keyword">var</span> fileRefPath = fileRef.attributes[<span class="number">0</span>].value</div><div class="line">        fileRefPath.removeFirst(<span class="number">6</span>)</div><div class="line">        </div><div class="line">        <span class="comment">// 判断是相对路径还是绝对路径</span></div><div class="line">        <span class="keyword">let</span> arr = fileRefPath.<span class="built_in">split</span>(separator: “/“)</div><div class="line">        <span class="keyword">var</span> projectPath = “”</div><div class="line">        <span class="keyword">if</span> arr.<span class="built_in">count</span> &gt; <span class="number">2</span> &#123;</div><div class="line">            projectPath = “\(fileRefPath)/project.pbxproj”</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            projectPath = “/\(pathStr)/\(fileRefPath)/project.pbxproj”</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 读取 project 文件内容分析</span></div><div class="line">        allSourceFile += <span class="type">ParseXcodeprojSource</span>(input: projectPath).parseAllFiles()</div><div class="line">        </div><div class="line">    &#125; <span class="comment">// end for fileRef in workspace.subNodes</span></div><div class="line">&#125; <span class="comment">// end for</span></div></pre></td></tr></table></figure></p>
<p>如上面代码所示，ParseXcodeprojSource 是专门用来解析 xcodeproj 的，parseAllFiles 方法根据解析的结果，取出所有 xcodeproj 包含的源码文件。</p>
<p>xcodeproj 的文件内容看起来大概是下面的样子。</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/06.png" alt=""></p>
<p>其实内容还有很多，需要一个个解析出来。</p>
<p>分析后分词的分割符号有 /*={};\”,() 这些，根据这些分割符号设计分词的 token 类型 XcodeprojTokensType，XcodeprojTokensType 为枚举包含下面十个类型：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XcodeprojTokensType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> codeComment <span class="comment">// 注释</span></div><div class="line">    <span class="keyword">case</span> string</div><div class="line">    <span class="keyword">case</span> id</div><div class="line">    <span class="keyword">case</span> leftBrace <span class="comment">// &#123;</span></div><div class="line">    <span class="keyword">case</span> rightBrace <span class="comment">// &#125;</span></div><div class="line">    <span class="keyword">case</span> leftParenthesis <span class="comment">// (</span></div><div class="line">    <span class="keyword">case</span> rightParenthesis <span class="comment">// )</span></div><div class="line">    <span class="keyword">case</span> <span class="built_in">equal</span> <span class="comment">// =</span></div><div class="line">    <span class="keyword">case</span> semicolon <span class="comment">// ;</span></div><div class="line">    <span class="keyword">case</span> comma <span class="comment">// ,</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>codeComment、string、id 这些类型会由多个 token 组成，所以最好将 xcodeproj 的基础 token 设计为下面的样子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojTokens</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> type: <span class="type">XcodeprojTokensType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> tokens: [<span class="type">Token</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由 tokens 字段记录多个 token。实现分词代码在这 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/ParseXcodeprojTokens.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseXcodeprojTokens.swift</a></p>
<p>xcodeproj 文件虽然不是 json，但是大小括号的规则和 json 还比较类似，大括号里的数据类似字典可以用 key、value 配对记录，小括号数据类似数组，记录 value 就可以。这样可以设计 xcodeproj 的节点类型为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XcodeprojNodeType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> normal</div><div class="line">    <span class="keyword">case</span> root <span class="comment">// 根节点</span></div><div class="line">    </div><div class="line">    <span class="keyword">case</span> dicStart <span class="comment">// &#123;</span></div><div class="line">    <span class="keyword">case</span> dicKey</div><div class="line">    <span class="keyword">case</span> dicValue</div><div class="line">    <span class="keyword">case</span> dicEnd   <span class="comment">// &#125;</span></div><div class="line">    </div><div class="line">    <span class="keyword">case</span> arrStart <span class="comment">// (</span></div><div class="line">    <span class="keyword">case</span> arrValue</div><div class="line">    <span class="keyword">case</span> arrEnd   <span class="comment">// )</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上面定义 XcodeprojNodeType 枚举，其大括号内数据的 key 类型为 dicKey，value 类型为 dicValue。小括号的 value 类型为 arrValue。节点设计为：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojNode</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> type: <span class="type">XcodeprojNodeType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> value: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">let</span> codeComment: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> subNodes: [<span class="type">XcodeprojNode</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解析代码都在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/ParseXcodeprojNode.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseXcodeprojNode.swift</a> 。</p>
<p>xcodeproj 也有层级，所以也需要构建一个树结构。结构代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojTreeNode</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type: <span class="type">XcodeprojTreeNodeType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> comment: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kvs: [<span class="type">XcodeprojTreeNodeKv</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> arr: [<span class="type">XcodeprojTreeNodeArrayValue</span>]</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">XcodeprojTreeNodeType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> value</div><div class="line">    <span class="keyword">case</span> keyValue</div><div class="line">    <span class="keyword">case</span> array</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojTreeNodeKey</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> comment: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojTreeNodeArrayValue</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> comment: <span class="type">String</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojTreeNodeKv</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> key: <span class="type">XcodeprojTreeNodeKey</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">XcodeprojTreeNode</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>考虑到 xcodeproj 里的注释很多，也都很有用，因此会多设计些结构来保存值和注释。思路是根据 XcodeprojNode 的类型来判断下一级是 key value 结构还是 array 结构。如果 XcodeprojNode 的类型是 XcodeprojNode 的类型是 dicStart 表示下级是 key value 结构。如果类型是 arrStart 就是 array 结构。当碰到类型是 dicEnd 同时和最初 dicStart 是同级时，递归下一级树结构。而 arrEnd 不用递归，xcodeproj 里的 array 只有值类型的数据。生成节点树结构这部分代码实现在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/ParseXcodeprojTreeNode.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseXcodeprojTreeNode.swift</a></p>
<p>断点看生成的结构如下图：</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/07.png" alt=""></p>
<p>其中 section 内容都在 objects 里</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/08.png" alt=""></p>
<p>有了基本节点树结构以后就可以设计 xcodeproj 里各个 section 的结构。主要有一下的 section：</p>
<ul>
<li>PBXBuildFile：文件，最终会关联到 PBXFileReference</li>
<li>PBXContainerItemProxy：部署的元素</li>
<li>PBXFileReference：各类文件，有源码、资源、库等文件</li>
<li>PBXFrameworksBuildPhase：用于 framework 的构建</li>
<li>PBXGroup：文件夹，可嵌套，里面包含了文件与文件夹的关系</li>
<li>PBXNativeTarget：Target 的设置</li>
<li>PBXProject：Project 的设置，有编译工程所需信息</li>
<li>PBXResourcesBuildPhase：编译资源文件，有 xib、storyboard、plist以及图片等资源文件</li>
<li>PBXSourcesBuildPhase：编译源文件（.m）</li>
<li>PBXTargetDependency： Taget 的依赖</li>
<li>PBXVariantGroup：.storyboard 文件</li>
<li>XCBuildConfiguration：Xcode 编译配置，对应 Xcode 的 Build Setting 面板内容</li>
<li>XCConfigurationList：构建配置相关，包含项目文件和 target 文件</li>
</ul>
<p>根据 xcodeproj 的结构规则设计结构体：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// project.pbxproj 结构</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Xcodeproj</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> archiveVersion = “”</div><div class="line">    <span class="keyword">var</span> classes = [<span class="type">XcodeprojTreeNodeArrayValue</span>]()</div><div class="line">    <span class="keyword">var</span> objectVersion = “” <span class="comment">// 区分 xcodeproj 不同协议版本</span></div><div class="line">    <span class="keyword">var</span> rootObject = <span class="type">PBXValueWithComment</span>(name: “”, value: “”)</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> pbxBuildFile = [<span class="type">String</span>:<span class="type">PBXBuildFile</span>]()</div><div class="line">    <span class="keyword">var</span> pbxContainerItemProxy = [<span class="type">String</span>:<span class="type">PBXContainerItemProxy</span>]()</div><div class="line">    <span class="keyword">var</span> pbxFileReference = [<span class="type">String</span>:<span class="type">PBXFileReference</span>]()</div><div class="line">    <span class="keyword">var</span> pbxFrameworksBuildPhase = [<span class="type">String</span>:<span class="type">PBXFrameworksBuildPhase</span>]()</div><div class="line">    <span class="keyword">var</span> pbxGroup = [<span class="type">String</span>:<span class="type">PBXGroup</span>]()</div><div class="line">    <span class="keyword">var</span> pbxNativeTarget = [<span class="type">String</span>:<span class="type">PBXNativeTarget</span>]()</div><div class="line">    <span class="keyword">var</span> pbxProject = [<span class="type">String</span>:<span class="type">PBXProject</span>]()</div><div class="line">    <span class="keyword">var</span> pbxResourcesBuildPhase = [<span class="type">String</span>:<span class="type">PBXResourcesBuildPhase</span>]()</div><div class="line">    <span class="keyword">var</span> pbxSourcesBuildPhase = [<span class="type">String</span>:<span class="type">PBXSourcesBuildPhase</span>]()</div><div class="line">    <span class="keyword">var</span> pbxTargetDependency = [<span class="type">String</span>:<span class="type">PBXTargetDependency</span>]()</div><div class="line">    <span class="keyword">var</span> pbxVariantGroup = [<span class="type">String</span>:<span class="type">PBXVariantGroup</span>]()</div><div class="line">    <span class="keyword">var</span> xcBuildConfiguration = [<span class="type">String</span>:<span class="type">XCBuildConfiguration</span>]()</div><div class="line">    <span class="keyword">var</span> xcConfigurationList = [<span class="type">String</span>:<span class="type">XCConfigurationList</span>]()</div><div class="line">    </div><div class="line">    <span class="keyword">init</span>() &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体每个字段集合元素的结构体比如 PBXBuildFile 和 PBXFileReference 对应的结构体和 xcodeproj 的 section 结构对应上。然后使用 ParseXcodeprojTreeNode 解析的节点树结构生成最终的 Xcodeproj section 的结构体。解析过程在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/ParseXcodeprojSection.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseXcodeprojSection.swift</a>。</p>
<p>调试看到 Xcodeproj 的结构如下：</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/09.png" alt=""></p>
<p>对 xcodeproj 的解析也写了单测来保证后期 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/TestXcodeproj.swift" target="_blank" rel="external">MethodTraceAnalyze/TestXcodeproj.swift</a>。</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/10.png" alt=""></p>
<p>得到 section 结构 Xcodeproj 后，就可以开始分析所有源文件的路径了。根据前面列出的 section 的说明，PBXGroup 包含了所有文件夹和文件的关系，Xcodeproj 的 pbxGroup 字段的 key 是文件夹，值是文件集合，因此可以设计一个结构体 XcodeprojSourceNode 用来存储文件夹和文件关系。XcodeprojSourceNode 结构如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">XcodeprojSourceNode</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> fatherValue: <span class="type">String</span> <span class="comment">// 文件夹</span></div><div class="line">    <span class="keyword">let</span> value: <span class="type">String</span> <span class="comment">// 文件的值</span></div><div class="line">    <span class="keyword">let</span> name: <span class="type">String</span> <span class="comment">// 文件名</span></div><div class="line">    <span class="keyword">let</span> type: <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过遍历 pbxGroup 可以将文件夹和文件对应上，文件名可以通过 pbxGroup 的 value 到 PBXFileReference 里去取。代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> nodes = [<span class="type">XcodeprojSourceNode</span>]()</div><div class="line"></div><div class="line"><span class="comment">// 第一次找出所有文件和文件夹</span></div><div class="line"><span class="keyword">for</span> (k,v) <span class="keyword">in</span> proj.pbxGroup &#123;</div><div class="line">    <span class="keyword">guard</span> v.children.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> v.children &#123;</div><div class="line">        <span class="comment">// 如果满足条件表示是目录</span></div><div class="line">        <span class="keyword">if</span> proj.pbxGroup.keys.<span class="built_in">contains</span>(child.value) &#123;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 满足条件是文件</span></div><div class="line">        <span class="keyword">if</span> proj.pbxFileReference.keys.<span class="built_in">contains</span>(child.value) &#123;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> fileRefer = proj.pbxFileReference[child.value] <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            &#125;</div><div class="line">        </div><div class="line">            nodes.append(<span class="type">XcodeprojSourceNode</span>(fatherValue: k, value: child.value, name: fileRefer.path, type: fileRefer.lastKnownFileType))</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="comment">// end for children</span></div><div class="line">    </div><div class="line">&#125; <span class="comment">// end for group</span></div></pre></td></tr></table></figure></p>
<p>接下来需要取得完整的文件路径。通过 recusiveFatherPaths 函数获取文件夹路径。这里需要注意的是需要处理 ../ 这种文件夹路径符，获取完整路径的实现代码可以看这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/Xcodeproj/ParseXcodeprojSource.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseXcodeprojSource.swift</a>。</p>
<p>有了每个源文件的路径，接下来就可以对这些源文件进行解析了。</p>
<h4 id="解析-m-mm-文件"><a href="#解析-m-mm-文件" class="headerlink" title="解析 .m .mm 文件"></a>解析 .m .mm 文件</h4><p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/14.png" alt=""></p>
<p>对 Objective-C 解析可以参考 LLVM，这里只需要找到每个方法对应的源码，所以自己也可以实现。分词前先看看 LLVM 是怎么定义 token 的。定义文件在这里 <a href="https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def" target="_blank" rel="external">https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def</a> 。根据这个定义我设计了 token 的结构体，主体部分如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 切割符号 []()&#123;&#125;.&amp;=*+-&lt;&gt;~!/%^|?:;,#@</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OCTK</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> unknown <span class="comment">// 不是 token</span></div><div class="line">    <span class="keyword">case</span> eof <span class="comment">// 文件结束</span></div><div class="line">    <span class="keyword">case</span> eod <span class="comment">// 行结束</span></div><div class="line">    <span class="keyword">case</span> codeCompletion <span class="comment">// Code completion marker</span></div><div class="line">    <span class="keyword">case</span> cxxDefaultargEnd <span class="comment">// C++ default argument end marker</span></div><div class="line">    <span class="keyword">case</span> comment <span class="comment">// 注释</span></div><div class="line">    <span class="keyword">case</span> identifier <span class="comment">// 比如 abcde123</span></div><div class="line">    <span class="keyword">case</span> numericConstant(<span class="type">OCTkNumericConstant</span>) <span class="comment">// 整型、浮点 0x123，解释计算时用，分析代码时可不用</span></div><div class="line">    <span class="keyword">case</span> charConstant <span class="comment">// ‘a’</span></div><div class="line">    <span class="keyword">case</span> stringLiteral <span class="comment">// “foo”</span></div><div class="line">    <span class="keyword">case</span> wideStringLiteral <span class="comment">// L”foo”</span></div><div class="line">    <span class="keyword">case</span> angleStringLiteral <span class="comment">// &lt;foo&gt; 待处理需要考虑作为小于符号的问题</span></div><div class="line">    </div><div class="line">    <span class="comment">// 标准定义部分</span></div><div class="line">    <span class="comment">// 标点符号</span></div><div class="line">    <span class="keyword">case</span> punctuators(<span class="type">OCTkPunctuators</span>)</div><div class="line">    </div><div class="line">    <span class="comment">//  关键字</span></div><div class="line">    <span class="keyword">case</span> keyword(<span class="type">OCTKKeyword</span>)</div><div class="line">    </div><div class="line">    <span class="comment">// @关键字</span></div><div class="line">    <span class="keyword">case</span> atKeyword(<span class="type">OCTKAtKeyword</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整的定义在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCTokensDefine.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseOCTokensDefine.swift</a>。分词过程可以参看 LLVM 的实现 <a href="http://clang.llvm.org/doxygen/Lexer_8cpp_source.html" target="_blank" rel="external">clang: lib/Lex/Lexer.cpp Source File</a>。我在处理分词时主要是按照分隔符一一对应处理，针对代码注释和字符串进行了特殊处理，一个注释一个 token，一个完整字符串一个 token。我分词实现代码 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCTokens.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseOCTokens.swift</a>。</p>
<p>由于只要取到类名和方法里的源码，所以语法分析时，只需要对类定义和方法定义做解析就可以，语法树中节点设计：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// OC 语法树节点</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">OCNode</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> type: <span class="type">OCNodeType</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> subNodes: [<span class="type">OCNode</span>]</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> identifier: <span class="type">String</span>   <span class="comment">// 标识</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> lineRange: (<span class="type">Int</span>,<span class="type">Int</span>) <span class="comment">// 行范围</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> source: <span class="type">String</span>       <span class="comment">// 对应代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 节点类型</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">OCNodeType</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> `<span class="keyword">default</span>`</div><div class="line">    <span class="keyword">case</span> root</div><div class="line">    <span class="keyword">case</span> `<span class="keyword">import</span>`</div><div class="line">    <span class="keyword">case</span> `<span class="class"><span class="keyword">class</span>`</span></div><div class="line">    <span class="title">case</span> <span class="title">method</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 lineRange 记录了方法所在文件的行范围，这样就能够从文件中取出代码，并记录在 source 字段中。</p>
<p>解析语法树需要先定义好解析过程的不同状态：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">RState</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> normal</div><div class="line">    <span class="keyword">case</span> eod                   <span class="comment">// 换行</span></div><div class="line">    <span class="keyword">case</span> methodStart           <span class="comment">// 方法开始</span></div><div class="line">    <span class="keyword">case</span> methodReturnEnd       <span class="comment">// 方法返回类型结束</span></div><div class="line">    <span class="keyword">case</span> methodNameEnd         <span class="comment">// 方法名结束</span></div><div class="line">    <span class="keyword">case</span> methodParamStart      <span class="comment">// 方法参数开始</span></div><div class="line">    <span class="keyword">case</span> methodContentStart    <span class="comment">// 方法内容开始</span></div><div class="line">    <span class="keyword">case</span> methodParamTypeStart  <span class="comment">// 方法参数类型开始</span></div><div class="line">    <span class="keyword">case</span> methodParamTypeEnd    <span class="comment">// 方法参数类型结束</span></div><div class="line">    <span class="keyword">case</span> methodParamEnd        <span class="comment">// 方法参数结束</span></div><div class="line">    <span class="keyword">case</span> methodParamNameEnd    <span class="comment">// 方法参数名结束</span></div><div class="line">    </div><div class="line">    <span class="keyword">case</span> at                    <span class="comment">// @</span></div><div class="line">    <span class="keyword">case</span> atImplementation      <span class="comment">// @implementation</span></div><div class="line">    </div><div class="line">    <span class="keyword">case</span> normalBlock           <span class="comment">// oc方法外部的 block &#123;&#125;，用于 c 方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整解析出方法所属类、方法行范围的代码在这里 <a href="https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCNodes.swift" target="_blank" rel="external">MethodTraceAnalyze/ParseOCNodes.swift</a></p>
<p>解析 .m 和 .mm 文件，一个一个串行解的话，对于大工程，每次解的速度很难接受，所以采用并行方式去读取解析多个文件，经过测试，发现每组在60个以上时能够最大利用我机器（2.5 GHz 双核Intel Core i7）的 CPU，内存占用只有60M，一万多.m文件的工程大概2分半能解完。分组并行的代码实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> allPath = <span class="type">XcodeProjectParse</span>.allSourceFileInWorkspace(path: workspacePath)</div><div class="line"><span class="keyword">var</span> allNodes = [<span class="type">OCNode</span>]()</div><div class="line"><span class="keyword">let</span> groupCount = <span class="number">60</span> <span class="comment">// 一组容纳个数</span></div><div class="line"><span class="keyword">let</span> groupTotal = allPath.<span class="built_in">count</span>/groupCount + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> groups = [[<span class="type">String</span>]]()</div><div class="line"><span class="keyword">for</span> <span class="type">I</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;groupTotal &#123;</div><div class="line">    <span class="keyword">var</span> group = [<span class="type">String</span>]()</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="type">I</span>*groupCount..&lt;(<span class="type">I</span>+<span class="number">1</span>)*groupCount &#123;</div><div class="line">        <span class="keyword">if</span> j &lt; allPath.<span class="built_in">count</span> &#123;</div><div class="line">            group.append(allPath[j])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> group.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</div><div class="line">        groups.append(group)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> group <span class="keyword">in</span> groups &#123;</div><div class="line">    <span class="keyword">let</span> dispatchGroup = <span class="type">DispatchGroup</span>()</div><div class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> group &#123;</div><div class="line">        dispatchGroup.enter()</div><div class="line">        <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>.global()</div><div class="line">        queue.async &#123;</div><div class="line">            <span class="keyword">let</span> ocContent = <span class="type">FileHandle</span>.fileContent(path: node)</div><div class="line">            <span class="keyword">let</span> node = <span class="type">ParseOCNodes</span>(input: ocContent).parse()</div><div class="line">            <span class="keyword">for</span> aNode <span class="keyword">in</span> node.subNodes &#123;</div><div class="line">                allNodes.append(aNode)</div><div class="line">            &#125;</div><div class="line">            dispatchGroup.leave()</div><div class="line">        &#125; <span class="comment">// end queue async</span></div><div class="line">    &#125; <span class="comment">// end for</span></div><div class="line">    dispatchGroup.wait()</div><div class="line">&#125; <span class="comment">// end for</span></div></pre></td></tr></table></figure></p>
<p>使用的是 dispatch group 的 wait，保证并行的一组完成再进入下一组。</p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/15.png" alt=""></p>
<p>现在有了每个方法对应的源码，接下来就可以和前面 trace 的方法对应上。页面展示只需要写段 js 就能够控制点击时展示对应方法的源码。</p>
<h4 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h4><p>在进行 HTML 页面展示前，需要将代码里的换行和空格替换成 HTML 里的对应的<br>和 &nbsp; 。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> allNodes = <span class="type">ParseOC</span>.ocNodes(workspacePath: “/<span class="type">Users</span>/ming/<span class="type">Downloads</span>/<span class="type">GCDFetchFeed</span>/<span class="type">GCDFetchFeed</span>/<span class="type">GCDFetchFeed</span>.xcworkspace”)</div><div class="line"></div><div class="line"><span class="keyword">var</span> sourceDic = [<span class="type">String</span>:<span class="type">String</span>]()</div><div class="line"><span class="keyword">for</span> aNode <span class="keyword">in</span> allNodes &#123;</div><div class="line">    sourceDic[aNode.identifier] = aNode.source.replacingOccurrences(of: “\n”, with: “&lt;/br&gt;”).replacingOccurrences(of: “ “, with: “&amp;nbsp;”)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用 p 标签作为源码展示的标签，方法执行顺序的编号加方法名作为 p 标签的 id，然后用 display: none; 将 p 标签隐藏。方法名用 a 标签，click 属性执行一段 js 代码，当 a 标签点击时能够显示方法对应的代码。这段 js 代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sourceShowHidden</span>(<span class="params">sourceIdName</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> sourceCode = <span class="built_in">document</span>.getElementById(sourceIdName);</div><div class="line">    sourceCode.style.display = “block”;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终效果如下图：</p>
<p><img src="/uploads/how-to-analyze-startup-time-cost-in-ios/11.png" alt=""></p>
<p>将动态分析和静态分析进行了结合，后面可以通过不同版本进行对比，发现哪些方法的代码实现改变了，能展示在页面上。还可以进一步静态分析出哪些方法会调用到 I/O 函数、起新线程、新队列等，然后展示到页面上，方便分析。</p>
<p>读到最后，可以看到这个方法分析工具并没有用任何一个轮子，其实有些是可以使用现有轮子的，比如 json、xml、xcodeproj、Objective-C 语法分析等，之所有没有用是因为不同轮子使用的语言和技术区别较大，当格式更新时如果使用的单个轮子没有更新会影响整个工具。开发这个工具主要工作是在解析上，所以使用自有解析技术也能够让所做的功能更聚焦，不做没用的功能，减少代码维护量，所要解析格式更新后，也能够自主去更新解析方式。更重要的一点是可以亲手接触下这些格式的语法设计。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>今天说了下启动优化的技术手段，总的说，对启动进行优化的决心重要程度是远大于技术手段的，决定着是否能够优化的更多。技术手段有很多，我觉得手段的好坏区别只是在效率上，最差的情况全用手动一个个去查耗时也是能够解题的。</p>
<p>最近看了鲁迅的一段话，很有感触，分享一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">我们好像都是爱生病的人</div><div class="line">苦的很</div><div class="line">我的一生</div><div class="line">好像是在不断生病和骂人中就过去多半了</div><div class="line">我三十岁不到，牙齿就掉光了</div><div class="line">满口义齿</div><div class="line">我戒酒</div><div class="line">吃鱼肝油</div><div class="line">以望延长我的生命</div><div class="line">倒不尽是为了我的爱人</div><div class="line">大半是为了我的敌人</div><div class="line">我自己知道的，我并不大度</div><div class="line">说到幸福</div><div class="line">只得面向过去</div><div class="line">或者面向除了坟墓以外毫无任何希望的将来</div><div class="line">每个战士都是如此</div><div class="line">我们活在这样的地方</div><div class="line">我们活在这样的时代</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/16.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/kuaishou-unused-class-swiftui-note-binary-tree-interview/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerli
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>2019年涂图</title>
    <link href="http://ming1016.github.io/2019/12/06/draw-in-2019/"/>
    <id>http://ming1016.github.io/2019/12/06/draw-in-2019/</id>
    <published>2019-12-06T05:48:40.000Z</published>
    <updated>2019-12-07T03:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-in-2019/01.jpg" alt=""><br><img src="/uploads/draw-in-2019/02.jpg" alt=""><br><img src="/uploads/draw-in-2019/03.jpg" alt=""><br><img src="/uploads/draw-in-2019/04.jpg" alt=""><br><img src="/uploads/draw-in-2019/05.jpg" alt=""><br><img src="/uploads/draw-in-2019/06.jpg" alt=""><br><img src="/uploads/draw-in-2019/07.jpg" alt=""><br><img src="/uploads/draw-in-2019/08.jpg" alt=""><br><img src="/uploads/draw-in-2019/09.jpg" alt=""><br><img src="/uploads/draw-in-2019/10.jpg" alt=""><br><img src="/uploads/draw-in-2019/11.jpg" alt=""><br><img src="/uploads/draw-in-2019/12.jpg" alt=""><br><img src="/uploads/draw-in-2019/13.jpg" alt=""><br><img src="/uploads/draw-in-2019/14.jpg" alt=""><br><img src="/uploads/draw-in-2019/15.jpg" alt=""><br><img src="/uploads/draw-in-2019/16.jpg" alt=""><br><img src="/uploads/draw-in-2019/18.jpg" alt=""><br><img src="/uploads/draw-in-2019/19.jpg" alt=""><br><img src="/uploads/draw-in-2019/20.jpg" alt=""><br><img src="/uploads/draw-in-2019/21.jpg" alt=""><br><img src="/uploads/draw-in-2019/22.jpg" alt=""><br><img src="/uploads/draw-in-2019/23.jpg" alt=""><br><img src="/uploads/draw-in-2019/24.jpg" alt=""><br><img src="/uploads/draw-in-2019/25.jpg" alt=""><br><img src="/uploads/draw-in-2019/26.jpg" alt=""><br><img src="/uploads/draw-in-2019/27.jpg" alt=""><br><img src="/uploads/draw-in-2019/28.jpg" alt=""><br><img src="/uploads/draw-in-2019/29.jpg" alt=""><br><img src="/uploads/draw-in-2019/30.jpg" alt=""><br><img src="/uploads/draw-in-2019/31.jpg" alt=""><br><img src="/uploads/draw-in-2019/32.jpg" alt=""><br><img src="/uploads/draw-in-2019/33.jpg" alt=""><br><img src="/uploads/draw-in-2019/34.jpg" alt=""><br><img src="/uploads/draw-in-2019/35.jpg" alt=""><br><img src="/uploads/draw-in-2019/36.jpg" alt=""><br><img src="/uploads/draw-in-2019/37.jpg" alt=""><br><img src="/uploads/draw-in-2019/38.jpg" alt=""><br><img src="/uploads/draw-in-2019/39.jpg" alt=""><br><img src="/uploads/draw-in-2019/40.jpg" alt=""><br><img src="/uploads/draw-in-2019/41.jpg" alt=""><br><img src="/uploads/draw-in-2019/42.jpg" alt=""><br><img src="/uploads/draw-in-2019/43.jpg" alt=""><br><img src="/uploads/draw-in-2019/44.jpg" alt=""><br><img src="/uploads/draw-in-2019/45.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-in-2019/01.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-in-2019/02.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-in-2019/03.
    
    </summary>
    
      <category term="My painting" scheme="http://ming1016.github.io/categories/My-painting/"/>
    
    
      <category term="Painting" scheme="http://ming1016.github.io/tags/Painting/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
      <category term="Procreate" scheme="http://ming1016.github.io/tags/Procreate/"/>
    
  </entry>
  
  <entry>
    <title>iOS 开发舆图</title>
    <link href="http://ming1016.github.io/2019/07/29/ios-map/"/>
    <id>http://ming1016.github.io/2019/07/29/ios-map/</id>
    <published>2019-07-29T04:49:06.000Z</published>
    <updated>2019-07-28T16:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>43篇 <a href="https://time.geekbang.org/column/intro/161" target="_blank" rel="external">《iOS开发高手课》</a>已完成，后面会对内容进行迭代，丰富下内容和配图。最近画了张 iOS 开发全景舆图，还有相关一些资料整理，方便我平时开发 App 时参看。舆图如下：</p>
<p><img src="/uploads/ios-map/1.png" alt=""><br><img src="/uploads/ios-map/2.png" alt=""><br><img src="/uploads/ios-map/3.png" alt=""><br><img src="/uploads/ios-map/4.png" alt=""><br><img src="/uploads/ios-map/5.png" alt=""><br><img src="/uploads/ios-map/6.png" alt=""></p>
<p>接下来，我按照 iOS 开发地图的顺序，和你推荐一些相关的学习资料。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>学习 iOS 开发最好是从学习一个完整的 App 入手，GitHub上的<a href="https://github.com/dkhamsing/open-source-ios-apps" target="_blank" rel="external">Open-Source iOS Apps</a><br>项目，收录了大量开源的完整 App 例子，比如 <a href="https://github.com/Dimillian/SwiftHN" target="_blank" rel="external">Hacker News Reader</a> 等已经上架了 App Store 的应用程序，所有例子都会标注是否上架 App Store的、所使用开发语言、推荐等级等信息，有利于进行选择学习。</p>
<p>开发一个完整的 App 也有最佳实践，这里有份<a href="https://github.com/futurice/ios-good-practices" target="_blank" rel="external">最佳实践</a>可以参考。</p>
<p>下面两个教程网站都会手把手通过实例教你怎么动手学习 iOS 各个知识点。</p>
<ol>
<li><a href="https://www.appcoda.com/" target="_blank" rel="external">AppCoda</a></li>
<li><a href="https://www.raywenderlich.com/library" target="_blank" rel="external">Raywenderlich</a></li>
</ol>
<h2 id="iOS-基础"><a href="#iOS-基础" class="headerlink" title="iOS 基础"></a>iOS 基础</h2><p>完整开发了多个 App 后，为了更好、更快的掌握开发，你就会有需要了解更多 iOS 基础知识的诉求，包括列表的优化、高效界面布局开发、图表图形、图片处理、动画多媒体等等。</p>
<p>图形渲染 Metal 框架的学习可以参看下面四篇文章</p>
<ol>
<li><a href="https://objccn.io/issue-18-2/" target="_blank" rel="external">Metal</a></li>
<li><a href="https://juejin.im/post/5a225ffcf265da432153daa4" target="_blank" rel="external">基于 Metal 的 ARKit 使用指南（上）</a></li>
<li><a href="https://juejin.im/post/59bb2a99f265da0650750e56" target="_blank" rel="external">基于 Metal 的 ARKit 使用指南（下）</a></li>
<li><a href="https://xiaozhuanlan.com/topic/6927418053" target="_blank" rel="external">基于 Metal 的现代渲染技术</a></li>
</ol>
<h2 id="iOS-系统"><a href="#iOS-系统" class="headerlink" title="iOS 系统"></a>iOS 系统</h2><p>iOS 基础学习到一定程度就需要了解 App 是如何在系统中工作的，系统提供了什么基础功能，提供了哪些界面控件等等。</p>
<p>扩展知识可以阅读下面四本书：</p>
<ol>
<li>《深入解析Mac OS X &amp; iOS操作系统》</li>
<li>《现代操作系统》</li>
<li>《深入理解计算机系统》</li>
<li>《程序员的自我修养》</li>
</ol>
<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>编程语言的学习可以参考官方手册，对于 Runtime 的扩展文章阅读：</p>
<ol>
<li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">Objective-C 消息发送与转发机制原理</a></li>
<li><a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="external">神经病院Objective-C Runtime入院第一天——isa和Class</a>（ <a href="https://halfrost.com/objc_runtime_isa_class/" target="_blank" rel="external">https://halfrost.com/objc_runtime_isa_class/</a> ）</li>
<li><a href="https://halfrost.com/objc_runtime_objc_msgsend/" target="_blank" rel="external">神经病院 Objective-C Runtime 住院第二天——消息发送与转发</a></li>
<li><a href="https://halfrost.com/how_to_use_runtime/" target="_blank" rel="external">神经病院 Objective-C Runtime 出院第三天——如何正确使用</a></li>
</ol>
<p>编程语言 Swift 推荐阅读书籍是《Swift 进阶》、《函数式Swift》。大量Swift Playground 可以了解 Swift 编程语言的特性，这里有份整理 <a href="https://github.com/uraimo/Awesome-Swift-Playgrounds" target="_blank" rel="external">GitHub - uraimo/Awesome-Swift-Playgrounds: A List of Awesome Swift Playgrounds</a> 。这份资料汇总了 SwiftUI 的资料  <a href="https://github.com/Juanpe/About-SwiftUI" target="_blank" rel="external">GitHub - Juanpe/About-SwiftUI: Gathering all info published, both by Apple and by others, about new framework SwiftUI.</a> 。这里有本在线书详细讲解了 Combine<br> <a href="https://heckj.github.io/swiftui-notes/" target="_blank" rel="external">《Using Combine》</a> 。</p>
<p>架构相关扩展阅读可以参看  <a href="https://kangzubin.com/ios-component-articles/" target="_blank" rel="external">iOS 组件化相关讨论文章汇总 | KANGZUBIN</a> 。</p>
<p>设计模式推荐书籍如下：</p>
<ul>
<li>《设计模式 可复用面向对象软件的基础》</li>
<li>《Objective-C 编程之道：iOS设计模式解析》</li>
<li>《Head First 设计模式》</li>
<li>《大话设计模式》</li>
</ul>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>开发的代码多了，开发效率和开发质量的提升就越来越离不开开发工具了。</p>
<p>iOS 开发工具 Xcode、Instrument 的使用学习，推荐看苹果开发者大会 WWDC 的 Session 视频。</p>
<p>扩展阅读文章推荐：</p>
<ol>
<li><a href="http://www.aosabook.org/en/llvm.html" target="_blank" rel="external">The Architecture of Open Source Application</a></li>
<li><a href="https://manu343726.github.io/2017-02-11-writing-ast-matchers-for-libclang/" target="_blank" rel="external">Writing AST matchers for libclang</a></li>
<li><a href="http://yulingtianxia.com/blog/2019/01/27/MVVM-Rules-for-OCLint/" target="_blank" rel="external">使用 OCLint 自定义 MVVM 规则</a></li>
<li><a href="https://mp.weixin.qq.com/s/vCzUNHyLfjQKF23Biq9z-g" target="_blank" rel="external">iOS 增量代码覆盖率检测实践</a></li>
</ol>
<p>阅读书籍推荐：</p>
<ol>
<li>《Getting Started with LLVM Core Libraries》</li>
<li>《Modern Compiler Implementation in C》</li>
<li>《Compiler》</li>
</ol>
<h2 id="开发完成"><a href="#开发完成" class="headerlink" title="开发完成"></a>开发完成</h2><p>当开发完成后就需要进行调试、持续化交付、测试。</p>
<p>LLDB 调试推荐先看<a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html" target="_blank" rel="external">官方指南</a>，再看这篇<a href="https://objccn.io/issue-19-2/" target="_blank" rel="external">“与调试器共舞 - LLDB 的华尔兹”</a>。为了更好的调试体验扩展 LLDB 可以参看这篇文章<a href="https://pspdfkit.com/blog/2018/how-to-extend-lldb-to-provide-a-better-debugging-experience/" target="_blank" rel="external">“How to Extend LLDB to Provide a Better Debugging Experience”</a>。</p>
<p>另外，这个<a href="https://github.com/MattPD/cpplinks/blob/master/debugging.md" target="_blank" rel="external">网址</a>收录了各种调试资料。</p>
<p>持续化交付可以参看各大公司的实践，比如：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/69526642" target="_blank" rel="external">知乎 iOS 客户端工程化工具 - Venom</a></li>
<li><a href="https://mp.weixin.qq.com/s/Oa52PvsHw8wS-OvYb3ArZg" target="_blank" rel="external">百度App iOS工程化实践: EasyBox破冰之旅</a></li>
<li><a href="https://mp.weixin.qq.com/s/6WAq_fM0znjO5eY12vjxFw" target="_blank" rel="external">如何实现“持续集成”？淘系闲鱼把研发效率翻了个翻</a></li>
</ol>
<p>测试扩展阅读推荐文章如下：</p>
<ol>
<li><a href="https://onevcat.com/2014/02/ios-test-with-kiwi/" target="_blank" rel="external">TDD的iOS开发初步以及Kiwi使用入门</a></li>
<li><a href="https://onevcat.com/2014/05/kiwi-mock-stub-test/" target="_blank" rel="external">Kiwi 使用进阶 Mock, Stub, 参数捕获和异步测试</a></li>
<li><a href="https://nshipster.com/unit-testing/" target="_blank" rel="external">Unit Testing</a></li>
<li><a href="https://tech.meituan.com/2017/06/23/mobile-app-automation.html" target="_blank" rel="external">客户端自动化测试研究</a></li>
<li><a href="https://mp.weixin.qq.com/s/5rt-uxApK-MeKYn0eKLVcQ?from_safari=1&amp;scene=40#wechat_redirect" target="_blank" rel="external">PICK一下，iOS自动化测试新方案出道</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247488757&amp;idx=1&amp;sn=22465225abd30e56181ad68cdcb60e88&amp;chksm=e8fcc21ddf8b4b0bc97126bb41d95ab8df24c9db20eb9b6efd36ba969ce2e1df000b702ef639&amp;mpshare=1&amp;scene=1&amp;srcid=0221Rpn12CYSXPIE0D1ndrNi&amp;pass_ticket=QDFhyHIsSuU8LkeDk3P%2Bsli%2FL%2BwfD5Y55dNIk2PcCwbawmrDVExKHNGlflrh0dhL#rd" target="_blank" rel="external">爱奇艺基于AI的移动端自动化测试框架的设计</a></li>
</ol>
<h2 id="上线后"><a href="#上线后" class="headerlink" title="上线后"></a>上线后</h2><p>开发完成后，做完测试，就可以上线了。上线后还需要做大量监控保证用户使用 App 的高可用性和好体验。动态化保证发版灵活和问题的快速修复。</p>
<p>推荐的扩展阅读如下：</p>
<ol>
<li><a href="https://everettjf.github.io/2018/08/06/ios-launch-performance-collection/" target="_blank" rel="external">iOS应用启动性能优化资料</a></li>
<li><a href="http://www.zoomfeng.com/blog/launch-time.html" target="_blank" rel="external">iOS启动时间优化</a></li>
<li><a href="https://developer.apple.com/library/archive/technotes/tn2151/_index.html" target="_blank" rel="external">Understanding and Analyzing Application Crash Reports</a></li>
<li><a href="http://www.zoomfeng.com/blog/plcrashreporter-1.html" target="_blank" rel="external">PLCrashreporter源码分析其一</a></li>
<li><a href="http://www.zoomfeng.com/blog/plcrashreporter-2.html" target="_blank" rel="external">PLCrashreporter源码分析其二</a></li>
<li><a href="https://inessential.com/hownottocrash" target="_blank" rel="external">How Not to Crash</a></li>
<li><a href="https://mp.weixin.qq.com/s/XM4bhncHzRFB7zMJa-g2-Q" target="_blank" rel="external">Logan：美团点评的开源移动端基础日志库</a></li>
<li><a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/" target="_blank" rel="external">Hook Objective-C Block with Libffi</a></li>
<li><a href="https://www.fireeye.com/blog/threat-research/2016/01/hot_or_not_the_bene.html" target="_blank" rel="external">Hot or Not? The Benefits and Risks of iOS Remote Hot Patching</a></li>
</ol>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><p>经历多次 App 开发到上线后的过程，碰到问题，解决问题，越发觉得计算机基础的重要性。牢固的基础能有利于碰到问题时快速定位和解决。</p>
<p>推荐扩展阅读文章和资源如下：</p>
<ol>
<li><a href="https://github.com/raywenderlich/swift-algorithm-club" target="_blank" rel="external">Algorithms and data structures in Swift, with explanations!</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/416/" target="_blank" rel="external">iOS Memory Deep Dive</a></li>
<li><a href="https://developer.apple.com/videos/play/wwdc2012/242/" target="_blank" rel="external">iOS App Performance: Memory</a></li>
<li><a href="http://newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="external">No pressure, Mon! Handling low memory conditions in iOS and Mavericks</a></li>
<li><a href="https://swift.gg/2017/09/07/friday-qa-2015-09-04-lets-build-dispatch_queue/" target="_blank" rel="external">从零构建 Dispatch Queue</a></li>
<li><a href="http://yulingtianxia.com/blog/2017/08/28/Threading-Programming-Guide-1/" target="_blank" rel="external">Threading Programming Guide(1)</a></li>
<li><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/" target="_blank" rel="external">Threading Programming Guide(2)</a></li>
<li><a href="http://yulingtianxia.com/blog/2017/10/08/Threading-Programming-Guide-3/" target="_blank" rel="external">Threading Programming Guide(3)</a></li>
<li><a href="https://swift.gg/2018/06/07/friday-qa-2015-02-06-locks-thread-safety-and-swift/" target="_blank" rel="external">Swift 中的锁和线程安全</a></li>
<li><a href="http://satanwoo.github.io/2016/10/23/multithread-dangling-pointer/" target="_blank" rel="external">浅谈一种解决多线程野指针的新思路</a></li>
<li><a href="https://bestswifter.com/deep-gcd/" target="_blank" rel="external">深入理解 GCD</a></li>
<li><a href="https://xiaozhuanlan.com/Grand-Central-Dispatch" target="_blank" rel="external">深入浅出GCD</a></li>
<li><a href="http://mrpeak.cn/blog/ios-runloop/" target="_blank" rel="external">解密 Runloop</a></li>
<li><a href="https://mp.weixin.qq.com/s/gPZnR7sF_22KSsqepohgNg" target="_blank" rel="external">Matrix-iOS 卡顿监控</a></li>
</ol>
<h2 id="通用知识"><a href="#通用知识" class="headerlink" title="通用知识"></a>通用知识</h2><p>iOS 开发中还有很多和其他计算机领域相通的知识，比如渲染、数据库、网络等。</p>
<p>推荐扩展阅读文章有：</p>
<ol>
<li><a href="https://lision.me/ios_rendering_process/" target="_blank" rel="external">深入理解 iOS Rendering Process</a></li>
<li><a href="https://objccn.io/issue-3-1/" target="_blank" rel="external">绘制像素到屏幕上</a></li>
<li><a href="https://swift.gg/2017/04/25/how-do-I-build-a-network-layer/" target="_blank" rel="external">手把手教你封装网络层</a></li>
<li><a href="https://github.com/Ikiga/IkigaJSON" target="_blank" rel="external">A high performance JSON library in Swift</a></li>
</ol>
<p>网络相关文章推荐如下：</p>
<ol>
<li><a href="https://mp.weixin.qq.com/s/BIfya6eVaWZW9ZEVz8RRcg" target="_blank" rel="external">百度App网络深度优化系列《三》弱网优化</a> </li>
<li><a href="http://zhoulingyu.com/2018/05/30/ios-network-traffic/" target="_blank" rel="external">iOS 流量监控分析 | 周小鱼のCODE_HOME</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-1.md" target="_blank" rel="external">TCP/IP（一）：数据链路层</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-2.md" target="_blank" rel="external">TCP/IP（二）：IP 协议</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-3.md" target="_blank" rel="external">TCP/IP（三）：IP 协议相关技术</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-4.md" target="_blank" rel="external">TCP/IP（四）：TCP 与 UDP 协议简介</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-5.md" target="_blank" rel="external">TCP/IP（五）：TCP 协议详解</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/tcp-ip-6.md" target="_blank" rel="external">TCP/IP（六）：HTTP 与 HTTPS 简介</a> </li>
<li><a href="http://chuansong.me/n/2577464" target="_blank" rel="external">携程App的网络性能优化实践</a> </li>
<li><a href="http://tech.meituan.com/SharkSDK.html" target="_blank" rel="external">美团点评移动网络优化实践</a> </li>
<li><a href="http://course.tuicool.com/course/details/58058f15a826b5f9e86678fb" target="_blank" rel="external">万人低头时代，支付宝APP无线网络性能该如何保障</a> </li>
<li><a href="https://mp.weixin.qq.com/s/qD9-Xj0CEil0Wtwq5eiPTg" target="_blank" rel="external">QQ空间在生产环境使用QUIC协议的经验</a> </li>
<li><a href="https://mp.weixin.qq.com/s/mRcz8o0usoqm_cEoGg9btg" target="_blank" rel="external">美图HTTPS优化探索与实践</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/https-9-questions.md" target="_blank" rel="external">九个问题从入门到熟悉 HTTPS</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/quic.md" target="_blank" rel="external">试图取代 TCP 的 QUIC 协议到底是什么</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/http-encoding.md" target="_blank" rel="external">小谈 HTTP 中的编码</a> </li>
<li><a href="https://github.com/bestswifter/blog/blob/master/articles/wireshark.md" target="_blank" rel="external">利用 WireShark 深入调试网络请求</a> </li>
<li><a href="https://juejin.im/post/59caf86ef265da06484467e5" target="_blank" rel="external">关于 iOS HTTP2.0 的一次学习实践 - 掘金</a> </li>
<li><a href="http://blog.cnbang.net/tech/3531/" target="_blank" rel="external">移动 APP 网络优化概述 « bang’s blog</a> </li>
<li><a href="http://wereadteam.github.io/2016/02/25/GYHttpMock/" target="_blank" rel="external">GYHttpMock：iOS HTTP请求模拟工具 | WeRead团队博客</a> </li>
<li><a href="https://knightsj.github.io/2017/07/18/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="external">YTKNetwork源码解析 | J<em>Knight</em></a> </li>
<li><a href="https://github.com/lefex/LefexWork/blob/master/blog/iOS/iOS%20%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%20HTTP%20%E7%9F%A5%E8%AF%86.md" target="_blank" rel="external">LefexWork/iOS 需要掌握的 HTTP 知识.md at master · lefex/LefexWork · GitHub</a> </li>
<li><a href="https://github.com/lefex/LefexWork/blob/master/blog/iOS/%E4%BB%A5%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E7%90%86%E8%A7%A3SDWebImage.md" target="_blank" rel="external">LefexWork/以不一样的方式理解SDWebImage.md at master · lefex/LefexWork · GitHub</a> </li>
<li><a href="https://blog.csdn.net/Hello_Hwc/article/details/72853786" target="_blank" rel="external">Alamofire的设计之道 - Leo的专栏 - CSDN博客</a> </li>
</ol>
<h2 id="专有知识"><a href="#专有知识" class="headerlink" title="专有知识"></a>专有知识</h2><p>专有知识我就不展开说了，参考上面舆图中标注的知识点去检索你需要的就可以了。</p>
<h2 id="视野"><a href="#视野" class="headerlink" title="视野"></a>视野</h2><p>推荐手册：</p>
<ol>
<li><a href="https://developer.apple.com/documentation/" target="_blank" rel="external">Apple Developer Documentation</a></li>
<li><a href="https://swiftgg.gitbook.io/swift/huan-ying-shi-yong-swift" target="_blank" rel="external">Swift 开发手册</a></li>
</ol>
<p>开源控件：</p>
<ol>
<li><a href="https://iosexample.com" target="_blank" rel="external">iOS Example</a></li>
<li><a href="https://www.cocoacontrols.com" target="_blank" rel="external">Cocoa Controls</a></li>
<li><a href="https://github.com/matteocrippa/awesome-swift" target="_blank" rel="external">awesome-swift</a></li>
<li><a href="https://xiaozhuanlan.com/topic/5796328014" target="_blank" rel="external">Swift 开源项目精选 - 应用架构角度</a></li>
<li><a href="https://xiaozhuanlan.com/topic/5271086934" target="_blank" rel="external">Swift 开源项目精选导图</a></li>
<li><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="external">SwiftGuide</a></li>
<li><a href="https://xiaozhuanlan.com/topic/7314260859" target="_blank" rel="external">Swift 开源项目团队介绍</a></li>
<li><a href="https://xiaozhuanlan.com/topic/9687124530" target="_blank" rel="external">Swift 知名开发者介绍</a></li>
</ol>
<p>视频推荐  <a href="https://talk.objc.io/" target="_blank" rel="external">Swift Talk - objc.io</a> 。</p>
<p>这里的 iOS 博客都很值得订阅，<a href="https://github.com/awesome-tips/blogs" target="_blank" rel="external">GitHub - awesome-tips/blogs: 行业优质博客汇总</a>。</p>
<p>其他资源参看上面的地图。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;43篇 &lt;a href=&quot;https://time.geekbang.org/column/intro/161&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《iOS开发高手课》&lt;/a&gt;已完成，后面会对内容进行迭代，丰富下内容和配图。最近画了张 iOS 开
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>白龙班</title>
    <link href="http://ming1016.github.io/2019/06/19/white-dragon-class/"/>
    <id>http://ming1016.github.io/2019/06/19/white-dragon-class/</id>
    <published>2019-06-19T11:24:38.000Z</published>
    <updated>2019-06-19T16:06:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是我十二年前写的一篇小说。当年每天早上8点半上班，为了写这篇，我四点起床，写到早饭前，坚持了好几周才完成。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>秋天的白龙山上，茂密的树叶渐渐枯萎，风中开始透着丝丝寒意。白龙班里多了五十来个一级成员。这些优秀的学生分布在不同的老师手上，如今飞逸老师手下已经有了九个一级成员，两个二级成员。</p>
<p>在这九名一级成员中，有一个学生名叫暴，沙西德星人，白发，常穿一套深紫底色黑花纹紧身衣，带着荧光坠子。她只用一年时间就升级成为一级成员。她为人十分冷淡，行事冷静，极少与人交谈。在升级竞赛中她选择的科目是作曲，她的参赛乐谱《清心宁静》， “宫，商，角，徵，羽”五音协调，吹坃器奏出，这是非常传统的一种谱曲，现在使用的并不很多。评委起初就觉得曲子十分好听，只是觉得由这小姑娘吹坃器而出，太过传统与演奏者形象不太协调。但这曲子实乃暴所谱。到了后面部分，节拍渐渐加快，五音又加上两音，使得曲子淳化入耳，正当评委听得心情震荡，如痴如醉之时，曲子极速进入高潮，两三个回旋之后戛然而止，余韵绕梁，意犹未尽。暴将坃器放下，一个评委上前拿起这坃器仔细观摩，显然这位年轻的评委还没有见过这古老的乐器。</p>
<p>年轻评委问道：“你这玩意吹出来的声音很奇特也很好听，能告诉我这是什么吗？”</p>
<p>暴表情平淡地说道：“这是沙西德星特有的吹奏乐器，我们叫它坃器，坃器形体为平底卵形，拿在手中便可运指演奏，为了减少复杂的叉口指法，我将其音孔按相似于冥星笛子的音孔顺序排列。坃器的吹奏者可吹出二十六音，包括两个八度内的全部半音和一个泛音。”</p>
<p>年轻评委说：“原来是坃器啊，坃器的曲子我以前也曾听过，但是怎么听你演奏的味道与以前我们听过的完全不同。”</p>
<p>暴说：“那是当然，我很早就开始制作仿古的坃器，把古制梨形六孔骨坃器改造为新型的九孔坃器，材料使用的是沙西德的紫陶。这九孔坃器在保留了原六孔骨坃器的外形和音色上又增大了音量，扩展了音域，能吹出全音阶和半音阶，使它成为可以转调的乐器。”</p>
<p>年轻评委说：“难怪这音色这么古朴醇厚，低沉悲壮，极富特色。你改变以前坃器的音孔排列方式，使演奏更为方便容易了。我还想问一下，是不是用它既可以独奏，又可以合奏或伴奏？”</p>
<p>暴回答说：“合奏伴奏就不必了，我一直都是用它独奏。”</p>
<p>年轻评委继续问道：“我以前听说坃器难奏高音，不知你的《清心宁静》后半部分能演奏出高音是何缘故。也是因为你改造了坃器的缘故吗？”</p>
<p>暴说：“正是。但是我后面那部分曲子并不是我参赛曲子《清心宁静》，而是我另外一部《心无点尘》，我一时兴起将它奏了出来。如要让坃器奏出高音，并不难，只是演奏高音的方法还需多多研究。你仔细看看我的那个坃器。”</p>
<p>年轻评委接过暴递过来的坃器，仔细察看。见那坃器平底卵形，紫陶铸就，高大约八厘米，腹径七厘米，外表镶嵌一块红木，红木饰片上刻绘着一条白龙和几块云纹。音孔前七后二，加上侧面一个较大的孔，共为十孔。年轻评委看到这里，大悟般说道：“我明白了，全凭多出的这一个大孔。”</p>
<p>暴冷冷的说：“不是。是因为所用紫陶的缘故。那个较大的孔是吹孔，刚才我吹奏时你没注意到吗？”</p>
<p>年轻评委的脸一下子红了起来，原来刚才他听得如醉如痴，似入仙境一般，眼眼一直看着美丽冷艳的暴，如同听着悦耳曲子时欣赏着一副赏心悦目的画一般。至于那音乐如何发出的他哪里顾得管啊。</p>
<p>暴伸手将年轻评委手中拿着的坃器拿了过来，转身将其放入挎包里，顺手取出一只嗤，众评委猜想这一定又是一件被改造过的古乐器，于是没有再多问些什么，示意暴继续演奏。</p>
<p>一段悠长的颤动波过后，曲子很快进入欢快阶段，节奏虽快，却不杂乱，欢快愉悦之情随即而来，老者听此便会忆起儿时欢快时光，中年人听时便觉余力未减，青年听时顿感热血沸腾。嗤原本只有六孔，还包括了上出孔，是底端封闭的一种横吹竹管乐器，嗤和笛用料相同，读音相近，但是所奏之音却大不相同。暴手中这个嗤如坃器般被改造为十孔。使用半孔指法﹐可吹全十二律。</p>
<p>众评委看着暴熟练的运指动作，手中无不揑了一把冷汗，但凡使用过乐器又特别精通笛和弦奏乐器类的人，无不惊叹暴的这双手能够在同一节拍中同时奏出许多种音，听起来如同四五个人合奏一般。监管人员也当场确定暴没用魔法舞弊。</p>
<p>正当大家全神关注暴的演奏之时。有一位女评委实在忍不住了，她突然站起来说道：“等等。”</p>
<p>暴立即停止吹嗤动作，奇怪的看着她。发现这个女评委方形脸蛋，带着一副眼镜，其余没有什么特别之处。</p>
<p>女评委说道：“你停停，你再将先前那《清心宁静》重奏一遍，当然能够顺便将《心无点尘》也吹奏出来那是最好，我很想再听一遍。”</p>
<p>暴漠视的说道：“我那《清心宁静》有九十八段，《心无点尘》二百零一段。我怎能在这一下子奏完。这些曲段都是我根据所遇不同事情时的不同心情谱写出来的。竞赛开始时我有几分紧张，所以我吹奏了其中一段“闭月羞花”。时间一长，我就不再紧张，我便随性吹奏了《心无点尘》中的一段短曲“催情”，后觉不妥，便将其缩短，草草结束。你竞然叫我把它们全部重奏一遍，我怎能办到呢？”</p>
<p>女评委看暴并无善意，她用眼神余光向周围瞧去，看到的都是众评委对自己的责怪，就识趣的坐了下来。</p>
<p>在场的还有冥星大型集团的许多高层人物，他们一眼就看出了暴的商用价值，她那两部曲谱和接近三百个极具特色的曲段如果用于商业演出，一定能创造很大的利润。而且暴还很年轻，仅十六岁，且相貌出众，身材匀称。当即在场的那些高层人物争相询问起暴的相关情况来。</p>
<p>暴正准备离开竞赛舞台，主评委叫住了她。</p>
<p>暴扭过半边脸低声说：“我已奏完，如何评断你们商量去吧，如你们不是因为我的曲子而是我本人的缘故评判不公，损坏的只是你们白龙班的名誉，与我无关。”</p>
<p>主评委一脸委屈地说道：“我不是这个意思，我想我们在座各位评委对你的曲子都十分喜欢的，你也不用担心升级一事。多少年来，白龙班很少有人能像你这样，不仅能谱出美妙的曲子，还能将古乐器改造为适合演奏所谱曲谱的乐器。我并不是要勉强你再奏一遍，我只是觉得你使用的是大家所不熟悉的乐器，你吹奏一遍就让众评委对你做出正确评价是有一定难度的。你为何不用一件通用乐器来演奏一遍呢？”</p>
<p>暴心想：“这般绕弯子，就是不相信我了。难道他们还以为我这乐器中有猫腻吗？”</p>
<p>暴走下舞台，将下个准备登场学员手中的笛子一把夺过来，坐在舞台边背对着评委，独自吹了起来。这曲子像是用坃器和嗤吹出，由于这两种乐器的音律评委们以前很少听到，俗话说音乐效果三分在曲，七分在音。由于大家对笛子声非常熟悉，所以曲子的精妙之处用笛声完全展露出来，众评委这才意识到方才所听坃器和嗤之音优美并不是那坃器和嗤有什么奇妙，而是演奏者技艺高超。于是对暴更加佩服起来。</p>
<p>原来暴从小就会吹奏笛子类主流乐器，只是最近几年，为采集多样音色，开始研究起改造古乐器来。虽然好久没有使用笛子了，这下吹起笛子来仍然娴熟不减当年。</p>
<p>天色渐黑，排在她后面等待竞赛的学员觉得暴所奏曲子强于自己太多，渐渐地差不多都自己离开了。大多数学员由于循规蹈矩，在曲风把握上没有突破，一年能谱四五段新曲已算较多，但如果追究这些新曲的来源，总是能够找到相对应的曲谱来。暴所谱曲段却风格众多，虽显繁杂却不失节奏，尽显新意，随心所欲，果真是信手沾来，皆成新曲。</p>
<p>最后在场的只剩下几名对作曲痴迷的学员。评委一个都没有离开，谁都不愿意丢掉这样一个能够将《清心宁静》欣赏完的机会。次日早上，也不知道暴演奏到第多少段了，总之没有一段是重复的，段与段之间衔接处理得天衣无缝，每当从一段不知不觉切换到另一段时，众评委无不“啊”的一声恍然大悟，随即鼓掌表示自己的钦佩之情。暴吹得有些倦了，望一眼远方刚升起的红彤彤的太阳，伸了一个懒腰，丢下还沉醉在音乐中的评委们，招呼没打一声就离开了。</p>
<p>这一晚飞逸也一直呆着那里，虽然她不是评委，也不是很精通乐理，但是从那些专家的议论中，她已经感到暴的了不起，对她产生了好感。后得知暴将分配到自己手下，心中更是欣悦无比。</p>
<h2 id="雪叶归来"><a href="#雪叶归来" class="headerlink" title="雪叶归来"></a>雪叶归来</h2><p>这天，雪叶曾经呆住了一年、受尽苦难的房屋门突然打开了，踏步走进一个人来。此时房间里已堆积了厚厚的一层灰，房角上布满了蜘蛛网，破烂的被褥还横七竖八地摊在床上，被褥上面也已经蒙上厚厚一层灰。显然两年来这里没有人来过。来人衣衫洁净，脚穿一双粉红色长筒靴。这人走到床边那面镜子旁，用手抓住袖口，慢慢拭去镜上的灰尘，一张妖娆娇媚，似玉生香的脸庞渐显出来。这时，她双眼流出泪水，镜台渐渐的被泪水给洗干净了。这时，她好象看到镜中浮现出一个头发散乱，枯皮瘦脸，衣衫褴褛，却同自己一般泪流满面的苦女子。</p>
<p>这人坐在床头看着敞开的门呻吟道：“米生，我还在这里等你啊！我一直想念着你，你知道吗？我一定要等你回来！”</p>
<p>这人一直坐在那，久久没有起身。</p>
<p>她就是雪叶，如今她已在明朝学府的另外一个叫做斑国班的班上取得了一级成员身份，现在办理了转班手续，今天回到了白龙班，依旧在飞逸老师手下做学生。当飞逸看到转班生的名字叫雪叶的时候，曾经大吃一惊，一度推辞不愿接纳。但由于其他老师没人愿意接纳这个传奇式的学生，因为雪叶曾是自己的学生而终于不得已将她接纳下来。</p>
<p>这时的雪叶，无论是衣着还是言谈举止已与往日大不相同，两年的变化着实让以前所有认识雪叶的人吃了一惊。雪叶一回到白龙班，就到米生住处去找米生，长川贞等人告诉雪叶，米生外出去给白龙班办事情去了，什么时候回来他也说不准。雪叶白天在白龙班里学习，夜晚就回到山下那间小屋中去等米生。</p>
<p>飞逸看雪叶每天晚上总是独自离开白龙班，去住山下。一天，她跟踪雪叶来到白龙山下。雪叶曾经住过的这间房屋与镇上其它房子相距很远，处在香川井镇的边缘地带。在这秋尽冬来的季节里，这间破旧的房屋周围的树木叶子已尽脱落，门前那条春夏潺潺流淌着的小溪早已枯竭。飞逸看着雪叶开门走进那间小屋，她便悄悄的躲在外边听里面的动静。</p>
<p>夜里四处一片漆黑，寒风飕飕刮着，枯枝发出唰唰唰的响声……忽然，屋中传来凄凉的哭声，这哭声撕心裂肺，听着叫人不寒而栗。</p>
<p>就这样飞逸一连跟踪了雪叶半个多月，发觉雪叶除了每晚去白龙山下的小屋外，没有任何异状，也没有和其他外来班级人员联络，方才放下心来。</p>
<h2 id="白羽号"><a href="#白羽号" class="headerlink" title="白羽号"></a>白羽号</h2><p>飞逸门下除了雪叶外，其他十个一、二级成员都学习和生活在她用尽毕生心血研制的一艘叫做“白羽号”的巨型太空飞船上，这架太空飞船放置在白龙班五层，此层是白龙班专门用来建造和存放大型飞船的兵工厂基地。</p>
<p>明朝学府一级成员要成为二级成员也需要通过竞赛，但是这个竞赛的范围扩展到了整个明朝学府，每一个学科的竞赛者都来自所有明朝学府各班。哪年哪个班要是能够有一个人成为二级成员，那就是十分了不得的事情了。白龙班仅飞逸老师一人手下就能够有两个二级成员实属不易，当然这也得亏飞逸在整个明朝学府中是一位十分有名的飞船设计师，那两个二级成员都是在飞逸老师的指导下，依靠电子学知识设计了新的机器人，才在竞赛中取胜而成为二级成员的，这自然也成了吸引其他优秀学生投入她门下的重要原因。</p>
<p>雪叶每天穿梭于飞逸“白羽号”太空飞船和小屋之间，慢慢体会着当年米生来回奔波的辛苦。这两年里冥星议员的女儿月湖和教米生招式的德斯都陆续成为了一级成员，其他的一级成员分别是个子较小的乐天派爱笑女易慧，方脸长鬓角的宋藏金,年龄偏大专攻单挑竞赛的华房星,月湖的妹妹半月,爱热闹的小侃和喜好乐器舞蹈的暴。另外两个二级成员是带红宝石耳环，身材高挑，抚媚的紮惑浮和头戴黑色魔女发冠，胸前带红宝石胸针，表情严肃的凌穆。雪叶当年一起学习的那些人由于难以取得一级成员身份而陆续离去，加之这两年雪叶一直都没有露面，白龙班极少有人认识她。</p>
<p>在白龙班里学习，不管级别高低，上午的课程都是在一起学习，下午一般各自研习各自学科项目。飞逸门下学生在“白羽号”建设初期就开始在它上面学习。冥星八六九八年十二月二十一日，这天，是“白羽号”峻工的日子，飞逸上午在传授完推进器原理后，将所有一级以上成员叫到自己的房间。飞逸的房间在“白羽号”前身部位，第五段，四十三区，301号间。飞逸的房间一共七百多平方米，分为两层：第一层有餐厅，客厅和卫生间；二层是实验室，娱乐室和卧室。飞逸招呼他们五人坐在客厅沙发上，自己去餐厅在点餐机器上选择了几份快餐，几分钟时间快餐便通过专用管道输送过来。</p>
<p>飞逸将吃的分发给每个人，自己拿了一份，吃了一口说道：“我们边吃边说，以后我们每天下午都要这样在这里聚餐，一起讨论白羽号的改进和白龙班的前途。”</p>
<p>易慧说：“我们这些人里还没有会制造飞船的人，紮惑浮和凌穆也只是对机器人制作精通而已。我们想帮你也帮不了啊。”</p>
<p>小侃接着说道：“是啊，我们现在还需要学习，现在飞船技术对我们来说还是很陌生的。”</p>
<p>德斯补充道：“如果说那些批量生产的飞船，不用多久我们就能够学会操作，原理的学习也用不了多久。但是老师这飞船设计巧妙，功能众多，体积巨大却仍然能够灵活运动等等，真是难以学会操作，更不用说对它进行改进了。”</p>
<p>半月说：“都这么长时间了，我还没有走遍过这“白羽号”，它真的是太大了。”</p>
<p>小侃说：“别的那些我们还不了解的先别说，光是看看老师房间的这个客厅就知道这飞船的设计有多精妙了。墙那边的那盆含羞草是一个音乐播放器，轻轻触碰它的叶片它就会立刻紧闭下垂，像害羞少女一般，含羞草的细胞是由细小如网状的蛋白质即股动蛋白所支撑。产生闭合运动时，股动蛋白的磷酸会脱落，当股动蛋白束散开时，细胞被破坏，结果水分跑出来，以致产生闭合运动。这种股动蛋白一般存在于动物的肌肉纤维里，飞逸老师将这种股动蛋白智能化，如同医生把脉一般，使之能够得到触碰者的心情数据，根据这心情数据播放出触碰者想听的音乐。还有这飞船的墙壁，地板和天花板全是光声感应屏，别看上面显示的是山水、瀑布、小溪、树林的风景画，飞逸老师工作时，这些感应屏幕就变成了系统显示器。它通过接受控制器发出的光感信号进行操作，地面可选区域进行全息图像显示。控制器使用的是表面声波式触摸屏，之所以没有用其它如电阻式，电容感应式，红外线式触摸屏，是因为表面声波触摸屏具有清晰度较高，透光率好的特点，耐用性，抗刮伤性良好。电阻式和电容感应式等表面有层度膜，使得清晰度和灵敏度稍差。表面声波式较其它类型触摸屏缺陷在于要经常去尘，灰尘会阻塞触摸屏表面的导波槽，使声波不能正常发射，或使波形改变导致控制器无法正常识别，但是这个缺陷在白羽号里完全可以不管，因为白羽号内对空气的净化工序相对于其它量产和非量产飞船来说是最好的，里面几乎一尘不染。”</p>
<p>易慧说：“我也喜欢表面声波屏，特别是它少了那层度膜，有那层度膜会使屏幕模糊，影响使用效果。小侃你知道它的原理吗？改天我们也将我的那个电阻式触摸屏控制器改造成声波屏的吧！”</p>
<p>小侃愣了一下，看看周围，见没人答话。她这时看见飞逸老师在一旁微笑着在听她们对话。</p>
<p>小侃尴尬地说：“我，我也不知道这原理，其实我连那些老式的原理都不清楚。我们一级成员怎么可能知道这些，你要问就问紮惑浮或凌穆好了。她们俩都是专攻电子学科的。”</p>
<p>暴突然说道：“这个简单，我知道，不用去问她们。声波屏的三个角分别粘贴着东、西、南、北四个方向的发射和接收声波的换能器，四边刻着反射表面超声波的反射条纹。当手指或软性物体触摸屏幕的时候，部分声波能量被吸收，变为接收信号，这些信号经过控制器处理后成为触摸者所要的东、西、南、北坐标。”</p>
<p>易慧问道：“什么是换能器。”</p>
<p>暴说：“我真奇怪你是怎么升上一级成员的。换能器是用特殊陶瓷材料制成的，分为发射换能器和接收换能器。它的功能是把控制器通过触摸屏电缆送来的电信号转化为声波能和由反射条纹汇聚成的表面声波能变为电信号。”</p>
<p>飞逸在一旁听着暴那有条不紊的原理讲解，心中暗喜。</p>
<p>德斯冷嘲热讽道：“想不到你们对这些偏门的小玩意这么有兴趣，知道的东西不少啊！”</p>
<p>小侃这时拿起茶几前的控制器，输入一串密码。墙壁，地板和天花板的风景画立刻变为白羽号各个部位的结构图，茶几和一些装饰用的植物都被移到地板下一层隐藏起来，沙发根据所坐人数将多余的部分也埋进下层，大家围坐成一个圆圈，中间呈现一个巨大的白羽号全息图。</p>
<p>小侃奇怪的说道：“原来老师早已经给我们准备好了。”</p>
<p>飞逸接过小侃手中的控制器，这控制器有十二寸大小，整个控制器仅是一块可触摸屏幕，她随手在上面点了几下，每个沙发被分为上下两块拉开，里面出来一个支架，随后沙发又合并上，每个支架上都架着一个和飞逸手中一样的触摸屏控制器，可以随意取下安上。触摸屏控制器旁还配有一台含羞草音乐播放器。</p>
<p>飞逸说：“点击控制器屏幕右下角图标，可以选择将沙发移动到不同区域，我已经定制好七十八个区域，这些区域分别模拟了白羽号的各个部位，在这个房间里可以对白羽号进行模拟改进，七十八个区域前都有相对应部位的全息图，中间是整个白羽号运作效果全息图。你们可以先试试看。”</p>
<p>小侃他们都选择了，接着沙发开始移动到各个区域去，如果几个人选择的区域相同，沙发会自动排列好，当沙发移到对应区域时，控制器系统会自动切换到对应部位的可编写系统中，编写代码也是使用触摸方式，人们可以随时调用操作系统屏幕下五分之二区域作为代码输入区。</p>
<p>飞逸看他们已经各就各位，说道：“我知道你们对太空飞船不够了解，更别说我研制的这个白羽号了。我虽然是你们的老师，但是从级别上来说我还是和紮惑浮，凌穆一样是个二级成员。按照明朝学府的规定，要成为三级成员，首先要申请为老师，门下必须有三名学生升级成为二级成员。还有一个条件就是在某一专业里的成就获得学府内阁承认，最后方能升级成为三级成员。如今我已有紮惑浮和凌穆两个二级成员，加上白羽号这个已经研究成功的成果，就差一个二级成员学生和白羽号的进一步完善了，我升级为三级成员指日可待。我叫你们下午到这里来帮助我也是这个缘故，我要在这一年里从你们这些一级成员中培养升级一个二级成员。其他人我将教给你们飞船的相关知识，以便和我一起完善白羽号，使白羽号能够尽快获得明朝学府内阁的承认。”</p>
<p>易慧，小侃，月湖，半月等都为飞逸感到高兴，想到自己老师马上就能够成为三级成员，无不感到脸上有光。紮惑浮和凌穆也因目前自己无法通过学府审核而独立师门，只好决定继续跟飞逸学习更多的太空飞船知识。</p>
<p>雪叶心想：“白龙班学生自私和势利，原来都是自老师学来。飞逸老师为了自己尽早升级，不顾他人如何想法，就一起喊来帮忙。不过看来同学们也挺开心似的，毕竟飞逸还要从他们中间培养一个二级成员，她一定会将自己的知识全部传授出来。现在我们一共有九名一级成员，飞逸会重点培养谁呢。不管她心中人选是谁，我都要全力争取，我要让米生回来时看见我的级别高高的，而不是以前那个可怜的雪叶，让他离开月湖，跟我过上好日子。”</p>
<p>飞逸看见雪叶一个人低着头在想什么，就没有去理会她。她又看了一眼暴，然后对大家说道：“你们自己先在这里看看白羽号内部结构的资料，有不懂的问题到二层来问我，我在二层实验室里一直工作到晚上十一点，只要是问的有关白羽号的问题我都会回答。如果你们学习感到累了，可以到二层娱乐室里休息休息。以后每天都这样安排。”</p>
<p>飞逸说完就走向暴，跟暴说了几句话后就上楼去了。雪叶将这一切看在眼里。心想：“飞逸一定有意要培养暴，暴资质奇好，可是飞逸她肯定也知道我在斑国班升级也只用了一年时间，而且去年我同时得到了单挑，电子，魔法三个学科的第一，我的成绩决不比暴差。自我回来后，飞逸总是避开我，不知是何缘故，这我得好好问问。”</p>
<h2 id="白艳公主"><a href="#白艳公主" class="headerlink" title="白艳公主"></a>白艳公主</h2><p>晚饭时分，雪叶正打算离开飞船回到山下小屋去，发现暴起身向飞逸二层工作间走去，雪叶跟上暴，将她叫住。问道：“是飞逸老师叫你这个时候上去找她的吗？”</p>
<p>暴感到奇怪，她说：“你怎么知道的。”</p>
<p>雪叶笑了笑，说道：“没什么，我们一起上去。”</p>
<p>暴点了点头和雪叶一起走上飞船二层。飞船的二层和一层面积一般大小，一上来就是一个娱乐大厅，大厅东侧“金珠坊”设有吧台，西侧“赢珠坊”设有十多张赌台和二十多台角子机。北侧“御匾所”地面为绿草地，碎石子铺路，“御匾所”中央有白月池，池边假山环绕，池上有一座拱桥叫白月桥，过桥池中间有一飞檐亭，亭旁有松，有梅，有竹。这里的竹林挺拔翠绿，且成主体。因竹表会友意，故此处亭子名会友亭。飞逸来到会友亭显然已有多时，当她看见雪叶和暴一同上来时，脸色一沉，叹了口气。</p>
<p>暴快步走近飞逸，说道：“老师，你找我有事吗？”</p>
<p>飞逸看了一眼暴身边的雪叶，说：“暴，雪叶，你们俩和其他的一级成员相比具有很大优势，从你们升级竞赛情况看来，你们能力并未完全发挥出来。雪叶，你擅长的学科较多，虽然二级成员竞赛是在整个学府进行，但你机会却比其他学生要多，那次你在斑国班一连取得三个第一名，着实在他们班风光了一回，我也耳有所闻。你以前是我们班的，我打心底为你感到高兴。暴，我总看见你驾驶着一个白色机器人，是叫‘白艳公主’对吧。那个是你做的吗？”</p>
<p>暴点了点头。</p>
<p>飞逸接着对暴说：“我还以为你会参加电子竞赛，结果你仅仅报名参加了作曲一门竞赛。你那场作曲竞赛我看了，相当精彩，人们都听得入了神，当时人们感觉时间过得很快，转眼间一晚上就过去了。”</p>
<p>暴说：“我这人对作曲感兴趣，就觉得没必要参加那么多门类竞赛了。”</p>
<p>飞逸说：“难得你这么自信，你来白龙班之前就制造了‘白艳公主’机器人，是谁教你做的？”</p>
<p>暴说：“是我母亲教我做的。”</p>
<p>飞逸微微一惊，她说：“能问问你母亲是谁吗？”</p>
<p>暴说道：“你问我母亲干嘛？”</p>
<p>飞逸一脸尴尬。</p>
<p>暴马上感觉到这样回答对老师有些不敬，就改口说道：“我母亲是沙西德星德比学府的老师。”</p>
<p>飞逸说：“哦，原来不是明朝学府的，难怪。我叫你来就是想多了解了解你。还有，去年你为什么会选择来白龙班呢？”</p>
<p>暴说：“我到白龙班来原因很简单，全都是因为这场学府大战。由于爆发战争，母亲被迫参战，结果前年在你们白龙班领域死去。我自小是母亲带大，母亲性格倔强，树敌无数，我都不知道她是战死沙场的还是被自己人害死的。我如果回沙西德星，定是凶多吉少。我听说冥星政府不能控制各学府间爆发战争，各学府里各个班级立场也有不同，白龙班处于中立，我自然就选择了进白龙班，与其说是加入白龙班来学习，不如说是逃难来了。”</p>
<p>飞逸说：“说起这场战争，我虽是冥星人，但也不怪你们沙西德人。你们星球的人民也无法掌握自己的命运，全球居民和学府里的人都要服从沙西德国王政权，国王说要打谁你们就得去打谁，政府对你们进行的是洗脑式教育，从小给你们灌输的是效忠国王的思想。冥星政府无法控制学府，明朝学府里各个班级都是各自为政，各辖一方。我不认为我们冥星比你们沙西德星好。你看这次问题就暴露出来了，冥星遇到了外敌侵略，反侵略得不到更多人的支持，爱国者被人称为不爱和平的人，冥星在受到外敌侵略的同时发生了内战危机。”</p>
<p>暴说：“此话不假，家家都有本难念的经。我来白龙班这一年里，就看到了由于白龙班和沙西德星签订了不战条约，白龙班屡遭明朝学府其他班级袭击的许多事情。”</p>
<p>飞逸说：“现在冥星就像一盘散沙，正被沙西德星和狱星一起欺负。好了，我说这些和白龙班宗旨无关的话干什么？”</p>
<p>暴说：“好吧，你的问话我都回答了，那我先走了。”</p>
<p>暴说完便转身欲走，飞逸忙说：“等等。”</p>
<p>暴停下正要移动的脚步，转过半边身子说：“老师还有什么要问的吗？”</p>
<p>飞逸看了看暴冷漠的眼神，又看了看雪叶，心想：“暴年龄虽小，但由于她母亲从小就教给了她著名的德比学府里的上乘知识，她自然是不在乎其他的知识。如果她不用明朝学府里的技术升级，只怕学府评估时不会将她算做我的学生。除了雪叶外，其他那些一级成员离二级成员的升级条件相差太远。我升到三级成员的希望就只能够寄托在雪叶一个人身上了，但雪叶……”</p>
<p>飞逸对暴说：“你现在没有了亲人，已经是白龙班的学生，就把这里当作你的家吧！以后有什么困难你直接跟我讲，我会将我所有的知识教给你。你先回去吧，我还要话要跟雪叶说。”</p>
<h2 id="米生"><a href="#米生" class="headerlink" title="米生"></a>米生</h2><p>暴答应一声就下楼去了。飞逸看暴走后，对雪叶说：“自你回白龙班后，我一直都有问题想问你。”</p>
<p>雪叶说：“如果今天我不是自己上来，只怕你是不会问我的了。”</p>
<p>飞逸说：“不是。我只是平时太忙，一直没有抽出时间来。”</p>
<p>雪叶心想：“哼！我回白龙班后你就一直对我不闻不问，还处处躲着我，你知道我总是晚饭时分离开，就叫暴这个时候上来，分明是故意不让我知道。真是虚伪，难怪米生不喜欢你。你不想教我，我就偏不服这个气，就是偷学我也要将你的本事学到手。”</p>
<p>雪叶想到这里，便笑着说道：“飞逸老师难得有空，现在你想问我什么就问吧！”</p>
<p>飞逸说：“你在斑国班的日子过得还好吧？”</p>
<p>雪叶说：“谢谢老师关心，我在斑国班的日子过得很好，那里的老师对我很亲切，说句实话，我还真不想离开那里呢！”</p>
<p>飞逸说：“那你为什么又回来了呢？”</p>
<p>雪叶说：“当然是为了和米生在一起了！我听长川贞说他去给白龙班办事去了，你知道他什么时候回来吗？”</p>
<p>飞逸听到雪叶为米生而回，不自觉地后退了一步，关上冒出汗来，紧张得脸色苍白。她结结巴巴地说：“我……我不知道，你还想见米生干什么，他对你那样……难道你是来找他报仇的吗？”</p>
<p>雪叶依然笑着回答说：“你们误解我了。我来只是想和米生重归于好，和他一起过上好日子。米生自来白龙班后就一直没有过过好日子，他以前那样对我是环境所逼，并非真心喜欢他人。现在我已经是个一级成员了，我们就不用再过苦日子了。而且我还要继续升级，帮米生实现他的梦想。”</p>
<p>飞逸看雪叶一字一句说得认真，神情也十分真诚，知道她的话均出自真心，就说道：“那天你离开白龙班，月湖抢过米生手中的电子记事本，知道了一切。因为你已经中了米生下的毒，我们还以为你已经死了。米生他这样对你，你就不恨他吗？”</p>
<p>雪叶说：“我从来没有恨过他，虽然当时我很难过，但后来想想也是，我当时那副模样谁瞧见会喜欢我呢？我现在最大的愿望就是马上见到米生，让他知道我们在一起以后会很幸福。”</p>
<p>飞逸心想：“米生只是个见利忘义的小人，而且心狠手辣，真是可怜雪叶了。如雪叶说的是真心话，那么……”</p>
<p>飞逸说：“你现在这身份，只怕米生高攀不上了。”</p>
<p>雪叶说：“米生就是再没本事，我都不会嫌弃他。飞逸老师，你能告诉我米生到底去哪里了，什么时候回来吗？我问了其他老师，他们都说不知道，他是你的学生，如果你说不知道，我还能够去问谁呢？”</p>
<p>飞逸说：“我要是知道一定会告诉你的。你那次中了米生下的毒是怎么好的呢？”</p>
<p>雪叶说：“那天米生回来不认我，我一个人恍恍惚惚跑下山后，被香川井镇的人抓住，他们将我遣送回华尔辞，途中用药给我解了毒。我违规住在明朝学府，如回到华尔辞必定要受惩罚，可能要在监狱里呆上十几年甚至更长时间。那时我唯一担心的是这次和米生一别，日后再无法相见。于是路经斑国班领域时，我就拼死从飞船上跳了下去，侥幸落到湖水中，后被斑国班里的人救起，我才有了今天。”</p>
<p>雪叶说到后面的遭遇时表情异样，完全没有了谈及米生时的那股兴奋，飞逸心想：“这两年里，雪叶她一定受过很多委屈，方才她那番话虽说未必属实。但我估计，这两年时间里支撑她活下来并拼命努力的唯一动力就是米生了。”</p>
<p>飞逸鼓励她说：“你的潜力很大，当年完全没有必要把机会让给米生，如果当年是你留在白龙班，说不定你们的生活早就过得很好了。如今你再加把劲，让米生回来看到你的大有作为，为以前自己的绝情感到内疚吧。”</p>
<p>雪叶又开心起来，说：“对，要他内疚一下也好，我要让他知道要珍惜我。日后我还需要老师你多多的帮助呢，只有老师你帮助我，我才能进一步升级啊。”</p>
<p>飞逸说：“和我不用这样客气，你是我的学生，有什么不懂的，问我便是。”</p>
<p>雪叶说：“这是当然了，我又怎么会和老师您客气，我只是希望老师多关照我一下。”说完，雪叶抬头看了看大钟，说：“老师，对不起！时间不早了，我要下山了。</p>
<p>飞逸说：“你为何每天都要下山。“白羽号”里住不习惯吗？”</p>
<p>雪叶笑着说：“不是，我喜欢住在我以前住过的那个小屋里，在那里有米生和我生活的许多记忆。回忆虽然苦多甜少，但却令我难以忘怀。”</p>
<p>飞逸说：“我能够理解你的心情，我也有过你这样的年龄，也曾有过类似你的感觉。等你再长大些，这些感情的事可能对你就不再那么重要了。”</p>
<p>雪叶笑着摇了摇头，离开了。飞逸站在原地很久没动，心中很是感慨。</p>
<h2 id="求知"><a href="#求知" class="headerlink" title="求知"></a>求知</h2><p>后来的日子里，一级成员们每日上午和学员一起学习，下午就到飞逸的房间里进行“白羽号”的研究。除了暴以外，飞逸给一级成员每人都制定了学习计划，计划的范围，几乎都是些操作飞船的技能。雪叶想深究却得不到足够的帮助，她上二层房间找飞逸时，飞逸总是和暴单独在一起。对雪叶提出的问题，飞逸每次都只是简单回答了事。雪叶心中十分气愤，对飞逸耿耿于怀。</p>
<p>一次，雪叶在白月桥上碰到飞逸，她提问说：“我看资料中提到‘白羽号’左侧装甲板在作战时会注入一种叫做‘猛禽’的物质，导致形状变化，结构强度增大，并且会拥有自我修复功能，特别能够有效的防御配备斩舰刀的机器人。斑国班却有一种非量产机器人叫‘孔雀红’，由尤科斯老师制作，这个机器人配有一把斩舰刀，比之其它刀显得更长更锋利，刀身由高密度的重金属粒子制成，平时压缩放置在‘孔雀红’左肩的护甲上。对大型战舰有一刀两断的威力，它主要针对的就是那种拥有自我修复功能的战舰。飞逸老师，你说，你的‘白羽号’和尤科斯的‘孔雀红’都说自己是对方的克星，不知道较量起来谁比谁厉害。现在你给我们看的资料全是封装好的，我想深究却无从下手。我看这资料只适用于学习驾驶。”</p>
<p>飞逸倒十分镇定的说：“这本来就是一个循序渐进的过程，不可操之过急。我这样做不过是希望你们先能够系统的了解‘白羽号’。”</p>
<p>雪叶气愤的说：“那你每天给暴讲的也都是这些皮毛知识吗？”</p>
<p>飞逸看了看一旁的暴，暴正坐在亭边椅子上把玩掌上触摸屏控制器，对她们的谈话并没在意。</p>
<p>于是飞逸说：“暴因以前所学的电子学并非我们明朝学府里的电子学知识，我担心她竞赛时会因为这个原因而无法升级，所以我把我们白龙班的电子学知识从基础开始对她个别辅导。”</p>
<p>雪叶说：“你骗我，电子学科知识明明可以相互通用的。”</p>
<p>暴这时站起身来说道：“明朝学府和德比学府在电子学方面教的知识区别很大，但是飞逸老师也并不是从头教我。融会贯通我还是会的。你刚才问的问题需要清楚的知道，两个机体所用材质性能和它们的能量产生原理，这才能够通过计算得出哪个机体对拼起来比较占优的结论。一层那些白羽号的资料确实太过浅显，作为驾驶的参考还行，作为一名优秀驾驶员掌握这些知识还是远远不够的。驾驶员除了经验外，了解其驾驶机体的原理和材质是必要的。比如说，敌人攻过来，机师根据自身机体情况要判定守还是回击。这时谁对自己驾驶的机体了解的多谁的判断就会更准确。”</p>
<p>飞逸先以为暴是因为自己给她传授了上乘知识，才采用不理睬的态度来回避。没想到暴为人耿直，从来都不玩虚的。</p>
<p>雪叶生气地对飞逸说：“你看，暴这样一个外星学生都觉得你给我们的资料太浅。”</p>
<p>飞逸无语。</p>
<p>暴对飞逸说：“雪叶既然这么想研究你的‘白羽号’，你就教她吧。不用在我身上花时间，升不升级对我来说意义不大。”</p>
<p>飞逸说：“我当然希望你们俩都能够升级。但是同一门学科一年只有一个人夺得冠军升级。”</p>
<p>雪叶说：“那你的意思就是暴比我更有能力夺第一了。”</p>
<p>暴说：“老师如果是这个意思，我愿意退出。老师不用担心我不能升级，我可以在作曲学科上拼一拼。”</p>
<p>雪叶对暴说：“你要是退出，飞逸老师只怕是不愿意，你要是在其它学科上升级了，她就没法升级了，学府机构评估会得出你竞赛所用知识非飞逸所教。那样飞逸门下还是只有两个二级成员。”</p>
<p>雪叶转过脸来对飞逸说：“你就好奇怪了。明明暴用不着你教，你却要如此死缠着她，我如此渴望获得你的教导，你却对我置之不理。这到底是什么原因。”</p>
<p>顿时一片沉寂。连白月池中金鱼游动时荡起的水波声都能清晰听见。雪叶一脸委屈，飞逸满面尴尬。</p>
<p>暴打破这沉寂说道：“或许飞逸老师是怕你将‘白羽号’的秘密告诉斑国班吧。我听说斑国班是反侵略派的，你从那里转来，老师她对你有些防范也是情有可原的吗！”</p>
<p>雪叶对暴说：“这话不能成立。要是这样的话，你来自沙西德星，虽然我们班和你们沙西德星签订了不战条约，但是毕竟曾是敌人。要我说，应该防范的是你才对。”</p>
<p>飞逸大声吼道：“你们都别争了。雪叶，你先下去！等暴升级后我再来教你。你也不要想得太多，我相信你绝不是斑国班的密探，况且斑国班现在还没有宣布与我们为敌呢！”</p>
<p>雪叶心想：“飞逸还当我是什么都不懂的小毛孩呢！等暴靠飞逸的那些知识升级后，飞逸就成了三级成员，三级成员做什么，三级成员就不需要再教学生了，去做自己的研究去了，进一步去学习变龙术那种不死能力去了。飞逸不就是为了这个吗？以后她还怎会来教我这些电子学知识呢？”</p>
<h2 id="取笑"><a href="#取笑" class="headerlink" title="取笑"></a>取笑</h2><p>雪叶越想越灰心，迈着沉重的步子慢慢走下去。一层的那些成员瞧雪叶心情沉重的走下来，互相交头接耳起来。</p>
<p>德斯走到雪叶跟前问道：“怎么了，又碰钉子了。老师是不是正忙着和心爱的暴在共度美好时光，没空理你。哈哈！”</p>
<p>宋藏金等人听了德斯这话一起哄笑起来。雪叶本来就生气，听到其他人的嘲笑，心情越发烦躁。德斯见雪叶生气不答，知道说中了她的要害，于是继续说起风凉话来。</p>
<p>德斯说：“飞逸还不是看中了暴是沙西德学府老师的女儿，你呢，孤苦伶仃的一个人，什么背景都没有，你还指望她会对你个别辅导，把她平生最上乘知识教给你吗。”</p>
<p>雪叶气愤地哼了一声道:“那你呢，你一副公子模样，家境又那么好，她怎地不教你。还有月湖，她是冥星议员的女儿，说到家族背景她总该强于暴吧，那为何飞逸也不教她呢？”</p>
<p>德斯冷笑说：“你是不是孤零零一个人独居时间太长了，连现在是什么形势都不知道了，现在冥星被沙西德星和狱星已经占据了大半。飞逸倒也很有远见，如果我们冥星被沙西德星这帮白发佬统治了，她这样做不也是给自己留了个后路吗？改明，我成二级成员后也多教几个沙西德学生来哦。”</p>
<p>宋藏金跟着起哄，他对坐在西南边的紮惑浮和凌穆说：“你们俩听见了，赶快去申请老师吧，日后多找几个白发学生教，也给你们留条后路啊。”</p>
<p>紮惑浮和凌穆都是飞逸老师手把手教过来的，但当时沙西德星和狱星进攻冥星，优势不大。此刻听到德斯等人的说话，虽觉有些道理，也不愿说这些对飞逸老师不敬的话。两人不睬众人，他们戴上耳机，伸手触摸一下含羞草播放器，一面看‘白羽号’资料，一面听起歌来。易慧和小侃都不是富家子弟，他们气冲冲的站在一旁，此时气得说不出话来。</p>
<p>雪叶说：“你们这叫吃不到葡萄说葡萄酸，飞逸老师就是看你们太世俗，又没什么真本事，才不愿传授你们上乘的知识的。估计德斯和月湖一级成员的身份，都是靠买通白龙班评委成员得来的吧！暴的那个‘白艳公主’机器人你们能够做得出吗？”</p>
<p>德斯笑道：“哈哈，真是好笑，做不出又有何相干。你说我们世俗，我看你才是小人，以小人之心度君子之腹！你以为白龙班评委那么好买通，这些评委都是从各班三级以上成员中精挑细检出来的，个个地位高于老师。学府的每次竞赛都有全方位记录，如评委作假被明朝学府内阁发现，那是要被喂龙的。有几个不怕死的评委敢买卖成员级别？再说，就算我和月湖的一级成员是买通的又怎么了，这也是本事，这本事你有吗？”</p>
<p>雪叶说：“我自然没你们这本事！”</p>
<p>德斯呵呵大笑道：“我看你很有本事！你那年从我们白龙班逃跑后，无名无分，像个乞丐，还中毒在身。谁知道你是爬上了哪一位上流男人的床，做了不要脸的事。不然怎么仅仅两年时间就轻而易举地取得了个一级成员身份。”</p>
<p>突然重重一拳，雪叶挥拳打到德斯脸上。</p>
<p>德斯捂住脸还在奸笑：“你们看啊！我说中了吧，你真不要脸。你再打呀，你越这样越说明你心虚。这里的所有人都和我想的一样，只是不愿意当着你面说罢了。我真为你感到丢脸，连米生那个大傻瓜都想毒死你，你死了就没人给他丢脸了。毒死你活该！”</p>
<p>雪叶这时听到德斯提及米生当年害自己的事，不禁泪流满面，咬牙切齿，握紧拳头欲和德斯拼命。这时月湖一把抓住了雪叶的手。</p>
<p>月湖指着德斯吼道：“德斯，你不要胡说！还提那米生干嘛？你是存心要气我不成？”</p>
<p>月湖转过来劝雪叶说：“雪叶，你不要去理德斯，他是狗嘴里吐不出象牙来。你要是和他对着来，他什么难听的话都能够说出来，他说的这些都是赌气话，你可千万不要当真！”</p>
<p>雪叶知道这是月湖在安慰自己，其实德斯所说的话的确是大家闲聊时都曾说过的，月湖偶尔也听到过这些闲言秽语，只是当着雪叶的面提及当年米生下毒的事，却是雪叶无法接受的，她就没去劝雪叶放弃米生的话。雪叶扭头看着月湖温柔的看着自己，月湖模样雍容华贵，气质不凡，雪叶越看越觉得自己相形见绌。其实现在的雪叶早已不是以前那个落魄的雪叶了，雪叶无论相貌还是穿着现在丝毫也不差于月湖，只不过雪叶心中始终不能忘记米生日记中所写的自己那时憔悴不堪的形象，心存阴影罢了。</p>
<p>雪叶抬起头看着月湖说：“月湖姐，你知道米生到哪里去了吗？”</p>
<p>月湖答道：“好妹妹，你回来后三天两日就要问我一次这个问题。我们俩这么好，我如果知道米生的情况怎会不告诉你？”</p>
<p>德斯听不下去了，急忙插话说：“真不可理喻，雪叶，你到底有完没完？每次碰到你都是前一句问米生在哪，后一句米生什么时候回来。你真可笑，米生不要你了，他想你死，你人不死，就死了这条心，回你那个什么斑国班去吧！那里的老师会好好疼你的，哈哈！”</p>
<h2 id="黑熊鬼将"><a href="#黑熊鬼将" class="headerlink" title="黑熊鬼将"></a>黑熊鬼将</h2><p>雪叶怒气刚消，但经德斯又这么一说，顿时满脸直冒杀气，她在心中默念一段咒语，身后立即浮现一头巨大的黑色熊幻影。黑熊张开大口，吼声震动整个房间，德斯先是吃了一惊，随后拔出单手剑来与熊格斗。黑熊手持巨锤，雪叶浮在空中，她身体四周环绕着黑色光圈，雪叶做什么动作，那黑熊就做什么动作，如同雪叶的傀儡。黑熊挥大锤向德斯砸去，德斯横剑一挡没有挡住，大锤砸到德斯身上。但这魔法终因雪叶魔力不够没能对德斯造成致命的伤害，不过这锤碰到德斯头部时还是使他头上感觉中了很重一锤似的，德斯“轰”的一声身体摔倒地上。刹时只见两道白光向德斯这边极速划过来。“铛”的一声，又一道白光划了过去，三道白光相碰到一起，火星四溅。雪叶见德斯倒地，双手拿着她的那对白龙爪双刀，俯身突前砍来，正好砍在一把长刀上。这刀是紮惑浮的红凤长刀。紮惑浮接住雪叶的白龙爪双刀，将长刀向上一挑，雪叶顺势后退一步，收起刀来。</p>
<p>紮惑浮手持长刀大声吼道：“你们要打就到外面去打，不要把飞船里的贵重设备打坏了！”</p>
<p>雪叶收起魔法，黑色光圈渐渐消失，她说：“紮惑浮前辈说的是。我们不该在这里动手。但刚才德斯的反应表现足以说明他成为白龙班学员靠的不是本领，天知道他是靠什么升级为一级成员的。”</p>
<p>德斯被雪叶这一吓，一时没敢再为自己辩解。</p>
<p>紮惑浮将长刀插入剑套，说：“斑国班的‘黑熊鬼将’今天我算是亲眼见到了。”</p>
<p>雪叶也将双刀收起，摇摇头说：“我这不能算是斑国班真正的‘黑熊鬼将’。‘黑熊鬼将’虽然只是斑国班入门功夫，但是招式却是十分丰富，威力也很大，级别低和高的人使起来看似相同，实际却有天壤之别。你刚才见我耍的只是其中一种招式罢了。”</p>
<p>紮惑浮微笑着说：“那改日我们再切磋切磋！”</p>
<p>雪叶点头应道：“没问题。只是我觉得很奇怪，刚才我出刀时看你并不在这里，还在很远的地方，瞬间你就过来了。你怎么来得这么快？。”</p>
<p>紮惑浮说：“你可不要小瞧了白龙班的功夫！适才，我用的是‘停陷术’，这个魔法的作用是降低对手的物理攻击速度。此法虽难击败对手，但对方想要败我也非易事。”</p>
<p>雪叶说：“一生能够精通一门武功足已！”</p>
<h2 id="绝色七彩"><a href="#绝色七彩" class="headerlink" title="绝色七彩"></a>绝色七彩</h2><p>紮惑浮继续说道：“因为当时和你相距太远，要想马上赶过来很困难，于是我用了‘绝色七彩’中的 ‘轻灵如舞’招数， 我将魔力赋予红凤长刀，迅速估算出你挥刀砍到德斯身上的时间，准确利用算出的时间差，我将红凤刀适力投掷出去，长刀一脱身，我的身体便轻盈无比起来，这时用‘轻灵如舞’的魔法咒语，打散我身体的分子，这些分子就像银光微尘一般当即被红凤刀吸住，这时红凤刀一被撞击，我身体的分子马上就组合恢复成人形。你刚才那一砍果真力大，我顿时就恢复过来了。”</p>
<p>雪叶心想：“白龙班的‘绝色七彩’原来这般精妙，完全不是当年米生所耍的那样。我可怜的米生，你被白龙班老师欺骗了啊！他们完全没有教你那些好的东西。飞逸偏心，不愿教你，只将真本领教给紮惑浮和暴他们，我一定要将这些真本事学到手！你快回来啊，我学会了好好教你。”</p>
<p>想到这里，雪叶马上跪在地上低着头恳请道：“紮惑浮前辈，请你收下我这个弟子，将这些教我，你要我做什么我都愿意。”</p>
<p>在场众人看雪叶当众跪下，个个惊得目瞪口呆。紮惑浮一时也觉尴尬，顿时手足无措，一时不知说什么好。</p>
<p>飞逸和暴听到白羽号里魔法警报器发出讯号，提示楼下有人施魔法，迅速从上层走下来，听了雪叶和紮惑浮的对话，又看到雪叶跪在地上要拜紮惑浮为师学艺，飞逸上前说道：“雪叶，快起来！这象什么话。你当我们白龙班是什么地方，求学需要这么低声下气的吗？你既然已是我们白龙班的学生，这些功夫自然会教你的，用得着这样吗？”</p>
<p>雪叶依然跪着不起，眼中含着泪花继续说道：“除非老师现在许诺马上就教我，不然我就不起来了。”</p>
<p>易慧和小侃看雪叶如此，为雪叶求学的精神所感动，齐声帮雪叶求道：“飞逸老师，教授知识本来就是老师天职，你就答应她吧。”</p>
<p>飞逸气愤地说：“我又没说不教！‘绝色七彩’本来就是一级成员应该掌握的一门武艺，只是我现在忙于给暴补习一些‘白羽号’的知识，一时抽不出时间来。”</p>
<p>飞逸说到这里停顿下来，她想了一会，转头对紮惑浮说：“这样吧，紮惑浮。你将你刚才使的那招‘轻灵如舞’就先教雪叶吧，但以后一定要记住，不到万不得已，不要和她较手。”</p>
<p>紮惑浮听老师这么一说，当即答应下来，她对跪在地上的雪叶说：“雪叶，快起来！我明日就教你我刚才使的那招。我即使已经申请成了老师，你也不用叫我老师啊。我们是同学，你又聪明，又勤奋，在斑国班仅两年就能够升级成为一级成员。我可是自愧不如呵！我想，不超出两年，你一定能够顺利成为一个老师。”</p>
<p>雪叶慢慢站起来，心想：“飞逸叫紮惑浮不要和我较手，就是怕我和她切磋功夫，怕我看到白龙班里的更多好功夫，飞逸为何这样排斥我？连紮惑浮自己都知道我比她强，飞逸当年却那么用心教她。现在她冷漠我，难道她是真的怀疑我是斑国班派到这来的奸细吗？我怎可能是斑国班奸细呢？我对斑国班又没有多少好感。算了，以前的事就不要再想了，现下学一招是一招，当着飞逸的面，紮惑浮肯定没法答应教我白龙班的其它功夫，待我和紮惑浮单独在一起的时候再求她教我也不迟。”</p>
<p>于是雪叶对紮惑浮说：“谢谢紮惑浮前辈！你过奖了。”</p>
<p>飞逸和暴去上层房间后，月湖，易慧和小侃三人马上围了过来，</p>
<p>月湖走近雪叶，拉着她的手，关切的说：“要是紮惑浮不好好教你，你就找我好了。”</p>
<p>易慧挺着胖大的肚子，她说：“绝色七彩’我也会点，飞逸老师没时间的话，我可以把我学会的都教给你。我还收集了好多资料呢。紮惑浮平时从不说奉承人的话，她今天都说你聪明，那我收集的这些资料对你一定很有作用，我脑袋瓜子笨，自己读了这些资料也悟不出什么，这么多年没多大进步，只学到了飞逸老师教我的一些知识。如果你不嫌弃我，可以和我一起研习这些资料。”</p>
<p>小侃笑嘻嘻的将易慧往后一拉，对雪叶说道：“如果你不嫌弃，我也有很多资料，也可以和我一起研习啊！”</p>
<p>雪叶听到这三人对自己这么好，心中十分感动，她激动地说：“我先前以为白龙班里个个都是自私的小人。今天不管你们三人是可怜我还是真心帮我，我都很开心。有你们帮我我就安心了。”</p>
<p>月湖说：“雪叶妹妹，光是我们三人帮你还是不够的，你还是要多多请教紮惑浮和凌穆，她们俩可以教你很多升到二级的经验。还好你是在飞逸老师门下，她现今门下就有两个二级成员，于你的进步来说真是太便利了。”</p>
<p>月湖说完往凌穆她们那边看了一眼，凌穆说：“我是没有问题，紮惑浮都当着飞逸的面答应教她，那我这招‘轻灵如舞’是一定要让雪叶学会的了。”</p>
<p>雪叶默默不语，一片沉寂。紮惑浮看雪叶低头不说话，知道她是因为自己只答应教她一招而不痛快。</p>
<p>紮惑浮说：“雪叶，你不用担心。适才我当着飞逸的面，说只教你一招，是因为怕说出‘绝色七彩’都教给你这话，飞逸会阻止我，其实大家都看出来了，飞逸不是很愿意教你，但我怎么可能只教你那一招呢？实际上，‘轻灵如舞’这招牵涉面很广，几乎涉及到 ‘绝色七彩’全部招数。基于这点，我将这一套招数都教给你也不为过，既没有违背我所答应老师的，也能够使你掌握‘绝色七彩’全部内容。只是有点我弄不明白，就是为什么飞逸老师不愿教你呢？”</p>
<p>雪叶开始听到紮惑浮说愿意教她时，心中顿时升起几分欢喜之情，后听到紮惑浮问她飞逸为什么不愿教她时，心中也觉得疑惑，一时不知如何回答。</p>
<p>雪叶随口说：“可能她真的是觉得我家没有背景，不像暴家那样有权有势，以为我没有什么利用价值吧。”</p>
<p>紮惑浮听后连连摇手，哈哈笑道：“这就好笑了，暴只是一个被沙西德星抛弃的士兵而已，人们也许会认为她是沙西德派来的奸细，但是你想，把一个奸细放在自己的班里，又重点培养她，飞逸老师不是太傻了吗？这样吧，就算暴真的如你所说家里有权势，有利用价值，那我呢？我父母十分普通，就是冥星里的一般居民，那飞逸怎么会教我教的那么痛快，还有凌穆，易慧，小侃等。除了对你外，飞逸老师对其他人都十分热心，从来对谁都不偏心，在白龙班这点是公认的。”</p>
<p>雪叶说：“我看她现在就是偏心。她让大家在这里看这些浅显的资料，却单独教暴那些真正有用的知识。”</p>
<p>凌穆站起来说道：“你想得太多了！雪叶，你所说的那些有用的知识，其实我们迟早都会学到的。飞逸之所以现在先教暴，这个是她素来的习惯。对于那些她自己研究出的知识，她总是先教会她认为最有资质的学生，然后让这个学生去教稍差的学生，稍差的学生再教比自己还差的学生。如此单对单相传，一来这些精妙的知识先学到的学生能够很清晰的传达下去；二来，想学这些知识的学生学习前会对这些知识充满神秘感而十分努力，他们学习的时候就能够比较集中精力，能够发愤用功。其实我也和紮惑浮有同样的疑问，那就是为什么飞逸第一个不教你，在资质方面你并不差于暴，最重要的是，你比暴要更加渴望获得这份知识。”</p>
<p>雪叶说：“那你说这是为什么。”</p>
<p>紮惑浮说：“我们也不知道。但我个人觉得，这个可能跟米生的突然消失有关。”</p>
<p>雪叶瞬时一惊，说：“米生不是出去给白龙班办事了吗？”</p>
<p>凌穆偷偷在紮惑浮背后掐了一把，紮惑浮马上改口说：“是，是去办事了，只是走得突然了点。”</p>
<p>雪叶问道：“你们倒是告诉我，米生他到底是去办什么事了？”</p>
<p>凌穆说：“我们也不知道。知道早就告诉你了。”</p>
<p>雪叶低头叹了口气，低声嘀咕说：“怎么谁都不愿告诉我……谁都不愿告诉我……”她这样反复嘀咕着走出了房间。月湖叫了雪叶几声，雪叶都没有答应，月湖知道雪叶此时肯定对谁都不相信了。</p>
<h2 id="月湖往事"><a href="#月湖往事" class="headerlink" title="月湖往事"></a>月湖往事</h2><p>后来几天时间，都不见雪叶到‘白羽号’里来，月湖四处寻找，在白龙班里搜了个遍，白龙像，名人堂，圣水井，悬空舞台，还有各个班级和所有学生住所。她之所以这样拼命的找雪叶，不是为了去履行教雪叶的约定。月湖知道雪叶之所以这么迫切的想学习知识都是为了米生，为了让米生开心。再说她自己的能力也不可能对雪叶有什么实质的帮助。她找雪叶的主要原因只是想和雪叶谈谈心，但是几天不见雪叶，她便越发的担心起来。</p>
<p>月湖往白龙山下走去，突然看见路边一个林子的小溪旁，一个女子正坐在水仙花丛中。水仙花开满了整个林子，那女子看这水仙花十分美丽，随手摘下一束，拿到鼻尖细闻。月湖快步走到她身边，一把将她手中的水仙花夺过来，那女子一抬头。月湖高兴地说道：“雪叶，总算找到你了！这花有毒，你知道吗？”</p>
<p>雪叶扭过头来反问道：“这么美的花怎么会有毒呢？”</p>
<p>月湖说：“这花有如金盏银台，高雅绝俗，婀娜多姿，清秀美丽，清香馥郁，洁白可爱。但是却是毒花。”</p>
<p>雪叶说：“怎么会是这样呢？”</p>
<p>月湖说：“这可不是我乱说的。你看，这花和叶的汁液里含的是石蒜碱，石蒜碱是一种有毒物质，对人体有害，触到它能使人皮肤红肿；花茎内含有拉丁可毒素，人嗅到或吃进它会引起呕吐，腹泻，甚至手脚发冷，致人休克，时间一长，人会因中枢麻醉死亡。”</p>
<p>雪叶打了一个寒颤，说道：“这症状我好象有过。月湖姐，你找我干嘛。”</p>
<p>月湖说：“那时米生给你下的毒就是这水仙花毒。我来是想找你说说话。”</p>
<p>月湖看雪叶不语，知她不愿别人提起米生下毒之事。继续说道：“雪叶妹妹，我想跟你说说我以前的事，你想听听吗？”</p>
<p>雪叶转忧为喜地说道：“你的事我当然想听了。我们就在这里聊吧，要聊多久就多久，反正飞逸现在也没打算将什么好东西教给我，我去和不去‘白羽号’都无所谓了。”</p>
<p>月湖开心地说道：“那太好了。”</p>
<p>接着月湖开始说自己的往事。月湖说道：“你也知道，我父亲是冥星议会的议员。有一天晚上，我父亲将我和我的丈夫皓月叫到身边，问我们小俩口，你们如果现在过的是普通居民的生活，感情会不会有变化。那时的我才十八岁，生活无忧无虑，感情上浪漫谛克，而且皓月对我无微不至，关爱至微，我当下果断回答父亲说，无论生活多么艰难，我和皓月都会长相厮守。父亲看我十分坚定，就让我和皓月搬出家门，让我们到华尔辞的元朔社区去生活。我本来就一直看不惯父亲的世俗作风，又觉得这一次父亲是考验我和皓月的感情，因为皓月家境不好，和我家不是门当户对，我一气之下连道别都没道别一声就走了。”</p>
<p>雪叶说：“这两年我也去华尔辞呆过 ，斑国班离华尔辞就很近，以前你在华尔辞哪个社区生活？”</p>
<p>月湖说：“我从小生活在华尔辞，华尔辞分为东西南北四个区，它们分别是华日，尔辰，辞正，元朔。‘华尔辞’这三字来自这四个区前三个的开头，这说明前三个区是华尔辞的主要社区，其排名先后顺序是，华日第一，经济最发达，地处华尔辞北部，政府机关就设在那个区。尔辰排第二，地处华尔辞西部，商业较发达，有少量部队驻扎。辞正排第三，是华尔辞东部的一个区，这里主要以文化娱乐为主。这三个区里聚集了冥星里那些有权有势的人。在南边是元朔，它是华尔辞中最贫困的一个区，那里的人常年生活在社会最底层。”</p>
<p>雪叶悲伤的回忆道：“我当年就是住在元朔区。那里的人特别多，里面住的人大部分都不是华尔辞和明朝学府的居民，他们几乎都是外来移民。华尔辞的企业家和明朝学府的师生统治着元朔地区的人民，元朔地区对外来人歧视现象严重，能坚持留在那里的受歧视的人都是怕从这里回去丢脸，或者期待在这里早晚能够遇上一个出人头地的机会。月湖姐，后来你们在元朔那里怎么了。”</p>
<p>月湖接着说：“我先找了份行政管理的工作，皓月找了份赌场发牌的工作。半年后，我从家里带出来的化妆品，牙膏，还有各种日用品都用完了，带的一些钱也快用完了，租住的房子换一个比一个差。我的脾气越来越坏，在公司里经常得罪人，脾气来了，我对上司也不尊敬了，工作职位不升反降。在公司里我感到有很多不公平。只要是明朝学府里出来的人谁都能够做到高层，其他的人想爬上去万分艰难。在公司，我以前那养尊处优、随便使唤别人的性子无处发挥，心里总是憋得慌，回到家后把气都发到皓月身上。皓月工作的赌场在东部辞正，来回车费很贵，他工资的三分之一都花在车上了。而且路上花的时间长，每晚都是十点多才回到家，如果忙起来，午夜转钟后回到家是常有的事。皓月小时候没有吃过什么苦，但是当时他为了我，说做什么都愿意。在赌场做服务工作是十分危险的事，那些有钱的主儿，赢了钱就赏点服务生，如果输了，不耐烦起来，对服务生又是骂又是打，赌场的经理一般都不管。辞正地区来赌钱的人都是各个星球有头有脸的人，皓月有好几个同事都是因为受不了虐待，有所反抗，结果在回家路上被人害死了。</p>
<p>“我那时只顾自己的感受耍性子，对皓月的困苦处境从来都没放在心上，只觉得自己生活档次节节下跌，无法适应，怪他没能力让我过上好生活。几周后我被公司解雇了，回家的路上我首先想到了我父亲，当晚，我将家里所有的钱拿去买了张飞机票赶回父母家中。一进家门，看见屋子里一片狼藉，东西全被翻乱了，玻璃饰品，瓷器花瓶，都打碎了。后来我才知道是因为父亲所支持的党派被另一党派夺了权。父亲为了避难，现在躲了起来。反对派找不到人，就把我家翻了个底朝天。我这才明白那日父亲为何叫我和皓月离开华日，顿时心中十分感激父亲，脑海里浮现出我和父亲一起生活时的点点滴滴。想到我以前太淘气，总是不听父亲的话，连婚姻大事也不顾父亲反对自已做主，父亲说的很对，皓月人虽好，但是却没有做大事业的风度，根据目前情景来看，只怕我要过一辈子苦日子了。想到这里，我开始后悔和皓月结婚了。以前父亲能够使我生活的无忧无虑，有求必应，能让我呼风唤雨，无所不能。我真是生在福中不知福，现在脱离了父亲，我一无所有了。</p>
<p>“我重新回到元朔我和皓月住的地方，回到家的时候，我看到皓月趴在桌子上睡着了，我狠狠地打了他脑袋两梨弓，说：“你不去上班待在家里睡大觉，你拿什么来养活我啊？”接着言语中我不知不觉又将他和我父亲对比起来，说他这样子一辈子也不可能做到我父亲那样的成就。皓月迷迷糊糊的睁开眼睛看着我，开始见我回来很是高兴，后来听我越说越气，对他十分严厉，就没有作声，后来干脆拿起皮包，穿上外套匆匆走出门去。在他转身的一瞬间，我看见他脸色不好，突然感觉到他有些生气了。那时我很想叫住他，对他解释说我的心情不好，请他原谅我。可是虚荣心却让我没有这样做。我站在阳台上，看着楼下刚走出大门的皓月，心中有种说不出的滋味，这时皓月突然抬头看见了我，脸上露出笑容，一点没有怪罪我的意思，看起来像是在告诉我：‘你回来真好！’我们刚到元朔时，他每日出去上班，走出大门都要抬头往阳台上看一眼。那时我每日都在阳台上看着他走出大门，然后慢慢走远，直到消失看不见，两人总是依依不舍。后来工作和生活的压力，使得我的这些感情慢慢淡薄了，三周后我便再没每天去阳台那目送他出门了。现下我看着他，他看着我，一人在阳台上，一人在楼下马路上。我感动了，眼泪不自觉地流下来，原来这半年来皓月一直都在等我出现在阳台上。皓月看我眼泪流下，他的眼圈也渐渐红了起来，突然猛一转身大踏步的向远处走去。这一转身好象是在告诉我，我的回来是他的最大满足和快活，他已经不再生气了。</p>
<p>“我又回到严酷的现实生活中来了。接下来的日子里，我又找了好几次工作，没有一份工作能够让我满意。从小到大养成的小姐脾气害了我，小时贪玩的我失去了很多好的学习机会。严酷的现实生活教育了我，我暗暗下定决心：如有机会一定要进明朝学府，努力学习自食其力的本领，也希望自己将来能帮父亲一把。后来，皓月工作渐渐有了起色，他升职成为大堂经理，他虽然资质不高，但他为人谦恭，性格温和却是很得上、下层喜欢，这可是那时我所不具有的。”</p>
<p>雪叶说道：“可是你现在为人热情、性格温和却是和那时的皓月哥一样了啊。”</p>
<p>月湖说：“是的，我现在的变化就是皓月影响的结果。”</p>
<p>雪叶说：“那你们后来生活好起来了，对吗？然后你就实现了自己的愿望，到白龙班来了。”</p>
<p>月湖说：“起初是好了一些，可是后来皓月为帮助一个下属，背了黑锅，不光工作没了，还被罚了钱。我刚感到生活好了些，手头宽松点，能够买上几件新衣裳了的时候，却因为他的善良又叫我们的生活下了地狱，我不住地埋怨他，经常地骂他傻，天天催促他出去赚钱，对他的不满一日甚于一日。皓月的父母年老失去了工作能力，也全靠他赚钱生活。在华尔辞，对每个人的信誉都有记录和评估，并且联网公开。他背的这个黑锅影响了他的社会信誉，华尔辞里好点的企业在聘人的时候一查，看到皓月的信誉度很低就不愿招他，他只得到元朔区里找些比较粗重的活干，比如做搬运什么的。由于我的工作态度差，我的信誉度也渐渐降低，极少有人愿意聘我做事，后来我干脆呆在家里什么也不做了。其实我们当时的那个家完全不能够算是一个家。最后由于拮据，我们只得搬到一个破烂的由铁皮车箱改成的房间里居住。下雨时屋里东边地上放上一个盆，西边地上放上一个碗，到处接漏雨。夜间雨漏滴答滴答的惹人烦，扰人睡。如果遇到刮风天，风又透过铁皮缝隙呼啸进来，冷不说，尖啸的风声就吵得人睡不着。遇到晴朗天气，这房子经太阳一晒，又变成了一个大蒸笼，人在里面热得喘不过气来。住在这样的房子里简直是在受煎熬，哪里还能浪漫起来。那时我日夜都在回想过去的日子，想着父亲对我说的话，心里后悔极了。后来渐渐树立一个信念，那就是听爸爸的话，慎重选择丈夫，不要光看那人的为人好或性格好，更重要的是要看他是否有能力。”</p>
<p>雪叶说：“真没有想到你竟然也有这样的经历，和我的经历倒也有几分相像之处。”</p>
<p>月湖苦笑道：“虽然身处的环境类似，但那时我的思想却与你那时大不相同。在我们住铁皮屋的日子里，皓月白天做的是粗重的体力活，每天累得晚上一倒头就睡，但到刮风下雨的晚上常被风声和漏雨声吵醒，屋子里到处湿漉漉。下过雨后，屋里的地上仍是泥浆一片。被子常散发出一种发霉气味。皓月终于大病一场。以前我从小说戏剧里的爱情片段中看到，一对恋人有一人病了，对方总是对他细微照顾，两人以前发生的矛盾就化解了，十分浪漫。但是现实中的我的体会却是那么的不同，不知道是因为那些书和戏剧的作者太过浪漫还是现实太残酷。每次看着躺在那由碎砖砌成的床上的皓月时，我心里丝毫没有那种怜爱的感觉，心里总在埋怨他为什么要病，怎么不快快好起来，你再病下去不起来我就要饿肚子了。皓月一旦好起来了，他总是说有我在一旁照料，是他的福气。这话我哪里当得起呵！</p>
<p>“我又埋怨起我们住的铁皮屋来，刚开始我说这些埋怨话时，他总是劝我不要心急，安慰我说日子总会好起来。我不相信他的话，常常拿他那次替别人背黑锅的事情讥讽他。时间长了，我再发起脾气，说起埋怨话来，他就低着头在一旁只是叹息，不再说那些有希望的话来安慰我了。</p>
<p>“我们的交流停止了，连吃饭时两人都是无言相对，屋子里只有漏雨声、风声、碗筷相碰声，开门声、关门声、渐渐远去的脚步声……”</p>
<p>雪叶说：“我那个时候和你一样，米生不在我身边的时候我也总觉得生活中忽然没有了一点生机，整个人就像死了一样。但是只要他一来到我的住处，我好象立马又活了过来。他在我身边给我讲外面看到听到的许许多多新鲜事，我马上就不觉得孤寂了。”</p>
<p>月湖见雪叶还是对米生无法忘却。她心里想：“米生那时给雪叶讲一些外面的新鲜事并不是要安慰她，热情是装出来的，实际上是为了掩饰他自己心中的罪恶。这些在他的电子记事本里不是都清清楚楚地写着吗，雪叶看了他的电子记事本为何还要相信他爱她，对他恋恋不忘呢？”<br>雪叶不知月湖为什么说着说着停了下来，就问道：“后来怎样了，你是不是觉得皓月不好，不想与他在一起了吗？”</p>
<p>月湖说：“我那时的确有过这个想法。我当时离开浩月，找到我以前结交的朋友，在几个朋友家我分别住过一段时间，开始时他们还以礼相待，但日子一长，我就成了朋友的累赘了。我在一个最要好的朋友家曾经住了一个多月，虽然朋友对我一直很好，但后来终于因为他的家人怠慢了我而自觉没趣离开。我的那些亲戚也因我父亲现在的处境而避开我。现在想到当时的景况我还感到心酸！想想以前亲戚朋友对我的毕恭毕敬，我在他们面前无论怎样耍性子，他们对我都是百般忍让，我还以为这是理所应当的事。现下才明白那都是因为父亲的地位和他对我宠爱的态度，没有父亲做靠山，我便一无所有。</p>
<p>“在没有人愿意帮我的情况下，我只得又回到了那铁皮屋。我回到铁皮屋的时候，皓月已经病倒了，而这次他害的却是一场大病。因为这段时间我不在家，皓月生活上没人照顾，病了还是强撑着干活，长期咳嗽没治，现在咳出肺炎来了。我这时也没有了办法，找亲朋好友借的钱马上就要用完，我真怕皓月会这样死掉。如果皓月死了，我以后的生活怎么过啊！那晚，我绝望的哭了，皓月也流下了眼泪。我那时哭是因为担心自己失去依靠，皓月他哭却是痛恨自己没能让我过上好日子。</p>
<p>“第二天，正好是一年一度政党竞选的日子，这时离我父亲弃家出走已有三年了，这三年，我和皓月在一起没有过上一天的好日子。以往对政治毫不关心的我，这天也走出家门，来到广场，等待看大屏幕播放竞选情况。我看到了，看到了我的父亲，他带着他的几名同党正意气风发的在那里演讲。我身旁一起观看大屏幕的人都在兴致勃勃地议论。听着他们的议论，我才知道我的父亲他们为了夺回政权，游说了明朝学府里很多反侵略班级，答应给他们兵权，调配了很多雇佣兵给他们使用。明朝学府在冥星里支持率相当高，有好几个反战争的班级都被父亲说服，冥星居民有了一些安全感。父亲这三年里和好几个学府老师结交成为朋友，那些老师派出自己最好的学生保护我父亲他们，当权党派的那些人四处追杀没有结果。”</p>
<p>雪叶问道：“当权党派一定要这样做吗？”</p>
<p>月湖说：“正是，这样做是巩固自己政权的需要。”</p>
<p>雪叶说：“这样是不是太无法无天了。”</p>
<p>月湖说：“当然不是所有当权党派都是这样。只因为我父亲他们党派太卑鄙，总是采取不正当手段获得竞选成功，所以他们的对头才以其人之道来治其人之身。”</p>
<p>雪叶问道：“那这次你父亲如果竞选成功，当权后不是也要去追杀以前追杀他的那些人吗？”</p>
<p>月湖说：“依我父亲的性格，他会这么做的。”</p>
<p>雪叶忽然想到了什么，她突然问月湖：“你父亲叫什么名字？”</p>
<p>月湖答道：“他叫月杀丸。”</p>
<p>雪叶一惊，低头自言自语道：“原来是他，他是议员！”</p>
<p>月湖听雪叶这么说，问道：“你认识我父亲么？”</p>
<p>雪叶慌忙掩饰，抬头答道：“哦！不，我……我怎么会认识你父亲那样的大人物？”</p>
<p>月湖睁大眼睛，奇怪的看着雪叶，只觉得雪叶仿佛有什么事在瞒着她。</p>
<p>雪叶瞧月湖这般看着自己，感到不自在。她说：“没事，你继续说，后来你去见你父亲了吗？”</p>
<p>月湖叹了口气，说：“唉！后来我自然是去找父亲了。当我找到父亲的时候，他看见我面黄肌瘦，好是心疼。从此我什么都听父亲安排，后来嫁给了金发本克星一名年轻有为的议员。”</p>
<p>雪叶对皓月担心起来，慌忙问道：“那皓月呢？他后来怎样了？”</p>
<p>月湖说：“我找到父亲以后，很久都没去那铁皮屋。”</p>
<p>说到这里月湖眼圈开始湿润起来。继续说道：“我嫁给的那个金发议员叫夜影飞，相貌英俊，倜傥潇洒，高翘的鼻梁，蓝色大眼睛，是许多少女心中的白马王子。跟皓月相比，无论是相貌还是才能都强他不知道多少倍。我嫁他之后，只身一人来到本克星，除他以外，无亲无故。夜影飞看我整日无聊，总是找机会和我聊天。聊天主题总是他们本克星里的一些女强人如何为国效力的故事，我明白他的意思，是叫我效仿她们，为本克星出份力。本克星以前和沙西德和狱星一样，都是皇族统治的国家，但学术科技和经济实力上却远远落后于他们。这个时候，本克星有很多思想家忧国忧民，为国家摆脱贫困积极探索。他们当时认为冥星是他们最好的学习对象，就设法和冥星攀亲。后来我才发觉，我的这个看似圆满的婚姻原来是个目的性非常强的政治婚姻。夜影飞娶我，一是为了和冥星结上姻亲，二，也是更重要的，是为了从我身上获得更多的冥星的先进思想。但从小到大，我对政治从来就没有发生过兴趣，要我给夜影飞出谋划策简直难于上青天。</p>
<p>“夜影飞从我身上不能得到他所需要的东西，于是觉得我庸俗之极，由开始的热言细语逐渐转为冷言冷语，最后干脆就不和我说话了。我心里很不是滋味，也没觉得自己有什么不对，倒看出他娶我的真正目的，只是想利用我，对我并没感情。夜间，我一个人睡在那黑黑的、皇宫般宽大的房子里，望着那四根支撑房子的大柱子，听着屋外海水的涛涛声，觉得孤独极了。</p>
<p>“我出嫁以后，父亲给我发来许多信，内容都是询问本克星的情况，我一封也没回复。这些日子，我也悟出了父亲嫁我到木克星来，并不只是为我好，也有他自己的目的。我晚上凝望着天空，不知不觉地想起皓月来了。我仔细琢磨，反复对比，突然感觉到，我活到现在遇到的人中只有皓月对我最好，他很想给我幸福，但他却没有那种能力。是不是天下没有能力的男儿都会和皓月一样对我好呢？我曾经这样想。”</p>
<p>雪叶突然像明白了什么似的，忽然瞪大眼睛望着月湖，然后问道：“你是说当年米生对你好，是因为他‘没有能力’，对吗？”</p>
<p>月湖显得很尴尬，他不好意思地说：“哦！你还真的时时刻刻都想着他啊。”</p>
<p>雪叶害羞地低下头，咧嘴不好意思地笑了一下。</p>
<p>月湖看着如此痴情的雪叶，心中满是感慨。说道：“我真羡慕你。如果当时我能和你一样，就不会错过皓月了。”</p>
<p>雪叶说：“你还没告诉我皓月哥后来怎样了呢。皓月哥是个好人，真希望他后来能够振作精神，赚到大钱把你这个拜金女娶回去。”</p>
<p>月湖听到雪叶这么一说，“嗤”的一声笑了出来。说道：“在本克星那段时间，我日夜都在回忆着和皓月一起的时光，我渐渐发现，皓月对我的好让我永远记得他。后来借回去看父亲的理由，我去了一趟华尔辞，走在通往以前我们居住的铁皮屋的那条小路上，我放眼搜索，铁皮屋已经不在了。我想，四年了，皓月可能已经改变了穷困的生活，现在有能力给我幸福了，而我却无福消受了。我沿着这那条小路往回走，风吹动路边的白杨树，发出‘沙沙’的声音，仿佛是在嘲笑我。我低头走着，看着路上的碎石子，想着皓月每天踏着这些石子，曾经为了能够养活我，拼命来回奔波。当我再次抬起头，朝小路旁那条小河对岸望去时，看见有一个孩子正在和他的父亲嬉戏，母亲一动不动地闭目坐在河边。这时小孩一不小心跌倒地上，‘哇’的一声哭起来，母亲马上站起身，伸手向前探索着朝小孩哭声传来的方向奔去，看来她是双目已经失明。父亲这时没有去管那小孩，赶紧过来扶住盲人母亲一起朝小孩走去。我望着这场面，心里感觉十分的甜蜜，会心地笑了笑，继续往前走。走了不到一百米远的地方，我突然看见一个非常熟悉的铁屋，还是那样的破旧，不同的是破铁皮屋顶上多了些木头压着的塑料袋。”</p>
<p>雪叶听到这里，抑制不住内心的激动，立即插嘴问道：“是你和皓月住的那个铁皮屋吗？”</p>
<p>月湖说：“是的。但我当时马上想到了那一家人，顿时明白过来。怪不得那个父亲的举止那么熟悉，那么令我感动，原来他就是皓月，只有皓月那样的男人才会那样细心，一般男人在有了子女后对妻子就大不如前了，他们的爱都会转移到孩子身上。但是我相信皓月不会这样，孩子蹒跚学步，摔倒一下不会怎样，而失聪母亲的无所适从才是真正值得关心的。我相信那个父亲一定就是皓月。当时我有两个选择，一个就是和皓月相认，把皓月夺回来；一个就是静静的离开，不去打扰他们平静的生活。”</p>
<p>雪叶忍不住问道：“你和他相认了？”</p>
<p>月湖笑着说：“没有，我离开了。我觉得我已经很对不起皓月了，以前他对我那么好，我全然没当回事。我知道，我当时说的一些话对他的伤害很大，在他患病最需要我照顾的时候，我不告而辞一定对他打击沉重。而且现在他已经有了自己的幸福生活，我不能破坏，不然太对不起他了，再说我夺回皓月，无依无靠的盲女怎么办？”</p>
<p>雪叶笑着说道：“从那时候开始，你心中定是一直怀念着皓月，你现在性格都渐渐变得和他一样了。”</p>
<p>月湖说：“我当时很想再看皓月一眼，想看看幸福时的皓月是什么样的，那一定是很可爱的形象。但我终究没有勇气过去看他一眼。”</p>
<p>雪叶急于知道结果，又赶紧问道：“后来呢？”</p>
<p>月湖说：“后来我就再没去铁皮屋，也没有回金发星、本克星了。我也不愿帮父亲做事，父亲拿我也没办法。后来，我看父亲已经对我不耐烦了，就请求父亲送我去明朝学府学习，他就爽快的答应了。来到白龙班后，我才知道他送我来仍有他自己的意图。”</p>
<p>雪叶问：“是什么意图呢？”</p>
<p>月湖说：“白龙班临近华尔辞，如今环绕华尔辞的明朝学府已经被沙西德和狱星部队抢占了三分之二的地盘。许多反侵略的班级都和沙、狱军签订了投降条约，支持冥星政府的学府班级越来越少了。白龙班一直保持中立，而且实力很强，父亲是想通过我来影响白龙班里的老师，使白龙班能够从中立立场转向帮助冥星政府对抗外星敌人。”</p>
<p>雪叶听到这里，感慨地说：“说来说去，你父亲心中想的都是冥星政府啊。他这个人还真是……”</p>
<h2 id="雪叶之谜"><a href="#雪叶之谜" class="headerlink" title="雪叶之谜"></a>雪叶之谜</h2><p>月湖听雪叶说话声音越来越小，觉得很奇怪。突然听见远处传来说话声。月湖转身顺手将雪叶拉住往下一按，两人伏在花丛中，看见远处一行人正向雪叶住的房子走来。这一行人越走越近，一边走还一边在谈论着什么。渐渐地看清楚了，原来他们大部分都是白龙班的老师。</p>
<p>待老师们走远，月湖问雪叶：“他们去你那里干什么？”</p>
<p>雪叶说：“我也不知道。不会是找我有事吧？”</p>
<p>月湖说：“你不过只有几天没到班上来，班规还没那么严；再说就算是找你，飞逸一个人也够了，没必要这么兴师动众的吧。”</p>
<p>雪叶说：“没想到白龙班会这么看重我！”</p>
<p>月湖说：“我看事情没那么简单。为什么一件事要一群人去做？那是因为那件事一个人完成不了。如果仅仅是找你有事办或有话说，哪有必要一群人一起到你家来，更何况这群人不是一般人，基本都是白龙班的领导者啊！”</p>
<p>雪叶镇静自若，笑着回答月湖说：“哈哈，难道他们怕我不成？”</p>
<p>月湖慌忙解释说：“我不就是不清楚是怎么回事，才担心你么？走！我们跟过去看个究竟。”</p>
<p>说完起身就要走。雪叶伸手将她拉住，说：“你刚才跟我讲的你的故事还没讲完呢。”</p>
<p>月湖回头要拿开雪叶拉她的手，雪叶笑着没松手。月湖有些不耐烦地说道：“雪叶妹妹，我知道你是想知道我和米生的事情，但是现在我告诉你，我觉得这群老师有些不对劲，今天这一行人来找你，很可能是对你不利。”</p>
<p>雪叶松了手笑道：“我又没做什么亏心事，我才不怕他们对我会有什么不利呢！”</p>
<p>月湖说：“你不知道，最近大家都在议论飞逸老师和你的事。你来白龙班后，飞逸就很反常，有时讲课的时候，突然停下来发呆，我们看她的神态，发现她是在观察你。”</p>
<p>听了月湖这番话，雪叶捂着嘴笑起来，她说：“是不是因为我那时睡着了。”</p>
<p>月湖说：“不是，以前有人睡觉她从不管。大家感觉到她好像处处躲着你似的，我们大家很奇怪：像你这样聪明有才的学生，她为什么不愿教呢？还有，自从你来白龙班以后，每次讲完课后，一直到晚上我们大家都再也找不到她了。”</p>
<p>雪叶感到了事情的严重，脸一沉，低声说道：“难道她一直在跟踪我！”</p>
<p>月湖心里一惊：“啊！什么？”</p>
<p>雪叶说：“他们前去的方向就是我住的房子啊。”</p>
<p>月湖忙说：“那今天他们更是可疑了。我们赶快跟上去！”</p>
<p>雪叶点点头。她们俩赶快尾追上去。途中雪叶没有再问月湖什么，月湖越发有些担心起来。</p>
<p>一边朝前赶路，月湖一边小声对雪叶说：“米生开始对我很痴情，我还以为是老天叫皓月再世呢！开始时我给他钱用，他就用我的钱买人教他学习一些功夫的招式，但是却常常被骗。好景不长，我父亲后来看我在白龙班依然没有帮他的意思，一气之下断了我的供给。我再没钱给他用了，这时我才看到米生的真面目。他一拿不到钱，就说我们有钱人小气，后来又怪我是把钱给我前夫了。我没有对他解释什么，我失望极了。我看透了米生，他无德无能，自私自利，对我好完全是为了方便自己用钱。我越发思念起皓月来，只觉得平生能得到一个对自己真好的人实在不容易！”</p>
<p>雪叶此时并没仔细月湖讲话，好像在担心会发生什么事情，只顾走路不说话。</p>
<p>月湖继续说道：“我觉得你和当时的皓月差不多，米生和我却有根本性的不同。米生非常虚伪，人面兽心，为了自己的前途，竞然要毒死你！”</p>
<p>雪叶斜眼看着月湖，反唇相讥道：“那你当时为了脱离困苦生活，丢下病得臥床不起的皓月自己走了，你这和米生当初对我的处理，性质有什么不一样？只是人都会变的，你现在不是变得很好了吗？大家都喜欢你，你的小姐脾气没有了。米生也应该能够变好的，而且他本来就很好，只是因为那时他生活太苦了，大家都瞧不起他，连老师也不愿教他，他才会变坏的。”</p>
<p>月湖说：“那米生为了满足他的虚荣心，现在还要和我在一起，而不愿重新和你在一起生活，你会怎么办？”</p>
<p>雪叶微笑着说：“他愿意和谁在一起就和谁在一起，我决不会生气和不安。只要他心里真的喜欢我我就满足了。我知道，他和你在一起是喜欢你的家境和背景，不是喜欢你的人，他真心喜欢的人是我。我只要他这样就够了。爱一个人不一定要和这个人厮守在一起，和一个人生活在一起可能更多的只是责任，并不是爱情。”</p>
<p>月湖听了雪叶这一番对爱情的理论，很是惊讶。她用一种佩服的眼光看着雪叶，一时不知道该说什么好。</p>
<p>她们说着走着，不知不觉跟踪那一行人来到雪叶住的小屋旁的一片树林里，伏在灌木丛中，这时天色越来越黑，而且刮起了大风，接着电闪雷鸣起来，伴随着轰隆隆的雷声，倾盆大雨‘哗哗哗’下了下来。这时，白龙班老师一行人来到小屋前，但并没有推门进去。月湖和雪叶伏在的他们附近的草丛中，虽然离那行人很近，但由于她们魔力很弱，加之她们闭住了自己的魔力，那行人一点也没有察觉到。</p>
<p>雪叶隐隐看见暴和另外两个飞逸手下的二级成员紮惑浮和凌穆也在那一行人里面。</p>
<p>她们忽然听见飞逸对身边一位身材高大的老师说：“就是这里，你确定雪叶就是那人吗？”</p>
<p>那高个老师道：“这个时候你还不相信我的话，还要我再说一遍吗？”</p>
<h2 id="阴阳二气诀"><a href="#阴阳二气诀" class="headerlink" title="阴阳二气诀"></a>阴阳二气诀</h2><p>飞逸说：“你说的那个魔法太邪，说起来倒是有可能实现，但是要做到是太难了。”</p>
<p>那老师笑道：“对我们来说是很困难。但是对斑国班这个由擅长魔法的金发本克星人组成的班级来说，就不是没有可能的事了。冥星政府的重要议员月杀丸，现在已经将他的女儿月湖嫁给了本克星的夜影飞，本克星和他们结盟了，正全力帮助他们抵抗沙、狱军。月杀丸这人为达目的总是不择手段，他掌权后，多少中立班级都被他控制了，都去参加了那种无意义的战斗。现在月杀丸又将目标锁定了我们白龙班。你看，月湖不是被他送到我们这儿来了吗？你说月湖她凭自己本事能成为我们班成员吗？这还不是因为月杀丸操纵了明朝学府内阁的结果。”</p>
<p>飞逸说：“雪叶也是月杀丸为了控制我们，通过这手段送过来的吗？”</p>
<p>高个老师回答说：“对呀，这个雪叶并不是以前你教的那个雪叶，当初米生对她下了毒，她怎能不死呢？现在的雪叶只是她的躯体，施法人利用斑国班尤科斯老师刚刚创造的‘阴阳二气诀’魔法，将他的思想和雪叶的躯体合二为一。这是我安置在斑国班里的一个密探说的，他说这个合体的人的思想是施法人的，记忆和能力是躯体原来人的。”</p>
<p>飞逸听到这里，心理十分害怕，她说：“如果是这样，雪叶她们要控制我们岂不是很容易，她只要利用‘阴阳二气诀’魔法，一个一个将我们合体了，她们的目的不就达到了吗？”</p>
<p>高个老师说：“你不要急吗！我听说使用这种魔法有个很大的局限。晚上十点左右合成人就会变回施法人模样，而且身体会变冷，施法人每多合体一个人他身上的寒冷就会增加一成，如果寒冷超过施法人承受底线就会被冻死。我相信没哪个施法人会不顾自己死活，贪婪的去合并许多人。”</p>
<p>飞逸忽然明白了什么似的说：“噢！我说晚上在这小屋旁，怎么总听见里面发出那么凄凉的哭声，原来是冻得受不了。怪不得她总是在我讲课时睡觉，原来她每晚冷得睡不着。”</p>
<p>高个老师严肃起来，厉声说道：“我们要乘她还没有来得及合并我们之前立即把她除掉，这个时候她没法藏匿斑国班的魔法。如果等她合并了我们中某一个人，她身上马上就会有白龙班的魔法，我们再想查出她的真实身份就没那么容易了。如果我们之间互相猜疑起来，白龙班岂不要毁在雪叶手上。我还听说，使用‘阴阳二气诀’魔法的人每月都要喝一个活人的血才能够继续生存。我算了算雪叶来我们这里的天数，和香川井镇这几个月来失踪的人数几乎一样。”</p>
<p>飞逸听到这里，几乎吓昏过去，她急忙命令暴和紮惑浮进小屋里去抓雪叶。这时高个老师慌忙叫住她们。他从身上掏出一个掌上仪器，又看看手表，说：“大家不要慌，还有十几分钟就十点了，等她变回原形，我们再进去：一来可以确定这件事情是否属实，以免犯下处理米生时犯的错误；二来，那个时候她再没法施展‘阴阳二气诀’ 魔法，虽然她的魔力可能增强，但是这魔力需要她恢复本体才能够施展，而到时候她是来不及恢复本体的。”</p>
<p>月湖伏在草丛中听到飞逸和高个老师的对话，心中甚是担忧，不时用害怕的眼光瞟向雪叶，心中充满恐惧，想着高个老师说的话如是真的，自己可要遭殃了。但她又盼望这一切都不是真的。</p>
<p>这时雪叶正紧挨着月湖并肩趴在草丛中，月湖扭头看了一眼雪叶，她正满脸愤怒地看着飞逸他们。月湖凝视了雪叶许久，突然发现雪叶这时扭头朝自己看来，只见雪叶这时另一侧那半边脸全是骨皮，毫无血肉，眼中射出凶狠的光，头发披散开去，正在冲自己恐怖的笑着。月湖突然觉得鼻子发酸，眼睛发胀，手脚发软，一时吓得想喊声音却发不出来了。</p>
<p>飞逸他们正在用魔法搜索周围的魔力，突然发现身后有股强大魔力传来，那位身材高大的老师大声喊道：“雪叶在我们后面！你们感觉到没有，这魔力和斑国班的魔力一样？”</p>
<p>听到喊声，众人一齐转过身去，只见一个穿着白龙班一级成员班服的女子从草丛中一跃而起，拔腿就向远处跑去。在那女子起身的一瞬间，暴看清了她的脸，那正是雪叶。暴和紮惑浮赶紧追去，众人也一起跟上追去。</p>
<p>拐过第三个路口，雪叶的身影突然消失了。这里四处都是高大的乔木和灌木草丛。雷声伴着雨水越下越大，众人身上淋得透湿，一阵冷风刮过，大家不禁打个寒颤，有的人冻得发起抖来。</p>
<p>高个老师说：“现在大家都将气息和魔力闭住。雪叶现在一定比我们谁都冷，她一定会浑身发抖的。”</p>
<p>说完，高个老师使用自己的魔力，开始仔细搜寻这四周。果然雪叶的发抖声被高个老师探到，暴和紮惑浮赶紧朝老师指示的方向冲去。突然，一头大黑熊从灌木丛中猛地窜出。紮惑浮立即意识到这就是雪叶曾使用过的那招“黑熊鬼将”。于是大声喊道：“斑国班的畜生，我们已经知道你不是雪叶，还不赶快给我们现出原形！”</p>
<p>灌木丛中立刻传来凄惨的吼声：“我就是雪……雪叶。你……你们想把我怎样？”</p>
<p>紮惑浮一听这声音虽然有些颤抖，但的确是雪叶本人的声音，一时不知如何回答是好。</p>
<p>其他人都将头转向那高个老师，高个老师想了一想，大声说道：“哼，你别想骗我们，你学雪叶的声音就能骗得了我们吗？就算你真是雪叶，你杀了那么多香川井镇的居民，这罪你也承受不起了。”</p>
<p>雪叶哈哈大笑，笑声凄凉中带着颤抖。那头黑熊向大家冲了过来。紮惑浮拔出红凤长刀“铛”的一声挡住了黑熊挥过来的巨锤。紮惑浮感叹雪叶的魔力竟然比上次增长了许多倍。其他老师也纷纷发出魔力，对黑熊进行魔法攻击。不一会，黑熊消失了，雪叶的大笑声也消失了，大家周围没有了斑国班的魔力。</p>
<h2 id="神秘的消失"><a href="#神秘的消失" class="headerlink" title="神秘的消失"></a>神秘的消失</h2><p>那以后，雪叶再没有回到白龙班来。三年时间过去了，飞逸的飞船依然没有完成。这是她天才的飞船创造才能害了她。飞逸在制造飞船过程中不断涌现一些新的想法，由于整个飞船体系过于庞大，到最后，整合起来困难重重，直到这第三个年头才有了些转机。飞逸制造飞船工期的推迟，导致她手下的学生除了月湖以外，都没有能够得到升级。</p>
<p>第一年，月湖在竞赛单挑项目上取得第一，晋升到二级成员。因为月湖是凭单挑项目升的级，而不是凭的飞逸教授的电子机械项目升级，所以飞逸没能因此晋升为三级成员。</p>
<p>第二年，月湖申请老师成功，月湖的父亲月杀丸利用自己的权利，叫了几名最有希望在单挑，魔法和生物竞技项目中得冠的人加入到白龙班成为月湖的学生，于是，当年这三项竞技的冠军得主全是月湖的学生。月杀丸又用手上的政治权利对明朝学府内阁施加压力，让月湖顺利晋升为三级成员。</p>
<p>第三个年头，月湖很快的学到了变身白龙的本领，成为不死之身。</p>
<p>这天，飞逸和暴正在白羽号飞船里讨论飞船的问题。暴突然对飞逸提起月湖，她说：“你觉得月湖这三年的升级之路正常吗？”</p>
<p>飞逸笑道：“当然不正常了。哈哈！原来暴也会嫉妒啊。但是谁叫人家是议员的女儿呢！这点你不得不服啊。”</p>
<p>暴说道：“事情并不是这样简单啊！我觉得现在的月湖不是原来的月湖，其实是被雪叶合体了的月湖。那时，刚从斑国班回来的雪叶，应该就是雪叶本人，如果她当时不是雪叶，而是被斑国班合体了的人，她早就和白龙班本领最高的人合体了，何必一拖再拖，而且每天都为米生牵肠挂肚，好象见不着米生就没法活下去一般呢？如果她已经被合体了，但是她的思想仍然是雪叶的，至于她是怎么做到能够用被合体人的思想主导合体人的，这我却弄不清楚。那晚我看见从草丛中跑走的人的确是雪叶，而我们在草丛中并没有发现还有一个月湖。所以当时她一定是与月湖合体了，据说斑国班尤科斯老师的‘阴阳二气诀’魔法将两人合体时，施法人不能一下子就消失自己的体貎，将思想植入被合体人体内，完成这个过程需要一会儿时间。不然她那时一定不是雪叶的模样，而应该是月湖的模样了。”</p>
<p>飞逸问道：“你怎么那么肯定是与月湖合体的。”</p>
<p>暴说：“当时我追雪叶回来，在那草丛中发现了这个。”暴拿出一个梅花簪子。说：“这是月湖的梅花簪子，那几天我听说月湖在到处找雪叶。我想那天她们肯定碰上了，后来看到我们去抓雪叶，就跟踪我们想看个究竟。当雪叶发现自己身份败露，就索性和旁边的月湖合体。她这样做可以一举两得，既可掩人耳目继续留在白龙班，又可利用月湖的特殊身份尽快升级成为三级成员。在明朝学府，三级成员可以查看明朝学府所有成员和学员的档案，只要需要，那些加密过的文件也可借阅。在这些文件里，她一定可以看到她一直都想知道的有关米生的情况。”</p>
<p>飞逸一惊道：“你怎么知道这些事情的。”</p>
<p>暴骄傲地说：“通过分析推断出来的啊。你想想，当初你千般阻扰雪叶升级是为什么。即使她是斑国班派来的探子，就你性格而言，你怎么会不希望她升级呢？她升级了，你不就能够成为你日思夜想的三级成员了吗？你那么担心她升级到底是什么原因？我后来联系雪叶一心要找米生的所为，联想到明朝学府升级为三级成员后可以查看学员档案的规定，发现你是怕雪叶知道米生的情况。”</p>
<p>飞逸哈哈大笑，高兴地说道：“好个暴，我果然没看错，你确实是个厉害的学生，连我的这个心事你都能够猜出来。”</p>
<h2 id="败露"><a href="#败露" class="headerlink" title="败露"></a>败露</h2><p>“咚咚咚”，一串下楼梯的声音从外面传来。暴说：“一定是月湖听见我们谈话了。”飞逸疾步奔向楼梯，扭头叫道：“暴，我们赶紧去阻止她，不要叫她看见了那些密件。”</p>
<p>暴和飞逸赶到母舰中央控制室，看见月湖双手撑在控制台上，正低头痛哭，声音凄惨阴森，大屏幕上显示出一段视频，米生在牢里被划破胸脯，身体里的内脏被挖出来，白龙班里的老师在四周围观。视频下显示一条信息：“米生，二十八岁，犯投毒杀人罪，判处死刑，交白龙班执行。明朝学府内阁。”</p>
<p>飞逸手足无措，站在门口无所适从。月湖转过身来恶狠狠的看着飞逸，眼中泪水不断。</p>
<p>月湖哭着大叫道：“你们为什么要这样对待米生，让他死得这样惨！米生怎样对我与你们何干？我从斑国班回来，证明米生并没有犯下杀人罪，是你们犯了侮告罪，你为什么不去自首？是不是怕因为这影响你的升级？你们这群恶魔！”</p>
<p>飞逸说：“你是斑国班老师用‘阴阳二气诀’合成的合体人，你并不是真的雪叶。对吧？”</p>
<p>月湖斩钉截铁地说：“我就是雪叶！”</p>
<p>飞逸用一种疑问的语气探问道：“雪叶被使用‘阴阳二气诀’合体后，怎么还能够有她的思想？”</p>
<p>雪叶说：“哼！这你哪里明白，斑国班的尤科斯老师使用自己的一半心灵进入我的身体，这样既能保全她的本体，也能将我救活，这是她创造的最新‘阴阳二气诀’魔法，这样的方法只有她一个人能够做到。由于尤科斯的心灵没有完全进入我的身体，这样做的结果，就是思想还是我的，但我的身体却具有了尤科斯老师记忆和魔力的一半。”</p>
<p>暴在一旁一边听一边点头称奇，然后插话说：“尤科斯果然胜人一等，这样的招术都能够想到，她不仅将一个快死的人给救活了，还把自己的本领轻而易举地传给了你。”</p>
<p>雪叶苦笑道：“好是好，只是得到‘阴阳二气诀’不是那么好受，每天夜晚，身体冰冷无法入眠的滋味你们是体会不到的。飞逸啊，飞逸，你很希望我雪叶死去，对吧？这样你就不用背负误杀米生的罪名了是吧？可怜我现在变成了月湖的模样，这就再没法证明雪叶没死了，也没法让明朝学府内阁处置你们这群杀人恶魔了。哈哈哈……你赢了！最终还是你赢了！”</p>
<p>雪叶这几声笑，笑得甚是凄惨，她突然旋转身子，速度转得越来越快，随即变为金色的沙子弥漫整个控制室里，然后慢慢的消失得无影无踪。</p>
<p>飞逸说：“斑国班的‘飞砂走石’魔法！”</p>
<p>“是啊，身体一下子变成金光闪闪的沙子，这魔术只有斑国班才有。”暴赞叹道。</p>
<p>飞逸长长叹了一口气，说道：“雪叶这么年轻，就不仅成为了明朝学府四级成员，已经变身为白龙而长生不老，她还同时掌握了白龙班和斑国班的一些绝招。希望她不要被月杀丸利用了啊。”</p>
<p>次日，飞逸和暴用完晚餐，在去飞船二层飞逸房间“御匾所”的路旁草地上闲聊。暴对飞逸说，雪叶这次虽然离开了飞船，但她不会善罢甘休，她会利用月湖的身像挑拨冥军和白龙班的关系，对白龙班不利。而且雪叶本身就已经是四级成员，她还能够变身为白龙，这次白龙班惨了。说到这里，忽然听见楼下一片吵杂声音传来，接着一串慌张的脚步声，有人跑了上来。</p>
<p>飞逸对跑上来的学生吼道：“是什么大不了的事把你急成这样，慌什么？什么事，快说！”</p>
<p>急步跑上来的是紮惑浮和凌穆。紮惑浮气喘吁吁的说：“飞……飞逸老师，有……有位老师死了。”</p>
<p>飞逸大吃一惊，问道：“慢慢说！不要慌，那老师是怎么死的？病死的吗？”</p>
<p>凌穆说：“不是，不是的。刚才我和紮惑浮在飞船外面散步，听见大家正在外面议论纷纷，说一个老师被人杀死了。我们赶紧回到飞船内，查到白龙班对这件事情的报道，看到那位老师的胸脯被划开，内脏抛在一旁，血流满地。真的好惨啊！”</p>
<p>飞逸倒吸了一口气，方寸乱极了。停了一会，她对紮惑浮和凌穆说：“你们赶快联系明朝学府内阁和其它的班级。将此事赶快上报内阁和通告所有人。”</p>
<p>凌穆和紮惑浮应了一声急忙奔向下层执行命令去了。飞逸和暴也紧跟她们走到下层。</p>
<p>飞逸脸上冒着冷汗，走到下层，在‘白羽号’的中央控制室里聚集起她的成员和学生。</p>
<p>紮惑浮很快跑过来，她报告飞逸：“我们连接不上外部网络，不能和外部进行通讯。只有白龙班的内部网络还能用。”</p>
<p>忽然听到有人惊叫着跑进来：“哎呀，又一个老师死了！也是胸脯被划开。好可怕呀！”</p>
<p>飞逸和紮惑浮等人同时一惊。飞逸的声音带着颤抖命令道：“你……你们赶紧……把飞船的大门关好……”</p>
<p>众人纷纷跑向飞船大门。</p>
<p>这时中央控制室里还剩下飞逸，暴，紮惑浮，月湖的妹妹半月和贵公子德斯，其他成员关好飞船大门，带领着雇佣兵各就各位，整个飞船进入红色警戒状态。</p>
<p>德斯这时看到飞逸一脸紧张，自言自语地说：“连死了两个老师，飞逸老师也害怕了呀。”</p>
<p>“德斯，你是怎么回事，这个时候还胡乱说话。”紮惑浮制止德斯乱说，是要缓和紧张形势，稳定大家情绪。</p>
<p>飞逸拍了拍紮惑浮的肩膀，意思是赞扬她做得对。然后她对德斯说：“你说的很对，我确实是有些害怕。我和其他老师们犯了一个无法原谅的错误，在没有调查清楚事情的情况下，为了顾全我们白龙班的名誉误杀了米生。米生确实罪不该死。这次雪叶找我们报仇来了。”</p>
<p>听了飞逸老师的话，除了暴以外，其他人均感到震惊。</p>
<p>德斯说：“雪叶离开我们已经三年多了，她什么时候回来的？她凭什么本事能够杀死白龙班的老师？”</p>
<p>暴反问德斯说：“如果是月湖，她能办到吗？”</p>
<p>德斯更大惑不解了，她说：“这和月湖又有什么关系？如果是月湖那我就不敢说了。哼！我真弄不懂，月湖到底是凭什么进步这么快的？是凭她的真本事还是靠其他下三烂手段。”</p>
<p>暴带着瞧不起的语气问德斯说：“你听说过‘阴阳二气诀’这个魔法没有？”</p>
<p>德斯不屑地答道：“这谁不知道，‘阴阳二气诀’是斑国班老师尤科斯创造的魔法，能够和别人合为一体借用他人的能力……”</p>
<p>德斯说着说着好像明白了什么，他话题一转，说：“难道……”</p>
<p>“不错，雪叶就是用这魔法和月湖合体了，现在，她知道了米生的死因，所以她……”暴把雪叶如何与月湖合体，如何努力升级获取查阅学生档案的资格，如何查阅秘密档案看到米生被处死的情景的事从头至尾简略地解说了一遍。</p>
<p>半月听后不信，急忙说道：“不会的，你骗人！我姐姐怎么会被雪叶合体呢？如果你这样说是真的，那我姐姐不就死了吗？”</p>
<p>突然，飞船被什么重重撞了一下，剧烈晃动起来。由于没有准备，大家一下子站立不稳，跌倒地上。飞逸爬起来，迅速打开视频察看飞船外情况，查找飞船被撞的原因。她看见飞船外面狼藉一片，其他小型飞船很多已被破坏，地上到处都是死人，肉血将地面几乎全染红了，有很多学员和雇佣兵在奔跑逃命。</p>
<p>半月在视频中看到外面的景象，吓得哆哆嗦嗦地说：“我们得……得想。。。想点办法，这样下去……白龙班。。。岂。。。岂不是要毁了。”</p>
<p>飞逸说：“不要慌！大家都坐到各自控制台里去，注意监视飞船周围，发现有目标攻击飞船就对它开炮。”</p>
<p>等了四、五个小时时间，始终没发现目标。这时天色渐渐暗下来。凌穆，小侃，华房星，宋藏金，易慧等成员回到中央控制室。</p>
<p>凌穆对飞逸说：“全部雇佣兵都安置到岗了，机器人兵也全部集中在机器人船舱候命了。”</p>
<p>飞逸说：“白龙班的内部网络通讯坏了，我们在船内，也不知道外面的情况怎么样了。现在天黑了，暴和紮惑浮出去调查一下。我现在要去我房间里编写几套应对变身白龙和斑国班魔法的程序。凌穆！控制室这里交给你了，如果发现外面有攻击，就按照我教给你的方案实施防御和反击。待会我会将新方案传给你。”</p>
<p>暴和紮惑浮急忙来到机器人舱。一会儿，机器人船舱舱门打开，“嗖–嗖–嗖–”十来个机器人从船舱飞了出去。紮惑浮驾驶着量产机器人在前带路，暴驾驶着她的‘白艳公主’机器人紧跟其后，雇佣兵机器人排成一字阵型跟随着他们。夜幕已经降临，他们打开探照灯，看到满山遍野尽是尸体，河水已被血水染红。当他们来到碑亭那里的名人堂时，一进门就远远看见中间那个墓碑有刚被动过的迹象，旁边有一具骸骨。机器人在墓碑附近停下来，一行人从机器人里走出来。</p>
<p>紮惑浮命令一个佣兵：“你，去墓碑那瞧瞧。”</p>
<p>那佣兵向前走了两三步，想到沿路看到那些惨景，顿觉腿脚发软，不知脚下被什么绊了一下，便跌倒地上，然后爬起来就极速转身往回跑。</p>
<p>“没用的东西，你怕什么？亏你还是我们白龙班的兵！” 紮惑浮气愤地吼道。他一脚将这佣兵踢开，拿过一只探照灯，走近碑前，用灯一照，看见碑上写的文字，尖叫一声，抛下探照灯，吓得只往后退。其他佣兵听到这尖叫声个个吓得浑身发抖，纷纷丢掉手中灯，直往后退。暴不明白是怎么回事，一个人拿着灯木呆的站在一旁。</p>
<p>紮惑浮颤抖着声音对暴说：“这是向前辈的坟墓，碑上的名字，怎地……怎么……”</p>
<p>“别慌，我来看看！” 暴说。她一直都镇定自若，此时言语中也透出几分惊慌来。暴拿着灯走到墓前，弯腰察看。 “米。。。米生。”她说，“这雪叶竟然把这坟墓挖了，把米生的尸体埋到这里了。看来她是疯了，现在还想着要米生成为白龙班的名人。”</p>
<p>一个佣兵带着发颤的声音问道：“那旁边的骨骸是……是不是……向前辈的……”</p>
<p>他的话还没说完，忽然听见远处传来一阵阵女人的狂笑声，笑声过后，一阵沉寂。在这无声无息的时候，每个人的心都在颤抖。大家屏住呼吸，仔细辨视四周情况。</p>
<p>只听暴大叫一声：“不好！”她手中的灯“哐噹”一声掉在地上，那些佣兵见状，四处乱跑开去。暴和紮惑浮手拉着手，背靠着背，手中拿着武器，做好迎敌的准备。突然，传来一阵佣兵的惨叫声，其中还杂有野兽的怒吼声，声音像是很远，又像就在身边发生。一会，又静了下来。暴对背后的紮惑浮说：“紮惑浮前辈，我们在明处，敌人在暗处，我们被动，快点走吧。”半响，紮惑浮没有答话，暴心想：“紮惑浮是不是意在叫我不要出声，待敌人走远我们再走？”</p>
<h2 id="雪叶对决暴"><a href="#雪叶对决暴" class="headerlink" title="雪叶对决暴"></a>雪叶对决暴</h2><p>想到这里，暴心里平静下来，转过脸去，看到紮惑浮木然不动。暴感觉不对劲，往地下一看，月光下忽然发现有个很大的龙爪印。暴心里一惊，身子一转，紮惑浮的身体失去支撑倒在了地上，地上躺着的紮惑浮胸口已被划破。她抬头一看，月湖模样的雪叶正威武地站在暴的面前。</p>
<p>暴这时已经不知道害怕了，她镇定地说：“雪叶，你也想杀了我吗？你今天杀了这么多人，他们大多数对米生的是不知情的，你为什么这样残酷？滥杀无辜！”</p>
<p>雪叶说：“你怎么说都没有用，我的思想现在已经不完全属于我了。杀人的一瞬间，我的思想是尤科斯控制的。但是我不后悔，我恨白龙班，恨里面所有的人，其中也包括你！你不要以为飞逸喜欢你，你就有多么了不起。我现在就用白龙班的功夫和你较量一下，看看你到底有多强。”</p>
<p>暴说：“我从来没说我比你强！在学府的升级竞赛中已经证明了你最强。我当然不是你的对手。”</p>
<p>雪叶说：“那是因为你瞧不起我，以为不屑和我一比，放弃了参加升级竞赛。现在我非要你和我比一比不可！”</p>
<p>说完，雪叶双脚跳起，挥起白龙爪双刀奋力向暴砍去。暴侧身左滚翻，躲过这一刀。然后半跪地上，迅速拔出背后的龙爪长刀，一场长刀对双刀的决斗开始了。雪叶的双刀虽然没有暴的长刀那么长，却利于近身保护，而且出招频率比长刀高许多。雪叶这时使出白龙班上位的辅助魔法“莲步轻舞”，使得本就出招速度很快的双刀变得更快。暴所持的长刀舞动范围大，虽进攻频率不高，但和雪叶的双刀一样善于防御。暴便用白龙班下位招式“白龙花妖”， 奋力舞动长刀左右上下抵挡进攻，“噹–噹，噹–噹”，火星四溅。雪叶不断逼迫，暴渐渐显得招架不住，但她情急不慌，当雪叶不断将攻击频率调高，直到频率快到最高点收不住手时，暴将双手握刀改为只手握刀，身子来一个一百八十度大旋转，迅速将刀一下收回，再来旋转一个一百八十度，跨前一步，双手握刀，一个半月斩砍向雪叶背部，雪叶这时由于进攻速度太快，身体直向前冲，握刀的双手来不及收回，眼看暴的长刀就要将自己一劈两半，只得猛地向前一扑。暴的这一砍配上了“绝色七彩”里“世外桃源”魔法，使得黑暗的夜空亮出一片片桃花幻影，桃花瓣被暴的半月斩的余波划成两半片片落下，长刀一直砍向雪叶的背部，雪叶虽然猛向前冲，但仍没躲过这一刀，只是没被砍断身体。但由于雪叶今天没穿屠龙护身衣，结果背部被划开一条大口子，扑的涌出血来。雪叶一只手撑着地面，另一只手背向身后捂住背上的伤口转过身来，口中含着血，眼睛恶狠狠地看着暴。暴站在那里手握长刀岿然不动。</p>
<p>雪叶将口中的血往地上一吐，抬起手腕用袖子拭去口角的血迹，对暴说：“你竟然只用白龙班下位招式就能够击中我，佩服！”</p>
<p>暴心想：“雪叶本就不擅长白龙班的武功，双刀对付身体庞大行动缓慢的人比较合适，而她却使用双刀这种武器对付我这个机灵的女子，这说明她使用白龙班的武功还不够娴熟。但是如果她使用斑国班的魔法，我就没法对付了，她竞赛时都是用斑国班的魔法战胜的对手。如今我生死攸关，该怎样对付她呢？”</p>
<p>雪叶看暴站在对面正犹豫不决，她对暴说：“我刚才说了，这次我只用白龙班的功夫和你比试。我说话算数，我认输了。”</p>
<p>暴松了一口气，将握紧长刀的手松开了。</p>
<p>雪叶忽然狂笑着道：“我虽然输了，但是你的命我还是要的。哈哈！”</p>
<p>暴一吓，握刀的手马上又紧了起来。</p>
<h2 id="飞逸之死"><a href="#飞逸之死" class="headerlink" title="飞逸之死"></a>飞逸之死</h2><p>白羽号飞船里，飞逸正在她的房间里编写程序，突然屏幕上面弹出消息：暴请求飞船开舱。飞逸启开飞船外监视屏幕，看见只有暴驾驶的‘白艳公主’机器人在飞船外空徘徊，紮惑浮和其他佣兵的机器人都没看见。飞逸拨通中央控制室，与凌穆通话。</p>
<p>飞逸的形象出现在白羽号飞船中央控制室大屏幕上，她对凌穆说：“听我的命令，千万不要开舱，待我观察观察再作决定。”</p>
<p>小胖易慧奇怪的询问道：“为什么不开舱啊？你这不是要害死暴吗？”</p>
<p>飞逸说：“你们听我的就行了。不用问那么多！”</p>
<p>易慧非常生气，示意小侃去劝飞逸老师，小侃见没人敢反对飞逸，他也就像没看到小易的示意一样没有吭声。</p>
<p>飞逸慌忙将编写完成的部分程序传给凌穆，另外还附上了几十套应对不同情况的方案。凌穆仔细琢磨这些方案来。感到这些方案预想到了所有可能发生的情况，越发佩服起飞逸老师来了。</p>
<p>凌穆心想：“飞逸不愧是白羽号的设计师，她对白羽号每处设置每个部件都了如指掌，只有她才能够写出这么好的应对方案来。难怪敌人一直不敢对白羽号动手。以前除了飞逸以外，对白羽号这么了解的只有暴。现在飞逸怀疑暴被雪叶用‘阴阳二气诀’合体了，不让进入飞船来，我可以乘这个机会好好了解一下白羽号。飞逸确实是制造飞船的天才，她使用其他白龙班飞船没有的新技术，在白羽号飞船上装备了隔热胶体，因此飞船可以进入大气圈；它表面还装备了叠层装甲，因此在战斗中不易被击毁。在武器装备方面，白羽号主要的武器是双重阳电子破城炮，安装在飞船“两腿”的前端。白羽号飞船还装备有其他一系列武器，例如‘菲尔德’光束炮，‘瓦冷特’线性枪，‘艾格斯拉格’巴尔干炮，还有大量飞弹发射管。这些都是白龙班的著名前辈精心研究的学术成果，飞逸学习和继承他们的成果，并加以改进，然后都用到了白羽号上，使得这个战斗性飞船成为白龙班名副其实的最优秀的飞船。只可惜白羽号飞船造价实在太高，无法批量生产，不然，我们白龙班还害怕其他人来侵犯吗？”</p>
<p>暴看白羽号迟迟不开舱，开启视频通话呼叫。暴这时出现在白羽号中央控制室大屏幕上，她神情紧张地喊道：“飞逸老师，请你赶快给我打开舱门，雪叶马上就要追过来了。”</p>
<p>飞逸在飞船里看到屏幕上暴焦急的样子，心想：“装得真够像的，当年雪叶你扮月湖瞒了我那么久，今天还想装扮成暴再来骗我吗？如果真的还有另外一个雪叶追你，她早就该追来了，还能给你这么多时间。何况那么多人都死了，暴怎么可能一个人回来？雪叶啊雪叶，你以为我偏爱暴就会对暴放松警惕，你就想利用合体暴混进飞船，如此小伎俩还想骗我，你太小看我了！”</p>
<p>飞逸在大屏幕上对凌穆下命令说：“凌穆，实施方案一，立即向暴攻击。”</p>
<p>凌穆命令机器人佣兵部队出动，四台组成一队，派出八队，阵型为每两队占据东西南北一方，每方向有两队，这两队再围成一个小方圈。这样便在同一个平面上做到了天衣无缝，为防止被困敌人向上飞行以求脱逃，由白羽号飞船监视阵型上下方，它的双重阳电子破城炮分别装在飞船左右两侧巨大的“长腿”上，左侧负责上方，右侧负责下方。暴看见这八队机器人，排着整整齐齐的队形向自己冲过来，还没等他们展开阵势，暴立即驾驶‘白艳公主’机器人往后一转，加大马力迅速后撤，也不高飞，也不降低。那八队机器人将阵型展开，围住‘白艳公主’，不断向它开火。当火力集中到一点时，暴急速一侧身，同时来个大翻转，掏出高能量光束步枪，对准最左侧一架机器人连发五枪百分之二跟踪光速弹将其打得粉碎。如此反复数次，一行三十二架机器人只剩下了二十来架。</p>
<p>飞逸看到这里大发雷霆，她吼道：“废物，你们这群雇佣兵是怎么训练的，三十多架居然没法围住一台机器人。”</p>
<p>凌穆看着屏幕上的战斗画面，心想：“飞逸平日极少顾及白羽号上雇佣兵的训练，那是因为她自己只注意重点尖子，又几乎将所有时间都用到设计飞船和改进飞船上了，这点她自己应该十分清楚。她这样的发火，无非是因为暴的驾驶技术远远高于这群雇佣兵，他们未能把暴引入白羽号的射程，使得飞逸引以为豪的白羽号无法发挥威力罢了。”</p>
<p>过了一会，飞逸见雇佣兵机器人实在无能，便对凌穆说：“将‘左腿’破城炮射向水平方向。”</p>
<p>凌穆听到这话十分不解，说：“那些雇佣兵怎么办。”</p>
<p>   “这样耗下去，他们迟早都要被击毙，还不如让他们的牺牲起些作用。” 飞逸不耐烦的说。</p>
<p>“我觉得这样做很不好。”凌穆忙说，“这样做一来会引起还在白羽号里的其他雇佣兵不满，致使白羽号内部人心浮动。二来，破城炮射击范围大，可是射速却很慢。它对于向上爬高和向下俯冲的机器人，因为他们中途无法急速改变方向，射速慢的倒不是问题。但是对于处于水平飞行的机器人，警告提示一出现，它只要马上朝上或向下一飞，很轻松地就能躲过破城炮的射击。”</p>
<p>飞逸听完凌穆这番话，笑着说道：“凌穆，我没有看错你，你不愧是个好学生。但是你多虑了！现在是何等情况？你看现在，整个白龙班几乎就要灭亡，无数雇佣兵兄弟都已战死。现在他们心里想的就只有消灭敌人的念头。眼前这点牺牲算得了什么？你说的第二个问题确实存在。我们同时开启两侧的电子破城炮，雪叶（暴身）不会知道打她的炮是瞄向上方还是向下方的。我们现在用瞄向上方的左侧破城炮向水平方向发射。白羽号大范围的炮除了这两台破城炮外，白羽号中部还有一台‘艾格斯拉格’巴尔干炮射击范围最大。但白羽号此前尚未做好作战准备，现在飞船的能量还不足以开启这台巴尔干炮，不然这次雪叶定死无疑。少了这台大炮，为防止她向上逃，我们就启用扩霰弹头飞弹，来打她个天罗地网。”</p>
<p>凌穆说：“飞逸老师考虑得周到，我马上照做。”</p>
<p>这时，大屏幕上突然出现暴的头像，暴说：“我是暴啊，你们在干什么，飞逸老师……”接着讯号突然消失，另一侧屏幕上显示暴又一个突然转身将另一台机器人击毙。</p>
<p>飞逸对凌穆说：“不要犹豫，赶紧执行命令！”</p>
<p>凌穆立刻调好控制台上数据，破城炮轰地一声射向雇佣兵机器人和暴的‘白艳公主’，暴驾驶着‘白艳公主’迅速向上斜飞过去，‘白艳公主’正准备向上爬高飞行，发现身边有颗与自己并排飞行的扩霰弹头，便伸手抓住它，用力抛向下方，扩霰弹在被抛出的瞬间爆炸散开，却毫未伤及‘白艳公主’。原来这扩霰弹是飞逸特别研制的定时炸弹，扩霰弹的爆炸时间正是白雪公主向上爬高飞行的时间，在这即将爆炸的一瞬间暴正好抓住扩霰弹并向下抛去，因此抛出就爆炸了。向下抛的原因是，这扩霰弹为了扩大爆炸范围，爆炸的时候是扩散向下，下方百米范围全被覆盖。</p>
<p>飞逸看到屏幕上的情景，急忙赶到中央控制室去，她要亲自操作射击。</p>
<p>飞逸站在凌穆旁对她说：“我这二十六个方案里面，前十个是白羽号配合机器人部队对付一到十个数目敌人的战略，从十一到十九是白羽号配合一名王牌驾驶员对付一个强大敌人的战略，二十到二十六是白羽号配合两名王牌驾驶员对付一个强大敌人的战略。如今白羽号里能够称得上王牌的驾驶员就只有你和我了，我们现在开始实施第十一号方案，你赶紧去驾驶你的机器人出去按照预定方案与敌人周旋，与我随时保持通讯联络。”</p>
<p>飞逸马上在控制台亲自调整部署起白羽号来。</p>
<p>凌穆走到中央控制室门口，又犹疑地转过身来对飞逸说：“从刚才暴的举动看，她对你的方案十分了解，你还认为她是雪叶吗？”</p>
<p>飞逸双手撑在控制台上，缓缓扭过头来，但她脸朝下低着头，并没看凌穆一眼，只是低声说：“这些我心里有数，你照我的话做就是了，不必多问！”凌穆担心地说道：“如果她不是雪叶，我们这样做……那……”</p>
<p>飞逸咬了咬下嘴唇，瞪大眼睛看着凌穆说：“怎么说呢？我之所以一直怀疑暴是雪叶，是因为到现在雪叶的真身都未出现，我真担心她将我跟暴讲的那些东西都学了过去，其中也包括这二十六套白羽号作战方案。”</p>
<p>凌穆默默点了点头，就什么再也没有说，大步跨出了大门。</p>
<p>飞逸控制着白羽号和驾驶机器人的凌穆配合，将那九套方案乱序排列使了个遍，结果都被暴破解了。飞逸马上把易慧叫到控制台前。</p>
<p>飞逸说：“现在形势非常严峻，我现在将白羽号交给你来操作。”</p>
<p>接着飞逸开启二十以后的方案，指着屏幕对易慧说：“我现在驾驶机器人出去帮助凌穆，你按照提示进行设置选择，好好配合我们对敌作战。随时保持联络，按照我的命令进行操作，不要随便自己决定，有疑问一定要先问我，不然我们就都完了。”</p>
<p>易慧笑着接受了任务，并叫飞逸放心，飞逸还是有些担心，虽然犹豫不决，但她还是毅然驾驶起机器人飞出了白羽号舱门。</p>
<p>飞逸驾驶着机器人配合白羽号和凌穆使用了两三套方案后，暴终于被击中，暴的‘白艳公主’左臂被打烂。这时远处突然传来一阵阵野兽般的吼叫声，瞬时一道白光从黑暗中闪电般划过，一条大白龙，摇摆着蛇形身躯急速过来，随之传来一声巨大的踏击声，凌穆的机器人被踩扁，接着，轰隆一声，炸得粉碎。</p>
<p>飞逸这一瞬间才明白过来，暴没有被雪叶合体，雪叶利用她的防范疑心，躲在一旁坐山观虎斗，让她自己把她辛苦培养的暴杀了，这时她心中悔恨交加，感到后悔极了。</p>
<p>飞逸失声大叫凌穆和紮惑浮的名字，叫声悲愤凄惨。</p>
<p>白龙停在飞逸驾驶的机器人面前，将头向后一昂，喉咙里发出咕噜咕噜的声音。飞逸立刻镇静下来，当白龙张口沿斜下四十五度角喷出火柱时，她开启机器人背部向上喷气装置，机器人立刻向下俯冲躲过火柱，就在向下俯冲的瞬间，飞逸让机器人向暴的‘白艳公主’所在的地面开出一炮，暴所在地下一塌陷，暴的‘白雪公主’立刻埋了进去，使得暴正好躲过上方向下喷射过来的火柱，破坏了白龙妄图一举两得的一击。飞逸在白龙欲挺直身体再次发起攻击的间隙，拉起土堆里的白艳公主，迅速向上空飞去。白龙摆动龙头从右下方沿四十五度角原路再喷火柱时。飞逸急忙将机器人向后一退，转身朝白羽号飞去。</p>
<p>易慧此刻遇到这突如其来的情况，一下子没了办法。</p>
<p>飞逸打开通讯频道对易慧说：“易慧，易慧，你不要紧张……赶紧打开飞船舱门，待我和白龙进入后，听我命令开启第三百九十一频道，输入‘骨牢’后确定，这时旁边会出现‘启动’按钮，我叫你按时，你再按。记住了，不要按早了，也不要按晚了。”</p>
<p>易慧连忙应答。飞逸驾驶机器人手托着重量大于自己一倍多的‘白艳公主’，沉重地向飞船飞去，速度降了将近三分之一。眼看白龙紧跟在后面追赶的速度越来越快，飞逸心急如焚，立刻写个信息发给了暴。接近舱门时，白龙已近在咫尺。白龙将大爪一挥，飞逸旋转着向上一飞，利用旋转的力量使劲将‘白艳公主’甩进舱门，自己却被白龙一口咬住，由于惯性，白龙一头扎进飞船舱门。白龙由于身形巨大，进舱时撞得白羽号剧烈晃动起来。此时易慧刚刚输完“骨牢”按下‘确定’，这一晃动突然将她跌倒，她赶紧爬起来，伸手就去抓控制台，一不小心碰到了‘启动’按钮，出舱室立刻哐啷哐啷的响了起来。暴被这剧烈的震动声惊醒，立刻明白了自己的处境，急忙开动失去平衡的‘白艳公主’，斜着身子艰难地朝最近的舱室飞去。这时，出舱室上下左右四侧隔板缓缓打开，四大块由白龙骨构成的栅栏形成一个巨大的牢笼，将进舱来的白龙死死困住。然后，船舱底部舱门折叠打开，将这牢笼丢了下去，白羽号飞船摆脱累赘，快速向远处飞去。</p>
<p>白龙甩掉口中的机器人，发出一道光闪，雪叶立即变回原形。飞逸从损坏了的机器人驾驶舱缓缓爬出。雪叶站在一旁手持白龙爪双刀，气势汹汹地看着飞逸。</p>
<p>飞逸看了雪叶一眼，忍不住哈哈大笑：“起初我还担心暴会和你一起困在这骨牢里，现在她脱险了，看来白龙班不会就这么完了。哈哈！论单挑，我不是你的对手，要杀要刮请便吧。”</p>
<p>雪叶突然扑倒在地上，双手抱住头，来回翻滚起来，一副疼痛难忍的模样。</p>
<p>疼痛过后，雪叶自言自语起来：“可恶，还是让那么多人跑了……跑了……行了，就此打住吧，你已经杀了那么多人了，快……快打住吧。不行，米生不在了，我也不想活了！你……你杀了我吧！不……我还想见皓月……我不能死……我一定要见……”</p>
<p>飞逸见雪叶反复不断地在那儿嘀咕着什么，觉得雪叶一定是受到了什么刺激，疯了！于是不住的摇着头，叹着气。</p>
<p>转眼间，骨牢里弥漫出一股黑烟。原来是雪叶在不断转换魔法，妄图化解自己身体分子从骨牢的缝隙逃离，可是看似栅栏的骨牢，却如同铜墙铁壁一般四周什么也钻不出去。</p>
<p>飞逸见雪叶使出十八般武艺皆都拿这骨牢没有办法，笑道：“这骨牢可是由阿斯来班著名的魔法专家查穆尔老师设计制造的，虽然你掌握了以魔法著称的斑国班的魔法和尤科斯的一半魔力，但是光凭这些还是不够的，还需要一定时日的修炼才能将你的魔力提到能够破解查穆尔老师的魔法的高度，可是在你修炼到这个程度以前你就要饿死在这里。哈哈！你终于可以见到你的米……”</p>
<p>话还没有说完，雪叶左手一刀已划开飞逸的喉咙，同时右手那刀剖开了飞逸的胸脯。</p>
<p>雪叶将手中的双刀插在地下，低着头不住哭泣，她哭啊哭啊，眼眶都哭得流出血来，她还是白天黑夜不住哭。在她四周全是白龙骨栅栏，一点能吃的东西都没有。这时，她所见之物已呈模糊状，再这样哭泣几天，她双目就要失明了。</p>
<p>这天夜间，雪叶模糊间见到一个红发少年，他上身穿着红背心，披着一件黑色长风衣，背上背着一把金色大长刀，下身穿着一件黑色布裤子，牵着一匹背甲龙。哼着小曲，踏着轻轻的步子朝自己这边走过来。</p>
<p>雪叶从地上缓缓爬起，双手抓着骨牢的白龙骨，颤声喊道：“米……米生，米生，是你吗？”</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是我十二年前写的一篇小说。当年每天早上8点半上班，为了写这篇，我四点起床，写到早饭前，坚持了好几周才完成。&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;
    
    </summary>
    
      <category term="My novel" scheme="http://ming1016.github.io/categories/My-novel/"/>
    
    
      <category term="Novel" scheme="http://ming1016.github.io/tags/Novel/"/>
    
  </entry>
  
  <entry>
    <title>这次swift大会分享准备的幻灯片和 demo</title>
    <link href="http://ming1016.github.io/2018/09/17/produce-slides-of-third-at-swift-conference/"/>
    <id>http://ming1016.github.io/2018/09/17/produce-slides-of-third-at-swift-conference/</id>
    <published>2018-09-17T02:04:11.000Z</published>
    <updated>2018-09-17T08:53:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>第三届在北京举办的@swift大会，我分享了用 swift 写解释器的思路，这个解释器 demo 我放在了 github 上，地址在 <a href="https://github.com/ming1016/HTN/tree/master/Sources/Core/OC" target="_blank" rel="external">https://github.com/ming1016/HTN/tree/master/Sources/Core/OC</a> 。demo 支持简单的几个 OC 语法，按照这个架子和思路大家可以当作一个去支持一个语言，和设计自己特定语法的雏形来练手。当年前端人人都在用的 babel 转义器的作者也写过一个雏型例子，看完这个雏型就大致了解了 babel 这个工程整个解析的思路，工程代码看起来轻松不少，从里面也能很快的学到了很多自己需要的知识。大会上我还提到了一个 demo，地址<a href="https://github.com/ming1016/ArchitectureDemo" target="_blank" rel="external">https://github.com/ming1016/ArchitectureDemo</a>。这个 demo 是对 casatwy 的 <a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">CTMediator</a> 扩展了一些 aop 和状态管理功能的一个例子，加了些链式写法，在接口里留了一个 eval 的方法。有兴趣也可以结合前一个 demo 的思路去实现这个接口的方法，让这个接口可以支持程序运行中解释执行想支持的语法内容。</p>
<p>这次大会分享的幻灯片制作方法采用了漫画制作的手法，先前看过 NHK 的漫勉这个节目了解了一些日本漫画家画漫画流程。我在这次的制作过程中，使用了更多的视角，不过运用的还不够好，以后会在这方面多学习下。龙珠超第3集最后几页登出一访谈鸟山明和龙珠超的漫画家。最新的龙珠超里，，另一位漫画家负责来画，鸟山明负责写龙珠超的故事和修改一些草图设计。采访时采访者要鸟山明给那漫画家提建议，鸟山明说希望能够又更多的视角来表现人物和场景。我翻了下以前龙珠的书发现这个建议果然是龙珠分镜吸引人的一个很关键的原因。取材方面，我在国家图书馆里找了很多资料，还有部分是把上次去日本玩看到喜欢的加了进去，比如浅草寺的树，白狐狸和长鼻鬼的面具，在川崎市的藤子F不二雄哆啦A梦主题馆里的看过的原画稿，还有夏季烟火大会的合服浴衣。大会完整幻灯片和草图的原尺寸（较大），我放在了网盘里：<a href="https://pan.baidu.com/s/1WlqTRodrVVksdc_43QO1Zw" target="_blank" rel="external">https://pan.baidu.com/s/1WlqTRodrVVksdc_43QO1Zw</a></p>
<h2 id="幻灯片"><a href="#幻灯片" class="headerlink" title="幻灯片"></a>幻灯片</h2><p><img src="/uploads/produce-slides-of-third-at-swift-conference/1.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/2.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/3.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/4.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/5.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/6.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/7.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/8.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/9.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/10.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/11.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/12.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/13.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/14.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/15.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/16.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/17.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/18.PNG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/19.PNG" alt="image"></p>
<h2 id="部分草图"><a href="#部分草图" class="headerlink" title="部分草图"></a>部分草图</h2><p><img src="/uploads/produce-slides-of-third-at-swift-conference/20.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/22.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/23.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/24.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/25.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/26.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/27.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/28.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/29.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/30.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/31.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/32.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/33.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/34.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/35.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/36.jpg" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/39.jpg" alt="image"></p>
<h2 id="大会现场"><a href="#大会现场" class="headerlink" title="大会现场"></a>大会现场</h2><p><img src="/uploads/produce-slides-of-third-at-swift-conference/42.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/43.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/44.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/45.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/46.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/47.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/48.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/40.JPG" alt="image"><br><img src="/uploads/produce-slides-of-third-at-swift-conference/41.JPG" alt="image"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三届在北京举办的@swift大会，我分享了用 swift 写解释器的思路，这个解释器 demo 我放在了 github 上，地址在 &lt;a href=&quot;https://github.com/ming1016/HTN/tree/master/Sources/Core/OC&quot; 
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="编译" scheme="http://ming1016.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
      <category term="swift" scheme="http://ming1016.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>18年上半年procreate的练习图图</title>
    <link href="http://ming1016.github.io/2018/09/14/draw-with-procreate-in-ipad-during-pre-half-in-20182/"/>
    <id>http://ming1016.github.io/2018/09/14/draw-with-procreate-in-ipad-during-pre-half-in-20182/</id>
    <published>2018-09-14T15:08:12.000Z</published>
    <updated>2018-09-18T09:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/1.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/2.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/3.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/4.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/5.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/6.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/7.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/8.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/9.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/10.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/11.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/12.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/13.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/14.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/15.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/16.jpg" alt=""><br><img src="/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/17.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-during-pre-half-in-2018/1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/draw-with-procreate-in-ipad-d
    
    </summary>
    
      <category term="My painting" scheme="http://ming1016.github.io/categories/My-painting/"/>
    
    
      <category term="Painting" scheme="http://ming1016.github.io/tags/Painting/"/>
    
      <category term="iPad" scheme="http://ming1016.github.io/tags/iPad/"/>
    
      <category term="Procreate" scheme="http://ming1016.github.io/tags/Procreate/"/>
    
  </entry>
  
  <entry>
    <title>深入剖析 JavaScriptCore</title>
    <link href="http://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/"/>
    <id>http://ming1016.github.io/2018/04/21/deeply-analyse-javascriptcore/</id>
    <published>2018-04-21T07:40:35.000Z</published>
    <updated>2018-04-21T07:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近开始涉及 JS 的解析和处理工作，所以专门研究了下这块。特别是动态类型的处理以及不同引擎对于平台无关的字节码的设计和处理会有很大的帮助。</p>
<h1 id="JavaScriptCore-介绍"><a href="#JavaScriptCore-介绍" class="headerlink" title="JavaScriptCore 介绍"></a>JavaScriptCore 介绍</h1><p>JavaScriptCore 是 JavaScript 引擎，通常会被叫做虚拟机，专门设计来解释和执行 JavaScript 代码。最开始的 JavaScriptCore  是从 KJS（KDE 的 JavaScript 引擎）以及 PCRE 正则表达式的基础上开发的，是基于抽象语法树的解释器。2008 年重写了，叫做 SquirrelFish，后来是 SquirrelFish Extreme，又叫 Nitro。目前 JavaScript 引擎还有 Google 的 V8 ，Mozilla 的 SpiderMonkey。</p>
<p>JavaScriptCore 还能够在 Objective-C 程序中来执行 JavaScript 的代码，也可以在 JavaScript 环境中插入自定义对象。</p>
<h1 id="JavaScriptCore-全貌"><a href="#JavaScriptCore-全貌" class="headerlink" title="JavaScriptCore 全貌"></a>JavaScriptCore 全貌</h1><p>下面是解析 JavaScript 源码解析编译的详细流程图：<br><img src="/uploads/deeply-analyse-javascriptcore/01.png" alt=""></p>
<h2 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h2><ul>
<li><p>Lexer：词法分析器，生成 tokens，大部分代码都在 parser/Lexer.cpp 里。</p>
</li>
<li><p>Parser：语法分析，基于 Lexer 的 tokens 生成语法树。手写了个 recusive descent parser 递归下降解析器，代码主要在 parser/Parser.cpp 里。</p>
</li>
<li><p>LLInt：Low Level Interpreter 执行 Parser 生成的 Byte code。代码在 llint/ 里，使用汇编，在  offlineasm/ 里，可以编译为 x86 和 ARMv7 的汇编和 C 代码。LLInt 希望达成除了词法和语法分析外零启动消耗，同时遵守用 JIT 在调用，堆栈和起存器的约定。</p>
</li>
<li><p>Baseline JIT：实时编译，性能不好用这个。在函数调用了 6 次，或者某段代码循环了大于100次会被触发。BaseLine JIT 的代码在 jit/ 里。BaseLine JIT 还对几乎所有堆的访问执行了复杂的多态内联高速缓存（Polymorphic inline caches）。多态内联缓存是 Smalltalk 社区优化动态分发的一个经典技术。</p>
</li>
<li><p>DFG JIT：低延迟优化 JIT，更差性能就用这个生成更优化的机器码来执行。在函数被调用了60次或者代码循环了1000次会触发。在 LLInt 和 Baseline JIT 中会收集一些包括最近参数，堆以及返回值中的数据等轻量级的性能信息，方便 DFG 进行类型判断。先获取类型信息可以减少大量的类型检查，推测失败 DFG 会取消优化，也叫 OSR exit。取消可以是同步的也可以是异步的。取消后会回到 Baseline JIT，退回一定次数会进行重新优化，收集更多统计信息，看情况再次调用 DFG。重新优化使用的是指数式回退策略应对一些怪异的代码。DFG 代码在 dfg/ 里。</p>
</li>
<li><p>FTL：高吞吐量优化 JIT，全称 Faster Than Light，DFG 高层优化配合 B3 底层优化。以前全称是 Fourth Tier LLVM 底层优化使用的是 LLVM。B3 对 LLVM 做了裁剪，对 JavaScriptCore 做了特性处理，B3 IR 的接口和 LLVM IR 很类似。B3 对 LLVM 的替换主要是考虑减少内存开销，LLVM 主要是针对编译器，编译器在这方面优化动力必然没有 JIT 需求高。B3 IR 将指针改成了更紧凑的整数来表示引用关系。不可变的常用的信息使用固定大小的结构来表示，其它的都放到另外的地方。紧凑的数据放到数组中，更多的数组更少的链表。这样形成的 IR 更省内存。<a href="http://www.filpizlo.com/" target="_blank" rel="external">Filip Pizlo</a> 主导的这个改动，DFG JIT 也是他弄的，为了能够更多的减少内存上的开销，他利用在 DFG 里已经做的 InsertionSet 将 LLVM IR 里的 def-use 干掉了，大概思路是把单向链表里批量插入新 IR 节点先放到 InsertionSet 里，在下次遍历 IR 时再批量插入。Filip Pizlo 还把 DFG 里的 UpsilonValue 替代 LLVM SSA 组成部分。B3 后面会把 LLVM 的寄存器分配算法 Greedy 一直到 B3 中。</p>
</li>
</ul>
<p>执行速度的对比：<br><img src="/uploads/deeply-analyse-javascriptcore/02.png" alt=""><br>相对速度，越高表示越好。</p>
<p>更多的说明可以参看 WebKit 官网 JavaScriptCore 的 Wiki 首页部分：<a href="https://trac.webkit.org/wiki/JavaScriptCore" target="_blank" rel="external">https://trac.webkit.org/wiki/JavaScriptCore</a></p>
<h2 id="主要的源码目录结构"><a href="#主要的源码目录结构" class="headerlink" title="主要的源码目录结构"></a>主要的源码目录结构</h2><ul>
<li>API：JavaScriptCore 对外的接口类</li>
<li>assembler：不同 CPU 的汇编生成，比如 ARM 和 X86</li>
<li>b3：ftl 里的 Backend</li>
<li>bytecode：字节码的内容，比如类型和计算过程</li>
<li>bytecompiler：编译字节码</li>
<li>Configurations：Xcode 的相关配置</li>
<li>Debugger：用于测试脚本的程序</li>
<li>dfg：DFG JIT 编译器</li>
<li>disassembler：反汇编</li>
<li>heap：运行时的堆和垃圾回收机制</li>
<li>ftl：第四层编译</li>
<li>interpreter：解释器，负责解析执行 ByteCode</li>
<li>jit：在运行时将 ByteCode 转成机器码，动态及时编译。</li>
<li>llint：Low Level Interpreter，编译四层里的第一层，负责解释执行低效字节码</li>
<li>parser：词法语法分析，构建语法树</li>
<li>profiler：信息收集，能收集函数调用频率和消耗时间。</li>
<li>runtime：运行时对于 js 的全套操作。</li>
<li>wasm：对 WebAssembly 的实现。</li>
<li>yarr：Yet Another Regex Runtime，运行时正则表达式的解析</li>
</ul>
<h1 id="JavaScriptCore-与-WebCore"><a href="#JavaScriptCore-与-WebCore" class="headerlink" title="JavaScriptCore 与 WebCore"></a>JavaScriptCore 与 WebCore</h1><p>ScriptController 会调用 JavaScriptCore 的 evaluate 和 checkSyntax 两个接口。DOM 节点的 JSBindings 通过回溯到 JSC::JSNonFinalObject 实现和 JavaScriptCore 的绑定。</p>
<p>VM 是 JavaScript 的 Runtime 环境。GlobalObject 是全剧对象，负责管理执行环境和 Object 的。ExecState 是执行脚本的对象，由 GlobalObject 管理的，负责记录脚本执行上下文。</p>
<p>接口执行脚本，创建一个 ProgramExecutable 对象来表示要执行的脚本负责编译成 ByteCode，调用 Interpreter 执行这个 ByteCode。</p>
<p>Binding 是 WebCore 为 JavaScriptCore 提供的封装层。这一层的定义可以在这里找到：<a href="https://trac.webkit.org/wiki/WebKitIDL" target="_blank" rel="external">https://trac.webkit.org/wiki/WebKitIDL</a>。WebKit 参照的是 W3C Web IDL <a href="https://www.w3.org/TR/WebIDL-1/" target="_blank" rel="external">https://www.w3.org/TR/WebIDL-1/</a>。</p>
<p>使用 IDL 定义接口规范，WebKit 使用一组 perl 脚本来转换 IDL，初始脚本是 generate-binding.pl。生成接口与 DOM 组件关联是通过 JSNode 来的。执行脚本和 Frame 的 setDocument 会更新 document 对象到 JavaScriptCore，通过 JSDomWindowBase::updateDocument 更新到 JSC::Heap 里。</p>
<h1 id="词法语法分析"><a href="#词法语法分析" class="headerlink" title="词法语法分析"></a>词法语法分析</h1><p>词法和语法分析程序 JavaScriptCore 是自己编写的。词法分析会把文本理解成很多 token，比如 a = 5; 就会被识别成下面这些 token，VARIABLE EQUAL CONSTANT END。然后通过语法分析，输出语法树。<br><img src="/uploads/deeply-analyse-javascriptcore/03.png" alt=""></p>
<p>需要先设计好 Node，Node 的类关系图如下：<br><img src="/uploads/deeply-analyse-javascriptcore/04.png" alt=""><br>举个包含加和乘的 statement 是如何组成 AST 的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.x * o.x + o.y * o.y</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-javascriptcore/05.png" alt=""><br>heap 代表的是可见数据，pure 代表的是抽象说明。</p>
<p>下面看看 Object 的构造<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">o.f = <span class="number">1</span>;</div><div class="line">o.g = <span class="number">2</span>;</div><div class="line">o.h = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-javascriptcore/06.png" alt=""></p>
<p>接下来看看 function 的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">o</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o.f &amp;&amp; o.f() == <span class="number">42</span>)</div><div class="line">        print(<span class="string">"hello"</span>);</div><div class="line">    <span class="keyword">if</span> (o.g &amp;&amp; o.g() == <span class="number">63</span>)</div><div class="line">        print(<span class="string">"bye"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/uploads/deeply-analyse-javascriptcore/07.png" alt=""></p>
<p>还有些其它的 parser 比如 Esprima 提供了一个在线 <a href="http://esprima.org/demo/parse.html" target="_blank" rel="external">demo</a> 可以在线 Parser。实现的代码在这里：<a href="https://github.com/jquery/esprima/tree/master/src" target="_blank" rel="external">https://github.com/jquery/esprima/tree/master/src</a> 主要使用的是递归下降和运算符优先级混合式来做的 parser。</p>
<p>我在 HTN （<a href="https://github.com/ming1016/HTN" target="_blank" rel="external">https://github.com/ming1016/HTN</a>）项目中做了个 js 的 AST 的 builder：<a href="https://github.com/ming1016/HTN/tree/master/Sources/Core/JavaScript" target="_blank" rel="external">https://github.com/ming1016/HTN/tree/master/Sources/Core/JavaScript</a> 分词和语法树生成使用的是状态机处理递归下降。</p>
<p>WebKit 的性能目录里有用 ES6 标准实现的 ECMA-55 BASIC 这个词法语法分析的测试。代码在：<a href="https://trac.webkit.org/browser/trunk/PerformanceTests/ARES-6/Basic?rev=211697" target="_blank" rel="external">https://trac.webkit.org/browser/trunk/PerformanceTests/ARES-6/Basic?rev=211697</a></p>
<p>程序会被表示成树，每个节点都有与其相关的代码，这些代码都可以递归的调用树中的子节点。Basic 的节点的结构是这样子的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="attr">evaluate</span>: Basic.NumberPow, <span class="attr">left</span>: primary, <span class="attr">right</span>: parsePrimary()&#125;</div></pre></td></tr></table></figure></p>
<p>Basic 是以不那么常见的方式使用生成器的，比如多个生成器函数，很多 yield points 和递归生成器调用。Basic 也有 for-of，类，Map 和 WeakMap。所以上的测试 ES6 程序通过 js 写的程序帮助理解 ES6 的解析过程。</p>
<h1 id="代码到-JIT-的过程"><a href="#代码到-JIT-的过程" class="headerlink" title="代码到 JIT 的过程"></a>代码到 JIT 的过程</h1><p>ProgramExecutable 的初始化会生成 Lexer，Parser 和字节码。入口是从 JS Binding 那层里调用 ScriptController::evaluateInWorld 进来，这个方法里的参数 sourceCode 就是 js 的代码的来源，方法内通过调用 runtime/Completion.cpp 里的方法 evaluate 来进入 executeProgram 方法的。总的来说 ProgramExecutable 主要是把代码编成字节码，Interpreter 是来执行字节码的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSValue result = vm.interpreter-&gt;executeProgram(source, exec, thisObj);</div></pre></td></tr></table></figure></p>
<p>executeProgram 方法将源码生成 ProgramExecutable 这个对象。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ProgramExecutable* program = ProgramExecutable::create(callFrame, source);</div></pre></td></tr></table></figure></p>
<p>这个对象里有 StringView 对象，program-&gt;source().view() 这样就可以对源码进行操作了。在那之前会先判断下是否这段 js 代码仅仅只是一个 JSON 对象，如果是就地按照 JSON 对象处理，不然就按照普通的 js 代码来处理。</p>
<p>普通处理会先编译成字节码，过程是先初始化全局属性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">JSObject* error = program-&gt;initializeGlobalProperties(vm, callFrame, scope);</div></pre></td></tr></table></figure></p>
<p>处理的结果都会记录在 callFrame 里。主要是通过 JSGlobalObject 这个对象的 addFunction 和 addVar 方法记录 Parser 出那些在全局空间的那些 let，const 和 class 的全局属性，或者 var，let 和 const 的全局变量。</p>
<p>接下来会创建一个 codeBlock：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ProgramCodeBlock* codeBlock;</div><div class="line">    &#123;</div><div class="line">        CodeBlock* tempCodeBlock;</div><div class="line">        JSObject* error = program-&gt;prepareForExecution&lt;ProgramExecutable&gt;(vm, <span class="literal">nullptr</span>, scope, CodeForCall, tempCodeBlock);</div><div class="line">        EXCEPTION_ASSERT(throwScope.exception() == <span class="keyword">reinterpret_cast</span>&lt;Exception*&gt;(error));</div><div class="line">        <span class="keyword">if</span> (UNLIKELY(error))</div><div class="line">            <span class="keyword">return</span> checkedReturn(error);</div><div class="line">        codeBlock = jsCast&lt;ProgramCodeBlock*&gt;(tempCodeBlock);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里 ProgramExecutable 会通过 prepareForExecution 方法里调用 prepareForExecutionImpl 来创建一个新的 CodeBlock。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">CodeBlock* codeBlock = newCodeBlockFor(kind, function, scope, exception);</div><div class="line">resultCodeBlock = codeBlock;</div><div class="line">EXCEPTION_ASSERT(!!throwScope.exception() == !codeBlock);</div><div class="line"><span class="keyword">if</span> (UNLIKELY(!codeBlock))</div><div class="line">    <span class="keyword">return</span> exception;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Options::validateBytecode())</div><div class="line">    codeBlock-&gt;validate();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (Options::useLLInt())</div><div class="line">    setupLLInt(vm, codeBlock);</div><div class="line"><span class="keyword">else</span></div><div class="line">    setupJIT(vm, codeBlock);</div><div class="line"></div><div class="line">installCode(vm, codeBlock, codeBlock-&gt;codeType(), codeBlock-&gt;specializationKind());</div></pre></td></tr></table></figure></p>
<p>这里看到，如果 Options 是指定 LLInt 的话就会调 setupLLInt 方法去设置这个 codeBlock，不然就通过 JIT 来。LLInt 在 LLIntSlowPaths.cpp 里通过  C 函数封装了 LowLevelInterpreter.asm 里的执行指令的汇编。触发 JIT 优化是通过热点探测方法，LLInt 会在字节码的 loop_hint 循环计数和 ret 函数返回指令的时候进行统计，结果保存在 ExcutionCounter 里。当函数或循环体执行一定次数时，通过 checkIfThresholdCrossedAndSet 方法得到布尔值结果来决定是否用 JIT 编译。</p>
<p>CodeBlock 有 GlobalCode，EvalCode，FunctionCode，ModuleCode 这些类型，用于 LLInt 和 JIT。编译后的 ByteCode 会存在 UnlinkedCodeBlock 里。</p>
<h1 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h1><p>总的来说 JavaScriptCore 是采用了类型推测和分层编译的思想，解析成字节码后 LLInt 的作用就是让 js 代码能够早点执行，由于解释的效率不高，所以达到一定条件可以并行的通过 Baseline JIT 编译成更高效的字节码来解释，如果到了更加容易使得 LLInt 解释效率差的情况就会并行使用 DFG JIT ，DFG 编译的结果也有代表 On stack replacement 的 osrExitSites 数组，这样的字节码的解释性能会更好，如果假设解释失败还可以再回到 Baseline，也不会有什么问题。启用 FTL 的条件就更高了，可能函数调用了好几万次也都不会开启。</p>
<p>分层编译的主要思想是先把源码解释成一种内部的表示也就是字节码，将其中使用率高的字节码转成汇编代码，汇编代码可以由 CPU 直接执行来最大程度的提高性能。</p>
<p>LLInt，Baseline JIT 和 DFG 三者会同时运行。可以在 jsc.cpp 里添加日志观察他们的工作状态<br><img src="/uploads/deeply-analyse-javascriptcore/08.png" alt=""></p>
<p>箭头指示的是堆栈替换 on-stack replacement，简称 OSR。这个技术可以将执行转移到任何 statement 的地方。OSR 可以不管执行引擎是什么都在去解析字节码状态，并且能够重构它去让其它引擎继续执行，OSR entry 是进入更高层优化，OSR exit 是降至低层。LLInt 到 Baseline JIT 时 OSR 只需要跳转到相应的机器代码地址就行，因为 Baseline JIT 每个指令边界上的所有变量的表示和 LLInt 是一样的。进入 DFG JIT 就会复杂些，DFG 通过将函数控制流图当作多个进入点，一个是函数函数启动入口一个是循环的入口。</p>
<p>如果每个函数都用像 DFG JIT 来优化那么消耗太大，这就类似每次运行就来个完整的源码编译成本地应用那样。如果每个语句都只执行一次，那么 JIT 编译就会比 LLInt 是时间要长，如果执行的次数越多，那么 LLInt 这种解释方式就会比编译方式要差，LLInt 的大部分时间都消耗在分派下个字节码指令的操作上了。</p>
<h2 id="DFG-JIT"><a href="#DFG-JIT" class="headerlink" title="DFG JIT"></a>DFG JIT</h2><p>全称 data flow graph JIT 数据流图 JIT。是一种推测优化的技术。会开始对一个类型做出一个能够对性能好的假设，先编译一个版本，如果后面发现假设不对就会跳转回原先代码，称为 Speculation failure。DFG 是并发编译器，DFG pipeline 的每个部分都是同时运行的，包括字节码解析和分析。</p>
<p><img src="/uploads/deeply-analyse-javascriptcore/09.png" alt=""><br>上图是 DFG JIT 的优化 pipeline。开始 DFG 会把字节码转成 DFG CPS 格式，这个格式会描述变量和临时数据之间的数据流关系。再用分析信息来推测类型，通过推测的类型减少类型的检查。接着进行传统的编译器方面的优化，最后编译器通过 DFG CPS 格式直接生成机器码。</p>
<p>DFG JIT 会将字节码解析成 SSA 形式，按执行路径收集类型信息。会使用 inlining 和 value profiling 等一些静态分析技术。类型推导把 value profile 里的常用的类型作为后面用的类型来预测，在 SpeculatedType.h 里定义里一些数据类型，符合 <a href="https://en.wikipedia.org/wiki/Data-flow_analysis" target="_blank" rel="external">Data-flow analysis</a> 规范，具体实现在 DFGPredictionPropagationPhase.cpp 里。Baseline JIT 次数超过一定数量就会生成一个新的类型，可能会触发 DFG 也可能会让 Baseline JIT 再执行几次。</p>
<p>DFG 的 register allocator 中汇编程序使用的是二地址，不用 op dest, src1, src2 这样三地址形式，只需要 op src1, src2 这样的二地址形式，结果存在第一个操作数里。</p>
<p>DFG JIT 将低效字节码转成更优化的高效形式。DFG 结合传统编译器的优化，比如寄存器的分配，控制流图的简化，公共子表达式消除，死代码消除和稀疏条件常量传播等。但是正儿八经的编译器是需要知道变量类型和堆里面的对象的结构的，这样才能更好的优化。DFG JIT 使用的是 LLInt 和 Baseline JIT 里分析出的变量类型来推断的。比如下面的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">plusThe</span>(<span class="params">x</span>) </span>&#123; </div><div class="line">    <span class="keyword">return</span> x + <span class="number">1</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 x 从代码上看是看不出类型的，它可能是字符串也可能是 integer 或者 double。LLInt 和 Baseline JIT 会从函数参数或者来自堆的读取来收集每个变量的值信息。DFG 不会一开始就编译 plusThe 这个函数，它会等到这个函数被执行了很多次，让 LLInt 和 Baseline JIT 尽可能的把类型信息收集全。根据这些信息来假设一个类型，一个确定的类型会节省空间和执行时间。如果假设的检查失败，就通过 OSR 把执行转移到 Baseline JIT 上。</p>
<h2 id="FTL-JIT"><a href="#FTL-JIT" class="headerlink" title="FTL JIT"></a>FTL JIT</h2><p>DFG JIT 可以优化 long-running 运行的代码性能，但是会影响 short-running 的程序，DFG 编译的时间和 DFG 生成代码的质量相比较来说还是过大。想让 DFG 生成更好的代码都会降低代码速度，还会增加 shorter-running 代码的延迟。DFG 不可能同时成为低延迟优化和 high-throughput 代码编译器。这时就需要再多一层来做较重的优化，同时让 DFG 保持自己的轻体重，使得 longer-running 和 shorter-running 代码能够保持平衡。<br><img src="/uploads/deeply-analyse-javascriptcore/10.png" alt=""><br>新的一层 FTL 实际上是 DFG Backend 的替换。会先在 DFG 的 JavaScript 函数表示转换为静态单一指派（SSA） 格式上做些 JavaScript 特性的优化。接着把 DFG IR 转换成 FTL 里用到的 B3 的 IR。最后生成机器码。</p>
<p>DFG 的机器代码生成器很快，但没有低级优化。对这块的优化采用先转成 SSA 形式，执行比如自动执行循环不变量代码来提高执行速率的循环不变量代码移动（loop-invariant code motion）的优化技术，这些优化完成后就可以 straight-forward linear 和 一对多（DFG SSA 的每个指令都可以产生）的转换为也基于 SSA 的没有 JavaScript 语言特性的 B3 的 IR。总的来说过程就是把源码生成字节码，接着变成 DFG CPS IR，再就是 DFG SSA IR，最后成 B3 的 IR，JavaScript 的动态性就是在这些过程中一步步被消除掉的。</p>
<p><img src="/uploads/deeply-analyse-javascriptcore/11.png" alt=""><br>代码在 LLInt，Baseline JIT 和 DFG JIT 运行一段时间才会调用 FTL。FTL 在并发线程中会从它们那收集分析信息。short-running 代码是不会导致 FTL 编译的，一般超过10毫秒的函数会触发 FTL 编译。</p>
<p>FTL 通过并发编译减小对启动速度的影响。</p>
<h2 id="FTL-Backend-B3"><a href="#FTL-Backend-B3" class="headerlink" title="FTL Backend B3"></a>FTL Backend B3</h2><p>B3 的全称 Bare Bones Backend，实现了大吞吐量同时缩短总体 FTL 编译时间。B3 的 IR 是一个低级别的中间表示，低级别意味着需要大量内存去表示每个函数，大量的内存意味着编译器在分析函数时需要扫描大量内存。B3 有两个 IR，一个叫 B3 IR 另一个机器级别的叫 Assembly IR，简称 Air。这两个 IR 的目标是代表低级操作，同时能最大限度的减少分析代码所需要的内存访问。达到这个目标需要减少 IR 对象整体大小，减少表示典型操作的 IR 对象数量，减少 IR 的 pointer chasing，最后时减少 IR 的总数。</p>
<p>B3 转换成 Air 会通过执行反向贪婪模式匹配来巧妙地针对每个 B3 操作选择正确的 Air 序列。具体的实现可以参看 B3LowerToAir.cpp 的代码。</p>
<p>下面来看看 B3 IR 的所做的优化。</p>
<ul>
<li>Strength reduction：主要包括控制流程图的简化，常量合并，消除死代码，剪除整数溢出的检查，还有其它简化规则。实现文件是 B3ReduceStrength.cpp。</li>
<li>Flow-sensitive 常量合并：在 B3FoldPathConstants.cpp 文件里。</li>
<li>全局共用子表达式消除：实现文件 B3EliminateCommonSubexpressions.cpp。</li>
<li>Tail duplication：B3DuplicateTails.cpp</li>
<li>SSA 修正：B3FixSSA.cpp</li>
<li>优化常量实际的位置：B3MoveConstants.cpp</li>
</ul>
<p>Air 里做的优化包括去除死代码，控制流图的简化以及修正部分寄存器 stalls 和溢出代码症状。Air 最重要的优化是寄存器分配。</p>
<p>B3 的动态语言支持靠的是 Patchpoints，还有一半功劳是操作码的 Check family，用来实现栈上替换，即 OSR。JavaScript 是种动态语言，没有可以快速执行的类型和操作，FTL JIT 就使用推测行为方式把这些操作转换成快速代码。</p>
<p>Air 在寄存器分配器的选择上使用了经典的图形着色寄存器分配器，叫迭代寄存器合并，简称 IRC。</p>
<h1 id="类型分析"><a href="#类型分析" class="headerlink" title="类型分析"></a>类型分析</h1><p>Web Inspector 工具是 WebKit 里提供的调试工具，通过这个工具可以很好的观察哪些函数甚至哪些条件执行了或者没有执行。最重要的是可以直观的观察变量类型，还能够跟踪值的继承链。<br><img src="/uploads/deeply-analyse-javascriptcore/12.png" alt=""><br>JavaScript 是动态类型语言，任何变量都可以是任何类型，表达式可以有任何类型，函数可以返回任何类型等等。由于不能立刻得到类型就没法确定地址字节大小，需要在运行时去反复推断。静态语言就不一样，一开始明确了类型，比如目标平台 int 类型占用4个字节，它对应的对象是个地址，偏移量是0，访问 int 时需要将对象地址加上4个字节。所以语言解释系统只要用数组和位移来存变量和方法地址就行了，这样几个机器语言的指令就可以对其执行各种操作。</p>
<p>下面来个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</div><div class="line">print(x);</div><div class="line">x = [<span class="string">"These"</span>, <span class="string">"is"</span>, <span class="string">"array with string"</span>];</div><div class="line">print(x);</div><div class="line"></div><div class="line"><span class="keyword">const</span> justReturn = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123; <span class="keyword">return</span> x; &#125;;</div><div class="line">justReturn(<span class="number">10</span>);</div><div class="line">justReturn([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">justReturn(<span class="string">"I am bad!"</span>);</div></pre></td></tr></table></figure></p>
<p>JavaScript 没有类型限制，语法不错就没问题，如果是静态类型语言的话就没法像上面的例子一样把数组赋给数字类型的变量。在 Type Profiler 中会显示类型名为 String? 和 Integer? 这样后面跟着问号符号的表示，这是在有多个不同类型被分配给相同变量，函数参数传递和函数返回时发生的。查看时可以看到所有这些被收集的类型的信息。</p>
<p>那么 JavaScriptCore 是如何分析变量类型的呢？先看段 js 代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的字节码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add: 10 m_instructions; 3 parameter(s); 1 variable(s)</div><div class="line">[ 0] enter             </div><div class="line">[ 1] get_scope       loc0</div><div class="line">[ 3] add             loc1, arg1, arg2</div><div class="line">[ 8] ret             loc1</div></pre></td></tr></table></figure></p>
<p>下面看看开启了 Type Profiler 后的字节码是什么样的：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function add: 40 m_instructions; 3 parameter(s); 1 variable(s)</div><div class="line">[ 0] enter             </div><div class="line">[ 1] get_scope         loc0</div><div class="line"></div><div class="line">// 分析函数参数</div><div class="line">[ 3] op_profile_type   arg1 </div><div class="line">[ 9] op_profile_type   arg2</div><div class="line"></div><div class="line">// 分析 add 表达式的操作数</div><div class="line">[15] op_profile_type   arg1</div><div class="line">[21] op_profile_type   arg2</div><div class="line">[27] add               loc1, arg1, arg2</div><div class="line"></div><div class="line">// 分析返回语句，收集这个函数的返回类型信息</div><div class="line">[32] op_profile_type   loc1</div><div class="line">[38] ret               loc1</div></pre></td></tr></table></figure></p>
<p>下面是进入 DFG 时转换成 DFG IR 的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>:  SetArgument(<span class="keyword">this</span>)</div><div class="line"><span class="number">1</span>:  SetArgument(arg1)</div><div class="line"><span class="number">2</span>:  SetArgument(arg2)</div><div class="line"><span class="number">3</span>:  JSConstant(JS|PureInt, Undefined)</div><div class="line"><span class="number">4</span>:  MovHint(@<span class="number">3</span>, loc0)</div><div class="line"><span class="number">5</span>:  SetLocal(@<span class="number">3</span>, loc0)</div><div class="line"><span class="number">6</span>:  JSConstant(JS|PureInt, <span class="attr">Weak</span>:Cell: <span class="number">0x10f458ca0</span> <span class="built_in">Function</span>)</div><div class="line"><span class="number">7</span>:  JSConstant(JS|PureInt, <span class="attr">Weak</span>:Cell: <span class="number">0x10f443800</span> GlobalScopeObject)</div><div class="line"><span class="number">8</span>:  MovHint(@<span class="number">7</span>, loc0)</div><div class="line"><span class="number">9</span>:  SetLocal(@<span class="number">7</span>, loc0)</div><div class="line"><span class="number">10</span>: GetLocal(JS|MustGen|PureInt, arg1)</div><div class="line"><span class="number">11</span>: ProfileType(@<span class="number">10</span>)</div><div class="line"><span class="number">12</span>: GetLocal(JS|MustGen|PureInt, arg2)</div><div class="line"><span class="number">13</span>: ProfileType(@<span class="number">12</span>)</div><div class="line"><span class="number">14</span>: ProfileType(@<span class="number">10</span>)</div><div class="line"><span class="number">15</span>: ProfileType(@<span class="number">12</span>)</div><div class="line"><span class="number">16</span>: ValueAdd(@<span class="number">10</span>, @<span class="number">12</span>, JS|MustGen|PureInt)</div><div class="line"><span class="number">17</span>: MovHint(@<span class="number">16</span>, loc1)</div><div class="line"><span class="number">18</span>: SetLocal(@<span class="number">16</span>, loc1)</div><div class="line"><span class="number">19</span>: ProfileType(@<span class="number">16</span>)</div><div class="line"><span class="number">20</span>: Return(@<span class="number">16</span>)</div></pre></td></tr></table></figure></p>
<p>现在还有很多 ProfileType，这些操作会有很大的消耗，DFG 会推测参数类型是整数，接下来会在这个假设下将 ProfileType 的那些操作移除掉。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>:  SetArgument(arg1)</div><div class="line"><span class="number">2</span>:  SetArgument(arg2)</div><div class="line"><span class="number">3</span>:  JSConstant(JS|PureInt, Undefined)</div><div class="line"><span class="number">4</span>:  MovHint(@<span class="number">3</span>, loc0)</div><div class="line"><span class="number">7</span>:  JSConstant(JS|PureInt, <span class="attr">Weak</span>:Cell: <span class="number">0x10f443800</span> GlobalScopeObject)</div><div class="line"><span class="number">8</span>:  MovHint(@<span class="number">7</span>, loc0)</div><div class="line"><span class="number">10</span>: GetLocal(@<span class="number">1</span>, arg1)</div><div class="line"><span class="number">12</span>: GetLocal(@<span class="number">2</span>, arg2)</div><div class="line"><span class="number">16</span>: ArithAdd(Int32:@<span class="number">10</span>, <span class="attr">Int32</span>:@<span class="number">12</span>)</div><div class="line"><span class="number">17</span>: MovHint(@<span class="number">16</span>, loc1)</div><div class="line"><span class="number">20</span>: Return(@<span class="number">16</span>)</div></pre></td></tr></table></figure></p>
<p>在对类型的处理上 V8 使用了一个结合 C++ 使用类和偏移位置思想的隐藏类来解决通过字符串匹配找属性的算法。做法是将有相同属性名和属性值的对象保存在同一个组的隐藏类里，这些属性在隐藏类里有着同样的偏移值，这样这个组里的对象能够共用这个隐藏类的信息。访问属性的过程是得到隐藏类的地址，根据属性名得到偏移值，通过偏移值和隐藏类地址得到属性地址。那么这个过程是否可以加速呢？答案是肯定的，通过 Inline Cache 缓存之前查找结果来减少方法和属性的哈希表查找时间。当一个对象或属性类型出现多种时缓存就会不断更新，V8 就会退到先前按照哈希表查找的方式来。</p>
<h1 id="指令集架构"><a href="#指令集架构" class="headerlink" title="指令集架构"></a>指令集架构</h1><p>JavaScriptCore 是基于寄存器的虚拟机 register-based VM。这种实现方式不用频繁入栈，出栈和三地址的指令集，所以效率高，但移植性弱点。</p>
<h2 id="基于寄存器指令集架构"><a href="#基于寄存器指令集架构" class="headerlink" title="基于寄存器指令集架构"></a>基于寄存器指令集架构</h2><p>三地址和二地址的指令集，基本都是使用基于寄存器的架构来实现的，要求除了 load 和 store 外的运算指令的源都要是寄存器。</p>
<p>下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = a + b;</div></pre></td></tr></table></figure></p>
<p>上面这句转换成机器指令样子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add i, a, b</div></pre></td></tr></table></figure></p>
<p>这样的形式就是三地址指令，很多的代码都是这样的二元运算然后再赋值，三地址正好可以分配两地址给二元运算的两个源，剩下一个地址给赋值目标。ARM 处理器的主要指令集就是三地址的。那么二地址是怎么处理的呢？将上面的代码换成下面的样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i += a;</div><div class="line">i += b;</div></pre></td></tr></table></figure></p>
<p>机器指令形式就变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add i, a</div><div class="line">add i, b</div></pre></td></tr></table></figure></p>
<p>这样一个源同时也作为赋值目标，X86 系列的处理器就是采用的二地址。</p>
<p>有了二地址和三地址，那么有一地址么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add a</div><div class="line">add b</div></pre></td></tr></table></figure></p>
<p>这就是一地址，只有操作源，那么目标呢？目标 i 是隐藏目标，这种运算的目标称为累加器的专用寄存器，运算都是依赖更新累加器的状态来完成。</p>
<h2 id="基于栈指令集架构"><a href="#基于栈指令集架构" class="headerlink" title="基于栈指令集架构"></a>基于栈指令集架构</h2><p>那么零地址呢？JVM 就是采用的这种。那么就先看下一段 JAVA 代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">QuickCalculate</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">onePlusOne</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">byte</span> x = <span class="number">1</span>;  </div><div class="line">        <span class="keyword">byte</span> y = <span class="number">1</span>;  </div><div class="line">        <span class="keyword">byte</span> z = (<span class="keyword">byte</span>) (x + y);  </div><div class="line">        <span class="keyword">return</span> z;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>转换成字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">iconst_1   // Push 整数常量1</div><div class="line">istore_1    // Pop 到局部变量1，相当于 byte x = 1; 这句</div><div class="line">iconst_1   // 再 Push 整数常量1 </div><div class="line">istore_2    // Pop 到局部变量2，相当于 byte y = 1; 这句</div><div class="line">iload_1     // Push x，这时 x 已经作为整数存在局部变量1里。</div><div class="line">iload_2     // Push y，这时 y 已经作为整数存在局部变量1里。</div><div class="line">iadd         // 执行加操作，栈顶就变成了 x + y，结果为一个整数</div><div class="line">int2byte   // 将整数转化成字节，结果还是占32位</div><div class="line">istore_3   // Pop 到局部变量3里，byte z = (byte)(x + y)</div><div class="line">iload_3    // Push z 的值使之可以被返回</div><div class="line">ireturn     // 返回结果，return z</div></pre></td></tr></table></figure></p>
<p>整个过程我放到了注释里。可以看到零地址形式的指令集就是基于栈架构的。这种架构的优势是可以用更少的空间存更多的指令，所以空间不是很富足时这种架构是可取的，不过零地址要完成一件事会比基于寄存器指令架构的二地址，三地址指令要多很多指令，执行效率还会低。</p>
<h2 id="指令集架构演化和比较"><a href="#指令集架构演化和比较" class="headerlink" title="指令集架构演化和比较"></a>指令集架构演化和比较</h2><p>JavaScriptCore 采用 SquirrleFish 之前的解释器他们都是树遍历式的，解释器会递归遍历树，在遍历树上的每个节点的操作都是根据解释其每个字节点返回的值来的。这种操作即不是基于栈也不是基于寄存器。举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = x + y * z</div></pre></td></tr></table></figure></p>
<p>按 AST 的后序遍历，最上面的 = 符号依赖子节点 + 符号节点返回的值，+ 符号依赖 x 节点和 <em> 符号节点的值，依此递归下去，这样最开始获取到值的就是最低一级的运算，在这个例子里就是 y 和 z 的运算的结果返回给 </em> 符号节点。这种就是典型的后序遍历。CRuby 1.9 之前也是用的这种方式解释执行的。</p>
<p>赋值符号 = 符号的左侧叫做左值，右侧的值叫做右值。左值也可能是复杂的表达式，比如数组或者结构体。根据求值顺序，对于二元运算的节点，是先遍历左子节点的。所以当左值是复杂表达式需要计算时是会优先进行计算的。再看个左值是数组的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftFirstTest</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];  </div><div class="line">        <span class="keyword">int</span> x = <span class="number">3</span>;  </div><div class="line">        <span class="keyword">int</span> y = <span class="number">5</span>;  </div><div class="line">        arr[<span class="number">0</span>] = x + y;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>arr[0] = x + y; 对应的字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 左值，数组下标</div><div class="line">aload_1  </div><div class="line">iconst_0  </div><div class="line">  </div><div class="line">// 右值</div><div class="line">iload_2 // x</div><div class="line">iload_3 // y</div><div class="line">iadd</div><div class="line"> </div><div class="line">iastore  // 赋值符号节点进行赋值</div></pre></td></tr></table></figure></p>
<p>可以看到左值是先计算的。</p>
<p>从树遍历到基于栈的解释，实际上是一个将 AST 树打平的过程。方法是后序遍历 AST 时使用 <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank" rel="external">Reverse Polish Notation</a> 这种后缀记法生成一个序列，成为一个线性结构，后面再解释执行这个操作序列。</p>
<p>JVM 是 Java 语言的虚机。Android 也是用的 Java 语言，那么它的虚机也是 JVM 吗？答案是否定的，Android 使用的虚机叫 <a href="https://en.wikipedia.org/wiki/Dalvik_(software" target="_blank" rel="external">Dalvik VM</a>)，这款虚机在很多设计上都与 JVM 兼容，字节码是二地址和三地址并用的方式，是基于寄存器的架构。Dalvik VM 用在移动端为了能够更加高效，开始就没有顾及太多可移植性，这样基于寄存器架构的优势就能够更好的发挥出来了。想更多了解 Dalvik VM 可以通过 <a href="http://www.milk.com/home/danfuzz/" target="_blank" rel="external">Dan Bornstein</a> 做的一个 Dalvik 的实现原理的演讲 <a href="https://sites.google.com/site/io/dalvik-vm-internals" target="_blank" rel="external">Dalvik VM Internals</a>。</p>
<p>JVM 和 Dalvik VM 的主要区别是后者字节码指令数量和内存更少。JVM 每个线程有一个 Java 栈用来记录方法调用的 activation record，每调用一个方法就会分配一个新栈帧，方法返回就 Pop 出栈帧。每个栈帧会有局部变量区，istore 这样的指令用来移动局部变量和参数到局部变量区。每个栈帧还会有求值栈，这个栈用来存储求值的中间结果和调用其他方法的参数等，使用 iconst 这样的指令来进行数据的移动，还可以通过 iadd，imul 这样的指令在求值栈中 Pop 出值进行求值，然后再把结果 Push 到栈里。</p>
<p>Dalvik VM 的每个线程有程序计数器和调用栈，方法的调用和 JVM 一样是会分配一个新的帧，不同的是 Dalvik VM 使用的是虚拟寄存器来替代 JVM 里的局部变量区和求值栈。方法调用会有一组自己的虚拟寄存器，常用的是 v0 - v15，有些指令可以使用 v0 - v255。只在虚拟寄存器中进行指令操作，数据移动少多了，保存局部变量的存储单元也会少很多。Dalvik VM 的寄存器每次方法调用会一组自己的，不过在 X86 架构中寄存器是全局的，这样 X86 需要考虑 calling converntion，就是需要保护一些寄存器的状态，在调用时需要处理这些，而 Dalvik VM 调用完方法后，那些寄存器值会恢复成调用前的可以很好的避免这样的问题。</p>
<p>V8 没有中间的字节码，而是直接编译 JavaScript 生成机器码。不过在内部也用了表达式栈来简化代码生成，在编译过程中使用虚拟栈帧来记录局部变量和栈的状态。生成代码的过程中会有窥孔优化用来去除多余的入栈和出栈，把栈操作转成寄存器操作，生成的代码看起来就和基于寄存器的代码类似了。</p>
<p>这就有个疑问了，零地址要做多次入栈和出栈操作，执行效率低，那么为什么还会有虚拟机比如 JVM 字节码还要用零地址形式呢？</p>
<p>像 X86 刚开始时的寄存器很多不是通用寄存器，由于让编译器去决定程序里那么多的变量该怎么装到寄存器里，那些应该应该映射到一个寄存器，哪些应该换出，这并不容易，JVM 采用零指令这种堆栈结构的原因就是不信任编译器的寄存器分配，所以使用堆栈结构，这样就可以避开寄存器分配这样的难题。不过后来 IBM 公开了他们的图染色寄存器分配算法，这样编译器的分配能力得到了很大的进步，所以现在都是编译器来主导寄存器分配。</p>
<p>很多主流高级语言虚拟机（high-level language virtual machine，简称 HLL VM）比如 JVM，CPython 都采用的基于栈的架构。这样做主要是因为不用考虑临时变量分配空间，只需要求值栈来做，这样的编译器更容易实现。还有就是可以更容易在硬件较差的机器上运行，前面也讲到基于栈这种架构指令对于存储空间的要求更少。最后就是考虑移植，复杂指令计算机（Complex Instruction Set Computer，简称 CISC）的通用寄存器比较少，32位只有8个32位通用寄存器。精简指令集计算机（Reduced Instruction Set Computer，简称 RISC）通用寄存器数量会多些，32位有16个寄存器。源架构寄存器数量通常和实际机器通用寄存器数量不一致而实现映射麻烦，基于栈架构里是没有通用寄存器的，实现虚机时可以就可以很容易自由的分配实际机器寄存器，移植起来自然也就容易多了。</p>
<p>处理器来说多是基于寄存器架构的，但是对于虚机来说，由于基于栈架构需要执行更多的 load 或 store 这样的指令，这样 Instruction dispatch 的次数和内存访问的次数会更多，所以基于寄存器的架构在虚机里同样也更优些，这也是为什么对于闭环的苹果来说会在 JavaScriptCore 的虚机里采用性能更好的基于寄存器的架构，而不去顾及移植性。</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="各大引擎的介绍"><a href="#各大引擎的介绍" class="headerlink" title="各大引擎的介绍"></a>各大引擎的介绍</h2><p>各个 JavaScript 引擎介绍：</p>
<ul>
<li><p>SpiderMonkey：用于 Mozilla Firefox，是最早的 JavaScript 引擎，基于栈的字节码。Parser 使用的手写纯递归下降式。</p>
</li>
<li><p>KJS：KDE 的引擎，用于 Konqueror 浏览器。树遍历解释器。Parser 使用的是 bison。</p>
</li>
<li><p>Rhino：使用 Java编写，开发源码，也是 Mozilla 的，相当于 Java 版的 SpiderMonkey，当时的想法是想把 JavaScript 做成服务端的脚本语言来用。Parser 是手写的纯递归下降式 <a href="https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/Parser.java" target="_blank" rel="external">rhino/src/org/mozilla/javascript/Parser.java</a> 。</p>
</li>
<li><p>Chakra：也叫 JScript 微软的 Internet Explorer 和 Microsoft Edge 在使用。</p>
</li>
<li><p>JavaScriptCore：苹果开发的开源 JavaScript 引擎，用在 Safari 等浏览器中。Safari 是带有 JIT 的 JavaScriptCore 的，而 UIWebView 是没有的。</p>
</li>
<li><p>V8：Google 开发的开源引擎，用于 Chrome。Parser 使用的是手写纯递归下降加运算符优先级混合式。V8 使用了 <a href="http://ariya.ofilabs.com/2012/07/lazy-parsing-in-javascript-engines.html" target="_blank" rel="external">2-pass</a>，会先收集一些上下文信息增加预测的准确性。V8 开始时是不用字节码会直接编译成机器码，Dart VM 也是这样设计的，他们一个问题的回答 <a href="https://www.dartlang.org/faq#q-why-didnt-google-build-a-bytecode-vm-targetable-by-multiple-languages-including-dart" target="_blank" rel="external">Why didn’t Google build a bytecode VM targetable by multiple languages including Dart?</a> 同样适用于 V8。不过 V8 5.9 启用了 <a href="https://v8project.blogspot.co.id/2017/04/v8-release-59.html" target="_blank" rel="external">Ignition</a> 字节码解释器，自此几大 JS 引擎都用了字节码。启用字节码的考虑主要是希望能够减少机器码对内存空间的占用。由于机器码占用的空间也很大，所以不好都缓存下来，不然内存和磁盘都吃不消，序列化和反序列化时间都太长，这样每次编译的机器码都不是完整的只会缓存最外的一层，如果代码最外层包了一层，启动代码每次都是不同的调用就会每次都编译，会导致缓存没有作用。由于字节码通过比较好的设计后能够做到比机器码紧凑，这样引入 Ignition 后内存明显的下降了。TurboFan 再对 Ignition 字节码来进行解释。</p>
</li>
</ul>
<h2 id="各个引擎之间通用技术"><a href="#各个引擎之间通用技术" class="headerlink" title="各个引擎之间通用技术"></a>各个引擎之间通用技术</h2><p>根据下面关键子去查找，可以了解更多的相关的虚机技术。</p>
<h3 id="源码到中间代码"><a href="#源码到中间代码" class="headerlink" title="源码到中间代码"></a>源码到中间代码</h3><ul>
<li>Recusive-descent parser：递归下降式 parser</li>
<li>Operator precedence parser：运算符优先级 parser</li>
<li>Deferred parser：延迟 parser</li>
</ul>
<h3 id="中间代码到目标代码"><a href="#中间代码到目标代码" class="headerlink" title="中间代码到目标代码"></a>中间代码到目标代码</h3><ul>
<li>Tiered compilation：多层编译</li>
<li>Background compilation：后台编译</li>
<li>Type feedback：类型反馈</li>
<li>Type specialization：类型特化</li>
<li>SSA-form IR：静态单赋值形式</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近开始涉及 JS 的解析和处理工作，所以专门研究了下这块。特别是动态类型的处理以及不同引擎对于平台无关的字节码的设计和处理会有很大的帮助。
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="JavaScript" scheme="http://ming1016.github.io/tags/JavaScript/"/>
    
      <category term="Web" scheme="http://ming1016.github.io/tags/Web/"/>
    
      <category term="编译" scheme="http://ming1016.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>读 SnapKit 和 Masonry 自动布局框架源码</title>
    <link href="http://ming1016.github.io/2018/04/07/read-snapkit-and-masonry-source-code/"/>
    <id>http://ming1016.github.io/2018/04/07/read-snapkit-and-masonry-source-code/</id>
    <published>2018-04-07T14:14:18.000Z</published>
    <updated>2018-04-07T14:17:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直觉得 SnapKit 和 Masonry 这两个框架设计和封装的很好，用起来的体验也是一致的，翻了下它们的源码，对其设计方式和涉及的技术做了下记录。文章打算围绕，给谁做约束？如何设置约束？设置完后如何处理？这三个问题看看 SnapKit 和 Masnory 分别是怎么做的，正好也能够窥探下作者是如何利用 Swift 和 Objective-C 两个不同语言的不同特性做到一致的使用体验的。</p>
<p>如果还不了解这两个框架的使用的话可以参看它们项目 GitHub 说明：<a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="external">GitHub - SnapKit/SnapKit: A Swift Autolayout DSL for iOS &amp; OS X</a>，<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="external">GitHub - SnapKit/Masonry: Harness the power of AutoLayout NSLayoutConstraints with a simplified, chainable and expressive syntax. Supports iOS and OSX Auto Layout</a></p>
<p>如果还不了解自动布局或者还没有用过的同学可以参看我三年前这篇文章，里面有详细的介绍和相关资料：<a href="http://www.starming.com/2015/11/03/deeply-analyse-autolayout/" target="_blank" rel="external">深入剖析Auto Layout，分析iOS各版本新增特性 | 星光社 - 戴铭的博客</a></p>
<p>进入那三个问题之前我们先看看两个框架的整体结构图，对它们有个大概的印象。</p>
<h2 id="SnapKit-源码结构图"><a href="#SnapKit-源码结构图" class="headerlink" title="SnapKit 源码结构图"></a>SnapKit 源码结构图</h2><p><img src="/uploads/read-snapkit-and-masonry-source-code/01.jpg" alt=""></p>
<h2 id="Masonry-源码结构图"><a href="#Masonry-源码结构图" class="headerlink" title="Masonry 源码结构图"></a>Masonry 源码结构图</h2><p><img src="/uploads/read-snapkit-and-masonry-source-code/02.jpg" alt=""></p>
<p>接下来我们来详细看看两个框架的内部，首先来看看刚才那三个问题中的第一个问题。</p>
<h1 id="给谁做约束？"><a href="#给谁做约束？" class="headerlink" title="给谁做约束？"></a>给谁做约束？</h1><h2 id="SnapKit"><a href="#SnapKit" class="headerlink" title="SnapKit"></a>SnapKit</h2><h3 id="ConstraintView"><a href="#ConstraintView" class="headerlink" title="ConstraintView"></a>ConstraintView</h3><p>这个 View 实际上在 iOS 里就是 UIView，在 macOS 上就是 NSView。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#<span class="keyword">if</span> os(iOS) || os(tvOS)</div><div class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">UIView</span></div><div class="line">#<span class="keyword">else</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">NSView</span></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>对 ConstraintView 做扩展，里面定义里一个属性 snp<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">ConstraintView</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> snp: <span class="type">ConstraintViewDSL</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="type">ConstraintViewDSL</span>(view: <span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个 snp 属性的类型就是结构体 ConstraintViewDSL。下面来看看 ConstraintViewDSL 这个结构体做什么用的。</p>
<h3 id="ConstraintViewDSL"><a href="#ConstraintViewDSL" class="headerlink" title="ConstraintViewDSL"></a>ConstraintViewDSL</h3><p>这个结构体会在初始化时通过 view 属性持有 ConstraintView。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">let</span> view: <span class="type">ConstraintView</span></div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(view: <span class="type">ConstraintView</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.view = view</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时还提供了那些我们必调用的 makeConstraints，contentHuggingHorizontalPriority 等等函数。这样我们就可以在 UIView 中直接调用这些函数来进行视图的约束设置了。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(<span class="number">_</span> closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="type">ConstraintMaker</span>.makeConstraints(item: <span class="keyword">self</span>.view, closure: closure)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> contentHuggingHorizontalPriority: <span class="type">Float</span> &#123;</div><div class="line">    <span class="keyword">get</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.view.contentHuggingPriority(<span class="keyword">for</span>: .horizontal).rawValue</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">set</span> &#123;</div><div class="line">        <span class="keyword">self</span>.view.setContentHuggingPriority(<span class="type">LayoutPriority</span>(rawValue: newValue), <span class="keyword">for</span>: .horizontal)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//还有 remakeConstraints，contentCompressionResistanceHorizontalPriority 等等就不一一列出了</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>ConstraintViewDSL 是继承自 ConstraintAttributesDSL。</p>
<h3 id="ConstraintAttributesDSL"><a href="#ConstraintAttributesDSL" class="headerlink" title="ConstraintAttributesDSL"></a>ConstraintAttributesDSL</h3><p>ConstraintAttributesDSL 是个协议，继承于 ConstraintBasicAttributesDSL 这个协议，为什么要多这一层呢，因为 ConstraintAttributesDSL 这个里面定了 iOS 8 系统出现的新的属性，比如 lastBaseline，firstBaseline，leftMargin 等。而 ConstraintBasicAttributesDSL 里定义的是一开始就有的那些属性比如 left，top，centerX，size 等。</p>
<h2 id="Masonry"><a href="#Masonry" class="headerlink" title="Masonry"></a>Masonry</h2><p>接下来我们看看 Masonry 是给谁做的约束。</p>
<h3 id="View-MASAdditions"><a href="#View-MASAdditions" class="headerlink" title="View+MASAdditions"></a>View+MASAdditions</h3><p>View+MASAdditions 就是 Masonry 的一个外部的入口，实质上就是 UIView 的一个 Category 作用就是用来设置 MASViewAttribute 的属性，并实例化，并且指定当前的 UIView 对应的 LayoutAttribute。和 SnapKit 一样， Masonry 也对 iOS 和 macOS 做了兼容，在 macOS 里就是 NSView，相关代码在 MASUtilities.h 文件里，这里除了平台相关代码外，还有些宏的定义和静态方法。这里我们可以看看静态方法 static inline id _MASBoxValue(const char *type, …) 的作用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> _MASBoxValue(<span class="keyword">const</span> <span class="keyword">char</span> *type, ...) &#123;</div><div class="line">    va_list v;</div><div class="line">    va_start(v, type);</div><div class="line">    <span class="keyword">id</span> obj = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">id</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">id</span> actual = va_arg(v, <span class="keyword">id</span>);</div><div class="line">        obj = actual;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="built_in">CGPoint</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">CGPoint</span> actual = (<span class="built_in">CGPoint</span>)va_arg(v, <span class="built_in">CGPoint</span>);</div><div class="line">        obj = [<span class="built_in">NSValue</span> value:&amp;actual withObjCType:type];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="built_in">CGSize</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">CGSize</span> actual = (<span class="built_in">CGSize</span>)va_arg(v, <span class="built_in">CGSize</span>);</div><div class="line">        obj = [<span class="built_in">NSValue</span> value:&amp;actual withObjCType:type];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(MASEdgeInsets)) == <span class="number">0</span>) &#123;</div><div class="line">        MASEdgeInsets actual = (MASEdgeInsets)va_arg(v, MASEdgeInsets);</div><div class="line">        obj = [<span class="built_in">NSValue</span> value:&amp;actual withObjCType:type];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">double</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">double</span> actual = (<span class="keyword">double</span>)va_arg(v, <span class="keyword">double</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithDouble:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">float</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> actual = (<span class="keyword">float</span>)va_arg(v, <span class="keyword">double</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithFloat:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">int</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> actual = (<span class="keyword">int</span>)va_arg(v, <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithInt:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">long</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">long</span> actual = (<span class="keyword">long</span>)va_arg(v, <span class="keyword">long</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithLong:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">long</span> <span class="keyword">long</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">long</span> <span class="keyword">long</span> actual = (<span class="keyword">long</span> <span class="keyword">long</span>)va_arg(v, <span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithLongLong:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">short</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">short</span> actual = (<span class="keyword">short</span>)va_arg(v, <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithShort:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">char</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">char</span> actual = (<span class="keyword">char</span>)va_arg(v, <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithChar:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">bool</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">bool</span> actual = (<span class="keyword">bool</span>)va_arg(v, <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithBool:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> actual = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)va_arg(v, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithUnsignedChar:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> actual = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)va_arg(v, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithUnsignedInt:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> actual = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)va_arg(v, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithUnsignedLong:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> actual = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)va_arg(v, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithUnsignedLongLong:actual];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcmp(type, <span class="keyword">@encode</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span>)) == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">short</span> actual = (<span class="keyword">unsigned</span> <span class="keyword">short</span>)va_arg(v, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</div><div class="line">        obj = [<span class="built_in">NSNumber</span> numberWithUnsignedShort:actual];</div><div class="line">    &#125;</div><div class="line">    va_end(v);</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看这段代码是不是就能猜出来是做什么的了，对，它就是我们经常使用的 mas_equalTo 这个方法，这里可以看到它是如何支持变参和如何将 float，double，int 这样的值类型数据转换成和 equalTo 一样的对象 NSNumber 数据的。这个写法灵感来自<a href="https://github.com/specta/expecta" target="_blank" rel="external">GitHub - specta/expecta: A Matcher Framework for Objective-C/Cocoa</a>。 mas_equalTo 和 equalTo 都是宏定义的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define mas_equalTo(...)                 equalTo(MASBoxValue((__VA_ARGS__)))</span></div><div class="line"></div><div class="line"><span class="meta">#define equalTo(...)                     mas_equalTo(__VA_ARGS__)</span></div><div class="line"></div><div class="line"><span class="meta">#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))</span></div></pre></td></tr></table></figure></p>
<p>MASBoxValue 这个宏定义就是上面的 _MASBoxValue 这个方法。细心同学会发现这两个 equal 的宏对应的方法是不同的，一个是 equalTo(MASBoxValue((<strong>VA_ARGS</strong>))) 另一个是 mas_equalTo(<strong>VA_ARGS</strong>) 但是这两个方法的实现是一样的。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint * (^)(<span class="keyword">id</span>))equalTo &#123;</div><div class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (MASConstraint * (^)(<span class="keyword">id</span>))mas_equalTo &#123;</div><div class="line">    <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样写就是避免宏定义冲突的一种方式。</p>
<p>这个 Category 还有那些我们总是调用的 mas_makeConstraints，mas_updateConstraints，mas_remakeConstraint 等方法。</p>
<p>mas_makeConstraints 的 block 参数会将创建的 MASConstraintMaker 这个工厂类对象暴露出去，让我们去设置这个类对象中的 MASConstraint 属性，然后通过该对象的 install 方法将当前视图中所有添加的约束添加到一个数组里。该数组里存储是 MASViewConstraint 对象，对应的就是 NSLayoutConstraint。具体代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</div><div class="line">    <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</div><div class="line">    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</div><div class="line">    block(constraintMaker);</div><div class="line">    <span class="keyword">return</span> [constraintMaker install];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种设计模式和 SnapKit 的一样使用了闭包来获取用户设置的数据，在设计模式里叫做好莱坞原则。</p>
<p>mas_updateConstraints 和 mas_makeConstraints 差不多，不过里面多了一行：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constraintMaker.updateExisting = <span class="literal">YES</span>;</div></pre></td></tr></table></figure></p>
<p>这样当添加约束时会通过这个属性是否为真来检查约束是否 intall 了，是的话就更新，没有就添加。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</div><div class="line">    existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (existingConstraint) &#123;</div><div class="line">    <span class="comment">// just update the constant</span></div><div class="line">    existingConstraint.constant = layoutConstraint.constant;</div><div class="line">    <span class="keyword">self</span>.layoutConstraint = existingConstraint;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</div><div class="line">    <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</div><div class="line">    [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>mas_remakeConstraints 的话是添加了这一句：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constraintMaker.removeExisting = <span class="literal">YES</span>;</div></pre></td></tr></table></figure></p>
<p>设置为 YES 后会将以前设置的约束 uninstall 掉，后面再把新设置的约束添加上。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</div><div class="line">    <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</div><div class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</div><div class="line">        [constraint uninstall];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后还有个方法 mas_closestCommonSuperview，这个方法一般我们都不会主动调用，所以很多人应该都太熟悉，不过这个断言报错大家应该会有很深刻的印象 couldn’t find a common superview for … 。所以这个方法如其名就是去找共同的父视图，还是最近的。框架内部也就在 MASViewConstraint  的 install 方法里用了一次。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)mas_closestCommonSuperview:(MAS_VIEW *)view &#123;</div><div class="line">    MAS_VIEW *closestCommonSuperview = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    MAS_VIEW *secondViewSuperview = view;</div><div class="line">    <span class="keyword">while</span> (!closestCommonSuperview &amp;&amp; secondViewSuperview) &#123;</div><div class="line">        MAS_VIEW *firstViewSuperview = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">while</span> (!closestCommonSuperview &amp;&amp; firstViewSuperview) &#123;</div><div class="line">            <span class="keyword">if</span> (secondViewSuperview == firstViewSuperview) &#123;</div><div class="line">                closestCommonSuperview = secondViewSuperview;</div><div class="line">            &#125;</div><div class="line">            firstViewSuperview = firstViewSuperview.superview;</div><div class="line">        &#125;</div><div class="line">        secondViewSuperview = secondViewSuperview.superview;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> closestCommonSuperview;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个查找是 N 方的，谁有办法能够优化下么。</p>
<h1 id="如何设置约束？"><a href="#如何设置约束？" class="headerlink" title="如何设置约束？"></a>如何设置约束？</h1><h2 id="SnapKit-1"><a href="#SnapKit-1" class="headerlink" title="SnapKit"></a>SnapKit</h2><p>先看看这张图，里面是我们使用框架时用的最多的设置 make 的过程，图里将每个操作对应的不同 ConstraintMaker 做了说明。<br><img src="/uploads/read-snapkit-and-masonry-source-code/03.jpg" alt=""><br>下面来对这几种 ConstraintMaker 来详细说下。</p>
<h3 id="ConstraintMaker"><a href="#ConstraintMaker" class="headerlink" title="ConstraintMaker"></a>ConstraintMaker</h3><p>这个是设置的入口，makeConstraints 函数一个闭包参数可以提供外部去设置ConstraintMaker 自己的 left，right，top 等属性来描述约束。这些属性的 getter 方法会返回 ConstraintMakerExtendable 实例。</p>
<p>先看看 ConstraintMaker 的构造函数：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>) &#123;</div><div class="line">    <span class="keyword">self</span>.item = item</div><div class="line">    <span class="keyword">self</span>.item.prepare()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LayoutConstraintItem 会通过给扩展 ConstraintLayoutGuide 和 ConstraintView 来达到约束 item 类型的作用。下面看看 prepare 这个函数的作用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> view = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</div><div class="line">        view.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看，禁用 AutoresizeMask 是在这里统一处理了。<br>接下来看看闭包参数设置属性的 getter 方法。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.makeExtendableWithAttributes(.<span class="keyword">left</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">makeExtendableWithAttributes</span><span class="params">(<span class="number">_</span> attributes: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintMakerExtendable</span> &#123;</div><div class="line">    <span class="keyword">let</span> description = <span class="type">ConstraintDescription</span>(item: <span class="keyword">self</span>.item, attributes: attributes)</div><div class="line">    <span class="keyword">self</span>.descriptions.append(description)</div><div class="line">    <span class="keyword">return</span> <span class="type">ConstraintMakerExtendable</span>(description)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConstraintMaker 包含了一个 ConstraintDescription 数组，里面会记录用户设置的各个属性，然后返回 ConstraintMakerExtendable。</p>
<h4 id="OptionSet"><a href="#OptionSet" class="headerlink" title="OptionSet"></a>OptionSet</h4><p>这里的 ConstraintAttributes 是个 OptionSet，ConstraintAttributes 结构体来遵从 OptionSet 选项集合协议，为什么不用枚举呢？因为在一次只有一个选项被选中是枚举是 OK 的。但是在 Swift 里的枚举是没法将多个枚举选项组成一个值的，比如 ConstraintAttributes 里的 edges，size 和 center 等就是组合而成的。而 OptionSet 结构体使用了高效的位域来表示的。还有，OptionSet 继承于 ExpressibleByArrayLiteral，这样还能够使用数组字面量来生成选项的集合。下面看看这个 ConstraintAttributes 是如何定义的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">0</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">1</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">2</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">4</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">8</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">16</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">32</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">64</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> height: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">128</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerX: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">256</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> centerY: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">512</span>) &#125;</div><div class="line"><span class="comment">//更多就不一一列出来</span></div><div class="line">...</div><div class="line"><span class="comment">// 组合的</span></div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> edges: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">15</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> size: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">192</span>) &#125;</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> center: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">768</span>) &#125;</div><div class="line"></div><div class="line"><span class="meta">@available</span>(iOS <span class="number">8.0</span>, *)</div><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> margins: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.<span class="keyword">init</span>(<span class="number">61440</span>) &#125;</div><div class="line"><span class="comment">//还有一些，先不列了</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到组合的 size 就是 width（64） + height（128）= size（192）。</p>
<h4 id="重载和自定义操作符"><a href="#重载和自定义操作符" class="headerlink" title="重载和自定义操作符"></a>重载和自定义操作符</h4><p>ConstraintAttributes 重载了 +，+=，-= 和 == 这些操作符。我们先看看代码<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintAttributes</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.union(<span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</div><div class="line">    <span class="keyword">left</span>.formUnion(<span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> -=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</div><div class="line">    <span class="keyword">left</span>.subtract(<span class="keyword">right</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.rawValue == <span class="keyword">right</span>.rawValue</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种重载很适合对自定义的结构体进行一些熟悉的简化符号操作。</p>
<p>如果希望自定义一些操作符的话就需要先声明下，让编译器知道这是个操作符，比如我们自定义一个操作符☃<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> v:<span class="type">Int</span> = <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ☃</div><div class="line"><span class="function"><span class="keyword">func</span> ☃<span class="params">(<span class="keyword">left</span>: A, <span class="keyword">right</span>: A)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">left</span>.v + <span class="number">1</span> == <span class="keyword">right</span>.v</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 infix 是中间运算符的意思，还有前置运算符 prefix 和后置运算符 postfix。自定义运算符之能是类似，/，=，-，+，*，%，&lt;，&gt;，!，&amp;，|，^，。，~ 等这样的符号组成，也能支持一些特殊的字符比如刚才的用的☃，还有⨁，∉ 这样的特殊符号。</p>
<p>自定义运算符还能够指定优先级分组 precedencegroup，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ⊆ : <span class="type">CPrecedence</span></div><div class="line">precedencegroup <span class="type">CPrecedence</span> &#123;</div><div class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></div><div class="line">    higherThan: <span class="type">AdditionPrecedence</span></div><div class="line">    lowerThan: <span class="type">MultiplicationPrecedence</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面列下常用类型对应的group<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// "Exponentiative"</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  &lt;&lt; : <span class="type">BitwiseShiftPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &amp;&lt;&lt; : <span class="type">BitwiseShiftPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  &gt;&gt; : <span class="type">BitwiseShiftPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &amp;&gt;&gt; : <span class="type">BitwiseShiftPrecedence</span></div><div class="line"></div><div class="line"><span class="comment">// "Multiplicative"</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   * : <span class="type">MultiplicationPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  &amp;* : <span class="type">MultiplicationPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   / : <span class="type">MultiplicationPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   % : <span class="type">MultiplicationPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   &amp; : <span class="type">MultiplicationPrecedence</span></div><div class="line"></div><div class="line"><span class="comment">// "Additive"</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   + : <span class="type">AdditionPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  &amp;+ : <span class="type">AdditionPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   - : <span class="type">AdditionPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  &amp;- : <span class="type">AdditionPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   | : <span class="type">AdditionPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>   ^ : <span class="type">AdditionPrecedence</span></div><div class="line"></div><div class="line"><span class="comment">// <span class="doctag">FIXME:</span> is this the right precedence level for "..." ?</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span>  ... : <span class="type">RangeFormationPrecedence</span></div><div class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> ..&lt; : <span class="type">RangeFormationPrecedence</span></div></pre></td></tr></table></figure></p>
<p>完整的操作符的定义和 precedencegroup 之间的优先级关系在 Swift 源码的  swift/stdlib/public/core/Policy.swift 文件里，在线看地址是：<a href="https://github.com/apple/swift/blob/a7ff0da33488b9050cf83df95f46e5b9aa2348d5/stdlib/public/core/Policy.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/a7ff0da33488b9050cf83df95f46e5b9aa2348d5/stdlib/public/core/Policy.swift</a> 。那些操作符优先级高些或者低些在这个文件里是一目了然。</p>
<h3 id="ConstraintMakerExtendable"><a href="#ConstraintMakerExtendable" class="headerlink" title="ConstraintMakerExtendable"></a>ConstraintMakerExtendable</h3><p>ConstraintMakerExtendable 继承 ConstraintMakerRelatable，它可以实现链式的多属性，有left，right，top 等等这样的属性，用以产生一个 ConstraintMakerRelatable 类型的实例。<br>我们看看 left 属性的 getter 定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</div><div class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">left</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到通过重载的操作符 += 能够将 .left 加到 ConstraintAttributes 里。</p>
<h3 id="ConstraintMakerRelatable"><a href="#ConstraintMakerRelatable" class="headerlink" title="ConstraintMakerRelatable"></a>ConstraintMakerRelatable</h3><p>用于指定约束关系比如常用的 equalTo。equalTo 函数里面是调用的 relatedTo 函数，返回 ConstraintMakerEditable 类型的实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">@discardableResult</div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">equalTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, <span class="number">_</span> file: String = #file, <span class="number">_</span> line: UInt = #line)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.relatedTo(other, relation: .<span class="built_in">equal</span>, file: file, line: line)</div><div class="line">&#125;</div><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">relatedTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">    <span class="keyword">let</span> related: <span class="type">ConstraintItem</span></div><div class="line">    <span class="keyword">let</span> constant: <span class="type">ConstraintConstantTarget</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintItem</span> &#123;</div><div class="line">        <span class="keyword">guard</span> other.attributes == <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span> ||</div><div class="line">            other.attributes.layoutAttributes.<span class="built_in">count</span> &lt;= <span class="number">1</span> ||</div><div class="line">            other.attributes.layoutAttributes == <span class="keyword">self</span>.description.attributes.layoutAttributes ||</div><div class="line">            other.attributes == .edges &amp;&amp; <span class="keyword">self</span>.description.attributes == .margins ||</div><div class="line">            other.attributes == .margins &amp;&amp; <span class="keyword">self</span>.description.attributes == .edges <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">fatalError</span>(<span class="string">"Cannot constraint to multiple non identical attributes. (<span class="subst">\(file)</span>, <span class="subst">\(line)</span>)"</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        related = other</div><div class="line">        constant = <span class="number">0.0</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</div><div class="line">        related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</div><div class="line">        constant = <span class="number">0.0</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintConstantTarget</span> &#123;</div><div class="line">        related = <span class="type">ConstraintItem</span>(target: <span class="literal">nil</span>, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</div><div class="line">        constant = other</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *), <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintLayoutGuide</span> &#123;</div><div class="line">        related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</div><div class="line">        constant = <span class="number">0.0</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">fatalError</span>(<span class="string">"Invalid constraint. (<span class="subst">\(file)</span>, <span class="subst">\(line)</span>)"</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> editable = <span class="type">ConstraintMakerEditable</span>(<span class="keyword">self</span>.description)</div><div class="line">    editable.description.sourceLocation = (file, line)</div><div class="line">    editable.description.relation = relation</div><div class="line">    editable.description.related = related</div><div class="line">    editable.description.constant = constant</div><div class="line">    <span class="keyword">return</span> editable</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 ConstraintRelatableTarget 是约束，equalTo 这个方法里面能传的参数类型比较多，可以通过这个协议来扩展下只支持的类型，达到限制类型的功能。ConstraintPriorityTarget，ConstraintInsetTarget，ConstraintOffsetTarget 和 ConstraintInsetTarget 也都有类似的作用，不过这几个还有个作用就是将 Float，Double，Int 和 UInt 这几种类型都转成 CGFloat。我们拿 ConstraintInsetTarget 来看看实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintInsetTarget</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> constraintInsetTargetValue: <span class="type">ConstraintInsets</span> &#123;</div><div class="line">        <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">ConstraintInsets</span> &#123;</div><div class="line">            <span class="keyword">return</span> amount</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">Float</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: <span class="type">CGFloat</span>(amount), <span class="keyword">left</span>: <span class="type">CGFloat</span>(amount), bottom: <span class="type">CGFloat</span>(amount), <span class="keyword">right</span>: <span class="type">CGFloat</span>(amount))</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">Double</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: <span class="type">CGFloat</span>(amount), <span class="keyword">left</span>: <span class="type">CGFloat</span>(amount), bottom: <span class="type">CGFloat</span>(amount), <span class="keyword">right</span>: <span class="type">CGFloat</span>(amount))</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">CGFloat</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: amount, <span class="keyword">left</span>: amount, bottom: amount, <span class="keyword">right</span>: amount)</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">Int</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: <span class="type">CGFloat</span>(amount), <span class="keyword">left</span>: <span class="type">CGFloat</span>(amount), bottom: <span class="type">CGFloat</span>(amount), <span class="keyword">right</span>: <span class="type">CGFloat</span>(amount))</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> amount = <span class="keyword">self</span> <span class="keyword">as</span>? <span class="type">UInt</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: <span class="type">CGFloat</span>(amount), <span class="keyword">left</span>: <span class="type">CGFloat</span>(amount), bottom: <span class="type">CGFloat</span>(amount), <span class="keyword">right</span>: <span class="type">CGFloat</span>(amount))</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">ConstraintInsets</span>(top: <span class="number">0</span>, <span class="keyword">left</span>: <span class="number">0</span>, bottom: <span class="number">0</span>, <span class="keyword">right</span>: <span class="number">0</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConstraintMakerEditable"><a href="#ConstraintMakerEditable" class="headerlink" title="ConstraintMakerEditable"></a>ConstraintMakerEditable</h3><p>ConstraintMakerEditable 继承 ConstraintMakerPriortizable，主要是设置约束的 offset 和 inset 还有 multipliedBy 和 dividedBy 函数。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerEditable</span>: <span class="title">ConstraintMakerPriortizable</span> </span>&#123;</div><div class="line"></div><div class="line">    @discardableResult</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">multipliedBy</span><span class="params">(<span class="number">_</span> amount: ConstraintMultiplierTarget)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">        <span class="keyword">self</span>.description.multiplier = amount</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @discardableResult</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dividedBy</span><span class="params">(<span class="number">_</span> amount: ConstraintMultiplierTarget)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.multipliedBy(<span class="number">1.0</span> / amount.constraintMultiplierTargetValue)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @discardableResult</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">offset</span><span class="params">(<span class="number">_</span> amount: ConstraintOffsetTarget)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">        <span class="keyword">self</span>.description.constant = amount.constraintOffsetTargetValue</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @discardableResult</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">inset</span><span class="params">(<span class="number">_</span> amount: ConstraintInsetTarget)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</div><div class="line">        <span class="keyword">self</span>.description.constant = amount.constraintInsetTargetValue</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ConstraintMakerPriortizable"><a href="#ConstraintMakerPriortizable" class="headerlink" title="ConstraintMakerPriortizable"></a>ConstraintMakerPriortizable</h3><p>ConstraintMakerPriortizable 继承 ConstraintMakerFinalizable，用来设置优先级，返回 ConstraintMakerFinalizable 类型的实例。</p>
<h3 id="ConstraintMakerFinalizable"><a href="#ConstraintMakerFinalizable" class="headerlink" title="ConstraintMakerFinalizable"></a>ConstraintMakerFinalizable</h3><p>里面类型为 ConstraintDescription 的属性的类是一个完整的约束描述，有了这个描述就可以做后面的处理了。里面的内容是完整的，这个类是一个描述类, 用于描述一条具体的约束, 包含了包括 ConstraintAttributes 在内的各种与约束有关的元素，一个 ConstraintDescription 实例，就可以提供与一种约束有关的所有内容。可以看到前面设置的属性，关系，乘除系数，优先级等因有尽有，如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintDescription</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> item: <span class="type">LayoutConstraintItem</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> attributes: <span class="type">ConstraintAttributes</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> relation: <span class="type">ConstraintRelation</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sourceLocation: (<span class="type">String</span>, <span class="type">UInt</span>)? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> label: <span class="type">String</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> related: <span class="type">ConstraintItem</span>? = <span class="literal">nil</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> multiplier: <span class="type">ConstraintMultiplierTarget</span> = <span class="number">1.0</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> constant: <span class="type">ConstraintConstantTarget</span> = <span class="number">0.0</span></div><div class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> priority: <span class="type">ConstraintPriorityTarget</span> = <span class="number">1000.0</span></div><div class="line">    <span class="keyword">internal</span> <span class="built_in">lazy</span> <span class="keyword">var</span> constraint: <span class="type">Constraint</span>? = &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> relation = <span class="keyword">self</span>.relation,</div><div class="line">              <span class="keyword">let</span> related = <span class="keyword">self</span>.related,</div><div class="line">              <span class="keyword">let</span> sourceLocation = <span class="keyword">self</span>.sourceLocation <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> from = <span class="type">ConstraintItem</span>(target: <span class="keyword">self</span>.item, attributes: <span class="keyword">self</span>.attributes)</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="type">Constraint</span>(</div><div class="line">            from: from,</div><div class="line">            to: related,</div><div class="line">            relation: relation,</div><div class="line">            sourceLocation: sourceLocation,</div><div class="line">            label: <span class="keyword">self</span>.label,</div><div class="line">            multiplier: <span class="keyword">self</span>.multiplier,</div><div class="line">            constant: <span class="keyword">self</span>.constant,</div><div class="line">            priority: <span class="keyword">self</span>.priority</div><div class="line">        )</div><div class="line">    &#125;()</div><div class="line">    </div><div class="line">    <span class="comment">// MARK: Initialization</span></div><div class="line">    </div><div class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>, attributes: <span class="type">ConstraintAttributes</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.item = item</div><div class="line">        <span class="keyword">self</span>.attributes = attributes</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Masonry-1"><a href="#Masonry-1" class="headerlink" title="Masonry"></a>Masonry</h2><p>在 Masonry 也有对应的 ConstraintMaker。</p>
<h3 id="MASConstraintMaker"><a href="#MASConstraintMaker" class="headerlink" title="MASConstraintMaker"></a>MASConstraintMaker</h3><p>MASConstraintMaker 是创建 MASConstraint 对象的。里面有个 constraints 数组专门用来存储创建的这些对象。前面 mas_makeConstraints 的那个 Block 暴露出的就是 MASConstraintMaker 对象。</p>
<p>接下来看看 MASConstraint 属性的 getter 方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint *)left &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeLeft</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会发现这些 getter 方法都会调用 addConstraintWithLayoutAttribute 这个方法。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</div><div class="line">    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</div><div class="line">    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</div><div class="line">    <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</div><div class="line">        <span class="comment">//replace with composite constraint</span></div><div class="line">        <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</div><div class="line">        MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</div><div class="line">        compositeConstraint.delegate = <span class="keyword">self</span>;</div><div class="line">        [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</div><div class="line">        <span class="keyword">return</span> compositeConstraint;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!constraint) &#123;</div><div class="line">        newConstraint.delegate = <span class="keyword">self</span>;</div><div class="line">        [<span class="keyword">self</span>.constraints addObject:newConstraint];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newConstraint;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里会发现每次 getter 都会创建一个新的 MASViewConstraint 对象，这里通过将新的 MASViewConstraint 对象的 delegate 设置成自己的方式让新对象也能够调用相同的方法创建一个新的 MASViewConstraint 对象，使得能够支持进行链式的调用。</p>
<h1 id="设置完后如何处理？"><a href="#设置完后如何处理？" class="headerlink" title="设置完后如何处理？"></a>设置完后如何处理？</h1><h2 id="SnapKit-2"><a href="#SnapKit-2" class="headerlink" title="SnapKit"></a>SnapKit</h2><p>下面通过 makeConstraints 我们来看看 ConstraintMaker 是如何在外部通过一个闭包来写约束关系的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</div><div class="line">    <span class="keyword">let</span> maker = <span class="type">ConstraintMaker</span>(item: item)</div><div class="line">    closure(maker)</div><div class="line">    <span class="keyword">var</span> constraints: [<span class="type">Constraint</span>] = []</div><div class="line">    <span class="keyword">for</span> description <span class="keyword">in</span> maker.descriptions &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> constraint = description.constraint <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        &#125;</div><div class="line">        constraints.append(constraint)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> constraint <span class="keyword">in</span> constraints &#123;</div><div class="line">        constraint.activateIfNeeded(updatingExisting: <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个闭包给叫做 maker 的 ConstraintMaker 实例写入了信息，遍历 maker 的 descriptions 之后（我们之前说一条约束语句最终得到一个 self.description，但往往会有多条约束，所以 ConstraintMakerFinalizable 里面的 self.description，在 ConstraintMaker 里被一个数组维护），我们得到了 Constraint 数组。<br>跟进 Constraint 里的 activateIfNeeded 这个函数看看约束是怎么写出来的了<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">activateIfNeeded</span><span class="params">(updatingExisting: Bool = <span class="literal">false</span>)</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> item = <span class="keyword">self</span>.from.layoutConstraintItem <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"WARNING: SnapKit failed to get from item from constraint. Activate will be a no-op."</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">let</span> layoutConstraints = <span class="keyword">self</span>.layoutConstraints</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> updatingExisting &#123;</div><div class="line">        <span class="keyword">var</span> existingLayoutConstraints: [<span class="type">LayoutConstraint</span>] = []</div><div class="line">        <span class="keyword">for</span> constraint <span class="keyword">in</span> item.constraints &#123;</div><div class="line">            existingLayoutConstraints += constraint.layoutConstraints</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> layoutConstraint <span class="keyword">in</span> layoutConstraints &#123;</div><div class="line">            <span class="keyword">let</span> existingLayoutConstraint = existingLayoutConstraints.first &#123; $<span class="number">0</span> == layoutConstraint &#125;</div><div class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> updateLayoutConstraint = existingLayoutConstraint <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">fatalError</span>(<span class="string">"Updated constraint could not find existing matching constraint to update: <span class="subst">\(layoutConstraint)</span>"</span>)</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">let</span> updateLayoutAttribute = (updateLayoutConstraint.secondAttribute == .notAnAttribute) ? updateLayoutConstraint.firstAttribute : updateLayoutConstraint.secondAttribute</div><div class="line">            updateLayoutConstraint.constant = <span class="keyword">self</span>.constant.constraintConstantTargetValueFor(layoutAttribute: updateLayoutAttribute)</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="type">NSLayoutConstraint</span>.activate(layoutConstraints)</div><div class="line">        item.add(constraints: [<span class="keyword">self</span>])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="Masonry-2"><a href="#Masonry-2" class="headerlink" title="Masonry"></a>Masonry</h2><h3 id="MASViewConstraint"><a href="#MASViewConstraint" class="headerlink" title="MASViewConstraint"></a>MASViewConstraint</h3><p>这个类是对 NSLayoutConstriant 的封装。它的父类是 MASConstraint，MASConstraint 是一个抽象不可实例的类，里面有接口和协议。它的兄弟类是 MASCompositeConstraint，里面有个数组专门存储 MASViewConstraint 对象。</p>
<p>MASViewConstraint 对象的 install 方法会将各个约束 install 到对应的视图上。我们看看 MASConstraintMaker 的 install 方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span> *)install &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</div><div class="line">        <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</div><div class="line">            [constraint uninstall];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</div><div class="line">    <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</div><div class="line">        constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</div><div class="line">        [constraint install];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.constraints removeAllObjects];</div><div class="line">    <span class="keyword">return</span> constraints;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法会遍历 constraints 里每个约束进行 install。在这个 install 方法里会创建 MASLayoutConstraint 对象，然后把这个对象添加到对应的的视图上。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MASLayoutConstraint *layoutConstraint</div><div class="line">    = [MASLayoutConstraint constraintWithItem:firstLayoutItem</div><div class="line">        attribute:firstLayoutAttribute</div><div class="line">        relatedBy:<span class="keyword">self</span>.layoutRelation</div><div class="line">        toItem:secondLayoutItem</div><div class="line">        attribute:secondLayoutAttribute</div><div class="line">        multiplier:<span class="keyword">self</span>.layoutMultiplier</div><div class="line">        constant:<span class="keyword">self</span>.layoutConstant];</div><div class="line"></div><div class="line">layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</div><div class="line">layoutConstraint.mas_key = <span class="keyword">self</span>.mas_key;</div></pre></td></tr></table></figure></p>
<p>创建完 MASLayoutConstraint 对象后，会根据约束的设置判断将约束添加到哪个视图上。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</div><div class="line">    MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</div><div class="line">    <span class="built_in">NSAssert</span>(closestCommonSuperview,</div><div class="line">             <span class="string">@"couldn't find a common superview for %@ and %@"</span>,</div><div class="line">              <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</div><div class="line">    <span class="keyword">self</span>.installedView = closestCommonSuperview;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</div><div class="line">    <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123;</div><div class="line">    existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (existingConstraint) &#123;</div><div class="line">    <span class="comment">// just update the constant</span></div><div class="line">    existingConstraint.constant = layoutConstraint.constant;</div><div class="line">    <span class="keyword">self</span>.layoutConstraint = existingConstraint;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</div><div class="line">    <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</div><div class="line">    [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过上面代码里的条件判断可以看出，如果有设置相对的那个视图就用先前提到的那个 mas_closestCommonSuperview 方法去找两视图的共同父视图，不然如果只设置了高宽，就把约束加到当前视图上，其它情况就加到当前视图的父视图上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;一直觉得 SnapKit 和 Masonry 这两个框架设计和封装的很好，用起来的体验也是一致的，翻了下它们的源码，对其设计方式和涉及的技术
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift 项目中涉及到 JSONDecoder，网络请求，泛型协议式编程的一些记录和想法</title>
    <link href="http://ming1016.github.io/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/"/>
    <id>http://ming1016.github.io/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/</id>
    <published>2018-04-02T11:12:28.000Z</published>
    <updated>2018-04-03T01:49:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目开发一直在使用 swift，因为 HTN 项目最近会有另外一位同事加入，所以打算对最近涉及到的一些技术和自己的一些想法做个记录，同时也能够方便同事熟悉代码。</p>
<h1 id="JSON-数据的处理"><a href="#JSON-数据的处理" class="headerlink" title="JSON 数据的处理"></a>JSON 数据的处理</h1><p>做项目只要是涉及到服务器端接口都没法避免和 JSON 数据打交道。对于来自网络的 JSON 结构化数据的处理，可以使用 JSONDecoder 这个苹果自己提供的字符串转模型类，这个类是在 Swift 4 的 Fundation 模块里提供的，可以在Swift 源码目录 swift/stdlib/public/SDK/Fundation/JSONEncoder.swift 看到苹果对这个类实现。</p>
<p>其它对 JSON 处理的库还有 SwiftyJSON <a href="https://github.com/SwiftyJSON/SwiftyJSON" target="_blank" rel="external">GitHub - SwiftyJSON/SwiftyJSON: The better way to deal with JSON data in Swift</a></p>
<h2 id="使用-JSONDecoder"><a href="#使用-JSONDecoder" class="headerlink" title="使用 JSONDecoder"></a>使用 JSONDecoder</h2><p>下面苹果使用 JSONDecoder 的一个例子来看看如何使用 JSONDecoder<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">struct GroceryProduct: Codable &#123;</div><div class="line">    var name: String</div><div class="line">    var points: Int</div><div class="line">    var description: String?</div><div class="line">&#125;</div><div class="line"></div><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "name": "Durian",</div><div class="line">    "points": 600,</div><div class="line">    "description": "A fruit with a distinctive scent."</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div><div class="line"></div><div class="line">let decoder = JSONDecoder()</div><div class="line">let product = try decoder.decode(GroceryProduct.self, from: json)</div><div class="line"></div><div class="line">print(product.name) // Prints "Durian"</div></pre></td></tr></table></figure></p>
<p>这里要注意 GroceryProduct 结构体需要遵循 Codable，因为 JSONDecoder 的实例对象的 decode 方法需要遵循 Decodable 协议的结构体。Codable 是 Encodable 和 Decodable 两个协议的组合，写法如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></div></pre></td></tr></table></figure></p>
<p>当然 JSON 数据的结构不会都是这么简单，如果遇到嵌套情况如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "name": "Durian",</div><div class="line">    "points": 600,</div><div class="line">    "ability": &#123;</div><div class="line">        "mathematics": "excellent",</div><div class="line">        "physics": "bad",</div><div class="line">        "chemistry": "fine"</div><div class="line">    &#125;,</div><div class="line">    "description": "A fruit with a distinctive scent."</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div></pre></td></tr></table></figure></p>
<p>这时可以通过在 struct 里再套一个 struct 来做，修改过的 struct 如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> ability: <span class="type">Ability</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ability</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> mathematics: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> physics: <span class="type">String</span></div><div class="line">        <span class="keyword">var</span> chemistry: <span class="type">String</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以观察到 ability 里数学物理化学的评价都是那几个，无非是优良差，所以很适合用枚举表示，swift 的枚举对于字符串关联类型枚举也有很好的支持，只要声明关联值类型是 String 就行了，改后的代码如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> ability: <span class="type">Ability</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span>?</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Ability</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> mathematics: <span class="type">Appraise</span></div><div class="line">        <span class="keyword">var</span> physics: <span class="type">Appraise</span></div><div class="line">        <span class="keyword">var</span> chemistry: <span class="type">Appraise</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Appraise</span>: <span class="title">String</span>, <span class="title">Codable</span> </span>&#123;</div><div class="line">        <span class="keyword">case</span> excellent, fine, bad</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>API 返回的结果会有一个不可控的因素，是什么呢？那就是有的键值有时会返回有时不会返回，那么这个 struct 怎么兼容呢？</p>
<p>好在swift 原生就支持了 optional，只需要在属性后加个问号就行了。比如 points 有时会返回有时不会，那么就可以这么写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span>? <span class="comment">//可能会用不到</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CodingKey-协议"><a href="#CodingKey-协议" class="headerlink" title="CodingKey 协议"></a>CodingKey 协议</h2><p>接口还会有一些其它不可控因素，比如会产生出 snake case 的命名风格，要求风格统一固然是很好，但是现实环境总会有些不可抗拒的因素，比如不同团队，不同公司或者不同风格洁癖的 coder 之间。还好 JSONDecoder 已经做好了。下面我们看看如何用：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let json = """</div><div class="line">&#123;</div><div class="line">    "nick_name": "Tom",</div><div class="line">    "points": 600,</div><div class="line">&#125;</div><div class="line">""".data(using: .utf8)!</div></pre></td></tr></table></figure></p>
<p>这里 nick_name 我们希望处理成 swift 的风格，那么我们可以使用一个遵循 CodingKey 协议的枚举来做映射。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> nickName: <span class="type">String</span></div><div class="line">    <span class="keyword">var</span> points: <span class="type">Int</span></div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span> : <span class="title">String</span>, <span class="title">CodingKey</span></span>&#123;</div><div class="line">        <span class="keyword">case</span> nickName = <span class="string">"nick_name"</span></div><div class="line">        <span class="keyword">case</span> points</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这个方法是个通用方法，不光能够处理 snake case 还能够起自己喜欢的命名，比如你喜欢简写，nick name 写成 nName，那么也可以用这个方法。Codable 协议默认的实现实际上已经能够 cover 掉现实环境的大部分问题了，如果有些自定义的东西要处理的话可以通过覆盖默认 Codable 的方式来做。关键点就是 encoder 的 container，通过获取 container 对象进行自定义操作。</p>
<h2 id="JSONDecoder-的-keyDecodingStrategy-属性"><a href="#JSONDecoder-的-keyDecodingStrategy-属性" class="headerlink" title="JSONDecoder 的 keyDecodingStrategy 属性"></a>JSONDecoder 的 keyDecodingStrategy 属性</h2><p>JSONDecoder 里还有专门的一个属性 keyDecodingStrategy，这个值是个布尔值，有个 case 是 convertFromSnakeCase，这样就会按照这个 strategy 来转换 snake case，这个是核心功能内置的，就不需要我们额外写代码处理了。上面加上的枚举 CodingKeys 也可以去掉了，只需要在 JSONDecoder 这个实例设置这个属性就行。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">decoder.keyDecodingStrategy = .convertFromSnakeCase</div></pre></td></tr></table></figure></p>
<p>keyDecodingStrategy 这个属性是在 swift 4.1 加上的，所以这个版本之前的还是用 CodingKey 这个协议来处理吧。</p>
<p>那么苹果是如何通过这个 keyDecodingStrategy 属性的设置来做到的呢？</p>
<p>感谢苹果使用 Swift 写了 Swift 的核心功能，以后想要了解更多功能背后原理可以不用啃 C++ 了，一边学习原理还能一边学习苹果内部是如何使用 Swift 的，所谓一举两得。</p>
<p>实现这个功能代码就在上文提到的 Swift 源码目录 swift/stdlib/public/SDK/Fundation/ 下的 JSONEncoder.swift  文件，如果不想把源码下下来也可以在 GitHub 上在线看，地址：<a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/JSONEncoder.swift" target="_blank" rel="external">https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/JSONEncoder.swift</a></p>
<p>先看看这个属性的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The strategy to use for decoding keys. Defaults to `.useDefaultKeys`.</span></div><div class="line">open <span class="keyword">var</span> keyDecodingStrategy: <span class="type">KeyDecodingStrategy</span> = .useDefaultKeys</div></pre></td></tr></table></figure></p>
<p>这个属性是一个 keyDecodingStrategy 枚举，默认是 .userDefaultKeys。这个枚举是这样定义的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">KeyDecodingStrategy</span> </span>&#123;</div><div class="line">    <span class="comment">/// Use the keys specified by each type. This is the default strategy.</span></div><div class="line">    <span class="keyword">case</span> useDefaultKeys</div><div class="line">    </div><div class="line">    <span class="comment">/// Convert from "snake_case_keys" to "camelCaseKeys" before attempting to match a key with the one specified by each type.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// The conversion to upper case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// Converting from snake case to camel case:</span></div><div class="line">    <span class="comment">/// 1. Capitalizes the word starting after each `_`</span></div><div class="line">    <span class="comment">/// 2. Removes all `_`</span></div><div class="line">    <span class="comment">/// 3. Preserves starting and ending `_` (as these are often used to indicate private variables or other metadata).</span></div><div class="line">    <span class="comment">/// For example, `one_two_three` becomes `oneTwoThree`. `_one_two_three_` becomes `_oneTwoThree_`.</span></div><div class="line">    <span class="comment">///</span></div><div class="line">    <span class="comment">/// - Note: Using a key decoding strategy has a nominal performance cost, as each string key has to be inspected for the `_` character.</span></div><div class="line">    <span class="keyword">case</span> convertFromSnakeCase</div><div class="line">    </div><div class="line">    <span class="comment">/// Provide a custom conversion from the key in the encoded JSON to the keys specified by the decoded types.</span></div><div class="line">    <span class="comment">/// The full path to the current decoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before decoding.</span></div><div class="line">    <span class="comment">/// If the result of the conversion is a duplicate key, then only one value will be present in the container for the type to decode from.</span></div><div class="line">    <span class="keyword">case</span> custom((<span class="number">_</span> codingPath: [<span class="type">CodingKey</span>]) -&gt; <span class="type">CodingKey</span>)</div><div class="line">    </div><div class="line">    fileprivate <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_convertFromSnakeCase</span><span class="params">(<span class="number">_</span> stringKey: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>case convertFromSnakeCase 就是我们使用的，注释部分描述了整个过程，首先会把 ‘<em>’ 符号后面的字母转成大写的，然后移除掉所有的 ‘</em>’ 符号，保留最前面和最后的 ‘_’ 符号。比如 <strong>nick<em>name</em> 就会转换成 </strong>nickName_ 而这些都是在枚举里定义的静态方法 _convertFromSnakeCase 里完成的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">_convertFromSnakeCase</span><span class="params">(<span class="number">_</span> stringKey: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">guard</span> !stringKey.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> stringKey &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Find the first non-underscore character</span></div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> firstNonUnderscore = stringKey.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span> != <span class="string">"_"</span> &#125;) <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Reached the end without finding an _</span></div><div class="line">        <span class="keyword">return</span> stringKey</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Find the last non-underscore character</span></div><div class="line">    <span class="keyword">var</span> lastNonUnderscore = stringKey.index(before: stringKey.endIndex)</div><div class="line">    <span class="keyword">while</span> lastNonUnderscore &gt; firstNonUnderscore &amp;&amp; stringKey[lastNonUnderscore] == <span class="string">"_"</span> &#123;</div><div class="line">        stringKey.formIndex(before: &amp;lastNonUnderscore);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> keyRange = firstNonUnderscore...lastNonUnderscore</div><div class="line">    <span class="keyword">let</span> leadingUnderscoreRange = stringKey.startIndex..&lt;firstNonUnderscore</div><div class="line">    <span class="keyword">let</span> trailingUnderscoreRange = stringKey.index(after: lastNonUnderscore)..&lt;stringKey.endIndex</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> components = stringKey[keyRange].<span class="built_in">split</span>(separator: <span class="string">"_"</span>)</div><div class="line">    <span class="keyword">let</span> joinedString : <span class="type">String</span></div><div class="line">    <span class="keyword">if</span> components.<span class="built_in">count</span> == <span class="number">1</span> &#123;</div><div class="line">        <span class="comment">// No underscores in key, leave the word as is - maybe already camel cased</span></div><div class="line">        joinedString = <span class="type">String</span>(stringKey[keyRange])</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        joinedString = ([components[<span class="number">0</span>].lowercased()] + components[<span class="number">1</span>...].<span class="built_in">map</span> &#123; $<span class="number">0</span>.capitalized &#125;).joined()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Do a cheap isEmpty check before creating and appending potentially empty strings</span></div><div class="line">    <span class="keyword">let</span> result : <span class="type">String</span></div><div class="line">    <span class="keyword">if</span> (leadingUnderscoreRange.isEmpty &amp;&amp; trailingUnderscoreRange.isEmpty) &#123;</div><div class="line">        result = joinedString</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leadingUnderscoreRange.isEmpty &amp;&amp; !trailingUnderscoreRange.isEmpty) &#123;</div><div class="line">        <span class="comment">// Both leading and trailing underscores</span></div><div class="line">        result = <span class="type">String</span>(stringKey[leadingUnderscoreRange]) + joinedString + <span class="type">String</span>(stringKey[trailingUnderscoreRange])</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!leadingUnderscoreRange.isEmpty) &#123;</div><div class="line">        <span class="comment">// Just leading</span></div><div class="line">        result = <span class="type">String</span>(stringKey[leadingUnderscoreRange]) + joinedString</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Just trailing</span></div><div class="line">        result = joinedString + <span class="type">String</span>(stringKey[trailingUnderscoreRange])</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码处理的逻辑不算复杂，功能也不多，但是还是有很多值得学习的地方，首先可以看看是如何处理边界条件的。可以看到两个边界条件都是用 guard 语法来处理的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">guard</span> !stringKey.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> stringKey &#125;</div><div class="line"></div><div class="line"><span class="comment">// Find the first non-underscore character</span></div><div class="line"><span class="keyword">guard</span> <span class="keyword">let</span> firstNonUnderscore = stringKey.index(<span class="keyword">where</span>: &#123; $<span class="number">0</span> != <span class="string">"_"</span> &#125;) <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Reached the end without finding an _</span></div><div class="line">    <span class="keyword">return</span> stringKey</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一个是判断空，第二个是通过 String 的 public func index(where predicate: (Character) throws -&gt; Bool) rethrows -&gt; String.Index?  这个函数来看字符串里是否包含了 ‘_’ 符号，如果没有包含就直接返回原 String 值。这个函数的参数就是一个自定义返回布尔值的 block，返回 true 即刻返回不再继续遍历了，可见苹果对于性能一点也不浪费。</p>
<p>然后这个返回的 index 值还有个作用就是可以得到 ‘<em>’ 符号在最前面后第一个非 ‘</em>’ 符号的字符。因为需求如此，不需要把最前面和最后面的 ‘<em>’ 转驼峰，但是前面和后面的 ‘</em>’ 符号个数又不一定，所以需要得到前面 ‘_’ 符号和后面的范围。</p>
<p>那么得到前面的范围后，后面的苹果是怎么做的呢？<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Find the last non-underscore character</span></div><div class="line"><span class="keyword">var</span> lastNonUnderscore = stringKey.index(before: stringKey.endIndex)</div><div class="line"><span class="keyword">while</span> lastNonUnderscore &gt; firstNonUnderscore &amp;&amp; stringKey[lastNonUnderscore] == <span class="string">"_"</span> &#123;</div><div class="line">    stringKey.formIndex(before: &amp;lastNonUnderscore);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里正好可以看到对 String 的 public func formIndex(before i: inout String.Index) 函数的应用，这里的参数定义为 inout 的作用是能够在函数里对这个参数不用通过返回的方式直接修改生效。这个函数的作用就是移动字符的 index，before 是往前移动，after 是往后移动。</p>
<p>上面的代码就是先找到整个字符串的最后的 index 然后开始从后往前找，找到不是 ‘_’ 符号时跳出这个 while，同时还要满足不超过 lastNonUnderscore 的范围。</p>
<p>在接下内容之前可以考虑这样一个问题，为什么在做前面的判断时为什么不用 public func formIndex(after i: inout String.Index) 这个方法，after 不是代表从开始往后移动遍历么，也可以达到找到第一个不是 ‘_’ 的字符就停止的效果。</p>
<p>苹果真是双枪老太婆，一击两发，既解决了边界问题又能解决一个需求，代码有了优化，代码量还减少了。其实面试过程中通常都会有些算法题的环节，很多人都以为只要有了解决思路或者写出简单的处理代码就可以了，我碰到了一些的面试人甚至用中文一条条写出思路以为就完事了。其实算法题的考察是分为两种的，一种是考智商的，就是解决办法很多或者解决办法很难，能够想到解法或者最优解是比较困难的，这样的题适合那些在面谈过程中能觉得实力和深度不错的人，通过这些题同时还能更多为判断面试人是否更具创造力，属于拔尖的考法。还有种是考严谨和实际项目能力的，这种更多是考察边界条件的处理，逻辑的严谨还有对代码优化的处理，这种题的解法和逻辑会比较简单。</p>
<p>_convertFromSnakeCase 这个枚举的静态函数会在创建 container 的时候调用，具体使用的函数是 _JSONKeyedDecodingContainer，在它的初始化方法里会判断  decoder.options.keyDecodingStrategy  这个枚举值，满足 convertFromSnakeCase 就会调用那个静态函数了。调用的时候还要注意一个处理就是转换成驼峰后的 key 可能会和已有命名重名，那么就需要选择进行一个选择，苹果的选择是第一个。实现方式如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">self</span>.container = <span class="type">Dictionary</span>(container.<span class="built_in">map</span> &#123;</div><div class="line">    key, value <span class="keyword">in</span> (<span class="type">JSONDecoder</span>.<span class="type">KeyDecodingStrategy</span>._convertFromSnakeCase(key), value)</div><div class="line">&#125;, uniquingKeysWith: &#123; (first, <span class="number">_</span>) <span class="keyword">in</span> first &#125;)</div></pre></td></tr></table></figure></p>
<p>这里遇到一个 Dictionary 的初始化函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>&lt;<span class="type">S</span>&gt;(<span class="number">_</span> keysAndValues: <span class="type">S</span>, uniquingKeysWith combine: (<span class="type">Dictionary</span>.<span class="type">Value</span>, <span class="type">Dictionary</span>.<span class="type">Value</span>) <span class="keyword">throws</span> -&gt; <span class="type">Dictionary</span>.<span class="type">Value</span>) <span class="keyword">rethrows</span> <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Sequence</span>, <span class="type">S</span>.<span class="type">Element</span> == (<span class="type">Key</span>, <span class="type">Value</span>)</div></pre></td></tr></table></figure></p>
<p>这个函数就是专门用来处理上面的重复 key 的问题。如果要选择最后一个 key 的值用这个函数也会很容易。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> pairsWithDuplicateKeys = [(<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"b"</span>, <span class="number">4</span>)]</div><div class="line"></div><div class="line"><span class="keyword">let</span> firstValues = <span class="type">Dictionary</span>(pairsWithDuplicateKeys,</div><div class="line">                             uniquingKeysWith: &#123; (first, <span class="number">_</span>) <span class="keyword">in</span> first &#125;)</div><div class="line"><span class="comment">// ["b": 2, "a": 1]</span></div><div class="line"><span class="keyword">let</span> lastValues = <span class="type">Dictionary</span>(pairsWithDuplicateKeys,</div><div class="line">                            uniquingKeysWith: &#123; (<span class="number">_</span>, last) <span class="keyword">in</span> last &#125;)</div><div class="line"><span class="comment">// ["b": 4, "a": 3]</span></div></pre></td></tr></table></figure></p>
<h2 id="枚举定义-block"><a href="#枚举定义-block" class="headerlink" title="枚举定义 block"></a>枚举定义 block</h2><p>KeyEncodingStrategy 还可以自定义 codingKey<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> custom((<span class="number">_</span> codingPath: [<span class="type">CodingKey</span>]) -&gt; <span class="type">CodingKey</span>)</div></pre></td></tr></table></figure></p>
<p>在 container 初始化时会调用这个 block 来进行 key 的转换，同样如果转换后出现重复 key 也会和 convertFromSnakeCase 一样选择第一个。这里可以看到 Swift 里的枚举还能够定义一个 block 方便自定义处理自己特定规则，这样就可以完全抛弃以前的那种覆盖 Codable 协议默认实现的方式了。</p>
<h2 id="inout"><a href="#inout" class="headerlink" title="inout"></a>inout</h2><p>上面提到了 public func formIndex(before i: inout Index) 这个函数，那么跟着这个函数在源码里看看它的实现，这个函数是在这个文件里实现的 <a href="https://github.com/apple/swift/blob/master/stdlib/public/SDK/Foundation/IndexSet.swift" target="_blank" rel="external">swift/IndexSet.swift at master · apple/swift · GitHub</a></p>
<p>找到这个方法时发现没有 inout 定义的同名函数也还在那里<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(before i: Index)</span></span> -&gt; <span class="type">Index</span> &#123;</div><div class="line">    <span class="keyword">if</span> i.value == i.extent.lowerBound &#123;</div><div class="line">        <span class="comment">// Move to the next range</span></div><div class="line">        <span class="keyword">if</span> i.rangeIndex == <span class="number">0</span> &#123;</div><div class="line">            <span class="comment">// We have no more to go</span></div><div class="line">            <span class="keyword">return</span> <span class="type">Index</span>(value: i.value, extent: i.extent, rangeIndex: i.rangeIndex, rangeCount: i.rangeCount)</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">let</span> rangeIndex = i.rangeIndex - <span class="number">1</span></div><div class="line">            <span class="keyword">let</span> rangeCount = i.rangeCount</div><div class="line">            <span class="keyword">let</span> extent = _range(at: rangeIndex)</div><div class="line">            <span class="keyword">let</span> value = extent.upperBound - <span class="number">1</span></div><div class="line">            <span class="keyword">return</span> <span class="type">Index</span>(value: value, extent: extent, rangeIndex: rangeIndex, rangeCount: rangeCount)</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Move to the previous value in this range</span></div><div class="line">        <span class="keyword">return</span> <span class="type">Index</span>(value: i.value - <span class="number">1</span>, extent: i.extent, rangeIndex: i.rangeIndex, rangeCount: i.rangeCount)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">formIndex</span><span class="params">(before i: <span class="keyword">inout</span> Index)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> i.value == i.extent.lowerBound &#123;</div><div class="line">        <span class="comment">// Move to the next range</span></div><div class="line">        <span class="keyword">if</span> i.rangeIndex == <span class="number">0</span> &#123;</div><div class="line">            <span class="comment">// We have no more to go</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            i.rangeIndex -= <span class="number">1</span></div><div class="line">            i.extent = _range(at: i.rangeIndex)</div><div class="line">            i.value = i.extent.upperBound - <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Move to the previous value in this range</span></div><div class="line">        i.value -= <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数的实现最直观的感受就是 inout 的少了三个 return。还有一个好处就是值类型参数 i 可以以引用方式传递，不需要 var 和 let 来修饰</p>
<p>当然 inout 还有一个好处在上面的函数里没有体现出来，那就是可以方便对多个值类型数据进行修改而不需要一一指明返回。</p>
<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>说到网络请求，在 Objective-C 世界里基本都是用的 AFNetworking <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">GitHub - AFNetworking/AFNetworking: A delightful networking framework for iOS, macOS, watchOS, and tvOS.</a> 在 Swift 里就是 Alamofire <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="external">GitHub - Alamofire/Alamofire: Elegant HTTP Networking in Swift</a> 。我在 Swift 1.0 之前 beta 版本时就注意到 Alamofire 库里，那时还是 Mattt Thompson 一个人在写，文件也只有一个。如今功能已经多了很多，但代码量依然不算太大。我在做 HTN 项目时对于网络请求的需求不是那么大，但是也有，于是开始的时候就是简单的使用 URLSession 来实现了一下网路请求，就是想直接拉下接口下发的 JSON 数据。</p>
<p>开始结合着前面解析 JSON 的方法，我这么写了个网络请求：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WebJSON</span>:<span class="title">Codable</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> name:<span class="type">String</span></div><div class="line">    <span class="keyword">var</span> node:<span class="type">String</span></div><div class="line">    <span class="keyword">var</span> version: <span class="type">Int</span>?</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.shared</div><div class="line"><span class="keyword">let</span> request:<span class="type">URLRequest</span> = <span class="type">NSURLRequest</span>.<span class="keyword">init</span>(url: <span class="type">URL</span>(string: <span class="string">"http://www.starming.com/api.php?get=testjson"</span>)!) <span class="keyword">as</span> <span class="type">URLRequest</span></div><div class="line"><span class="keyword">let</span> task = session.dataTask(with: request) &#123; (data, res, error) <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">            <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">WebJSON</span>.<span class="keyword">self</span>, from: data!)</div><div class="line">            <span class="built_in">print</span>(jsonModel)</div><div class="line">        &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么写是 ok 的，能够成功请求得到 JSON 数据然后转换成对应的结构数据。不过如果还有另外几处也要进行网络请求，拿这一坨代码不是要到处写了。那么先看看 Alamofire 干这个活是什么样子的？<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/get"</span>).responseData &#123; response <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = response.data &#123;</div><div class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">            <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">H5Editor</span>.<span class="keyword">self</span>, from: data)</div><div class="line">        &#125; <span class="keyword">catch</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Alamofire 有 responseJSON 的方法，不过解完是个字典，用的时候需要做很多容错判断很不方便，所以还是要使用 JSONDecoder 或者其它第三方库。不过 Alamofire 的写法已经做了一些简化，当然里面还实现了更多的功能，我待会再说，现在我的主要任务是简化调用。于是动手改改先前的实现，学习 Alamofire 的做法，首先创建一个类，然后简化掉 request 写法，再建个 block 方便请求完成后的数据返回处理，最后使用泛型支持不同 struct 的数据统一返回。写完后，我给这个网络类起个名字叫 SMNetWorking 这个类实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">open <span class="class"><span class="keyword">class</span> <span class="title">SMNetWorking</span>&lt;<span class="title">T</span>:<span class="title">Codable</span>&gt; </span>&#123;</div><div class="line">    open <span class="keyword">let</span> session:<span class="type">URLSession</span></div><div class="line">    </div><div class="line">    <span class="keyword">typealias</span> <span class="type">CompletionJSONClosure</span> = (<span class="number">_</span> data:<span class="type">T</span>) -&gt; <span class="type">Void</span></div><div class="line">    <span class="keyword">var</span> completionJSONClosure:<span class="type">CompletionJSONClosure</span> =  &#123;<span class="number">_</span> <span class="keyword">in</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>() &#123;</div><div class="line">        <span class="keyword">self</span>.session = <span class="type">URLSession</span>.shared</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//JSON的请求</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">requestJSON</span><span class="params">(<span class="number">_</span> url: SMURLNetWorking,</span></span></div><div class="line">                     doneClosure:@escaping CompletionJSONClosure</div><div class="line">                    ) &#123;</div><div class="line">        <span class="keyword">self</span>.completionJSONClosure = doneClosure</div><div class="line">        <span class="keyword">let</span> request:<span class="type">URLRequest</span> = <span class="type">NSURLRequest</span>.<span class="keyword">init</span>(url: url.asURL()) <span class="keyword">as</span> <span class="type">URLRequest</span></div><div class="line">        <span class="keyword">let</span> task = <span class="keyword">self</span>.session.dataTask(with: request) &#123; (data, res, error) <span class="keyword">in</span></div><div class="line">            <span class="keyword">if</span> (error == <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="built_in">print</span>(<span class="string">"解析 JSON 成功"</span>)</div><div class="line">                    <span class="keyword">let</span> jsonModel = <span class="keyword">try</span> decoder.decode(<span class="type">T</span>.<span class="keyword">self</span>, from: data!)</div><div class="line">                    <span class="keyword">self</span>.completionJSONClosure(jsonModel)</div><div class="line">                &#125; <span class="keyword">catch</span> &#123;</div><div class="line">                    <span class="built_in">print</span>(<span class="string">"解析 JSON 失败"</span>)</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        task.resume()</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*----------Protocol----------*/</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SMURLNetWorking</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*----------Extension---------*/</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">SMURLNetWorking</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asURL</span><span class="params">()</span></span> -&gt; <span class="type">URL</span> &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string:<span class="keyword">self</span>) <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="type">URL</span>(string:<span class="string">"http:www.starming.com"</span>)!</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> url</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样调用起来就简单得多了，看起来如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().requestJSON(<span class="string">"https://httpbin.org/get"</span>) &#123; (jsonModel) <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(jsonModel)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然这样写起来是简单多了，特别是请求不同的接口返回不同结构时，本地定义了很多的 model 结构体，那么请求时只需要指明不同的 model 类型，block 里就能够直接返回对应的值。</p>
<p>默认都按照 GET 方法请求，在实际项目中会用到其它比如 POST 等方法，Alamofire 的做法是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// HTTP method definitions.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// See https://tools.ietf.org/html/rfc7231#section-4.3</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> options = <span class="string">"OPTIONS"</span></div><div class="line">    <span class="keyword">case</span> <span class="keyword">get</span>     = <span class="string">"GET"</span></div><div class="line">    <span class="keyword">case</span> head    = <span class="string">"HEAD"</span></div><div class="line">    <span class="keyword">case</span> post    = <span class="string">"POST"</span></div><div class="line">    <span class="keyword">case</span> put     = <span class="string">"PUT"</span></div><div class="line">    <span class="keyword">case</span> patch   = <span class="string">"PATCH"</span></div><div class="line">    <span class="keyword">case</span> delete  = <span class="string">"DELETE"</span></div><div class="line">    <span class="keyword">case</span> trace   = <span class="string">"TRACE"</span></div><div class="line">    <span class="keyword">case</span> connect = <span class="string">"CONNECT"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>会先定义一个枚举，依据的标准也列在了注释里。使用起来是这样的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/get"</span>) <span class="comment">// method defaults to `.get`</span></div><div class="line"></div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/post"</span>, method: .post)</div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/put"</span>, method: .put)</div><div class="line"><span class="type">Alamofire</span>.request(<span class="string">"https://httpbin.org/delete"</span>, method: .delete)</div></pre></td></tr></table></figure></p>
<p>可以看出在 request 方法里有个可选参数，设置完会给 NSURLRequest 的 httpMethod 的这个可选属性附上设置的值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">init</span>(url: <span class="type">URLConvertible</span>, method: <span class="type">HTTPMethod</span>, headers: <span class="type">HTTPHeaders</span>? = <span class="literal">nil</span>) <span class="keyword">throws</span> &#123;</div><div class="line">    <span class="keyword">let</span> url = <span class="keyword">try</span> url.asURL()</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(url: url)</div><div class="line">    </div><div class="line">    httpMethod = method.rawValue</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> headers = headers &#123;</div><div class="line">        <span class="keyword">for</span> (headerField, headerValue) <span class="keyword">in</span> headers &#123;</div><div class="line">            setValue(headerValue, forHTTPHeaderField: headerField)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么接下来我在 SMNetWorking 类里也加上这个功能，先定义一个枚举：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTPMethod</span>: <span class="title">String</span> </span>&#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">GET</span>,<span class="type">OPTIONS</span>,<span class="type">HEAD</span>,<span class="type">POST</span>,<span class="type">PUT</span>,<span class="type">PATCH</span>,<span class="type">DELETE</span>,<span class="type">TRACE</span>,<span class="type">CONNECT</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>利用枚举的字符串协议特性，可以将枚举名直接转值的字符串，可以通过这种方式简化枚举定义。</p>
<p>翻下 NSURLRequest 提供的那些可选设置项还不少，如果把这些设置都做成一个个可配参数那么后期维护会非常麻烦。所以我打算使用链式来弄。先 fix HTTPMethod 这个。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链式方法</span></div><div class="line"><span class="comment">//HTTPMethod 的设置</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpMethod</span><span class="params">(<span class="number">_</span> md:HTTPMethod)</span></span> -&gt; <span class="type">SMNetWorking</span> &#123;</div><div class="line">    <span class="keyword">self</span>.op.httpMethod = md</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 op 是个结构体，专门用来存放这些可选项的值的。完整的代码可以在这里看到 <a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/SMNetWorking.swift" target="_blank" rel="external">HTN/SMNetWorking.swift at master · ming1016/HTN · GitHub</a></p>
<p>使用起来也很方便：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().method(.<span class="type">POST</span>).requestJSON(<span class="string">"https://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>有了这样一个结构的设计后面扩展起来会非常方便，不过目前的功能是能够满足基本需求的，所以需要完善的比如对于 POST 请求需要的 HTTTP Body，还有 HTTP Headers 的自定义设置，Authentication 里的 HTTP Basic Authentication，Authentication with URLCredential 等，这些也可以先提供一个接口到外部去设置。所以可以先建个 block 把 URLRequest 提供出去由外围设置。</p>
<p>弄完后的使用效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">WModel</span>&gt;().method(.<span class="type">POST</span>).configRequest &#123; (request) <span class="keyword">in</span></div><div class="line">    <span class="comment">//设置 request</span></div><div class="line">&#125;.requestJSON(<span class="string">"https://httpbin.org/get"</span>)</div></pre></td></tr></table></figure></p>
<p>就刚才提到的请求参数来说，Alamofire 是定义了一个 ParameterEncoding 协议，协议里规定一个统一处理的方法 func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest 这样就可以对多种情况做一样的返回处理了。从遵循这个协议的结构体可以看到 URL，JSON 和 PropertyList 都遵循了，那么从实现这个协议的 encode 函数的实现里可以看到他们都是殊途同归到 request 的 httpBody 里。可以拿 URLEncoding 看看具体实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</div><div class="line">    <span class="keyword">var</span> urlRequest = <span class="keyword">try</span> urlRequest.asURLRequest()</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> parameters = parameters <span class="keyword">else</span> &#123; <span class="keyword">return</span> urlRequest &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> method = <span class="type">HTTPMethod</span>(rawValue: urlRequest.httpMethod ?? <span class="string">"GET"</span>), encodesParametersInURL(with: method) &#123;</div><div class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> url = urlRequest.url <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="type">AFError</span>.parameterEncodingFailed(reason: .missingURL)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> <span class="keyword">var</span> urlComponents = <span class="type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="literal">false</span>), !parameters.isEmpty &#123;</div><div class="line">            <span class="keyword">let</span> percentEncodedQuery = (urlComponents.percentEncodedQuery.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"&amp;"</span> &#125; ?? <span class="string">""</span>) + query(parameters)</div><div class="line">            urlComponents.percentEncodedQuery = percentEncodedQuery</div><div class="line">            urlRequest.url = urlComponents.url</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> urlRequest.value(forHTTPHeaderField: <span class="string">"Content-Type"</span>) == <span class="literal">nil</span> &#123;</div><div class="line">            urlRequest.setValue(<span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> urlRequest</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="泛型协议式编程"><a href="#泛型协议式编程" class="headerlink" title="泛型协议式编程"></a>泛型协议式编程</h1><p>对于目前 HTN 项目来说，请求到了数据，将 JSON 解析生成了对应的 Struct，那么下一步就是要把这个结构化的数据生成不同平台的代码，比如首先是 Objective-C 代码，然后是 Swift 代码，再然后会有 Java 代码。为了能够更好的合并多语言里重复的东西，我打算将处理生成不同语言的实现遵循相同的协议，这样就可以更规范更减少重复的实现这样的功能了。最终的效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">SMNetWorking</span>&lt;<span class="type">H5Editor</span>&gt;().requestJSON(<span class="string">"https://httpbin.org/get"</span>) &#123; (jsonModel) <span class="keyword">in</span></div><div class="line">        <span class="keyword">let</span> reStr = <span class="type">H5EditorToFrame</span>&lt;<span class="type">H5EditorObjc</span>&gt;(<span class="type">H5EditorObjc</span>()).convert(jsonModel)</div><div class="line">        <span class="built_in">print</span>(reStr)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是转成 Swift 的话就把 H5EditorObjc 改成 H5EditorSwift 就好了，他们遵循的都是 HTNMultilingualismSpecification 协议，其它语言依此类推。如果遇到统一的实现，可以建个协议的扩展，然后用统一函数去实现就好了。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">HTNMultilingualismSpecification</span> </span>&#123;</div><div class="line">    <span class="comment">//统一处理函数放这里</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种设计很类似类簇，比如我们熟悉的 NSString 就是这么设计的，根据初始化的不同，比如 initWith 什么的实例出来的对象是不同的，不过他们都遵循了相同的协议，所以我们在使用的时候没有感觉到差别。</p>
<p>HTNMultilingualismSpecification 这个协议里具体的定义在这里：<a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/HTNMultilingualism.swift" target="_blank" rel="external">https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/Core/HTNFundation/HTNMultilingualism.swift</a></p>
<p>回头看看 JSONDecoder 也是使用协议泛型式编程的一个典范。先看看 decode 函数的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">open <span class="function"><span class="keyword">func</span> <span class="title">decode</span>&lt;T : Decodable&gt;<span class="params">(<span class="number">_</span> type: T.<span class="keyword">Type</span>, from data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></div></pre></td></tr></table></figure></p>
<p>入参 type 是遵循了统一的 Decodable 协议的，那么就可以按照统一的方法去做处理，在内部实现时实际上 JSONDecoder 会代理给 _JSONDecoder 来实现具体逻辑的。所以在 decode 里的具体实现值类型转换的 unbox 函数都是在 _JSONDecoder 的扩展里实现的。unbox 会处理数字，字符串，布尔值这些基础数据类型，如果有其它层级的结构体也会一层层解下去， _JSONDecoder 的 _JSONDecodingStorage 通过保存最终得到完整的结构体。可以通过下面的代码看出支持这个过程的结构是怎么设计的。首先是 _JSONDecoder 的属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The decoder's storage.</span></div><div class="line">fileprivate <span class="keyword">var</span> storage: _JSONDecodingStorage</div><div class="line"></div><div class="line"><span class="comment">/// Options set on the top-level decoder.</span></div><div class="line">fileprivate <span class="keyword">let</span> options: <span class="type">JSONDecoder</span>._Options</div><div class="line"></div><div class="line"><span class="comment">/// The path to the current point in encoding.</span></div><div class="line">fileprivate(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> codingPath: [<span class="type">CodingKey</span>]</div><div class="line"></div><div class="line"><span class="comment">/// Contextual user-provided information for use during encoding.</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">var</span> userInfo: [<span class="type">CodingUserInfoKey</span> : <span class="type">Any</span>] &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.options.userInfo</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是初始化<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Initializes `self` with the given top-level container and options.</span></div><div class="line">fileprivate <span class="keyword">init</span>(referencing container: <span class="type">Any</span>, at codingPath: [<span class="type">CodingKey</span>] = [], options: <span class="type">JSONDecoder</span>._Options) &#123;</div><div class="line">    <span class="keyword">self</span>.storage = _JSONDecodingStorage()</div><div class="line">    <span class="keyword">self</span>.storage.push(container: container)</div><div class="line">    <span class="keyword">self</span>.codingPath = codingPath</div><div class="line">    <span class="keyword">self</span>.options = options</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到 storage 在初始化时只 push 了顶层，push 的实现是：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fileprivate <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(container: Any)</span></span> &#123;</div><div class="line">    <span class="keyword">self</span>.containers.append(container)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>containers 在定义的时候是个 [Any] 数组，这样就允许 container 包含 container 也就是 struct 包含 struct 这样的结构。</p>
<h1 id="函数式思想编程"><a href="#函数式思想编程" class="headerlink" title="函数式思想编程"></a>函数式思想编程</h1><p>在处理映射成表达式是设置布局属性最复杂的地方，需要考虑兼顾到各种表达式情况的处理，这样救需要设计一个类似 SnapKit 那样可链式调用设置值的结构，我先设计了一个结构体用来存一些可变的信息<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PtEqual</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> leftId = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">left</span> = <span class="type">WgPt</span>.<span class="keyword">none</span></div><div class="line">    <span class="keyword">var</span> leftIdPrefix = <span class="string">""</span> <span class="comment">//左前缀</span></div><div class="line">    <span class="keyword">var</span> rightType = <span class="type">PtEqualRightType</span>.pt</div><div class="line">    <span class="keyword">var</span> rightId = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightIdPrefix = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> <span class="keyword">right</span> = <span class="type">WgPt</span>.<span class="keyword">none</span></div><div class="line">    <span class="keyword">var</span> rightFloat:<span class="type">Float</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> rightInt:<span class="type">Int</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">var</span> rightColor = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightText = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightString = <span class="string">""</span></div><div class="line">    <span class="keyword">var</span> rightSuffix = <span class="string">""</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> equalType = <span class="type">EqualType</span>.normal</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于这些结构的设置会在 PtEqualC 这个类里去处理，把每个结构体属性的设置做成各个函数返回类本身即可实现。效果如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p.<span class="keyword">left</span>(.width).leftId(id).leftIdPrefix(<span class="string">"self."</span>).rightType(.float).rightFloat(fl.viewPt.padding.<span class="keyword">left</span> * <span class="number">2</span>).equalType(.decrease)</div></pre></td></tr></table></figure></p>
<p>不过每次设置完后需要累加到最后返回的字符串里，这样一个过程其实也可以封装一个简单函数，比如 add()。这个怎么做能够更通用呢？比如希望支持不同的累加方法等。</p>
<p>那么可以先设计一个累加的 block 属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">MutiClosure</span> = (<span class="number">_</span> pe: <span class="type">PtEqual</span>) -&gt; <span class="type">String</span></div><div class="line"><span class="keyword">var</span> accumulatorLineClosure:<span class="type">MutiClosure</span> = &#123;<span class="number">_</span> <span class="keyword">in</span> <span class="keyword">return</span> <span class="string">""</span>&#125;</div></pre></td></tr></table></figure></p>
<p>添加累加字符串和换行标示<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mutiEqualStr = <span class="string">""</span>         <span class="comment">//累加的字符串</span></div><div class="line"><span class="keyword">var</span> mutiEqualLineMark = <span class="string">"\n"</span>  <span class="comment">//换行标识</span></div></pre></td></tr></table></figure></p>
<p>写个函数去设置这个 block 返回是类自己用于链式<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//累计设置的 PtEqual 字符串</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">accumulatorLine</span><span class="params">(<span class="number">_</span> closure:@escaping MutiClosure)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    <span class="keyword">self</span>.accumulatorLineClosure = closure</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后添加一个函数专门用来使用的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//执行累加动作</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> filterBl &#123;</div><div class="line">        <span class="keyword">self</span>.mutiEqualStr += accumulatorLineClosure(<span class="keyword">self</span>.pe) + <span class="keyword">self</span>.mutiEqualLineMark</div><div class="line">    &#125;</div><div class="line">    <span class="number">_</span> = resetFilter()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看看用起来是什么效果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="type">HTNMt</span>.<span class="type">PtEqualC</span>().accumulatorLine(&#123; (pe) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.ptEqualToStr(pe: pe)</div><div class="line">&#125;).<span class="built_in">filter</span>(&#123; () -&gt; <span class="type">Bool</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> vpt.isNormal</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    p.<span class="keyword">left</span>(.height).rightFloat(fl.viewPt.padding.top * <span class="number">2</span>).add()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>细心的同学会注意到这里多了两个东西，一个是 filter， 一个是 once，这两个函数里的 block 会把一些通用逻辑进行封装。filter 的设置会根据返回决定是否处理后面的 block 或者结构体属性的设置，实现方式如下<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//过滤条件</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">filter</span><span class="params">(<span class="number">_</span> closure: FilterClosure)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    filterBl = closure()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 filterBl 是类的一个属性，后面会根据这个属性来决定动作是否继续执行。比如属性的设置会去判断<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">left</span><span class="params">(<span class="number">_</span> wp:WgPt)</span></span> -&gt; <span class="type">PtEqualC</span> &#123;</div><div class="line">    filterBl ? <span class="keyword">self</span>.pe.<span class="keyword">left</span> = wp : ()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>once 这个函数也会判断<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">once</span><span class="params">(<span class="number">_</span> closure:<span class="params">(<span class="number">_</span> pc: PtEqualC)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">PtEqualC</span>&#123;</div><div class="line">    <span class="keyword">if</span> filterBl &#123;</div><div class="line">        closure(<span class="keyword">self</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="number">_</span> = resetPe()</div><div class="line">    <span class="number">_</span> = resetFilter()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时 once 这个函数还会重置 filterBl 和重置设置的结构体，一箭三雕，相当于一个完整的设置周期。</p>
<p>有了这样一套函数，再复杂的设置过程以及逻辑处理都可以很清晰统一的表达出来，下面可以看一个复杂布局比如映射成原生表达式的代码效果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//UIView *myViewContainer = [UIView new];</span></div><div class="line">lyStr += newEqualStr(vType: .view, id: cId) + <span class="string">"\n"</span></div><div class="line"></div><div class="line"><span class="comment">//属性拼装</span></div><div class="line">lyStr += <span class="type">HTNMt</span>.<span class="type">PtEqualC</span>().accumulatorLine(&#123; (pe) -&gt; <span class="type">String</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.ptEqualToStr(pe: pe)</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    p.<span class="keyword">left</span>(.top).leftId(cId).end()</div><div class="line">    <span class="keyword">if</span> fl.isFirst &#123;</div><div class="line">        <span class="comment">//myViewContainer.top = 0.0;</span></div><div class="line">        p.rightType(.float).rightFloat(<span class="number">0</span>).add()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//myViewContainer.top = lastView.bottom;</span></div><div class="line">        p.rightId(fl.lastId + <span class="string">"Container"</span>).rightType(.pt).<span class="keyword">right</span>(.bottom).add()</div><div class="line">    &#125;</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//myViewContainer.left = 0.0;</span></div><div class="line">    p.leftId(cId).<span class="keyword">left</span>(.<span class="keyword">left</span>).rightType(.float).rightFloat(<span class="number">0</span>).add()</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//myViewContainer.width = self.myView.width;</span></div><div class="line">    p.leftId(cId).<span class="keyword">left</span>(.width).rightType(.pt).rightIdPrefix(<span class="string">"self."</span>).rightId(id).<span class="keyword">right</span>(.width).add()</div><div class="line">    </div><div class="line">    <span class="comment">//myViewContainer.height = self.myView.height;</span></div><div class="line">    p.<span class="keyword">left</span>(.height).<span class="keyword">right</span>(.height).add()</div><div class="line">&#125;).once(&#123; (p) <span class="keyword">in</span></div><div class="line">    <span class="comment">//self.myView.width -= 16 * 2;</span></div><div class="line">    p.<span class="keyword">left</span>(.width).leftId(id).leftIdPrefix(<span class="string">"self."</span>).rightType(.float).rightFloat(fl.viewPt.padding.<span class="keyword">left</span> * <span class="number">2</span>).equalType(.decrease).add()</div><div class="line">    </div><div class="line">    <span class="comment">//self.myView.height -= 8 * 2;</span></div><div class="line">    p.<span class="keyword">left</span>(.height).rightFloat(fl.viewPt.padding.top * <span class="number">2</span>).add()</div><div class="line">    </div><div class="line">    <span class="comment">//self.myView.top = 8;</span></div><div class="line">    p.equalType(.normal).<span class="keyword">left</span>(.top).rightType(.float).rightFloat(fl.viewPt.padding.top).add()</div><div class="line">    </div><div class="line">    <span class="comment">//属性 verticalAlign 或 horizontalAlign 是 padding 和其它排列时的区别处理</span></div><div class="line">    <span class="keyword">if</span> fl.viewPt.horizontalAlign == .padding &#123;</div><div class="line">        <span class="comment">//self.myView.left = 16;</span></div><div class="line">        p.<span class="keyword">left</span>(.<span class="keyword">left</span>).rightFloat(fl.viewPt.padding.<span class="keyword">left</span>).add()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//[self.myView sizeToFit];</span></div><div class="line">        p.add(sizeToFit(elm: <span class="string">"self.<span class="subst">\(id)</span>"</span>))</div><div class="line">        p.<span class="keyword">left</span>(.height).rightType(.pt).rightId(cId).<span class="keyword">right</span>(.height).add()</div><div class="line">        <span class="keyword">switch</span> fl.viewPt.horizontalAlign &#123;</div><div class="line">        <span class="keyword">case</span> .center:</div><div class="line">            p.<span class="keyword">left</span>(<span class="type">HTNMt</span>.<span class="type">WgPt</span>.center).<span class="keyword">right</span>(.center).add()</div><div class="line">        <span class="keyword">case</span> .<span class="keyword">left</span>:</div><div class="line">            p.<span class="keyword">left</span>(.<span class="keyword">left</span>).<span class="keyword">right</span>(.<span class="keyword">left</span>).add()</div><div class="line">        <span class="keyword">case</span> .<span class="keyword">right</span>:</div><div class="line">            p.<span class="keyword">left</span>(.<span class="keyword">right</span>).<span class="keyword">right</span>(.<span class="keyword">right</span>).add()</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            ()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;).mutiEqualStr</div></pre></td></tr></table></figure></p>
<p>完整代码在这里：<a href="https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/H5Editor/H5EditorObjc.swift" target="_blank" rel="external">https://github.com/ming1016/HTN/blob/master/HTNSwift/HTNSwift/H5Editor/H5EditorObjc.swift</a></p>
<p>PS：最近在一个公司分享时有人希望推荐下 iOS 相关的博客，当时我推荐了孙源的博客，其实孙源也推荐过一个博客，当时由于地址没记住没有说出来，现在推荐给大家：<a href="https://www.mikeash.com/" target="_blank" rel="external">https://www.mikeash.com/</a> 他的twitter：<a href="https://twitter.com/mikeash?lang=en" target="_blank" rel="external">https://twitter.com/mikeash</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近项目开发一直在使用 swift，因为 HTN 项目最近会有另外一位同事加入，所以打算对最近涉及到的一些技术和自己的一些想法做个记录，同时
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</title>
    <link href="http://ming1016.github.io/2018/01/24/why-swift/"/>
    <id>http://ming1016.github.io/2018/01/24/why-swift/</id>
    <published>2018-01-24T09:14:03.000Z</published>
    <updated>2018-01-25T05:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章主要是为了给组内要做的分享准备内容。这段时间几个项目都用到 Swift，在上次 GIAC 大会上就被问到为什么要用 Swift，正好这个主题可以聊聊 Swift 的哪些特性吸引了我。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>先来个例子看下泛型是解决什么问题的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nations = [<span class="string">"中国"</span>, <span class="string">"美国"</span>, <span class="string">"日本"</span>]</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showNations</span><span class="params">(arr : [String])</span></span> &#123;</div><div class="line">    arr.<span class="built_in">map</span> &#123; str <span class="keyword">in</span></div><div class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(str)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先定一个字符串数组，然后把里面的字符串打印出来。这里的 map 写法还可以优化下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arr.<span class="built_in">map</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>那么还能做什么优化呢。将 showNations 的入参数组泛型以支持多类型，比如 [int]，[double] 等。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">showArray</span>&lt;T&gt;<span class="params">(arr: [T])</span></span> &#123;</div><div class="line">    arr.<span class="built_in">map</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span>) &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出泛型能够很方便的将不同类型数据进行相同操作的逻辑归并在一起。</p>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>先看下我的 HTN 项目里状态机的 Transition 结构体的定义<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HTNTransition</span>&lt;<span class="title">S</span>: <span class="title">Hashable</span>, <span class="title">E</span>: <span class="title">Hashable</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">let</span> event: <span class="type">E</span></div><div class="line">    <span class="keyword">let</span> fromState: <span class="type">S</span></div><div class="line">    <span class="keyword">let</span> toState: <span class="type">S</span></div><div class="line">    </div><div class="line">    <span class="keyword">init</span>(event: <span class="type">E</span>, fromState: <span class="type">S</span>, toState: <span class="type">S</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.event = event</div><div class="line">        <span class="keyword">self</span>.fromState = fromState</div><div class="line">        <span class="keyword">self</span>.toState = toState</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的 fromState，toState 和 event 可以是不同类型的数据，可以是枚举，字符串或者整数等，定义 S 和 E 两个不同的泛型可以让状态和事件类型不相同，这样接口会更加的灵活，更容易适配更多的项目。</p>
<p>大家会注意到 S 和 E 的冒号后面还有个 Hashable 协议，这就是要求它们符合这个协议的类型约束。使用协议的话可以使得这两个类型更加的规范和易于扩展。</p>
<p>Swift 的基本类型 String，Int，Double 和 Bool 等都是遵循 Hashable 的，还有无关联值的枚举也是的。Hashable 提供了一个 hashValue 方法用在判断遵循协议对象是否相等时用。</p>
<p>Hashable 协议同时也是遵守 Equatable 协议，通过实现 == 运算符来确定自定义的类或结构是否相同。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>在协议里定义的关联类型也可以用泛型来处理。比如我们先定义一个协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HTNState</span> </span>&#123;</div><div class="line">    associatedtype <span class="type">StateType</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: StateType)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用非泛型的实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">states</span>: <span class="title">HTNState</span> </span>&#123;</div><div class="line">    <span class="keyword">typealias</span> <span class="type">StateType</span> = <span class="type">Int</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: Int)</span></span> &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>采用泛型遵循协议可以按照下面方式来写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">states</span>&lt;<span class="title">T</span>&gt;: <span class="title">HTNState</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> item: T)</span></span> &#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样关联类型也能够享受泛型的好处了。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>但是在使用关联类型的时候需要注意当声明一个使用了关联属性的协议作为属性时，比如下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stateDelegate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">var</span> state: <span class="type">T</span></div><div class="line">    <span class="keyword">var</span> delegate: <span class="type">HTNState</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会提示 no initializers 的错误，接着会提示 error: protocol ‘HTNState’ can only be used as a generic constraint because it has Self or associated type requirements 。意思是 HTNState 协议只能作为泛型约束来用，因为它里面包含必需的 self 或者关联类型。</p>
<p>那么该如何处理呢？这里需要通过类型擦除来解决，主要思路就是加个中间层在代码中让这个抽象的类型具体化。实际上在 Swift 的标准库里就有类型擦除很好的运用，比如 AnySequence 的协议。</p>
<h2 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h2><p>函数，扩展和关联类型都可以使用 where 语句。where 语句是对泛型在应用时的一种约束。比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">stateFilter</span>&lt;FromState:HTNState, ToState:HTNState&gt;<span class="params">(<span class="number">_</span> from:FromState, <span class="number">_</span> to:ToState)</span></span> <span class="keyword">where</span> <span class="type">FromState</span>.<span class="type">StateType</span> == <span class="type">ToState</span>.<span class="type">StateType</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个函数就要求他们的 StateType 具有相同类型。</p>
<h2 id="泛型和-Any-类型"><a href="#泛型和-Any-类型" class="headerlink" title="泛型和 Any 类型"></a>泛型和 Any 类型</h2><p>这两个类型看起来很相似，但是一定要小心两者的区别。他们区别在于 Any 类型会避开类型的检查，所以尽量少用最好不用。泛型一方面很灵活一方面也很安全，下面举个例子感受下两者的区别：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span>&lt;T&gt;<span class="params">(<span class="number">_</span> input: T)</span></span> -&gt; <span class="type">T</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> input;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">anyAdd</span><span class="params">(<span class="number">_</span> input: Any)</span></span> -&gt; <span class="type">Any</span> &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    <span class="keyword">return</span> input;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两个函数都是可以允许任意类型的 input 参数，不同在于返回的类型在 anyAdd 函数里是可以和入参不一样的，这样就会失控，在后续的操作中容易出错。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先来了解下集合的基本概念，首先集合是泛型的比如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> stateArray: <span class="type">Array</span>&lt;<span class="type">String</span>&gt; = [<span class="string">"工作"</span>,<span class="string">"吃饭"</span>,<span class="string">"玩游戏"</span>,<span class="string">"睡觉"</span>]</div></pre></td></tr></table></figure></p>
<p>集合它需要先有个遍历的功能，通过 GeneratorType 协议，可以不关注具体元素类型只要不断的用迭代器调 next 就可以得到全部元素。但是使用迭代器没法进行多次的遍历，这时就需要使用 Sequence 来解决这个问题。像集合的 forEach，elementsEqual，contains，minElement，maxElement，map，flatMap，filter，reduce 等功能都是因为有了 Sequence 的多次遍历。</p>
<p>最后 Collection 概念是因为 Sequence 无法确定集合里的位置而在 Sequence 的基础上实现了 Indexable 协议。有了 Collection 就可以确定元素的位置，包括开始位置和结束位置，这样就能够确定哪些元素是已经访问过的，从而避免多次访问同一个元素。还能够通过一个给定的位置直接找到那个位置的元素。</p>
<p>以上描述如下图：<br><img src="/uploads/why-swift/01.png" alt=""></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Swift 里有个简单的 AnyIterator<element> 结构体<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnyIterator</span>&lt;<span class="title">Element</span>&gt;: <span class="title">IteratorProtocol</span> </span>&#123; </div><div class="line">	<span class="keyword">init</span>(<span class="number">_</span> body: @escaping () -&gt; <span class="type">Element</span>?)</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></element></p>
<p>AnyIterator 实现了 IteratorProtocol 和 Sequence 协议。通过下面的例子我们来看看如何使用 AnyIterator ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">stateItr</span> : <span class="title">IteratorProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> num:<span class="type">Int</span> = <span class="number">1</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>?&#123;</div><div class="line">        num += <span class="number">2</span></div><div class="line">        <span class="keyword">return</span> num</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNext</span>&lt;I: IteratorProtocol&gt;<span class="params">( elm: I)</span></span> -&gt; <span class="type">AnyIterator</span>&lt;<span class="type">I</span>.<span class="type">Element</span>&gt; <span class="keyword">where</span> <span class="type">I</span>.<span class="type">Element</span> == <span class="type">Int</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">var</span> l = elm</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(l.next()</span> ?? 0)"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="type">AnyIterator</span> &#123; l.next() &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">findNext(elm: findNext(elm: findNext(elm: stateItr())))</div></pre></td></tr></table></figure></p>
<p>首先是定义个遵循了 IteratorProtocol 并实现了 next 函数的类。再实现一个 AnyIterator 的迭代器方法，这样通过这个方法的调用就可以不断的去找符合的元素了。</p>
<p>这里有个对 where 语句的运用，where I.Element == Int。如果把这句改成 where I.Element == String 会出现下面的错误提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Playground execution failed:</div><div class="line"></div><div class="line">error: MyPlayground.playground:18:37: error: cannot invoke &apos;findNext(elm:)&apos; with an argument list of type &apos;(elm: stateItr)&apos;</div><div class="line">findNext(elm: findNext(elm: findNext(elm: stateItr())))</div><div class="line">                                    ^</div><div class="line"></div><div class="line">MyPlayground.playground:11:6: note: candidate requires that the types &apos;Int&apos; and &apos;String&apos; be equivalent (requirement specified as &apos;I.Element&apos; == &apos;String&apos; [with I = stateItr])</div><div class="line">func findNext&lt;I: IteratorProtocol&gt;( elm: I) -&gt; AnyIterator&lt;I.Element&gt; where I.Element == String</div><div class="line">     ^</div></pre></td></tr></table></figure></p>
<p>编译器会在代码检查阶段通过代码跟踪就发现类型不匹配的安全隐患，这里不得不对 Swift 的设计点个赞先</p>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>上面的迭代器只会以单次触发的方式反复计算下个元素，但是对于希望能够重新查找或重新生成已生成的元素，这样还需要有个新的迭代器和一个子 Sequence。在 Sequence 协议里可以看到这样的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">    <span class="comment">//Element 表示序列元素的类型</span></div><div class="line">    associatedtype <span class="type">Element</span> <span class="keyword">where</span> <span class="type">Self</span>.<span class="type">Element</span> == <span class="type">Self</span>.<span class="type">Iterator</span>.<span class="type">Element</span></div><div class="line">    <span class="comment">//迭代接口类型</span></div><div class="line">    associatedtype <span class="type">Iterator</span> : <span class="type">IteratorProtocol</span></div><div class="line">    <span class="comment">//子 Sequence 类型</span></div><div class="line">    associatedtype <span class="type">SubSequence</span></div><div class="line">    <span class="comment">//返回 Sequence 元素的迭代器</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">makeIterator</span><span class="params">()</span></span> -&gt; <span class="type">Self</span>.<span class="type">Iterator</span></div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>重新查找靠的是这个新的迭代器，而对于切片这样的会重新生成新 Sequence 的操作就需要 SubSequence 进行存储和返回。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>对 Sequence 进行进一步的完善，最重要的就是使其具有下标索引，使得元素能够通过下标索引方式取到。Collection 是个有限的范围，有开始索引和结束索引，所以 Collection 和 Sequence 的无限范围是不一样的。有了有限的范围 Collection 就可以有 count 属性进行计数了。</p>
<p>除了标准库里的 String，Array，Dictionary 和 Set 外比如 Data 和 IndexSet 也由于遵循了 Collection 协议而获得了标准库了那些集合类型的能力。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在泛型的第一个例子里我们就看到了 map 的使用，我们看看 map 的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(<span class="keyword">Self</span>.Generator.Element)</span></span></span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>]</div></pre></td></tr></table></figure></p>
<p>这里 (Self.Generator.Element) -&gt; T 就是 map 闭包的定义，Self.Generator.Element 就是当前元素的类型。</p>
<h2 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h2><p>二维数组经过 flatmap 会降维到一维，还能过滤掉 nil 值。下面看看 Swift 源码（swift/stdlib/public/core/SequenceAlgorithms.swift.gyb）中 flatmap 的实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><span class="comment">// flatMap()</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns an array containing the concatenated results of calling the</span></div><div class="line">  <span class="comment">/// given transformation with each element of this sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use this method to receive a single-level collection when your</span></div><div class="line">  <span class="comment">/// transformation produces a sequence or collection for each element.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In this example, note the difference in the result of using `map` and</span></div><div class="line">  <span class="comment">/// `flatMap` with a transformation that returns an array.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let numbers = [1, 2, 3, 4]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let mapped = numbers.map &#123; Array(count: $0, repeatedValue: $0) &#125;</span></div><div class="line">  <span class="comment">///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let flatMapped = numbers.flatMap &#123; Array(count: $0, repeatedValue: $0) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In fact, `s.flatMap(transform)`  is equivalent to</span></div><div class="line">  <span class="comment">/// `Array(s.map(transform).joined())`.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameter transform: A closure that accepts an element of this</span></div><div class="line">  <span class="comment">///   sequence as its argument and returns a sequence or collection.</span></div><div class="line">  <span class="comment">/// - Returns: The resulting flattened array.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span></div><div class="line">  <span class="comment">///   and *n* is the length of the result.</span></div><div class="line">  <span class="comment">/// - SeeAlso: `joined()`, `map(_:)`</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> transform: <span class="params">($&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.$&#123;<span class="type">GElement</span>&#125;] &#123;</div><div class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.$&#123;<span class="type">GElement</span>&#125;] = []</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns an array containing the non-`nil` results of calling the given</span></div><div class="line">  <span class="comment">/// transformation with each element of this sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use this method to receive an array of nonoptional values when your</span></div><div class="line">  <span class="comment">/// transformation produces an optional value.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// In this example, note the difference in the result of using `map` and</span></div><div class="line">  <span class="comment">/// `flatMap` with a transformation that returns an optional `Int` value.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let mapped: [Int?] = possibleNumbers.map &#123; str in Int(str) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, nil, nil, 5]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let flatMapped: [Int] = possibleNumbers.flatMap &#123; str in Int(str) &#125;</span></div><div class="line">  <span class="comment">///     // [1, 2, 5]</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameter transform: A closure that accepts an element of this</span></div><div class="line">  <span class="comment">///   sequence as its argument and returns an optional value.</span></div><div class="line">  <span class="comment">/// - Returns: An array of the non-`nil` results of calling `transform`</span></div><div class="line">  <span class="comment">///   with each element of the sequence.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span></div><div class="line">  <span class="comment">///   and *n* is the length of the result.</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> transform: <span class="params">($&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</div><div class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</div><div class="line">        result.append(newElement)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出打平的原理是将集合中所有元素都添加到另外一个集合里。在第二个 extension 里通过 if let 语句会挡住那些解包不成功的元素。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>Reduce 是编程语言语义学里的归约语义学，也叫累加器。下面同样可以看看 Swift 源码里对其的实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><span class="comment">// reduce()</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</div><div class="line">  <span class="comment">/// Returns the result of combining the elements of the sequence using the</span></div><div class="line">  <span class="comment">/// given closure.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// Use the `reduce(_:_:)` method to produce a single value from the elements</span></div><div class="line">  <span class="comment">/// of an entire sequence. For example, you can use this method on an array</span></div><div class="line">  <span class="comment">/// of numbers to find their sum or product.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// The `nextPartialResult` closure is called sequentially with an</span></div><div class="line">  <span class="comment">/// accumulating value initialized to `initialResult` and each element of</span></div><div class="line">  <span class="comment">/// the sequence. This example shows how to find the sum of an array of</span></div><div class="line">  <span class="comment">/// numbers.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">///     let numbers = [1, 2, 3, 4]</span></div><div class="line">  <span class="comment">///     let numberSum = numbers.reduce(0, &#123; x, y in</span></div><div class="line">  <span class="comment">///         x + y</span></div><div class="line">  <span class="comment">///     &#125;)</span></div><div class="line">  <span class="comment">///     // numberSum == 10</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// When `numbers.reduce(_:_:)` is called, the following steps occur:</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// 1. The `nextPartialResult` closure is called with `initialResult`---`0`</span></div><div class="line">  <span class="comment">///    in this case---and the first element of `numbers`, returning the sum:</span></div><div class="line">  <span class="comment">///    `1`.</span></div><div class="line">  <span class="comment">/// 2. The closure is called again repeatedly with the previous call's return</span></div><div class="line">  <span class="comment">///    value and each element of the sequence.</span></div><div class="line">  <span class="comment">/// 3. When the sequence is exhausted, the last value returned from the</span></div><div class="line">  <span class="comment">///    closure is returned to the caller.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// If the sequence has no elements, `nextPartialResult` is never executed</span></div><div class="line">  <span class="comment">/// and `initialResult` is the result of the call to `reduce(_:_:)`.</span></div><div class="line">  <span class="comment">///</span></div><div class="line">  <span class="comment">/// - Parameters:</span></div><div class="line">  <span class="comment">///   - initialResult: The value to use as the initial accumulating value.</span></div><div class="line">  <span class="comment">///     `initialResult` is passed to `nextPartialResult` the first time the</span></div><div class="line">  <span class="comment">///     closure is executed.</span></div><div class="line">  <span class="comment">///   - nextPartialResult: A closure that combines an accumulating value and</span></div><div class="line">  <span class="comment">///     an element of the sequence into a new accumulating value, to be used</span></div><div class="line">  <span class="comment">///     in the next call of the `nextPartialResult` closure or returned to</span></div><div class="line">  <span class="comment">///     the caller.</span></div><div class="line">  <span class="comment">/// - Returns: The final accumulated value. If the sequence has no elements,</span></div><div class="line">  <span class="comment">///   the result is `initialResult`.</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(</span></span></div><div class="line">    <span class="number">_</span> initialResult: Result,</div><div class="line">    <span class="number">_</span> nextPartialResult:</div><div class="line">      <span class="params">(<span class="number">_</span> partialResult: Result, $&#123;GElement&#125;)</span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span></div><div class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span> &#123;</div><div class="line">    <span class="keyword">var</span> accumulator = initialResult</div><div class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">      accumulator = <span class="keyword">try</span> nextPartialResult(accumulator, element)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> accumulator</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到里面会通过 initialResult 来记录前面的返回结果和当前元素进行在闭包里的操作。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>看看数组的基本用法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建数组</span></div><div class="line"><span class="keyword">var</span> nums = [<span class="type">Int</span>]() <span class="comment">//创建空数组</span></div><div class="line"><span class="keyword">var</span> mArray = nums + [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>] + [<span class="number">5</span>,<span class="number">9</span>]<span class="comment">//合并多个有相同类型元素数组的值</span></div><div class="line"><span class="keyword">var</span> animals: [<span class="type">String</span>] = [<span class="string">"dragon"</span>, <span class="string">"cat"</span>, <span class="string">"mice"</span>, <span class="string">"dog"</span>]</div><div class="line"></div><div class="line"><span class="comment">//添加数组</span></div><div class="line">animals.append(<span class="string">"bird"</span>)</div><div class="line">animals += [<span class="string">"ant"</span>]</div><div class="line"></div><div class="line"><span class="comment">//获取和改变数组</span></div><div class="line"><span class="keyword">var</span> firstItem = mArray[<span class="number">0</span>]</div><div class="line">animals[<span class="number">0</span>] = <span class="string">"red dragon"</span></div><div class="line">animals[<span class="number">2</span>...<span class="number">4</span>] = [<span class="string">"black dragon"</span>, <span class="string">"white dragon"</span>] <span class="comment">//使用下标改变多个元素</span></div><div class="line">animals.insert(<span class="string">"chinese dragon"</span>, at: <span class="number">0</span>) <span class="comment">//在索引值之前添加元素</span></div><div class="line"><span class="keyword">let</span> mapleSyrup = animals.remove(at: <span class="number">0</span>) <span class="comment">//移除数组中的一个元素</span></div><div class="line"><span class="keyword">let</span> apples = animals.removeLast() <span class="comment">//移除最后一个元素</span></div><div class="line"></div><div class="line"><span class="comment">////数组遍历</span></div><div class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals &#123;</div><div class="line">    <span class="built_in">print</span>(animal)</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span> (index, animal) <span class="keyword">in</span> animals.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"animal <span class="subst">\(String(index + <span class="number">1</span>)</span>): <span class="subst">\(animal)</span>"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"> animal 1: red dragon</div><div class="line"> animal 2: cat</div><div class="line"> animal 3: black dragon</div><div class="line"> animal 4: white dragon</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<h2 id="弱引用的-Swift-数组"><a href="#弱引用的-Swift-数组" class="headerlink" title="弱引用的 Swift 数组"></a>弱引用的 Swift 数组</h2><p>Swift 里的数组默认会强引用里面的元素，但是有时候可能希望能够弱引用，那么就可以使用 NSPointerArray。它在初始化的时候可以决定是用弱引用方式还是强引用方式。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> strongArr = <span class="type">NSPointerArray</span>.strongObjects() <span class="comment">// 强引用</span></div><div class="line"><span class="keyword">let</span> weakArr = <span class="type">NSPointerArray</span>.weakObjects() <span class="comment">// Maintains weak references</span></div></pre></td></tr></table></figure></p>
<p>Dictionary 的要想用弱引用可以使用 NSMapTable，Set 对应的是 NSHashTable。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>看看基本用法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//创建 Dictionary</span></div><div class="line"><span class="keyword">var</span> strs = [<span class="type">Int</span>: <span class="type">String</span>]()</div><div class="line"><span class="keyword">var</span> colors: [<span class="type">String</span>: <span class="type">String</span>] = [<span class="string">"red"</span>: <span class="string">"#e83f45"</span>, <span class="string">"yellow"</span>: <span class="string">"#ffe651"</span>]</div><div class="line">strs[<span class="number">16</span>] = <span class="string">"sixteen"</span></div><div class="line"></div><div class="line"><span class="comment">//updateValue 这个方法会返回更新前的值</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> oldValue = colors.updateValue(<span class="string">"#e83f47"</span>, forKey: <span class="string">"red"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"The old value for DUB was <span class="subst">\(oldValue)</span>."</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//遍历</span></div><div class="line"><span class="keyword">for</span> (color, value) <span class="keyword">in</span> colors &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(color)</span>: <span class="subst">\(value)</span>"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//map</span></div><div class="line"><span class="keyword">let</span> newColorValues = colors.<span class="built_in">map</span> &#123; <span class="string">"hex:<span class="subst">\($<span class="number">0</span>.value)</span>"</span> &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(newColorValues)</span>"</span>)</div><div class="line"></div><div class="line"><span class="comment">//mapValues 返回完整的新 Dictionary</span></div><div class="line"><span class="keyword">let</span> newColors = colors.mapValues &#123; <span class="string">"hex:<span class="subst">\($<span class="number">0</span>)</span>"</span> &#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(newColors)</span>"</span>)</div></pre></td></tr></table></figure></p>
<h1 id="协议式编程"><a href="#协议式编程" class="headerlink" title="协议式编程"></a>协议式编程</h1><p>Swift 被设计成单继承，如果希望是多继承就需要使用协议。协议还有个比较重要的作用就是通过 associatedtype 要求使用者遵守指定的泛型约束。</p>
<p>下面先看看传统编程的开发模式：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackDragon</span>: <span class="title">Dragon</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteDragon</span>: <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">BlackDragon</span>().fire()</div><div class="line"><span class="type">WhiteDragon</span>().fire()</div></pre></td></tr></table></figure></p>
<p>这个例子可以看出 fire() 就是重复代码，那么首先想到的方法就是通过直接在基类里添加这个方法或者通过 extension 来对他们基类进行扩展：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这时我们希望加个方法让 Dragon 能够 fly：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dragon</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fly~~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样 BlackDragon 和 WhiteDragon 就都有这两个能力了，如果我们设计出一个新的龙 YellowDragon 或者更多 Dragon 都没有 fly 的能力，这时该如何。因为没法多继承，那么没法拆成两个基类，这样必然就会出现重复代码。但是有了协议这个问题就好解决了。具体实现如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFly</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fly~~~"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackDragon</span>: <span class="title">DragonFire</span>, <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteDragon</span>: <span class="title">DragonFire</span>, <span class="title">DragonFly</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowDragon</span>: <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PurpleDragon</span>: <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="type">BlackDragon</span>().fire()</div><div class="line"><span class="type">WhiteDragon</span>().fire()</div><div class="line"><span class="type">BlackDragon</span>().fly()</div><div class="line"><span class="type">YellowDragon</span>().fire()</div></pre></td></tr></table></figure></p>
<p>可以看到一来没有了重复代码，二来结构也清晰了很多而且更容易扩展，Dragon 的种类和能力的组合也更加方便和清晰。extension 使得协议有了实现默认方法的能力。</p>
<p>关于多继承 Swift 是采用 Trait 的方式，其它语言 C++ 是直接支持多继承的，方式是这个类会持有多个父类的实例。Java 的多继承只继承能做什么，怎么做还是要自己来。和 Trait 类似的解决方案是 Mixin，Ruby 就是用的这种元编程思想。</p>
<p>协议还可以继承，还可以通过 &amp; 来聚合，判断一个类是否遵循了一个协议可以使用 is 关键字。</p>
<p>当然协议还可以作为类型，比如一个数组泛型元素指定为一个协议，那么这个数组里的元素只要遵循这个协议就可以了。</p>
<h1 id="Swift-内存管理"><a href="#Swift-内存管理" class="headerlink" title="Swift 内存管理"></a>Swift 内存管理</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>在 Heap 上内存分配的时候需要锁定 Heap 上能够容纳存放对象的空闲块，主要是为了线程安全，我们需要对这些进行锁定和同步。</p>
<p>Heap 是完全二叉树，即除最底层节点外都是填满的，最底层节点填充是从左到右。Swift 的 Heap 是通过双向链表实现。由于 Heap 是可以 retain 和 release 所以很容易分配空间就不连续了。采用链表的目的是希望能够将内存块连起来，在 release 时通过调整链表指针来整合空间。</p>
<p>在 retain 时不可避免需要遍历 Heap，找到合适大小的内存块，能优化的也只是记录以前遍历的情况减少一些遍历。但是 Heap 是很大的，这样每次遍历还是很耗时，而且 release 为了能够整合空间还需要判断当前内存块的前一块和后面那块是否为空闲等，如果空闲还需要遍历链表查询，所以最终的解决方式是双向链表。只把空闲内存块用指针连起来形成链表，这样 retain 时可以减少遍历，效率理论上可以提高一倍，在 release 时将多余空间插入到 Heap 开始的位置和先前移到前面的空间进行整合。</p>
<p>即使效率高了但是还是比不过 Stack，所以苹果也将以前 OC 里的一些放在 Heap 里的类型改造成了值类型。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 的结构很简单，push 和 pop 就完事了，内存上只需要维护 Stack 末端的指针即可。由于它的简单所以处理一些时效性不高，临时的事情是非常合适的，所以可以把 Stack 看成是一个交换临时数据的内存区域。在多线程上，由于 Stack 是线程独有的，所以也不需要考虑线程安全相关问题。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>Swift 也有内存对齐的概念<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes</span></div><div class="line">    <span class="comment">//8 + 4</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonHomePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes + 对齐内存(4 Bytes)</span></div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="comment">//4 + 4 + 8</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> firePositionSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.size <span class="comment">//12</span></div><div class="line"><span class="keyword">let</span> homePositionSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonHomePosition</span>&gt;.size <span class="comment">//16</span></div></pre></td></tr></table></figure></p>
<h2 id="Swift-派发机制"><a href="#Swift-派发机制" class="headerlink" title="Swift 派发机制"></a>Swift 派发机制</h2><p>派发目的是让 CPU 知道被调用的函数在哪里。Swift 语言是支持编译型语言的直接派发，函数表派发和消息机制派发三种派发方式的，下面分别对这三种派发方式说明下。</p>
<h3 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h3><p>C++ 默认使用的是直接派发，加上 virtual 修饰符可以改成函数表派发。直接派发是最快的，原因是调用指令会少，还可以通过编译器进行比如内联等方式的优化。缺点是由于缺少动态性而不支持继承。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">land</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">DragonWillFire</span><span class="params">(<span class="number">_</span> position:DragonFirePosition)</span></span> &#123;</div><div class="line">    position.land()</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> position = <span class="type">DragonFirePosition</span>(x: <span class="number">342</span>, y: <span class="number">213</span>)</div><div class="line"><span class="type">DragonWillFire</span>(position)</div></pre></td></tr></table></figure></p>
<p>编译 inline 后 DragonWillFire(DragonFirePosition(x: 342, y: 213)) 会直接跳到方法实现的地方，结果就变成 position.land()。</p>
<h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>Java 默认就是使用的函数表派发，通过 final 修饰符改成直接派发。函数表派发是有动态性的，在 Swift 里函数表叫 witness table，大部分语言叫 virtual table。一个类里会用数组来存储里面的函数指针，override 父类的函数会替代以前的函数，子类添加的函数会被加到这个数组里。举个例子：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">swim</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//normal eat</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyingFish</span>: <span class="title">Fish</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="comment">//flying fish eat</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fly</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器会给 Fish 类和 FlyingFish 类分别创建 witness table。在 Fish 的函数表里有 swim 和 eat 函数，在 FlyingFish 函数表里有父类 Fish 的 swim，覆盖了父类的 eat 和新增加的函数 fly。</p>
<p>一个函数被调用时会先去读取对象的函数表，再根据类的地址加上该的函数的偏移量得到函数地址，然后跳到那个地址上去。从编译后的字节码这方面来看就是两次读取一次跳转，比直接派发还是慢了些。</p>
<h3 id="消息机制派发"><a href="#消息机制派发" class="headerlink" title="消息机制派发"></a>消息机制派发</h3><p>这种机制是在运行时可以改变函数的行为，KVO 和 CoreData 都是这种机制的运用。OC 默认就是使用的消息机制派发，使用 C 来直接派发获取高性能。Swift 可以通过 dynamic 修饰来支持消息机制派发。</p>
<p>当一个消息被派发，运行时就会按照继承关系向上查找被调用的函数。但是这样效率不高，所以需要通过缓存来提高效率，这样查找性能就能和函数派发差不多了。</p>
<h3 id="具体派发"><a href="#具体派发" class="headerlink" title="具体派发"></a>具体派发</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>值类型都会采用直接派发。无论是 class 还是协议 的 extension 也都是直接派发。class 和协议是函数表派发。</p>
<h4 id="指定派发方式"><a href="#指定派发方式" class="headerlink" title="指定派发方式"></a>指定派发方式</h4><ul>
<li>final：让类里的函数使用直接派发，这样该函数将会没有动态性，运行时也没法取到这个函数。</li>
<li>dynamic：可以让类里的函数使用消息机制派发，可以让 extension 里的函数被 override。</li>
</ul>
<h4 id="派发优化"><a href="#派发优化" class="headerlink" title="派发优化"></a>派发优化</h4><p>Swift 会在这上面做优化，比如一个函数没有 override，Swift 就可能会使用直接派发的方式，所以如果属性绑定了 KVO 它的 getter 和 setter 方法可能会被优化成直接派发而导致 KVO 的失效，所以记得加上 dynamic 的修饰来保证有效。后面 Swift 应该会在这个优化上去做更多的处理。</p>
<h2 id="基本数据类型内存管理"><a href="#基本数据类型内存管理" class="headerlink" title="基本数据类型内存管理"></a>基本数据类型内存管理</h2><p>通过 MemoryLayout 来看看基本数据类型的内存是占用多大<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.size      <span class="comment">//8</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.size    <span class="comment">//2</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.size     <span class="comment">//1</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.size    <span class="comment">//4</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.size   <span class="comment">//8</span></div></pre></td></tr></table></figure></p>
<h2 id="Struct-内存管理"><a href="#Struct-内存管理" class="headerlink" title="Struct 内存管理"></a>Struct 内存管理</h2><p>对于 Struct 在编译中就能够确定空间，也就不需要额外的空间给运行时用，运行过程调用时就是直接传地址。</p>
<p>下面我们再看看 Struct 的 MemoryLayout<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DragonFirePosition</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x:<span class="type">Int64</span> <span class="comment">//8 Bytes</span></div><div class="line">    <span class="keyword">var</span> y:<span class="type">Int32</span> <span class="comment">//4 Bytes</span></div><div class="line">    <span class="comment">//8 + 4</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">land</span><span class="params">()</span></span> &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.size       <span class="comment">//12</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.alignment  <span class="comment">//8</span></div><div class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">DragonFirePosition</span>&gt;.<span class="built_in">stride</span>     <span class="comment">//16</span></div></pre></td></tr></table></figure></p>
<p>alignment 可以看出是按照 8 Bytes 来对齐的，所以这里 struct 是用到了字节对齐，实际占用大小通过 stride 可以看出就是 8 * 2 为16。</p>
<p>如果把 var x:Int64 改成可选类型会增加 4个 Bytes，不过就这个 case 来说实际大小还是16，这个也是因为内存对齐的原因。</p>
<h2 id="Class-内存管理"><a href="#Class-内存管理" class="headerlink" title="Class 内存管理"></a>Class 内存管理</h2><p>Class 本身是在 Stack 上分配的，在 Heap 上还需要保存 Class 的 Type 信息，这个 Type 信息里有函数表，在函数派发时就可以按照这个函数表进行派发了。继承的话子类只要在自己的 Type 信息里记录自己的信息即可。</p>
<h2 id="协议类型内存管理"><a href="#协议类型内存管理" class="headerlink" title="协议类型内存管理"></a>协议类型内存管理</h2><p>协议类型的内存模型是 Existential Container。先看下面例子<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">DragonFire</span> </span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fire</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"fire!!!"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YellowDragon</span>: <span class="title">DragonFire</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> eyes = <span class="string">"blue"</span></div><div class="line">    <span class="keyword">let</span> teeth = <span class="number">48</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> classSize = <span class="type">MemoryLayout</span>&lt;<span class="type">YellowDragon</span>&gt;.size  <span class="comment">//32</span></div><div class="line"><span class="keyword">let</span> protocolSize = <span class="type">MemoryLayout</span>&lt;<span class="type">DragonFire</span>&gt;.size <span class="comment">//40</span></div></pre></td></tr></table></figure></p>
<p>这个例子里看这个结构体即遵循了这个协议而且内容还比这个协议多，而协议的 size 还要大，这个是为啥呢？这个是由于 Existential Container 的前三个 word 是叫 Value buffer 用来存储 inline 的值。第四个 word 是 Value Witness Table，存储值的各种操作比如 allocate，copy，destruct 和 deallocate 等。第五个 word 是 Protocol Witness Table 是存储协议的函数。</p>
<h2 id="泛型的内存管理"><a href="#泛型的内存管理" class="headerlink" title="泛型的内存管理"></a>泛型的内存管理</h2><p>泛型采用的和 Existential Container 原理类似。Value Witness Table 和 Protocol Witness Table 会作为隐形的参数传递到泛型方法里。不过经过编译器的层层 inline 优化，最终类型都会被推导出来也就不再需要 Existential Container 这一套了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;写这篇文章主要是为了给组内要做的分享准备内容。这段时间几个项目都用到 Swift，在上次 GIAC 大会上就被问到为什么要用 Swift，正
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Swift" scheme="http://ming1016.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GIAC 大会上分享的《Swift 将 Web 代码转成60帧满帧原生应用的方案及实践》的幻灯片</title>
    <link href="http://ming1016.github.io/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/"/>
    <id>http://ming1016.github.io/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/</id>
    <published>2018-01-10T07:31:54.000Z</published>
    <updated>2018-01-10T09:14:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/01.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/02.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/03.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/04.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/05.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/06.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/07.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/08.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/09.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/10.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/11.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/12.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/13.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/14.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/15.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/16.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/17.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/18.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/19.png" alt=""><br><img src="/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/20.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/01.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;/uploads/slides-of-g
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="iOS" scheme="http://ming1016.github.io/tags/iOS/"/>
    
      <category term="Slides" scheme="http://ming1016.github.io/tags/Slides/"/>
    
  </entry>
  
  <entry>
    <title>花野</title>
    <link href="http://ming1016.github.io/2018/01/04/huaye/"/>
    <id>http://ming1016.github.io/2018/01/04/huaye/</id>
    <published>2018-01-04T11:27:32.000Z</published>
    <updated>2018-01-04T11:31:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/huaye/01.png" alt=""></p>
<p>早上七点半闹钟响起，我皱眉闭眼伸手去把床头柜上的闹钟关掉。昨晚睡前看电视剧看多了，我决定再眯一会，意识模糊的又呼呼过去，怎的刚才梦里那蛇又追过来了，眼看要一口要咬到我的大腿了，我居然给吓醒了，呼！算了，反正再睡又要被蛇咬，看看时间，呀，八点了，还有半个小时就要出门上班了，我赶紧起身双脚插上拖鞋双手抓住后面头发扎起辫子，挽起双手袖子赶着弄早点吃，来到厨房发现垃圾老公又忘带出去，都说处女座心细，我怎么瞧不出。</p>
<p>穿上我的小西装直奔到我们小区门口亿达房产售楼处。</p>
<p>“小琴，今儿又是掐着点到呢，真羡慕你们住的近的”我隔壁同事王潘凑过来说道。</p>
<p>“我三十三，你二十四，以后别叫我小琴小琴的了。”</p>
<p>“秦琴，对哦，都三十了快当大妈年纪了，结婚也有七年了吧，怎么还不生个娃啊，看着小区里这么多小青年的娃娃一个个都长的这么大了。虽然你看起来是普通了点，哦，该不会是您老公没兴趣跟你做那事吧。”</p>
<p>我随便应付了两句就开始坐下开始准备工作了。</p>
<p>是啊，结婚也十年了，我也确实是不够漂亮，但绝对不是王潘说的那样。说起来还是要怪我那不挣钱的老公，我怕孩子生下来养不起。</p>
<p>“你们小区房最大多少平的。”</p>
<p>这位客户身穿白色小西装修长身材乌黑长发正用左手摘下墨镜右手按着我的桌上问我话。我急忙从发呆状态中回过神来。</p>
<p>“哦，我们这最大的是大三居，两厅两卫，一百五十平的，你等等，我查查看看还有几套。”边说着我边在电脑上的亿达数据管理后台里检索着。</p>
<p>“这样，你看，一共一千七百五十万，这里有户型图你先看看，等会我再带你去看看房。这户型现在只有最后一套了。”我熟练的用手指着屏幕示意让她来看。当然不管是谁都说是最后一套这个是我们行业的标准行话。</p>
<p>“不用了，我先交定金定下吧。”</p>
<p>这位富婆麻利的交完定金就开着她的宾利车走了。我站在店门口叹了口气。</p>
<p>隔壁王潘走过来望了望外面又望了望我说：“这主子够爽快的，这么年轻就这么有钱，肯定是被哪个男的给包养了。”</p>
<p>“我只是觉得她挺漂亮的。”</p>
<p>话虽这么说，其实这样的客户确实少见，买房这事哪个主不是考虑考虑再考虑的。连我这么一个事不关己高高挂起的非八卦人士也对这富婆好奇起来。</p>
<p>几个月后，我带着疲惫的身躯和沙哑的嗓子迎着月光下班。路过小区的一处滑滑梯时忽然看见那富婆正在挣脱一名身材高大年轻男人，一时好奇，同时为了不引起富婆的注意，我悄悄坐到一旁长木椅上，假装跟其他妈妈一样拿起手机，看似陪着孩子在外面溜着玩。滑滑梯这块孩子太多特别是傍晚这个点。富婆和那男的之间的对话我听的也不是很清楚。这时微信朋友圈娜娜发了个题为“十四年后，同学的美国女儿和我的中国女儿有怎样的差异”的文章，这个标题党文章引起我的兴趣，我尽然读了进去。</p>
<p>“小琴，你在这里等谁呢？”</p>
<p>我一惊，看富婆正坐在我身旁仔细打量着我呢。</p>
<p>“哦，没等谁，坐着休息会，看看手机来着。”我勉强的笑了笑</p>
<p>“这次买房真是麻烦你了，帮着我跑前跑后的。”</p>
<p>“没什么，这个是我的工作嘛，应该的。”其实她这活比其他人轻松多了，其他人那问长问短的麻烦死了。</p>
<p>富婆名叫林月珍，丈夫是非常著名的索土唱片公司的大老板，这段时间里帮着她弄房子的事情，知道了她是因为和他丈夫闹矛盾才分居的，什么矛盾我没问她也没说。</p>
<p>此时我发现月珍一直看着我没有说话，嘴角带着一丝丝的笑意，好像看出了些什么似的，弄得我都有些心虚了，微微的低下了头。</p>
<p>“我知道，你看见我跟一个男的拉拉扯扯的才坐在这的吧。”月珍继续盯着我。</p>
<p>“我……”</p>
<p>“他不是我先生。”</p>
<p>“那他是？”</p>
<p>“你一定是在想这又是一个只有貌美和年轻的女子嫁给了一个事业有成的老男人，在家寂寞空虚没地位，于是出轨找年轻帅气男子求安慰的俗气故事吧。”</p>
<p>“没有，我没有这个意思。”我急忙摇手示意。</p>
<p>“如果我说事情就是这样的呢。”</p>
<p>“咦！真是这样！”</p>
<p>“看，你就是这样想的。”月珍转过头，眼光看着前方，一下子眼神变得忧郁起来，微风吹着她黑黑的长发飘落在长长的睫毛上，她伸手将头发撘到后面说道：“其实不是这样的。”</p>
<p>气氛沉寂下来，其实我很想知道为什么但是也没有去问，我不希望我看起来很八婆。</p>
<p>“对了，明天我家有个派对，记得来哦。”月珍突然转移了话题。</p>
<p>“恩，一定。”</p>
<p>次日。我如约来到她家。来了后我就后悔了，派对上我的衣服是最差，我那地摊上买的包包我真恨不得把它塞到墙缝中。通过观察我发现月珍的朋友差不多都是娱乐圈和房产圈的人，跟他们完全没有话题，聊了几句我就一个人躲到一旁吃点心去了。</p>
<p>“小琴，来，我给你介绍下，这位是你们亿达集团总裁蒋星的儿子蒋启泽先生。”月珍拍了下我的肩膀说道。</p>
<p>我放下手中的点心，下意识的双手在衣服上擦了擦，站了起来，抬起头看见蒋启泽穿着一身白色西装，打着黑色领带，高挑的鼻梁，白净清秀的脸，威严的双眼蕴藏着一点含蓄期待的着我。要不是月珍说他是亿达集团总裁的公子，我还以为他是哪个明星来着。</p>
<p>“这位是就是我刚才说的秦琴，你们先聊着，我去招呼下其他人。”月珍将我介绍完就离开了。</p>
<p>我跟蒋启泽相互打了招呼就一起坐了下来。坐在这么一个有钱，高个又帅气的男人旁边，想着他身边坐着一个这么普通的我，一股自卑感狂袭过来。</p>
<p>“我在这个小区售楼处上班，也算是你父亲集团的一名小卒子了。”我忙找了个话题。</p>
<p>“嗯，这个我知道了，林月珍先跟我说了，她还说你帮了她很多忙，叫我以后多关照下你。”他说着，眼神严肃，并没有看我。</p>
<p>也是，我有什么好看的。派对结束后，感觉好累，回到家中，老公已经睡着，我躺在床上闭上双眼，我只是个普通的售楼小姐，难道还期待着什么吗？而且我也是有老公的人了。</p>
<p>一周后，我来到售楼处，发现蒋启泽站在门口。</p>
<p>“秦琴，你今天迟到了，下次要注意了。”他突然冒出了这句。</p>
<p>“咦，你怎么到这来了。”</p>
<p>这时王潘跑了过来，把我往旁边一拉告诉我说蒋启泽现在要来接管我们售楼处。</p>
<p>“遵命，长官，下次我一定注意。”我半开玩笑着说到，也不知怎么的，我突然觉得心情好了很多，难道是因为他吗。</p>
<p>每当我从他座位经过时，总是感觉背后他在注视着我，不知道我这种自恋的信心是从哪来的。他作为领导是成功的，这几个月我们的业绩明显提升了，我觉得这跟他的身份和魅力是分不开，我们售楼处女性居多，别管老的年轻的，结婚没结婚的都很喜欢他，当然也包括了我。</p>
<p>“我发现你变漂亮了。蒋启泽挺不错吧。”在小区一亭子里月珍一脸坏笑的看着我。</p>
<p>“是你叫他来这的？”</p>
<p>“我可没有这么大能耐能请得动，他转到这来我也是大吃一惊呢。”月珍坏笑的越发明显了，她接着说道：“他放着亿达总部的事不做来到一个小小售楼处当个领班，我真好奇那天派对上你跟他聊了什么呢。”</p>
<p>我摇了摇头。他第一天来这上班，其他人都到了他却一直站在门口，是因为在等我。不，不，这怎么可能。</p>
<p>晚上，老公早早就躺在了床上，我爬到他上面，笑眯眯的问他：“你觉得我最近有什么变化吗？”</p>
<p>“没看出来。”</p>
<p>“太不关注我了，别人都说我漂亮了呢。”</p>
<p>“没觉得，不过看起来是比以前要更开心了，对我也比以前要好了，别人说出轨的女人就是这样的。”龙炎一本正经的说。</p>
<p>“是啊，谁叫你上次对我父母不好了。我现在找了个大帅哥来慰藉我受伤的心灵。不理你了”我一把将枕头打到他的头上，拉上被子背对着他睡下了。</p>
<p>龙炎也是淡定居然没有啃声。我心有不甘，又不想主动探究。</p>
<p>“上次是谁对谁不好了。”沉寂了半天龙炎终于说话了，可是上来就是这句。</p>
<p>“我知道我父亲有不对的地方，但是你看看你的态度，太不成熟了。”我回道。上次我父亲和他父亲因为意见不合出现了分歧，我父亲言语间轻视了龙炎的父亲，龙炎就让我父亲回去，后来连着几天都没有理我们。</p>
<p>“我就是不成熟，我知道你爸瞧不起我也瞧不起我家人。”感觉这事是戳中了龙炎的痛点，屋子里灯光已关但还是能看见他眼角亮着泪光。他性子很脆弱，家庭很普通，人很努力，结婚前看他雄性壮志的挺看好他的。可这些年来在他的音乐事业上一直也没有突破，感觉再这样下去也不是办法，只能我自己多努力了。想着每天我忙死忙活的想多挣些钱，忙得那么晚回家就看见他呼呼睡，心里就来气。</p>
<p>“不服气，你就努力让我爸瞧得起啊。”我这句话声音有点大了，龙炎可能看出我生气了，也没有再回我。其实现在想想当初要不是我看上了他，像他这样的性格估计现在都还找不到女朋友。</p>
<p>因为昨晚被龙炎气的，上班都没有好心情，这就是所谓的家庭的牵绊吧，成家后就没法活的洒脱了。除非找对了人。到了公司发现蒋启泽还没有来，一般他都是很早到的，我爱睡懒觉总是来得晚。</p>
<p>“你这失魂落魄的是怎么了？”这是王潘例行每天都要凑过来点评下我一天开始的状态。</p>
<p>“没什么，家里琐碎事。”</p>
<p>“你们家那个大音乐家又让你生气了？”八卦女就是八卦女，一猜就准。</p>
<p>“我怎么感觉不是呢。”王潘把我无精打采的头往她那面一扭，说道：“我看你一直盯着蒋总那边看，是不是奇怪为啥他今儿没来。”</p>
<p>“对，他为什么今天没来。”我突然来劲了。</p>
<p>“就说嘛，我看这段时间你的心早就不在大音乐家那了。整天偷看蒋总。”</p>
<p>“去！”我把王潘往旁边一推。</p>
<p>“下面的消息可能会让你失望了，听说蒋总回去了，能不能回来还不一定呢。回去干嘛我可不知道，你不要问我。”王潘一边挥着手一边离开去干活了。</p>
<p>是谁让蒋启泽回去的，他爸？哎，比起我们这个小小的分部他们的事那不知道要重要多少倍。现在我都还不清楚为什么他要到我们这里做领班。可能是他爸想让他历练历练，看他做的不错又叫他回去了？</p>
<p>接下来的日子就不好受了，每天看到蒋启泽空空的位置就会觉得心也空空的。这样的心情发生在我这样一个少妇的身上也真够呛的。我又不是少女了怎么还会有这样的感觉。想想我少女时也没有过这种感觉，可能没有遇到蒋启泽这样的人吧。</p>
<p>过了一个月，还没有蒋启泽的消息，我开始紧张了，想着可能他是不是不会回来了，我只想能够每天看下他就好，也没有什么其它的奢望。他在时的感觉真是很好，他的为人处世稳重而又不失活泼，魅力四射，感染着团队每个人，真的很希望他能够再回来。我是不是有些自私了。</p>
<p>“你们那情况怎么样？”我收到到蒋启泽的一条手机消息。</p>
<p>“还行，不过完成这个月销售额还是有风险。”</p>
<p>“我下周二回来，一起努力完成这个月任务吧。”</p>
<p>“嗯，好的。”</p>
<p>“挺想能够快些回来。”</p>
<p>“我们也很想你，快些回来吧。”发完这条消息，我开心的从沙发上蹦了起来，手拿靠枕左右摇摆扭着屁股。</p>
<p>砰，门开了，龙炎一脸阴沉走进家门。</p>
<p>“今天工作怎样？”我努力想用我好的心情去感染下龙炎，于是热情开心的对他说。</p>
<p>“工作丢了。”</p>
<p>我的脸一下拉了下来，心想肯定是他那又坏又倔的脾气惹老板生气了。</p>
<p>“这次又是什么原因？”我严厉的问他。</p>
<p>“他不让我弹我自己的曲子，说难听。”</p>
<p>“那你就弹他们喜欢的曲子呗，男子汉能屈能伸，我们家现在这个情况有什么不能够先放一放，先把这个家稳定了呀。你这样三天两头的换工作，日子怎么过，我还想要个小孩呢。你就不能为了我做些牺牲吗？每天关在工作室里，都这么晚回，这么多年没有事业也没有朋友，像这样什么时候才是头。”</p>
<p>“我就是这性格，改不了了。”</p>
<p>本来刚好起来的心情全给毁掉了。</p>
<p>蒋启泽回到公司后可以看得出不止我一个人兴奋不已，就连王潘都凑上去将自己精心准备的礼物送给他，看来他回来之前是跟每个人都说了一个遍。过了一段时间，蒋启泽要带他夫人和孩子去度假，不过这次我看着他那空空的位置一点都没有担心的感觉，因为这次终究是能回来的。</p>
<p>年终时公司年会上，有个合影环节，蒋启泽主动过来要求跟我合影，合影时他紧紧的靠着我，我脑海中浮现出一个微博上看到的那种女粉丝和男影星合影的画面。年会时的一些其它环节蒋启泽也是全程陪着我，我们一起玩了抓娃娃，夹玻璃球，跳舞毯等等一些娱乐项目。</p>
<p>春天到了，又到了大家一起拓展的时候，大巴上小船长拓展公司的培训师们就开始陪着我们玩游戏了。来到目的地，这次拓展的地方选择是一处四面环山，北面山壁下还有条浅河，分完房间放好行李，大伙来到一个广场开始了分队。一共三队，我们组自个起了个很霸气的名字镶黄旗，教官分旗子时我们领的是黄旗，因为最大的头蒋启泽在我们这队，而镶黄旗是满族由皇帝亲自来统领的上上旗。接着蒋启泽还在黄旗四周涂上红色颜料，中间画上了一条黑龙让使看起来更像镶黄旗。</p>
<p>在做第一个拓展时我们三个队就开始较劲了，感觉大家那股子劲一下子就调动了起来，连我也有了些集体存亡感，只可惜这第一个项目猜图考的是记忆和知识，我这平时就只喜欢备着面巾纸看肥皂剧的主，智力和知识含量皆缺对这个项目也只能是有心而无力了。</p>
<p>午饭后在房间休息到三点，开始了我们期待的水上竞技项目。这个项目就跟电视上的那个一样，我想着这下可以好好看看大家怎么掉下水出丑了，当然理想总是丰满性感的，现实却是跟我一样骨感。</p>
<p>比完水上竞技后，我发现河边有一排竹筏，于是取掉挂岸绳一脚踏了上去，坐在船尾竹椅上拿起竹竿准备撑杆起舵。这时竹筏突然左侧一斜，水浪往上一溅。我抬头看见蒋启泽正双手平伸努力着掌握平衡。</p>
<p>“嗨，这竹筏可真够不稳的。”他说。待竹筏平稳后，他继续说道：“你这一身湿的，怎么也不跟他们一起回房间换身衣服。”</p>
<p>“你不也是。”</p>
<p>“我哪，我不是看你要玩这竹筏就来陪陪你。”说着，他将包里带的浴巾取出走到我身边将它披在了我的身上。</p>
<p>“你真细心，还想着带这个。”</p>
<p>“习惯了。不过你今天够呛的，别人最多掉水个一两次吧，看你爬几步就要掉一次。我都不忍心看下去了。”</p>
<p>他一副怜悯的眼色看着我，我也无所谓了，反正从小我就缺乏体育细胞。</p>
<p>“还好有你，三分钟就到了终点，教官都说其它公司也很少有人能够达到这个成绩，猜图六个来回就全中了，我们这组的这两个第一你是头功，不愧是队长。不像我，估计是日本肥皂剧看多了，越看越笨。”</p>
<p>“看美剧是练脑子，看韩剧是意淫，看国产剧就想着千万千万可不要结婚啊，否则以后的婆婆分分钟整死你。”</p>
<p>“哈哈。”我忍不住捂着嘴巴笑起来。“那日剧呢？”</p>
<p>“日剧……看日剧会觉得生活美好。所以秦琴你肯定是个纯真善良的好姑娘。”</p>
<p>“还纯真，还姑娘呢，我结婚都7年了。”明明听着挺开心的。</p>
<p>“我也结婚了，不也有人说我像小伙子嘛。”</p>
<p>“你本来就像个小伙子，一个乳臭未干的小伙子。”</p>
<p>“好哇，这样说你上司，看我怎么收拾你。”他坏笑着使脚用力一跺。</p>
<p>这突然的失衡，我一下子掉到水中，他也跟着跳到水中，水不深只到我腰间，蒋启泽一手扶着我的肩，一手在我头发和脸上擦着，我双眼一直看着他的眼睛。</p>
<p>害羞内敛，若即若离，水中，冷静的双眼，欲拒还迎的诱惑，被湿身的身体，等待着咬下禁忌的果实……我伸出手抱住了他，仰头闭上了双眼。</p>
<p>他推开了我，连同着我的心也被他用力地推得远远的。</p>
<p>我爬上竹筏撑杆滑向岸，夕阳逆光下的湖面映射出我无地自容的脸，是我太飘飘然了，没法保证自己不会出轨，不管是精神上的还是身体上的，小说亦或电视剧中可歌可泣的爱情故事当然存在，只是对于我这样普通又敏感的人，身体里爱情欲望的火苗一旦被强烈的异性荷尔蒙点燃，就会燃烧出巨大的火焰。</p>
<p>晚上烧烤时，我坐在位置上发呆，想将自己的行为抹去，厌恶着自己。</p>
<p>“来，吃点我烤的鸡翅，烤的人太多了，好不容易抢了个位置烤。”王潘一手拿着一根一手将一盘鸡翅放在了桌上，贴近我的耳朵悄悄的说：“我看见了哦。”</p>
<p>“看见什么了。”我斜眼看了她一眼。</p>
<p>“别装了，划竹筏那会。”</p>
<p>“那又怎么了。”</p>
<p>“唉，我说你啊，缺少女性魅力，我可是说真的，你就不能打扮打扮，穿得时尚些。这些男人不管结婚的没结婚的都喜欢有魅力有味道的女人，总想着征服想要的女人，你一定要明白，这样才能让男人有欲望。不过，你就是长得太一般般了。”</p>
<p>“喂！”</p>
<p>王潘说完又拿着一个空盘子去烧烤了。虽然她这样说还是很难过，但是能让我松了口气，愚蠢难堪的我让他讨厌了，这样就不用再有期待了。</p>
<p>这段时间蒋启泽和我的亲近让我忘乎所以，仔细想想他对每位同事都很好，对我有时候会特别点可能是因为我一直以来我的业绩比其他人要好点吧，所谓上司对下属的感情投资无非就是这样。我还傻傻的期待着那些成人童话的情节，我好蠢。</p>
<p>拓展第二天是要进行上山寻宝游戏，其实就是比看哪个队能够先到山顶。由于要求是全队成员都到达才算赢，所以沿路的风景谁都无暇顾及，生怕自己会拖全队的后腿。</p>
<p>昨晚没有睡好，平时也没有锻炼，山路走了一半不到就已经气喘吁吁，满脸汗滴，低头迈着蹒跚的步子渐渐落到队伍的最后，我几乎打算放弃了，想要坐在路边石头上休息。</p>
<p>前面一只手向我伸来，抬头刺眼的阳光下逆光着他高大的黑影。我抓住他，他巨大的手紧紧的握着我。</p>
<p>他是出于队长的责任还是昨日的愧疚都不再重要，看着他手臂上的汗水和他宽大的背影，我只想和他能够多呆一会。</p>
<p>来到山顶的一颗大树下，他用手拂过我的头发，轻轻拭去我未干的汗水：“你知道我为什么会调到这里来的吗？”</p>
<p>“不知道。”我装作疑惑的表情。</p>
<p>“你知道。”他说。树荫阳光交辉晒在他英俊帅气的脸上，他温柔地看着我说：“还不是因为你。”</p>
<p>“我，这么平凡，为什么？”</p>
<p>“第一次看到你就觉得你很亲切，那么朴素，和我身边那些人完全不一样。”</p>
<p>我脸唰的一下子就红了起来，和昨晚的心情对比如同过山车一样。说：“看来你这富家公子山珍海味吃多了，有时也想换换我这样粗俗大妈类型的口味。”</p>
<p>“我也不知道为什么，每次看到你时我都觉得你需要我，体内充满了无限的力量，让我有想做更好自己的欲望。”</p>
<p>“那你的夫人不需要你吗？”</p>
<p>“你不要提她，可以吗？”他伸手捂住了我的嘴，然后慢慢放下。</p>
<p>他为难的看着我，低下了头说道：“我很迷茫，我对这样的关系一直都很害怕。”</p>
<p>燃烧的火焰，不实际的妄恋，待我回过神来时已进退两难，葬身火海，我不想去伤害谁，也不愿背叛任何人，可能你会觉得那不是爱，只是冲动的欲望。</p>
<p>“不过。”他转向我，双手握住我的肩，说：“我已经无法回头。”</p>
<p>弯腰抱住我，湿润的唇舌交融一起。说实话，我想和他一直这样，明明我还没有做好与伦理道德为敌的准备。他是有妇之夫，我是有夫之妇，我知道我们不能这样亲密，绝对不行，此时我脑海里没有出现我老公。一想到我的心不再如平静般的湖水，就会感到无比难受。但是，即便如此，我也还是……一下下就好，想被他拥抱，我就知足，不希望更多，我一直是这样的想着，但是，在他怀中时，我也紧紧的抱住了他，想要更多，在我心里还有一个我。我知道是我依恋，除非是这火焰燃烧尽，不然我没法死心，对这过眼云烟的恋情，对温柔体贴的他死心。</p>
<p>余光中我仿佛看到远处有人在看着我们，我不禁探头望去。</p>
<p>“怎么了？”他问。</p>
<p>“我感觉有人在那边看。”</p>
<p>蒋启泽也往那边看了看，说道：“看你紧张的，做贼心虚吧。”</p>
<p>“你不也是。”我说。</p>
<p>是啊，其他人怎么看我们，恋人，还是夫妻，不，都不是，我们这样的关系存在对于他们都是不可原谅的。不过，我现在很幸福，前所未有的幸福。</p>
<p>下山路上，太阳盘旋在山脊上面，阳光照耀在山间密树林的枝叶上，野鸟的鸣叫，小溪潺潺声，前面拐角处蒋启泽跟队友们拿着我们的镶黄旗在等着我，他微笑就像清凉的微风将我汗水和疲劳吹去，我跑向队伍，跑向他。</p>
<p>拓展结束后回到售楼处，龙炎在那里等着我回家，我将蒋启泽和我老公互相做了介绍就回了家。</p>
<p>自那以后，无论是工作中还是在家里，他一直在我脑海里，期待着每天上班能和他见面，幻想里，我能够在旁人面前对他撒娇，戏弄他，欺负他，无拘无束开心的让人无法相信。有了这些感觉，才会有更好的心情，用更好的微笑面对自己的老公。这就是所谓的因自知理亏而对丈夫和家会更好吧。</p>
<p>这天，我又迟到，不过蒋启泽没在门口，平日只要是我迟到他必定会站着等我来。我将包放到桌上，往他的办公室望去，发现里面有一个陌生男子。过了一会那陌生男子召集我们大家开了会，这才得知蒋启泽调回了总部。手一软笔直接掉到本子上。</p>
<p>我们说到底就是偷情，如果被家人和周围的人知道了，这辈子就晚了，如今他知道要回头，那他还是幸福的。偷情是一种背叛家人伤害周围的人异于通常的肮脏淫乱的欲望，涉足后就无法找到出口，也没有返回的可能，它是能够摧毁所有禁忌之果，它与我终究无缘。</p>
<p>回到家里，坦白说我不想做饭，是因为他？是，只是想到以后见不到面就让我没法动弹，他温柔的声音还在我的耳边萦绕。感觉自己就要被燃烧成灰烬，我最终没有能够成为被人唾弃的坏女人。</p>
<p>这时门铃响起，我打开门发现是林月珍，她依然还是那么光鲜夺人，穿着石色Heritage Trench风衣，手中挂着Jaune Vif色鳄鱼皮Be Dior手提包。</p>
<p>“我听蒋启泽说了，他可能不会再回来了。”</p>
<p>我招呼着她进来，默默的没有说话。</p>
<p>“看来是的了。你跟他那个了？”</p>
<p>我摇了摇头。</p>
<p>“那接吻了？”她问。</p>
<p>我点了点头。</p>
<p>“这个蒋启泽也是的，只是接个吻就跑了。”月珍看着我无神的双眼，用手揪了揪我的脸，说道：“你不要担心，他会这样做，说明他对你是认真的，不然他不会因为想得更远而害怕。他缺乏的是让你们一起面对的决心。”</p>
<p>“你还这么说，你的家庭不就是因为第三者才弄成这样的么，你还希望我充当这样的角色。”</p>
<p>“谁告诉你我跟丈夫分居是因为这个。”她一下子激动起来，过了一会，她又平静的说：“只是一个误会，现在我们好了，今天我也是来告诉你我马上要搬回我丈夫那了，儿子还等着他妈妈呢。”</p>
<p>“那太好了，恭喜你们的复合，不过就是可惜以后就很难再看到你这样有魅力的人妻了。”</p>
<p>月珍不好意思的轻推了我一下说：“还有，周末我们会去草原给一个新签约的很有前途的歌手做庆祝，你们家也一起去吧，我还有好多话想跟你聊呢。”</p>
<p>“好啊。”</p>
<p>我也有好多话想跟她说，也只能跟她说了。</p>
<p>晚上，龙炎回到家中，看桌上没有饭菜，他放下他背上的吉他包，自己走向厨房开始做吃的。</p>
<p>“你怎么不问我为什么没有做饭。”我说。</p>
<p>“我来做吧。”他说。</p>
<p>“你周末有空吗？”我问。</p>
<p>“没有，周末我还有个演出。”</p>
<p>“每次都这样，等会吃完了，龙炎你是又要去房间写歌吧，早上我还没醒你又要去你那工作室了吧。天天写，天天弹，天天唱，你是个机器吗？每次都说还在努力，努力了这么多年还是这样，你说你不行吧，对我也就这样，我到底为什么嫁给了你。”</p>
<p>我怎么会这样，将被抛弃后的急躁都发泄到了龙炎身上，但是为什么我觉得还有个人能够让我发泄真好，难道夫妻之间就是因此而存在的吗？</p>
<p>但是龙炎并没有反驳我什么，他总是这样，他只要他的音乐就够了，人在哪方面满足了，就会对其它方面不屑一顾。而我，就好像怨妇一样。</p>
<p>一个吻无论有多炙热，也终需归于平静。</p>
<p>这次来草原打算来清空下自己。</p>
<p>傍晚，一辆大巴停在我们篝火旁，车下来四五个人，走近，我仔细瞧见是龙炎和他们乐队的人。我拉着身边的月珍走了过去。</p>
<p>“龙炎，你怎么也来这了。”我说。</p>
<p>“哦。”龙炎看了眼我身旁的月珍，停顿了下，接着说：“我是来这里表演的。就是那晚我跟你说的那个演出。”</p>
<p>“这样啊。哦对了，我忘记做介绍了，这个是我老公，叫龙炎，一眼就能看出是做音乐的。”接着我神气的向龙炎指了指月珍，说：“这个就是我跟你提过的那位客户林月珍，怎么样，很漂亮吧。”</p>
<p>龙炎看向月珍，月珍却侧过脸去，面带为难。</p>
<p>“咦，看的好认真啊，是不是都有点后悔早结婚了。不过呢，你可不要乱想，人家白富美可是不会看上你的。”我说。</p>
<p>“小琴，龙炎不是那样的人。”月珍说。</p>
<p>“你又不了解他，怎么这么肯定。”我说。</p>
<p>“你们慢聊，我去工作了。”龙炎说完就去搬乐器了。</p>
<p>我和月珍坐在草地上看着龙炎他们在篝火对面忙着摆放，调着音，天色已黑。</p>
<p>“我从小就是很受欢迎的那种人。”月珍说道。她头仰起看着夜晚的星空继续说道：“我承认，美丽的女人在人生上会有很多优势，像我就得到了几乎所有女人都渴望得到的。但是太完美的生活，反而让我没有了食欲。每天起床睁开眼到晚上躺下闭上眼，我的生活不过是不断的重复前一天的事情而已，没有任何激情可言。三十多岁却已经像一百多，几乎能够看到下一个三十年后的自己。我们都是如此，不安时渴望安全感，安稳时却又想着浪迹天涯。一个女人厌倦了乏味而不愿放弃是因为已经习惯，但是习惯永远无法击败新鲜感带来的刺激。”</p>
<p>月珍看了看我说：“我也和你一样对一个已婚男子动心，但是却没有你那么幸运。他对我始终止步于普通朋友。他落魄野性和冷漠，就像一匹销魂的孤独草原狼，还有一副整个世界都欠了他的样子真是深得我心。结婚前我交过很多男朋友，觉得初恋般的第一口是比第二第三口好吃的，新鲜的比陈的好吃，热的比凉的好吃，但是却发现没吃过的才是最好吃的。”</p>
<p>“还有会对月珍你都不动心的男人，我还真想见见呢。”我说。</p>
<p>“哈哈。那人你天天都能见到”月珍笑着说。</p>
<p>我天天能见到的人…</p>
<p>“不会是？”当然我会想到龙炎。</p>
<p>“恩，是的。你知道吗？他签约我们唱片公司了，他的第一盘专辑一定会大卖，虽然他是因为我才被我爱人发掘到的，但是最终还是靠的他自己的才华才得到了这次机会。但是你放心，你老公从来没有对我的追求有过任何反应，我现在对他也已经死心了。”她说。</p>
<p>“蒋启泽也知道你跟龙炎的事情？”我问。</p>
<p>“对，我跟他说过，以前龙炎的表演他也看过。”</p>
<p>“什么时候说的。”</p>
<p>“一个月前吧。怎么了？”</p>
<p>一个月前，那不是在比上次拓展更早，之后他见过我和龙炎一起，当时我还介绍了他是我老公。难道他避开我是因为龙炎，都说第三者越是对涉足家庭另一方越了解负罪感就会越强烈，上次在山上他也不希望我问他老婆的事情就是最好的证明。我仿佛明白了蒋启泽离开的原因了。</p>
<p>表演开始了，自从我和龙炎结婚以来他的演出我一场也没有再看过。今儿坐在宽广的草地上听着他自己写的歌有种回到大学的感觉，他在台上还是和那时一样，一副所有事情都和自己无关却完全沉浸在自己音乐的表情。</p>
<p>那时就是这样一个总是若无旁人的男孩却在我自习时突然出现在门口把我叫了出去，说他每次见到我都会心跳不已。</p>
<p>随着表演的进行，我发现他的歌比以前更好听了，越来越专业和世俗了，他还是对生活妥协了。我好像看到了他的成长和付出的回报。</p>
<p>表演结束，龙炎走到我身边说：“本来准备回家跟你说这事的。”</p>
<p>他靠近我胸前，贴近我，双手将我抱住，闭上双眼，仿佛疲倦的斗士在我耳边说：“生个孩子吧，我想让他也玩音乐。”</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/huaye/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;早上七点半闹钟响起，我皱眉闭眼伸手去把床头柜上的闹钟关掉。昨晚睡前看电视剧看多了，我决定再眯一会，意识模糊的又呼呼过去，怎的刚才梦里那蛇又追过来了，眼看要一口要咬到我的大腿了，我
    
    </summary>
    
      <category term="My novel" scheme="http://ming1016.github.io/categories/My-novel/"/>
    
    
      <category term="Novel" scheme="http://ming1016.github.io/tags/Novel/"/>
    
  </entry>
  
  <entry>
    <title>白芈</title>
    <link href="http://ming1016.github.io/2018/01/04/baimi/"/>
    <id>http://ming1016.github.io/2018/01/04/baimi/</id>
    <published>2018-01-04T11:24:38.000Z</published>
    <updated>2020-05-24T01:17:39.624Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/uploads/baimi/01.png" alt=""></p>
<p>“你过线了！”我说。</p>
<p>“过了怎么了！”</p>
<p>“你这个猪，占这么大的位置！”</p>
<p>“你个猴，瘦不拉几的，要那么大位置干嘛！”</p>
<p>类似这样的对话几乎每天都会有，这天更是一发不可收拾。同桌余敏推了我一下，我耐不住心中的烦闷，接着就是一脚朝她肚子那里踢过去。她连同着椅子一起滑倒到侧对面一排桌子里，结果，她哭了。</p>
<p>在办公室。</p>
<p>“西陵，你是男生，跟女生打架算什么本事。”老师说。</p>
<p>“是她先推我的。”</p>
<p>“她说是你骂她猪，哪有这样侮辱同学的，待会去跟她道歉，听到没？”</p>
<p>“西陵，你在看什么，我问你话你听到没。”</p>
<p>我看着窗外，窗外树枝在风中吱吱的响着，我讨厌老师，讨厌她把我调到后面跟余敏同桌。窗外传来课间休息时的喧闹声，我往更远处的操场方向看去，看到了旗杆，还有旗杆下的大讲台，发现白芈站在大讲台边上。我立刻起身手扶窗檐伸颈望去。</p>
<p>“喂，你到底在看什么？”老师继续问。</p>
<p>“哦。”我转过身来，说：“我在看外面是不是下雨了。”</p>
<p>“这大晴天的下什么雨。算了，你走，先出去，以后要是我再听说你欺负余敏就叫你爸妈过来。”</p>
<p>老师低着头示意我出去。</p>
<p>放学了，我赶着去街机厅玩游戏，经过大讲台时，突然一个声音叫住了我。</p>
<p>“怎么样，不跟我同桌很没意思吧。”</p>
<p>我没有抬头，我知道是白芈，这声音我太熟悉了。我没有回答，低着头慢慢的走开了。</p>
<p>白芈是我跟余敏之前的同桌，因为白芈比较瘦小，我也很瘦，所以我们是坐在前几排离黑板很近。白芈她是四年级中途转学过来的，我应该算是这里她的第一个同桌了，一开始我们就很谈得来。我从小就是属于那种很不爱说话的人，但是和她总有讲不完的话，上课时也是小声偷偷的聊天。</p>
<p>有一次爸爸给我买了一个挂在胸前的黄色表，白芈特别喜欢，我就送给了她。但是，没多久，由于我们总是上课讲悄悄话，我就被调到了后排跟余敏同桌了。</p>
<p>没跟白芈同桌的日子我总觉得缺少什么，想念和她同桌的那段时间。可能是这个原因，于是把心中的压抑发泄到了余敏身上。</p>
<p>到了六年级，临近小学毕业了。一堂课上我困意十足，于是右手托着半个脸庞，蒙蒙半睁眼间，发现十一点钟方向的白芈正趴着桌上脸朝后看着我，这样一直看着我，我跟她对视了很久。下课后我跑到单杠那一个人开心的拉着引体向上，拉着拉着回想起来刚才的情景，心想会不会是梦，上课时我是睡着了吗？</p>
<p>“什么事情这么高兴呢？”哥们程亮问我。</p>
<p>“没什么！”我继续拉着我的引体向上。</p>
<p>“是跟你喜欢的女孩有关吧。”</p>
<p>“我没有喜欢的女孩。”我假装一脸不屑的说。</p>
<p>“我看一本书上说一个人三岁后就会有喜欢的异性了，经过研究证明了的，无不例外，不要骗我了，跟我说说是谁？”程亮坏笑着问我</p>
<p>“那你就是承认你三岁就有喜欢的人咯。”我反问。</p>
<p>“那当然，那会我就喜欢我们钢琴老师了，现在喜欢我们班长，快说说你的。”程亮倒是挺大方的。</p>
<p>“嗯…”我还是比较犹豫，总感觉这心里的小秘密说出来挺不好意思的，陈亮喜欢班长倒是不奇怪，我感觉班上怎么说都有一大半男生都会喜欢她，以前也跟班长同桌过，不过因为合不来用铅笔戳了她的手，后来被她老哥给揍了一顿。</p>
<p>“我跟她同桌过，我就说这么多。”我努力想避开这个问题。</p>
<p>“你同桌过那么多人，我怎么知道是谁。我都跟你说了我的，你还不愿意告诉我，没意思。”</p>
<p>程亮慢慢靠近我，一只手挡住我的耳朵悄悄跟我说：“我看今天白芈找你留联系方式和家庭地址时脸都是红的，你们俩不会有什么吧。”</p>
<p>“不是大家都留了吗？要不是你们在旁边乱起哄说什么让我写的详细点怕找不到那些话，她会脸红吗？”</p>
<p>“她可没有让我们留，她都是找的女生留的，就你一个男生，不然我们怎么会开这个玩笑，看来是她对你有意思哦。对了，她也跟你同桌过，我还记得那天她刚跟你同桌的那一天。你专门跑过来问我觉得白芈是不是很漂亮。我觉得我猜的没错。”</p>
<p>我无话可说，程亮居然还记得两年前的事，不过这两年我觉得我应该是喜欢白芈的，虽然我们都没有怎么说过话。</p>
<p>初中时，我和白芈读了不同的学校，但是每当我经过小学或者碰到和白芈一个学校的小学同学时都会想起和她同桌时的画面和那次对视的情景来。</p>
<p>在初中的生活中我加入了校足球队，业余生活慢慢充实起来，我的身体渐渐趋于细长型，脸部轮廓也越来越清晰，为校队争取到四强后，全校同学基本都认识了我，好几次我在马路边走时，对面一群女生叫着我的名字。</p>
<p>虽然平时的训练很辛苦，回到家基本就是倒头就睡那种，不过在冲凉和睡前的那一小会我还是会时不时的想起白芈。</p>
<p>一天中午比赛完后我来到教室后面的树林子里乘凉发现白芈跟现在和我同班的我们的小学同学林薇聊着什么，她看到我来了后匆匆跟林薇道别就离开了，一句话也没跟我说，好像刻意避开我一样。白芈走后，林薇一边哭一遍朝教室那边走去，见势我急忙上去问她：“发生什么事情了？”</p>
<p>“没什么，不关你的事，你不要管。”</p>
<p>我觉得奇怪又好奇，看到林薇哭的这么伤心，心想会不会是她喜欢的小学同学喜欢别人了，然后白芈过来告诉她了。但是这个又不大好意思在这个时候八卦，于是想转移话题，说：“白芈怎么过来了？”</p>
<p>林薇看我一直跟着她问这问那，擦着眼泪不耐烦的回答道：“来找你的行吧。”</p>
<p>“找我干嘛！”</p>
<p>“喜欢你不行啊。”说完转身跑开了。</p>
<p>其实这就是我想要听到的吧，但是心里明明知道林薇这样回答我是很明显的敷衍，想想要是真的来看我的话怎么看到我就走了，而且是一看到我就低头跑开，况且林薇哭是什么意思啊。但是即使是这么明显的敷衍的话，我却还希望是真的啊。</p>
<p>一天梦中，我梦见在我在书店门口碰见了白芈，她没有看见我，我们插肩而过。结果第二天我去书店时，在门口真的碰见了她，这画面跟梦里一模一样。</p>
<p>在后面的日子一共碰见过好几次，有时是在另外一个书店，有时是在路上，不过基本上都是我看到她，她好像都没看到我。说起来真的很神奇，我基本没有在外面碰到过除了白芈以外的同学，可是却能够看到她好几次，这究竟是缘，还是只因为我太关注她。</p>
<p>最后的一次碰面，也是我们初中以来唯一和最后一次交谈，虽然只有那么短短的一句话。</p>
<p>那天我在书店挑完书准备结账，这时正巧白芈也在那结账。</p>
<p>“白芈！你也在这买书？”我问道。</p>
<p>“是啊，我经常来这。”</p>
<p>接着就是一阵长长的沉默，她低着头，我也低着头，我总想说点什么，却总是欲言又止，眼睛不知道看何处。想想以前小学时我们欢快的聊天画面，现在的我们如同陌生人一般保持着距离。这时，她的右手臂碰到了我的左手臂，我本来就很紧张，这下更加紧张了，我没有挪开手，只希望她是不小心碰到的然后移开。可是她没有挪开，她会是和我有一样的有所顾及吗？我能明显感觉到她的颤抖，不过我根本没法去多想些什么，因为我的上身也在抖动着，一只腿突然也软了下来，我只得用我的右手臂搁在收账台上做支撑。白芈结完帐先离开了，我才慢慢的恢复过来。</p>
<p>再后来，我当了老师，一直没见过白芈。一开始总盼望能够再次见到她，后来渐渐的也就不再有想见的想法了，慢慢的把她藏在自己心里和自己融为了一体。</p>
<p>许多年过去了，我也做过很多其他事情，有过低落有过风光，但心里却渐渐平静起来。</p>
<p>这天我习惯性的来到一家书店找书看，在一栏打折书上发现一本封面是一个黄色的儿童表的书，这个表看起来跟以前我叔叔送我的那个表很像，于是我就随手翻起这本短篇小说集子的目录来，翻到次页，突然，我发现有篇名字叫做“西陵的表”，西陵， 这不是我的名字吗？接着我直接翻到那一页读了起来。里面写到：</p>
<p>“这年，我的父亲又换一份工作，我跟母亲随着他一起搬到那个厂子的附近。这次的房子更小了，父亲每天回到家都看起来很憔悴，母亲三天两头都会跟他吵，多半都是埋怨父亲的无能吧。</p>
<p>那时我刚读完小学三年级，即将来到一个陌生的学校面对陌生的同学，我从小就不爱说话，心里充满着对未知的恐惧。上学的第一天，我见到了我的同桌西陵，他是一个很乖很腼腆的男生，看到了他，我心里感觉踏实了很多，于是我总想着找他说话，开始时，西陵总是低着头简单的回复我几句，后来我发现每次其他同学带玩具到班上来时他都会凑过去看，于是我就问他喜欢什么动画片和玩具，他一谈起这些就像变了个人似的滔滔不绝，看着他说着某某角色怎样怎样厉害的兴奋的表情，我总觉得特别的羡慕。</p>
<p>西陵说他爸妈管的严，动画片不让他看，他就偷偷的看，然后他爸妈也不跟他买玩具。但是尽管这样，西陵从来都不抱怨他爸妈，他总是乖乖的，感觉就像只温顺的小猫，每次跟我讲话或对视时都是腼腆的低着头。</p>
<p>有天他带着一个黄色的表过来，我看那个表特别可爱，在上课时就伸手去拿那个表玩，西陵突然从颈子上取下表递给我说送给我了。这应该是我收到的第一个男生送的礼物了吧。</p>
<p>一次上课时我问西陵这个表的右侧那个按键是做什么用时，他接过手边对我解释边示范，这时被老师发现了，第二节课班主任就把他换到了后排。</p>
<p>西陵被换到后面去后，我经常在下课的时候听见他跟他的新同桌余敏对骂，我想他是怎么了，跟我同桌时那个害羞温顺的男孩怎么了。是因为我吗？会是因为跟我分开不开心还是觉得我害他被换到了后排心里有气，当然我是宁愿是前者了。</p>
<p>就在西陵跟余敏发生冲突被老师叫到办公室批评的那天，一放学我就早早跑出教室站在大讲台的边沿上等西陵，当西陵经过时，我很想确定他的想法，但是我不希望他是怪我，于是我就满怀希望的急忙上前问他是不是因为没有跟我同桌而觉得没有意思。问完，只见西陵一直低着头也没有看我一眼就这样走过去了。当时我的心立即由热转凉，看着他低着头离开的背影，有些筹措，心里特别后悔那次课上找他讲话。</p>
<p>正是夏日当头，中午时分总是令人困乏。下午的第一节是地理课，是我不喜欢的一门课，我毫无精神的趴在桌上将书立了起来正好挡住我的头。我习惯的朝五点钟方向看了去，只见西陵右手托着脸正看着我，他一脸疲乏，面无表情，他的眼睛一直看着我，我有点无从适从，却又表现的很平静，我想这是个机会我跟他道歉。于是我没有出声，用嘴型说出了对不起，但是西陵显然太困了，当我说完他已经趴在桌上睡了。</p>
<p>小学的生活就这样结束了。</p>
<p>初中因为西陵父亲的原因，他进入了我们那最好的初中，跟他一起进入那个初中还有另外一个小学同学林薇，也是我们的大美女班长，而我跟着大部分小学同学去了附近的一所初中。</p>
<p>初中后我就经常到他们学校找林薇，这个起因是林薇很喜欢以前一个小学同学程亮，程亮也很喜欢林薇，但是在不同学校后一旦有些不愉快就不是那么方便解决了，所以呢，小两口一闹矛盾程亮就找我让我帮着说说好话什么，林薇也是，如此以来我就是和事佬两头帮着说好话。他们俩毕竟当时还小，经不起风浪，以前还好，天天能够在一起，现在好了，难得碰面，而且一碰面就斗嘴。</p>
<p>说实在的，大部分时间他们都在生对方的闷气。</p>
<p>这天，程亮让我帮他传个话，说以后不跟林薇见面了，就算是分手吧。</p>
<p>我来到林薇那，说是有个非常重要的事情要告诉她，哪知道林薇早就猜到了，然后她问我他是不是喜欢其他女生，我当然说没有了，其实也是真没有。哪知道林薇哼哼了几声，说肯定是我和程亮好了，我听到这里当然生气了，想着这段时间为了他们的事情跑前跑后，虽然我是自愿帮这个忙的。</p>
<p>但是我帮他们一是为了朋友，同时也是有点小私心了。跟西陵不在一个学校后，我一直想多了解点他的情况，每次我都会以关心老同学的口气向林薇询问西陵的情况。</p>
<p>为了消除林薇的猜忌，我对她说我跟程亮只是好朋友，他也不是因为我才跟她分手的。林薇依旧不信，她说程亮说人懂事时就会有喜欢的人，不然就是不正常的，如果要让她相信我，除非我告诉她我现在喜欢谁。我当时有些尴尬，我不是很想把我的想法告诉她，但是如果不说的话，这个误会会越来越深，我只好跟她说了实话，说我每次跑到这其实是希望了解西陵现在的情况，希望能够在这看到西陵。</p>
<p>我刚说完这话。</p>
<p>西陵突然在林薇身后出现了。我当时一惊，害怕西陵听到刚才我说的话，急忙低下头，匆匆的跟林薇道了下别就跑掉了。</p>
<p>一路上，我的脸一阵一阵的发热，我也不知道西陵到底有没有听到我说的话。如果他听到了他会怎么想，这些我都不敢想。在看到他的那一瞬间，我发现他比小学时更高了，脸庞轮廓更加清晰了，更俊美了。真的像林薇说的，西陵刚到初中就被选入校队，每次的练习赛中，由于西陵的表现很出色，而且外形气质属于忧郁冷静型的，导致他特别受女生的欢迎，还有很多高中的女生也会跑来为他加油。</p>
<p>林薇和程亮分手后，我常常一个人来到西陵他们学校的操场边看西陵他们练习足球。有次我去看了会他们的练习，然后我就到他们学校附近一个书店买书。</p>
<p>刚买完书出门时，正好碰到西陵进门，我担心他会问起我为什么到他们学校这买书，我头也没抬就这样快速的走出了书店。</p>
<p>跟他擦肩而过的瞬间我的余光看到他的手臂和腿部的汗水，泥土和伤痕，脑海里浮现起他跟我们校队的那场比赛，浮现出西陵在那场比赛中不停的奔跑，长传出的漂亮弧线球，铲断，大力的射门，浮现出西陵训练时认真的模样，浮现出我们校队队员训练时懒散的模样。</p>
<p>后来我就经常的到他们学校附近的书店看书，这样我就能够经常碰见他了。日复一日的浸泡在书店中，渐渐的我对看书和写作的兴趣也越来越高，这就是为什么日后我把写作当作了我一辈子的事业来做的原因。</p>
<p>和他最后的一次碰面，我正在买书结账时，忽然旁边出现一个高大的身影，双手把手中的书放到桌上，双眼看着我，叫了我的名字。</p>
<p>我抬头看见是西陵，突然间的很想说很多话，可能是我太在乎他了，不知道他现在会不会还是跟小学时那样亲切，我只说我是经常来这里。西陵还是和小学时那样腼腆的笑了笑然后低下了头，一下子，我也不知道说些什么，只得也低下了头。</p>
<p>书店的老板正在清算我的书，时间虽然很短，但是对于我来说实在太漫长了，我有点窒息的感觉，一不小心我的手臂靠在了西陵的手臂上，我没有立刻挪开，但是精神的过度紧张让我的身子颤抖起来，这时我发现西陵的手臂也在抖动，难道他也紧张吗？我不由的往他那看过去，只见他满脸通红一直红到脖子上。</p>
<p>那以后，父亲所工作的厂子倒闭了，不得不又换到另外一个地方，就这样我离开了和西陵一起过的地方。</p>
<p>再大些了后，我和其他女人一样嫁了人，生了小孩。</p>
<p>但是，西陵送我的表我还一直挂在胸前，即使它已经失去了光泽，陈旧，没法显示时间，即使我已经变成了老女人，我依旧带着它。每当看到它或想到它在胸前，我都会回想起西陵，都会回想起小学中和西陵同桌的时光。</p>
<p>西陵！你知道吗，自从你送我这块表后，我都一直带着它，那时我就爱上了你，一直到现在，会到永远。”</p>
<p>看完，我心情无比复杂，本来已经平静的心开始骚动起来，泪水早已把书纸弄湿。</p>
<p>“你好，我叫白芈。你叫什么名字啊？”</p>
<p>“西陵。”</p>
<p>“西陵，我是刚转过来的。”</p>
<p>“刚才老师不是介绍过么。”</p>
<p>我偷偷看了她一眼，白芈很瘦，瓜子脸，高高鼻梁，清澈的眼睛。她发现我在看她，也笑着看着我，我不好意思的转过头，不过眼睛余光还能看到她还在继续看着我笑。</p>
<p>漫步在小学里，虽然教学楼都翻新了个遍，但是那个大讲台依旧留在那里，我站在当时白芈站的地方下面，白芈的身影渐渐出现，仿佛她一直在等着我回答她：“没能跟你同桌真的很没有意思”。</p>
<p>“白芈，我很想再跟你同桌，我很想。。。”我伸出手准备去牵她下来，但泪水已经滴滴嗒嗒不住的落在了手臂上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/uploads/baimi/01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;“你过线了！”我说。&lt;/p&gt;
&lt;p&gt;“过了怎么了！”&lt;/p&gt;
&lt;p&gt;“你这个猪，占这么大的位置！”&lt;/p&gt;
&lt;p&gt;“你个猴，瘦不拉几的，要那么大位置干嘛！”&lt;/p&gt;
&lt;p&gt;类似这
    
    </summary>
    
      <category term="My novel" scheme="http://ming1016.github.io/categories/My-novel/"/>
    
    
      <category term="Novel" scheme="http://ming1016.github.io/tags/Novel/"/>
    
  </entry>
  
  <entry>
    <title>在滴滴，我是如何指数级提升开发技术的？</title>
    <link href="http://ming1016.github.io/2017/10/24/how-do-i-improve-the-development/"/>
    <id>http://ming1016.github.io/2017/10/24/how-do-i-improve-the-development/</id>
    <published>2017-10-24T11:16:27.000Z</published>
    <updated>2017-10-24T11:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何提升开发技术的方法很多，比如专注，刻苦，热情，兴趣等，不过我这里不会提这些，下面想说的是我觉得能够指数级提升的窍门和一些自己在求索路上的一些体会，也算是一个阶段性的总结吧。趁着今天是程序员节，给大家做个分享，希望对需要的同学有用。</p>
<h2 id="窍门一，将代码放到-GitHub-上"><a href="#窍门一，将代码放到-GitHub-上" class="headerlink" title="窍门一，将代码放到 GitHub 上"></a>窍门一，将代码放到 GitHub 上</h2><p>看到这个标题一般人的反应就是觉得自己的代码和那些高大上的开源库比起来相形见绌，有种拿不出手的感觉。但是要想提高技术，是提高自己的技术，只要和自己比就好了。将代码发出来不是献丑而是为了交流，交流就会获得信息，都说信息时代科技进步都是指数级，这个道理在这里也同样适用。</p>
<p>记得以前我特别喜欢 Google 做的 Google Reader，每天打开电脑第一件事器就是浏览下关注的那些 RSS Feeds，自己定制的信息流和 Google Reder 对信息的完整保留，体验上轻松的标记已读和全部已读，当时是再也找不出替代品了。在 Google 关闭这个服务后很长一段时间我都没有看过 RSS，转向使用 Twitter 和后来的微博来关注自己感兴趣的内容，比如国内的一些插画家，漫画家，游戏媒体，Cosplay 当然还有一些感兴趣的相关开发的人。</p>
<p>后来，我发现关注微博的人多了后，一些好的博客内容很容易被埋没在 timeline 中。这个时候我发现了 Reeder 这个 RSS 阅读器 APP，体验做得非常棒，不光是 UI 设计和交互，还有应用的流畅度，离线浏览等体验都是顶级的。我打算也弄一个学习下，就跟小学时喜欢七龙珠就模仿着画一样。实现基本几个功能后我就发到了 GitHub 上，结果碰到了好几个也喜欢 RSS 的开发者，他们看我在 README.md 里提到了后面计划做的事情，分别提了 PR 完成了那些功能，还有一个把界面翻天覆地的改了一通，还加了 icon 和启动图，最后还加上了两个主题选择，还修改了好几处代码不规范和不合理的地方，我 review 完就知此人设计和代码功底都很深，对这样一个艺术和程序完美结合的人佩服不已。</p>
<p>后来这个项目让我认识了不少的朋友，在他们提交的代码里我也学习到了很多。</p>
<h2 id="窍门二，选择优秀同事"><a href="#窍门二，选择优秀同事" class="headerlink" title="窍门二，选择优秀同事"></a>窍门二，选择优秀同事</h2><p>和优秀同事共事利于成长这是个显而易见的道理，但我为什么还要单拎出来说呢。因为这个点我体会非常深，也感觉是我技术提升的一个很大的节点。在这些优秀的同事里有位大家都很熟悉的孙源一直是我学习的榜样。记得在微博上第一次看到他分享的 RunLoop（视频地址：<a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XODgxODkzODI0.html</a> ） 就很有感触，讲得通俗易懂由浅入深，后面只要他有新的文章和新的技术分享不管是对外的还是公司内部的还有直播平台的我都一个一个看完了，其中有好几篇都看了好多遍。这个过程犹如海绵吸水，停不下来。</p>
<p>滴滴里还有好多高手，方方面面，除了对各个技术点有深入研究的人外，还有整体架构设计高手。安全，性能，数据，智能都有着很多非常专业和领域影响力的老师们，公司内会有很多技术讲座，涉及到各个领域，滴滴的大数据和人工智能在业界也是很有名的，内部也有着系列的讲座可以去学习，最近的系列课程我都有在追。每期的讲师都是这个领域最有权威的人。当然也少不了孙源的讲座，自热每次我也都听了。</p>
<h2 id="窍门三，主题分享"><a href="#窍门三，主题分享" class="headerlink" title="窍门三，主题分享"></a>窍门三，主题分享</h2><p>记得第一次技术分享是在组内做的一个白板分享，为了避免分享时跑题和讲不全，我在分享前专门把要分享的内容在 A4 纸上画了一遍。白板讲时拿着那张纸边看边讲，讲完后我发现在 A4 纸上画的这个过程最有价值了，在这个过程里我对整个相关内容会做一个总结，会考虑重点，铺垫等等因数，这个轮回下来在整理过程中我发现其实对知识点有了更深的记忆。</p>
<p>每次的分享其实都会考虑比较多的事情，首先是内容。谁都不愿意听到处都能够看到的东西，这样为了保证新鲜感，首先要根据自己的主题看看那些到处都能看到的东西是什么（这个过程其实比较痛苦需要查找大量资料），尽量避免那些大家耳熟能详的料，多分享些经过自己思考总结出来的理解，我觉得某个知识点只是搞懂了和实践成功了还是远远不够的，在搞懂的基础上去想为什么这样设计而不那样设计，通过自己的理解想通了那才是有意思的事情。这样就会迫使自己看大量的知识，自然而然也就学习到了大量的知识，是不是有种被推着往前进的感觉。</p>
<p>再就是要考虑准备的时间，如果时间长那么就可以专门准备一个 Demo 现场来演示，或者美化美化幻灯片之类。时间短的话只要力保内容有用就好了。上次 GMTC 大会前组织方极客帮专门邀请了左耳朵耗子来给我们这些讲师们分享如何做分享。他提到很重要的一点就是内容要有用，就是所谓的干货，为了不让分享枯燥那么使用讲故事的方式来吸引听众是最有效和最容易让人记住的。</p>
<p>分享当然还有一个很重要的好处就是和其他分享者还有听众交朋友，每次分享都会遇见很多人，新朋友老朋友，还有不同公司的人，能够了解到其它公司正在做什么，他们的成果和他们正在攻克的难题，了解现在流行的方案是什么。开阔了视野也就开阔了思路。</p>
<h2 id="窍门四，在定的时间节点里将涉及到的问题尽可能问到底"><a href="#窍门四，在定的时间节点里将涉及到的问题尽可能问到底" class="headerlink" title="窍门四，在定的时间节点里将涉及到的问题尽可能问到底"></a>窍门四，在定的时间节点里将涉及到的问题尽可能问到底</h2><p>大多数人都是有惰性的，那么什么样的窍门是能够适合所有人的呢。我觉得时间的节点设定非常关键。先说下什么是时间节点呢？比如某版本需求提测时间点，再比如某次分享的时间点。有了这个时间点，就可以在节点时间到达前将问题考究透，这段时间先不去关注其它东西，运气好的话时间充沛就能够考究的多些。每次节点完成都可以好好犒劳下自己，这样下次进入另一个周期时能够充满战斗力。</p>
<p>有一个我影响很深刻的工程大小瘦身的任务，这个也是有个时间节点。在这个任务下达之前，我们已经手动做过了一轮对无用资源的清理，剩下的只能依靠工具了。我几乎用遍了所有相关工具，当时有种孙悟空在东海龙宫试兵器的感觉，怎么都不顺手。又没有定海神针，那么只能自己造了。现有工具主要的问题是准确度不高，所以每次都需要手动核对下，这样每个版本来回几次，我们代码又这么多，这种工作量会让人吃不消的。但是任务又不能不完成，想着用户在外面急着打车需要安装滴滴时，程序包太大耽误下载时间又浪费流量该多不好。</p>
<p>这种检查核对工作重复枯燥又很耗时，工期又很紧，但是为了用户体验，我还是决定挑战下自己。我发现，提高准确度达到不需要人工检查是很有难度的，连 App Code 都没有做到。可人有急智，我发现通过模拟编译的过程，将代码整理成有效的结构进行分析和比对可以很容易自己控制各种检查规则。想完就撸起袖子加油干，几天后就做了出来。不过开始时没注意时间复杂度，导致速度慢得无法接受。于是一点一点地抠，把它们一个个转成空间复杂度后速度得到了质的飞跃。接下来几天，在实际工程代码检查过程中又解决了一些运行时写法的问题。为了提高体验我还做了一键清理，将无用的代码直接注释掉。这样在后面版本里节省了大量的人工检查时间。这次的“瘦身”过程也在今年的 GMTC 大会上做了分享，分享的 Slides 我放到了这里 <a href="https://pan.baidu.com/s/1skPAIID" target="_blank" rel="external">https://pan.baidu.com/s/1skPAIID</a> 。里面涉及的编译相关的技术，我也写了篇博客进行总结，地址：<a href="https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM" target="_blank" rel="external">https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM</a>。</p>
<p>再列个经历，当时在研究自动布局的过程中，我发现苹果基于自动布局抽象出一个 Stack View 来做布局，这种布局思路更加规范，更容易提高开发效率，但是却不支持低版本 iOS 系统。那时，我就在想能不能和 VFL 语言结合起来，这样开发起来岂不会效率更高？想了几天，觉得考虑的比较全面了，就差一个落地项目来推着自己完成它了，我就跟老大申请了在一个小版本对一个大需求涉及的页面和功能进行重构。当时就是想着是有了一个时间节点就能够推着自己走了，想做的事情也不会烂尾。</p>
<p>理想是丰满的，可现实却是骨感的——只有4天开发时间，前3天我才勉强完成库的开发，里面残缺不堪的，所以我只好把周末都搭上去了。周日下午，主要流程都完成后，我买了杯咖啡来到软件园湖边休息了半个小时。现在回想，这半个小时算是版本开发周期里除了睡觉外唯一的休息了。从开发到后面测试的那些天里，我都是每天6点到公司，晚上12点离开公司。最后，掐着点完成了功能版本的上线。</p>
<p>这个库我也是基于自动布局来包装的一个类似 Stack View 的库，能支持低版本，同时设计了一个简洁的界面描述语言，通过解析这个语言来对应生成界面，这样开发时只需要使用简单的语言描述即可。虽然这个开发的过程比较痛苦，但是完成后的喜悦感和成就感还是蛮大的不是么。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何提升开发技术的方法很多，比如专注，刻苦，热情，兴趣等，不过我这里不会提这些，下面想说的是我觉得能够指数级提升的窍门和一些自己在求索路上的一些体会，也算是一个阶段性的总结吧。趁着今天是程序员节，给大家做个分享，希望对需要的同学有用。&lt;/p&gt;
&lt;h2 id=&quot;窍门一，将代码
    
    </summary>
    
      <category term="Programming" scheme="http://ming1016.github.io/categories/Programming/"/>
    
    
      <category term="Study" scheme="http://ming1016.github.io/tags/Study/"/>
    
  </entry>
  
</feed>
