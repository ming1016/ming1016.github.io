<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="前滴滴出行技术专家。极客时间《iOS开发高手课》和纸书《跟戴铭学iOS编程》作者。个人博客：戴铭的博客。微信公共号：starming-weixin。微博：@戴铭">
    <meta name="author" content="戴铭">
    
    <title>
        
            Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理) |
        
        戴铭的博客
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/img/logo-starming.png">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ming1016.github.io","root":"/","language":"zh-Hans"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/img/ming.jpeg","favicon":"/img/logo-starming.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":null,"description":"混乱中的有序"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                戴铭的博客
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/img/ming.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">戴铭</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2018-01-24 17:14:03</span>
        <span class="mobile">2018-01-24 17:14</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Programming/">Programming</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/iOS/">iOS</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/Swift/">Swift</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.9k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>25 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这篇文章主要是为了给组内要做的分享准备内容。这段时间几个项目都用到 Swift，在上次 GIAC 大会上就被问到为什么要用 Swift，正好这个主题可以聊聊 Swift 的哪些特性吸引了我。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>先来个例子看下泛型是解决什么问题的。</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> nations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"中国"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"美国"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"日本"</span></span><span class="token punctuation">]</span>
<span class="token keyword">func</span> <span class="token function-definition function">showNations</span><span class="token punctuation">(</span>arr <span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    arr<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span> str <span class="token keyword">in</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">str</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们先定一个字符串数组，然后把里面的字符串打印出来。这里的 map 写法还可以优化下：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">arr<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token short-argument">$0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么还能做什么优化呢。将 showNations 的入参数组泛型以支持多类型，比如 [int]，[double] 等。</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">showArray</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span>arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    arr<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token short-argument">$0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可以看出泛型能够很方便的将不同类型数据进行相同操作的逻辑归并在一起。</p>
<h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>先看下我的 HTN 项目里状态机的 Transition 结构体的定义</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token class-name">HTNTransition</span><span class="token operator">&lt;</span><span class="token class-name">S</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span><span class="token punctuation">,</span> <span class="token class-name">E</span><span class="token punctuation">:</span> <span class="token class-name">Hashable</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> event<span class="token punctuation">:</span> <span class="token class-name">E</span>
    <span class="token keyword">let</span> fromState<span class="token punctuation">:</span> <span class="token class-name">S</span>
    <span class="token keyword">let</span> toState<span class="token punctuation">:</span> <span class="token class-name">S</span>
    
    <span class="token keyword">init</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> <span class="token class-name">E</span><span class="token punctuation">,</span> fromState<span class="token punctuation">:</span> <span class="token class-name">S</span><span class="token punctuation">,</span> toState<span class="token punctuation">:</span> <span class="token class-name">S</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">self</span><span class="token punctuation">.</span>event <span class="token operator">=</span> event
        <span class="token keyword">self</span><span class="token punctuation">.</span>fromState <span class="token operator">=</span> fromState
        <span class="token keyword">self</span><span class="token punctuation">.</span>toState <span class="token operator">=</span> toState
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的 fromState，toState 和 event 可以是不同类型的数据，可以是枚举，字符串或者整数等，定义 S 和 E 两个不同的泛型可以让状态和事件类型不相同，这样接口会更加的灵活，更容易适配更多的项目。</p>
<p>大家会注意到 S 和 E 的冒号后面还有个 Hashable 协议，这就是要求它们符合这个协议的类型约束。使用协议的话可以使得这两个类型更加的规范和易于扩展。</p>
<p>Swift 的基本类型 String，Int，Double 和 Bool 等都是遵循 Hashable 的，还有无关联值的枚举也是的。Hashable 提供了一个 hashValue 方法用在判断遵循协议对象是否相等时用。</p>
<p>Hashable 协议同时也是遵守 Equatable 协议，通过实现 &#x3D;&#x3D; 运算符来确定自定义的类或结构是否相同。</p>
<h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>在协议里定义的关联类型也可以用泛型来处理。比如我们先定义一个协议</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">protocol</span> <span class="token class-name">HTNState</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">StateType</span>
    <span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">StateType</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>采用非泛型的实现如下：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> states<span class="token punctuation">:</span> <span class="token class-name">HTNState</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">typealias</span> <span class="token class-name">StateType</span> <span class="token operator">=</span> <span class="token class-name">Int</span>
    <span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">Int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>采用泛型遵循协议可以按照下面方式来写：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> states<span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token class-name">HTNState</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> item<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样关联类型也能够享受泛型的好处了。</p>
<h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>但是在使用关联类型的时候需要注意当声明一个使用了关联属性的协议作为属性时，比如下面的代码：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> stateDelegate<span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> state<span class="token punctuation">:</span> <span class="token class-name">T</span>
    <span class="token keyword">var</span> delegate<span class="token punctuation">:</span> <span class="token class-name">HTNState</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>先会提示 no initializers 的错误，接着会提示 error: protocol ‘HTNState’ can only be used as a generic constraint because it has Self or associated type requirements 。意思是 HTNState 协议只能作为泛型约束来用，因为它里面包含必需的 self 或者关联类型。</p>
<p>那么该如何处理呢？这里需要通过类型擦除来解决，主要思路就是加个中间层在代码中让这个抽象的类型具体化。实际上在 Swift 的标准库里就有类型擦除很好的运用，比如 AnySequence 的协议。</p>
<h2 id="Where-语句"><a href="#Where-语句" class="headerlink" title="Where 语句"></a>Where 语句</h2><p>函数，扩展和关联类型都可以使用 where 语句。where 语句是对泛型在应用时的一种约束。比如：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">stateFilter</span><span class="token operator">&lt;</span><span class="token class-name">FromState</span><span class="token punctuation">:</span><span class="token class-name">HTNState</span><span class="token punctuation">,</span> <span class="token class-name">ToState</span><span class="token punctuation">:</span><span class="token class-name">HTNState</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token omit keyword">_</span> from<span class="token punctuation">:</span><span class="token class-name">FromState</span><span class="token punctuation">,</span> <span class="token omit keyword">_</span> to<span class="token punctuation">:</span><span class="token class-name">ToState</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token class-name">FromState</span><span class="token punctuation">.</span><span class="token class-name">StateType</span> <span class="token operator">==</span> <span class="token class-name">ToState</span><span class="token punctuation">.</span><span class="token class-name">StateType</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这个函数就要求他们的 StateType 具有相同类型。</p>
<h2 id="泛型和-Any-类型"><a href="#泛型和-Any-类型" class="headerlink" title="泛型和 Any 类型"></a>泛型和 Any 类型</h2><p>这两个类型看起来很相似，但是一定要小心两者的区别。他们区别在于 Any 类型会避开类型的检查，所以尽量少用最好不用。泛型一方面很灵活一方面也很安全，下面举个例子感受下两者的区别：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">add</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token omit keyword">_</span> input<span class="token punctuation">:</span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">T</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span> input<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function-definition function">anyAdd</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> input<span class="token punctuation">:</span> <span class="token keyword">Any</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">Any</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//...</span>
    <span class="token keyword">return</span> input<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个函数都是可以允许任意类型的 input 参数，不同在于返回的类型在 anyAdd 函数里是可以和入参不一样的，这样就会失控，在后续的操作中容易出错。</p>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>先来了解下集合的基本概念，首先集合是泛型的比如：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> stateArray<span class="token punctuation">:</span> <span class="token class-name">Array</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"工作"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"吃饭"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"玩游戏"</span></span><span class="token punctuation">,</span><span class="token string-literal"><span class="token string">"睡觉"</span></span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>集合它需要先有个遍历的功能，通过 GeneratorType 协议，可以不关注具体元素类型只要不断的用迭代器调 next 就可以得到全部元素。但是使用迭代器没法进行多次的遍历，这时就需要使用 Sequence 来解决这个问题。像集合的 forEach，elementsEqual，contains，minElement，maxElement，map，flatMap，filter，reduce 等功能都是因为有了 Sequence 的多次遍历。</p>
<p>最后 Collection 概念是因为 Sequence 无法确定集合里的位置而在 Sequence 的基础上实现了 Indexable 协议。有了 Collection 就可以确定元素的位置，包括开始位置和结束位置，这样就能够确定哪些元素是已经访问过的，从而避免多次访问同一个元素。还能够通过一个给定的位置直接找到那个位置的元素。</p>
<p>以上描述如下图：<br><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="/uploads/why-swift/01.png" class="lozad post-image"src="/uploads/why-swift/01.png"></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>Swift 里有个简单的 AnyIterator<Element> 结构体</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token class-name">AnyIterator</span><span class="token operator">&lt;</span><span class="token class-name">Element</span><span class="token operator">></span><span class="token punctuation">:</span> <span class="token class-name">IteratorProtocol</span> <span class="token punctuation">&#123;</span> 
	<span class="token keyword">init</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> body<span class="token punctuation">:</span> <span class="token attribute atrule">@escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Element</span><span class="token operator">?</span><span class="token punctuation">)</span>
	<span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>AnyIterator 实现了 IteratorProtocol 和 Sequence 协议。通过下面的例子我们来看看如何使用 AnyIterator ：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> stateItr <span class="token punctuation">:</span> <span class="token class-name">IteratorProtocol</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> num<span class="token punctuation">:</span><span class="token class-name">Int</span> <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">func</span> <span class="token function-definition function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">Int</span><span class="token operator">?</span><span class="token punctuation">&#123;</span>
        num <span class="token operator">+=</span> <span class="token number">2</span>
        <span class="token keyword">return</span> num
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function-definition function">findNext</span><span class="token operator">&lt;</span><span class="token class-name">I</span><span class="token punctuation">:</span> <span class="token class-name">IteratorProtocol</span><span class="token operator">></span><span class="token punctuation">(</span> elm<span class="token punctuation">:</span> <span class="token class-name">I</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">AnyIterator</span><span class="token operator">&lt;</span><span class="token class-name">I</span><span class="token punctuation">.</span><span class="token class-name">Element</span><span class="token operator">></span> <span class="token keyword">where</span> <span class="token class-name">I</span><span class="token punctuation">.</span><span class="token class-name">Element</span> <span class="token operator">==</span> <span class="token class-name">Int</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> l <span class="token operator">=</span> elm
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">l<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">??</span> <span class="token number">0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token class-name">AnyIterator</span> <span class="token punctuation">&#123;</span> l<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token function">findNext</span><span class="token punctuation">(</span>elm<span class="token punctuation">:</span> <span class="token function">findNext</span><span class="token punctuation">(</span>elm<span class="token punctuation">:</span> <span class="token function">findNext</span><span class="token punctuation">(</span>elm<span class="token punctuation">:</span> <span class="token function">stateItr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先是定义个遵循了 IteratorProtocol 并实现了 next 函数的类。再实现一个 AnyIterator 的迭代器方法，这样通过这个方法的调用就可以不断的去找符合的元素了。</p>
<p>这里有个对 where 语句的运用，where I.Element &#x3D;&#x3D; Int。如果把这句改成 where I.Element &#x3D;&#x3D; String 会出现下面的错误提示</p>
<pre class="line-numbers language-none"><code class="language-none">Playground execution failed:

error: MyPlayground.playground:18:37: error: cannot invoke &#39;findNext(elm:)&#39; with an argument list of type &#39;(elm: stateItr)&#39;
findNext(elm: findNext(elm: findNext(elm: stateItr())))
                                    ^

MyPlayground.playground:11:6: note: candidate requires that the types &#39;Int&#39; and &#39;String&#39; be equivalent (requirement specified as &#39;I.Element&#39; &#x3D;&#x3D; &#39;String&#39; [with I &#x3D; stateItr])
func findNext&lt;I: IteratorProtocol&gt;( elm: I) -&gt; AnyIterator&lt;I.Element&gt; where I.Element &#x3D;&#x3D; String
     ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译器会在代码检查阶段通过代码跟踪就发现类型不匹配的安全隐患，这里不得不对 Swift 的设计点个赞先</p>
<h2 id="Sequence"><a href="#Sequence" class="headerlink" title="Sequence"></a>Sequence</h2><p>上面的迭代器只会以单次触发的方式反复计算下个元素，但是对于希望能够重新查找或重新生成已生成的元素，这样还需要有个新的迭代器和一个子 Sequence。在 Sequence 协议里可以看到这样的定义：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">protocol</span> <span class="token class-name">Sequence</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">//Element 表示序列元素的类型</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Element</span> <span class="token keyword">where</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Element</span> <span class="token operator">==</span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Iterator</span><span class="token punctuation">.</span><span class="token class-name">Element</span>
    <span class="token comment">//迭代接口类型</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">Iterator</span> <span class="token punctuation">:</span> <span class="token class-name">IteratorProtocol</span>
    <span class="token comment">//子 Sequence 类型</span>
    <span class="token keyword">associatedtype</span> <span class="token class-name">SubSequence</span>
    <span class="token comment">//返回 Sequence 元素的迭代器</span>
    <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">makeIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Iterator</span>
    <span class="token comment">//...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>重新查找靠的是这个新的迭代器，而对于切片这样的会重新生成新 Sequence 的操作就需要 SubSequence 进行存储和返回。</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>对 Sequence 进行进一步的完善，最重要的就是使其具有下标索引，使得元素能够通过下标索引方式取到。Collection 是个有限的范围，有开始索引和结束索引，所以 Collection 和 Sequence 的无限范围是不一样的。有了有限的范围 Collection 就可以有 count 属性进行计数了。</p>
<p>除了标准库里的 String，Array，Dictionary 和 Set 外比如 Data 和 IndexSet 也由于遵循了 Collection 协议而获得了标准库了那些集合类型的能力。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>在泛型的第一个例子里我们就看到了 map 的使用，我们看看 map 的定义：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function-definition function">map</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">></span><span class="token punctuation">(</span>transform<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">Self</span><span class="token punctuation">.</span><span class="token class-name">Generator</span><span class="token punctuation">.</span><span class="token class-name">Element</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token class-name">T</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token class-name">T</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里 (Self.Generator.Element) -&gt; T 就是 map 闭包的定义，Self.Generator.Element 就是当前元素的类型。</p>
<h2 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h2><p>二维数组经过 flatmap 会降维到一维，还能过滤掉 nil 值。下面看看 Swift 源码（swift&#x2F;stdlib&#x2F;public&#x2F;core&#x2F;SequenceAlgorithms.swift.gyb）中 flatmap 的实现：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token comment">//===----------------------------------------------------------------------===//</span>
<span class="token comment">// flatMap()</span>
<span class="token comment">//===----------------------------------------------------------------------===//</span>

<span class="token keyword">extension</span> <span class="token class-name">Sequence</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/// Returns an array containing the concatenated results of calling the</span>
  <span class="token comment">/// given transformation with each element of this sequence.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// Use this method to receive a single-level collection when your</span>
  <span class="token comment">/// transformation produces a sequence or collection for each element.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// In this example, note the difference in the result of using `map` and</span>
  <span class="token comment">/// `flatMap` with a transformation that returns an array.</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let numbers = [1, 2, 3, 4]</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let mapped = numbers.map &#123; Array(count: $0, repeatedValue: $0) &#125;</span>
  <span class="token comment">///     // [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let flatMapped = numbers.flatMap &#123; Array(count: $0, repeatedValue: $0) &#125;</span>
  <span class="token comment">///     // [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</span>
  <span class="token comment">///</span>
  <span class="token comment">/// In fact, `s.flatMap(transform)`  is equivalent to</span>
  <span class="token comment">/// `Array(s.map(transform).joined())`.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// - Parameter transform: A closure that accepts an element of this</span>
  <span class="token comment">///   sequence as its argument and returns a sequence or collection.</span>
  <span class="token comment">/// - Returns: The resulting flattened array.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span>
  <span class="token comment">///   and *n* is the length of the result.</span>
  <span class="token comment">/// - SeeAlso: `joined()`, `map(_:)`</span>
  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">flatMap</span><span class="token operator">&lt;</span><span class="token class-name">SegmentOfResult</span> <span class="token punctuation">:</span> <span class="token class-name">Sequence</span><span class="token operator">></span><span class="token punctuation">(</span>
    <span class="token omit keyword">_</span> transform<span class="token punctuation">:</span> <span class="token punctuation">(</span>$<span class="token punctuation">&#123;</span><span class="token class-name">GElement</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-></span> <span class="token class-name">SegmentOfResult</span>
  <span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token class-name">SegmentOfResult</span><span class="token punctuation">.</span>$<span class="token punctuation">&#123;</span><span class="token class-name">GElement</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> result<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">SegmentOfResult</span><span class="token punctuation">.</span>$<span class="token punctuation">&#123;</span><span class="token class-name">GElement</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">&#123;</span>
      result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>contentsOf<span class="token punctuation">:</span> <span class="token keyword">try</span> <span class="token function">transform</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">extension</span> <span class="token class-name">Sequence</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/// Returns an array containing the non-`nil` results of calling the given</span>
  <span class="token comment">/// transformation with each element of this sequence.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// Use this method to receive an array of nonoptional values when your</span>
  <span class="token comment">/// transformation produces an optional value.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// In this example, note the difference in the result of using `map` and</span>
  <span class="token comment">/// `flatMap` with a transformation that returns an optional `Int` value.</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let possibleNumbers = ["1", "2", "three", "///4///", "5"]</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let mapped: [Int?] = possibleNumbers.map &#123; str in Int(str) &#125;</span>
  <span class="token comment">///     // [1, 2, nil, nil, 5]</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let flatMapped: [Int] = possibleNumbers.flatMap &#123; str in Int(str) &#125;</span>
  <span class="token comment">///     // [1, 2, 5]</span>
  <span class="token comment">///</span>
  <span class="token comment">/// - Parameter transform: A closure that accepts an element of this</span>
  <span class="token comment">///   sequence as its argument and returns an optional value.</span>
  <span class="token comment">/// - Returns: An array of the non-`nil` results of calling `transform`</span>
  <span class="token comment">///   with each element of the sequence.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// - Complexity: O(*m* + *n*), where *m* is the length of this sequence</span>
  <span class="token comment">///   and *n* is the length of the result.</span>
  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">flatMap</span><span class="token operator">&lt;</span><span class="token class-name">ElementOfResult</span><span class="token operator">></span><span class="token punctuation">(</span>
    <span class="token omit keyword">_</span> transform<span class="token punctuation">:</span> <span class="token punctuation">(</span>$<span class="token punctuation">&#123;</span><span class="token class-name">GElement</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-></span> <span class="token class-name">ElementOfResult</span><span class="token operator">?</span>
  <span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token class-name">ElementOfResult</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> result<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">ElementOfResult</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">if</span> <span class="token keyword">let</span> newElement <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">transform</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>newElement<span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从代码中可以看出打平的原理是将集合中所有元素都添加到另外一个集合里。在第二个 extension 里通过 if let 语句会挡住那些解包不成功的元素。</p>
<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>Reduce 是编程语言语义学里的归约语义学，也叫累加器。下面同样可以看看 Swift 源码里对其的实现：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token comment">//===----------------------------------------------------------------------===//</span>
<span class="token comment">// reduce()</span>
<span class="token comment">//===----------------------------------------------------------------------===//</span>

<span class="token keyword">extension</span> <span class="token class-name">Sequence</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">/// Returns the result of combining the elements of the sequence using the</span>
  <span class="token comment">/// given closure.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// Use the `reduce(_:_:)` method to produce a single value from the elements</span>
  <span class="token comment">/// of an entire sequence. For example, you can use this method on an array</span>
  <span class="token comment">/// of numbers to find their sum or product.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// The `nextPartialResult` closure is called sequentially with an</span>
  <span class="token comment">/// accumulating value initialized to `initialResult` and each element of</span>
  <span class="token comment">/// the sequence. This example shows how to find the sum of an array of</span>
  <span class="token comment">/// numbers.</span>
  <span class="token comment">///</span>
  <span class="token comment">///     let numbers = [1, 2, 3, 4]</span>
  <span class="token comment">///     let numberSum = numbers.reduce(0, &#123; x, y in</span>
  <span class="token comment">///         x + y</span>
  <span class="token comment">///     &#125;)</span>
  <span class="token comment">///     // numberSum == 10</span>
  <span class="token comment">///</span>
  <span class="token comment">/// When `numbers.reduce(_:_:)` is called, the following steps occur:</span>
  <span class="token comment">///</span>
  <span class="token comment">/// 1. The `nextPartialResult` closure is called with `initialResult`---`0`</span>
  <span class="token comment">///    in this case---and the first element of `numbers`, returning the sum:</span>
  <span class="token comment">///    `1`.</span>
  <span class="token comment">/// 2. The closure is called again repeatedly with the previous call's return</span>
  <span class="token comment">///    value and each element of the sequence.</span>
  <span class="token comment">/// 3. When the sequence is exhausted, the last value returned from the</span>
  <span class="token comment">///    closure is returned to the caller.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// If the sequence has no elements, `nextPartialResult` is never executed</span>
  <span class="token comment">/// and `initialResult` is the result of the call to `reduce(_:_:)`.</span>
  <span class="token comment">///</span>
  <span class="token comment">/// - Parameters:</span>
  <span class="token comment">///   - initialResult: The value to use as the initial accumulating value.</span>
  <span class="token comment">///     `initialResult` is passed to `nextPartialResult` the first time the</span>
  <span class="token comment">///     closure is executed.</span>
  <span class="token comment">///   - nextPartialResult: A closure that combines an accumulating value and</span>
  <span class="token comment">///     an element of the sequence into a new accumulating value, to be used</span>
  <span class="token comment">///     in the next call of the `nextPartialResult` closure or returned to</span>
  <span class="token comment">///     the caller.</span>
  <span class="token comment">/// - Returns: The final accumulated value. If the sequence has no elements,</span>
  <span class="token comment">///   the result is `initialResult`.</span>
  <span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function-definition function">reduce</span><span class="token operator">&lt;</span><span class="token class-name">Result</span><span class="token operator">></span><span class="token punctuation">(</span>
    <span class="token omit keyword">_</span> initialResult<span class="token punctuation">:</span> <span class="token class-name">Result</span><span class="token punctuation">,</span>
    <span class="token omit keyword">_</span> nextPartialResult<span class="token punctuation">:</span>
      <span class="token punctuation">(</span><span class="token omit keyword">_</span> partialResult<span class="token punctuation">:</span> <span class="token class-name">Result</span><span class="token punctuation">,</span> $<span class="token punctuation">&#123;</span><span class="token class-name">GElement</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-></span> <span class="token class-name">Result</span>
  <span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-></span> <span class="token class-name">Result</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> accumulator <span class="token operator">=</span> initialResult
    <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">&#123;</span>
      accumulator <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">nextPartialResult</span><span class="token punctuation">(</span>accumulator<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> accumulator
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到里面会通过 initialResult 来记录前面的返回结果和当前元素进行在闭包里的操作。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>看看数组的基本用法</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token comment">//创建数组</span>
<span class="token keyword">var</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建空数组</span>
<span class="token keyword">var</span> mArray <span class="token operator">=</span> nums <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token comment">//合并多个有相同类型元素数组的值</span>
<span class="token keyword">var</span> animals<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"dragon"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"cat"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"mice"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"dog"</span></span><span class="token punctuation">]</span>

<span class="token comment">//添加数组</span>
animals<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"bird"</span></span><span class="token punctuation">)</span>
animals <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"ant"</span></span><span class="token punctuation">]</span>

<span class="token comment">//获取和改变数组</span>
<span class="token keyword">var</span> firstItem <span class="token operator">=</span> mArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
animals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"red dragon"</span></span>
animals<span class="token punctuation">[</span><span class="token number">2</span><span class="token operator">...</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"black dragon"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"white dragon"</span></span><span class="token punctuation">]</span> <span class="token comment">//使用下标改变多个元素</span>
animals<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"chinese dragon"</span></span><span class="token punctuation">,</span> at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//在索引值之前添加元素</span>
<span class="token keyword">let</span> mapleSyrup <span class="token operator">=</span> animals<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//移除数组中的一个元素</span>
<span class="token keyword">let</span> apples <span class="token operator">=</span> animals<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//移除最后一个元素</span>

<span class="token comment">////数组遍历</span>
<span class="token keyword">for</span> animal <span class="token keyword">in</span> animals <span class="token punctuation">&#123;</span>
    <span class="token function">print</span><span class="token punctuation">(</span>animal<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> animal<span class="token punctuation">)</span> <span class="token keyword">in</span> animals<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"animal </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token class-name">String</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">animal</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">/*
 animal 1: red dragon
 animal 2: cat
 animal 3: black dragon
 animal 4: white dragon
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="弱引用的-Swift-数组"><a href="#弱引用的-Swift-数组" class="headerlink" title="弱引用的 Swift 数组"></a>弱引用的 Swift 数组</h2><p>Swift 里的数组默认会强引用里面的元素，但是有时候可能希望能够弱引用，那么就可以使用 NSPointerArray。它在初始化的时候可以决定是用弱引用方式还是强引用方式。</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">let</span> strongArr <span class="token operator">=</span> <span class="token class-name">NSPointerArray</span><span class="token punctuation">.</span><span class="token function">strongObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 强引用</span>
<span class="token keyword">let</span> weakArr <span class="token operator">=</span> <span class="token class-name">NSPointerArray</span><span class="token punctuation">.</span><span class="token function">weakObjects</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Maintains weak references</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>Dictionary 的要想用弱引用可以使用 NSMapTable，Set 对应的是 NSHashTable。</p>
<h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><p>看看基本用法：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token comment">//创建 Dictionary</span>
<span class="token keyword">var</span> strs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token class-name">Int</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> colors<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token class-name">String</span><span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string-literal"><span class="token string">"red"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"#e83f45"</span></span><span class="token punctuation">,</span> <span class="token string-literal"><span class="token string">"yellow"</span></span><span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"#ffe651"</span></span><span class="token punctuation">]</span>
strs<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"sixteen"</span></span>

<span class="token comment">//updateValue 这个方法会返回更新前的值</span>
<span class="token keyword">if</span> <span class="token keyword">let</span> oldValue <span class="token operator">=</span> colors<span class="token punctuation">.</span><span class="token function">updateValue</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"#e83f47"</span></span><span class="token punctuation">,</span> forKey<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">"red"</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"The old value for DUB was </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">oldValue</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">."</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//遍历</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>color<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token keyword">in</span> colors <span class="token punctuation">&#123;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">color</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">: </span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//map</span>
<span class="token keyword">let</span> newColorValues <span class="token operator">=</span> colors<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span> <span class="token string-literal"><span class="token string">"hex:</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token short-argument">$0</span><span class="token punctuation">.</span>value</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span> <span class="token punctuation">&#125;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">newColorValues</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span>

<span class="token comment">//mapValues 返回完整的新 Dictionary</span>
<span class="token keyword">let</span> newColors <span class="token operator">=</span> colors<span class="token punctuation">.</span>mapValues <span class="token punctuation">&#123;</span> <span class="token string-literal"><span class="token string">"hex:</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation"><span class="token short-argument">$0</span></span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span> <span class="token punctuation">&#125;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"</span><span class="token interpolation-punctuation punctuation">\(</span><span class="token interpolation">newColors</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">"</span></span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="协议式编程"><a href="#协议式编程" class="headerlink" title="协议式编程"></a>协议式编程</h1><p>Swift 被设计成单继承，如果希望是多继承就需要使用协议。协议还有个比较重要的作用就是通过 associatedtype 要求使用者遵守指定的泛型约束。</p>
<p>下面先看看传统编程的开发模式：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Dragon</span> <span class="token punctuation">&#123;</span>
    
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">BlackDragon</span><span class="token punctuation">:</span> <span class="token class-name">Dragon</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">WhiteDragon</span><span class="token punctuation">:</span> <span class="token class-name">Dragon</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">BlackDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">WhiteDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个例子可以看出 fire() 就是重复代码，那么首先想到的方法就是通过直接在基类里添加这个方法或者通过 extension 来对他们基类进行扩展：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token class-name">Dragon</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这时我们希望加个方法让 Dragon 能够 fly：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token class-name">Dragon</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fly~~~"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样 BlackDragon 和 WhiteDragon 就都有这两个能力了，如果我们设计出一个新的龙 YellowDragon 或者更多 Dragon 都没有 fly 的能力，这时该如何。因为没法多继承，那么没法拆成两个基类，这样必然就会出现重复代码。但是有了协议这个问题就好解决了。具体实现如下：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">protocol</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">protocol</span> <span class="token class-name">DragonFly</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">extension</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">extension</span> <span class="token class-name">DragonFly</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fly~~~"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">BlackDragon</span><span class="token punctuation">:</span> <span class="token class-name">DragonFire</span><span class="token punctuation">,</span> <span class="token class-name">DragonFly</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">WhiteDragon</span><span class="token punctuation">:</span> <span class="token class-name">DragonFire</span><span class="token punctuation">,</span> <span class="token class-name">DragonFly</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">YellowDragon</span><span class="token punctuation">:</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">PurpleDragon</span><span class="token punctuation">:</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token class-name">BlackDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">WhiteDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">BlackDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">YellowDragon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到一来没有了重复代码，二来结构也清晰了很多而且更容易扩展，Dragon 的种类和能力的组合也更加方便和清晰。extension 使得协议有了实现默认方法的能力。</p>
<p>关于多继承 Swift 是采用 Trait 的方式，其它语言 C++ 是直接支持多继承的，方式是这个类会持有多个父类的实例。Java 的多继承只继承能做什么，怎么做还是要自己来。和 Trait 类似的解决方案是 Mixin，Ruby 就是用的这种元编程思想。</p>
<p>协议还可以继承，还可以通过 &amp; 来聚合，判断一个类是否遵循了一个协议可以使用 is 关键字。</p>
<p>当然协议还可以作为类型，比如一个数组泛型元素指定为一个协议，那么这个数组里的元素只要遵循这个协议就可以了。</p>
<h1 id="Swift-内存管理"><a href="#Swift-内存管理" class="headerlink" title="Swift 内存管理"></a>Swift 内存管理</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>在 Heap 上内存分配的时候需要锁定 Heap 上能够容纳存放对象的空闲块，主要是为了线程安全，我们需要对这些进行锁定和同步。</p>
<p>Heap 是完全二叉树，即除最底层节点外都是填满的，最底层节点填充是从左到右。Swift 的 Heap 是通过双向链表实现。由于 Heap 是可以 retain 和 release 所以很容易分配空间就不连续了。采用链表的目的是希望能够将内存块连起来，在 release 时通过调整链表指针来整合空间。</p>
<p>在 retain 时不可避免需要遍历 Heap，找到合适大小的内存块，能优化的也只是记录以前遍历的情况减少一些遍历。但是 Heap 是很大的，这样每次遍历还是很耗时，而且 release 为了能够整合空间还需要判断当前内存块的前一块和后面那块是否为空闲等，如果空闲还需要遍历链表查询，所以最终的解决方式是双向链表。只把空闲内存块用指针连起来形成链表，这样 retain 时可以减少遍历，效率理论上可以提高一倍，在 release 时将多余空间插入到 Heap 开始的位置和先前移到前面的空间进行整合。</p>
<p>即使效率高了但是还是比不过 Stack，所以苹果也将以前 OC 里的一些放在 Heap 里的类型改造成了值类型。</p>
<h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 的结构很简单，push 和 pop 就完事了，内存上只需要维护 Stack 末端的指针即可。由于它的简单所以处理一些时效性不高，临时的事情是非常合适的，所以可以把 Stack 看成是一个交换临时数据的内存区域。在多线程上，由于 Stack 是线程独有的，所以也不需要考虑线程安全相关问题。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>Swift 也有内存对齐的概念</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token class-name">DragonFirePosition</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">:</span><span class="token class-name">Int64</span> <span class="token comment">//8 Bytes</span>
    <span class="token keyword">var</span> y<span class="token punctuation">:</span><span class="token class-name">Int32</span> <span class="token comment">//4 Bytes</span>
    <span class="token comment">//8 + 4</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">struct</span> <span class="token class-name">DragonHomePosition</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> y<span class="token punctuation">:</span><span class="token class-name">Int32</span> <span class="token comment">//4 Bytes + 对齐内存(4 Bytes)</span>
    <span class="token keyword">var</span> x<span class="token punctuation">:</span><span class="token class-name">Int64</span> <span class="token comment">//8 Bytes</span>
    <span class="token comment">//4 + 4 + 8</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">let</span> firePositionSize <span class="token operator">=</span> <span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonFirePosition</span><span class="token operator">></span><span class="token punctuation">.</span>size <span class="token comment">//12</span>
<span class="token keyword">let</span> homePositionSize <span class="token operator">=</span> <span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonHomePosition</span><span class="token operator">></span><span class="token punctuation">.</span>size <span class="token comment">//16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Swift-派发机制"><a href="#Swift-派发机制" class="headerlink" title="Swift 派发机制"></a>Swift 派发机制</h2><p>派发目的是让 CPU 知道被调用的函数在哪里。Swift 语言是支持编译型语言的直接派发，函数表派发和消息机制派发三种派发方式的，下面分别对这三种派发方式说明下。</p>
<h3 id="直接派发"><a href="#直接派发" class="headerlink" title="直接派发"></a>直接派发</h3><p>C++ 默认使用的是直接派发，加上 virtual 修饰符可以改成函数表派发。直接派发是最快的，原因是调用指令会少，还可以通过编译器进行比如内联等方式的优化。缺点是由于缺少动态性而不支持继承。</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token class-name">DragonFirePosition</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">:</span><span class="token class-name">Int64</span>
    <span class="token keyword">var</span> y<span class="token punctuation">:</span><span class="token class-name">Int32</span>
    <span class="token keyword">func</span> <span class="token function-definition function">land</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function-definition function">DragonWillFire</span><span class="token punctuation">(</span><span class="token omit keyword">_</span> position<span class="token punctuation">:</span><span class="token class-name">DragonFirePosition</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    position<span class="token punctuation">.</span><span class="token function">land</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">let</span> position <span class="token operator">=</span> <span class="token class-name">DragonFirePosition</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">342</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">213</span><span class="token punctuation">)</span>
<span class="token class-name">DragonWillFire</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>编译 inline 后 DragonWillFire(DragonFirePosition(x: 342, y: 213)) 会直接跳到方法实现的地方，结果就变成 position.land()。</p>
<h3 id="函数表派发"><a href="#函数表派发" class="headerlink" title="函数表派发"></a>函数表派发</h3><p>Java 默认就是使用的函数表派发，通过 final 修饰符改成直接派发。函数表派发是有动态性的，在 Swift 里函数表叫 witness table，大部分语言叫 virtual table。一个类里会用数组来存储里面的函数指针，override 父类的函数会替代以前的函数，子类添加的函数会被加到这个数组里。举个例子：</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Fish</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">swim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//normal eat</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">class</span> <span class="token class-name">FlyingFish</span><span class="token punctuation">:</span> <span class="token class-name">Fish</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function-definition function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//flying fish eat</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>编译器会给 Fish 类和 FlyingFish 类分别创建 witness table。在 Fish 的函数表里有 swim 和 eat 函数，在 FlyingFish 函数表里有父类 Fish 的 swim，覆盖了父类的 eat 和新增加的函数 fly。</p>
<p>一个函数被调用时会先去读取对象的函数表，再根据类的地址加上该的函数的偏移量得到函数地址，然后跳到那个地址上去。从编译后的字节码这方面来看就是两次读取一次跳转，比直接派发还是慢了些。</p>
<h3 id="消息机制派发"><a href="#消息机制派发" class="headerlink" title="消息机制派发"></a>消息机制派发</h3><p>这种机制是在运行时可以改变函数的行为，KVO 和 CoreData 都是这种机制的运用。OC 默认就是使用的消息机制派发，使用 C 来直接派发获取高性能。Swift 可以通过 dynamic 修饰来支持消息机制派发。</p>
<p>当一个消息被派发，运行时就会按照继承关系向上查找被调用的函数。但是这样效率不高，所以需要通过缓存来提高效率，这样查找性能就能和函数派发差不多了。</p>
<h3 id="具体派发"><a href="#具体派发" class="headerlink" title="具体派发"></a>具体派发</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>值类型都会采用直接派发。无论是 class 还是协议 的 extension 也都是直接派发。class 和协议是函数表派发。</p>
<h4 id="指定派发方式"><a href="#指定派发方式" class="headerlink" title="指定派发方式"></a>指定派发方式</h4><ul>
<li>final：让类里的函数使用直接派发，这样该函数将会没有动态性，运行时也没法取到这个函数。</li>
<li>dynamic：可以让类里的函数使用消息机制派发，可以让 extension 里的函数被 override。</li>
</ul>
<h4 id="派发优化"><a href="#派发优化" class="headerlink" title="派发优化"></a>派发优化</h4><p>Swift 会在这上面做优化，比如一个函数没有 override，Swift 就可能会使用直接派发的方式，所以如果属性绑定了 KVO 它的 getter 和 setter 方法可能会被优化成直接派发而导致 KVO 的失效，所以记得加上 dynamic 的修饰来保证有效。后面 Swift 应该会在这个优化上去做更多的处理。</p>
<h2 id="基本数据类型内存管理"><a href="#基本数据类型内存管理" class="headerlink" title="基本数据类型内存管理"></a>基本数据类型内存管理</h2><p>通过 MemoryLayout 来看看基本数据类型的内存是占用多大</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">Int</span><span class="token operator">></span><span class="token punctuation">.</span>size      <span class="token comment">//8</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">Int16</span><span class="token operator">></span><span class="token punctuation">.</span>size    <span class="token comment">//2</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">Bool</span><span class="token operator">></span><span class="token punctuation">.</span>size     <span class="token comment">//1</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">Float</span><span class="token operator">></span><span class="token punctuation">.</span>size    <span class="token comment">//4</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">Double</span><span class="token operator">></span><span class="token punctuation">.</span>size   <span class="token comment">//8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Struct-内存管理"><a href="#Struct-内存管理" class="headerlink" title="Struct 内存管理"></a>Struct 内存管理</h2><p>对于 Struct 在编译中就能够确定空间，也就不需要额外的空间给运行时用，运行过程调用时就是直接传地址。</p>
<p>下面我们再看看 Struct 的 MemoryLayout</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token class-name">DragonFirePosition</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> x<span class="token punctuation">:</span><span class="token class-name">Int64</span> <span class="token comment">//8 Bytes</span>
    <span class="token keyword">var</span> y<span class="token punctuation">:</span><span class="token class-name">Int32</span> <span class="token comment">//4 Bytes</span>
    <span class="token comment">//8 + 4</span>
    <span class="token keyword">func</span> <span class="token function-definition function">land</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonFirePosition</span><span class="token operator">></span><span class="token punctuation">.</span>size       <span class="token comment">//12</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonFirePosition</span><span class="token operator">></span><span class="token punctuation">.</span>alignment  <span class="token comment">//8</span>
<span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonFirePosition</span><span class="token operator">></span><span class="token punctuation">.</span>stride     <span class="token comment">//16</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>alignment 可以看出是按照 8 Bytes 来对齐的，所以这里 struct 是用到了字节对齐，实际占用大小通过 stride 可以看出就是 8 * 2 为16。</p>
<p>如果把 var x:Int64 改成可选类型会增加 4个 Bytes，不过就这个 case 来说实际大小还是16，这个也是因为内存对齐的原因。</p>
<h2 id="Class-内存管理"><a href="#Class-内存管理" class="headerlink" title="Class 内存管理"></a>Class 内存管理</h2><p>Class 本身是在 Stack 上分配的，在 Heap 上还需要保存 Class 的 Type 信息，这个 Type 信息里有函数表，在函数派发时就可以按照这个函数表进行派发了。继承的话子类只要在自己的 Type 信息里记录自己的信息即可。</p>
<h2 id="协议类型内存管理"><a href="#协议类型内存管理" class="headerlink" title="协议类型内存管理"></a>协议类型内存管理</h2><p>协议类型的内存模型是 Existential Container。先看下面例子</p>
<pre class="line-numbers language-swift" data-language="swift"><code class="language-swift"><span class="token keyword">protocol</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">extension</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">func</span> <span class="token function-definition function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">"fire!!!"</span></span><span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">struct</span> <span class="token class-name">YellowDragon</span><span class="token punctuation">:</span> <span class="token class-name">DragonFire</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">let</span> eyes <span class="token operator">=</span> <span class="token string-literal"><span class="token string">"blue"</span></span>
    <span class="token keyword">let</span> teeth <span class="token operator">=</span> <span class="token number">48</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">let</span> classSize <span class="token operator">=</span> <span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">YellowDragon</span><span class="token operator">></span><span class="token punctuation">.</span>size  <span class="token comment">//32</span>
<span class="token keyword">let</span> protocolSize <span class="token operator">=</span> <span class="token class-name">MemoryLayout</span><span class="token operator">&lt;</span><span class="token class-name">DragonFire</span><span class="token operator">></span><span class="token punctuation">.</span>size <span class="token comment">//40</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个例子里看这个结构体即遵循了这个协议而且内容还比这个协议多，而协议的 size 还要大，这个是为啥呢？这个是由于 Existential Container 的前三个 word 是叫 Value buffer 用来存储 inline 的值。第四个 word 是 Value Witness Table，存储值的各种操作比如 allocate，copy，destruct 和 deallocate 等。第五个 word 是 Protocol Witness Table 是存储协议的函数。</p>
<h2 id="泛型的内存管理"><a href="#泛型的内存管理" class="headerlink" title="泛型的内存管理"></a>泛型的内存管理</h2><p>泛型采用的和 Existential Container 原理类似。Value Witness Table 和 Protocol Witness Table 会作为隐形的参数传递到泛型方法里。不过经过编译器的层层 inline 优化，最终类型都会被推导出来也就不再需要 Existential Container 这一套了。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：Why Swift? Generics(泛型), Collection(集合类型), POP(协议式编程), Memory Management(内存管理)</li>
        <li>Post author：戴铭</li>
        <li>Create time：2018-01-24 17:14:03</li>
        <li>
            Post link：https://ming1016.github.io/2018/01/24/why-swift/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/iOS/">#iOS</a>&nbsp;
                    </li>
                
                    <li class="tag-item">
                        <a href="/tags/Swift/">#Swift</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2018/04/02/record-and-think-about-swift-project-jsondecoder-networking-and-pop/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Swift 项目中涉及到 JSONDecoder，网络请求，泛型协议式编程的一些记录和想法</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2018/01/10/slides-of-giac-how-to-use-swift-transfer-web-to-60-frame-native-code/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">GIAC 大会上分享的《Swift 将 Web 代码转成60帧满帧原生应用的方案及实践》的幻灯片</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2014</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">戴铭</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
            <div class="icp-info info-item"><a target="_blank" rel="nofollow" href="https://beian.miit.gov.cn">鄂ICP备17011999号 京公网安备 7011999号</a></div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">2.1.</span> <span class="nav-text">类型约束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">关联类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">2.3.</span> <span class="nav-text">类型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Where-%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.4.</span> <span class="nav-text">Where 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E5%92%8C-Any-%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.5.</span> <span class="nav-text">泛型和 Any 类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">3.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.2.</span> <span class="nav-text">迭代器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequence"><span class="nav-number">3.3.</span> <span class="nav-text">Sequence</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection"><span class="nav-number">3.4.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">3.5.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flatmap"><span class="nav-number">3.6.</span> <span class="nav-text">flatmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reduce"><span class="nav-number">3.7.</span> <span class="nav-text">Reduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">3.8.</span> <span class="nav-text">Array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E7%9A%84-Swift-%E6%95%B0%E7%BB%84"><span class="nav-number">3.9.</span> <span class="nav-text">弱引用的 Swift 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dictionary"><span class="nav-number">3.10.</span> <span class="nav-text">Dictionary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">协议式编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">Swift 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">5.1.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap"><span class="nav-number">5.1.1.</span> <span class="nav-text">Heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack"><span class="nav-number">5.1.2.</span> <span class="nav-text">Stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="nav-number">5.1.3.</span> <span class="nav-text">内存对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift-%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">Swift 派发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%B4%BE%E5%8F%91"><span class="nav-number">5.2.1.</span> <span class="nav-text">直接派发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E6%B4%BE%E5%8F%91"><span class="nav-number">5.2.2.</span> <span class="nav-text">函数表派发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B4%BE%E5%8F%91"><span class="nav-number">5.2.3.</span> <span class="nav-text">消息机制派发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%B4%BE%E5%8F%91"><span class="nav-number">5.2.4.</span> <span class="nav-text">具体派发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%B4%BE%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">指定派发方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E5%8F%91%E4%BC%98%E5%8C%96"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">派发优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">基本数据类型内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Struct-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.4.</span> <span class="nav-text">Struct 内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.5.</span> <span class="nav-text">Class 内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">协议类型内存管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">5.7.</span> <span class="nav-text">泛型的内存管理</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>



</body>
</html>
